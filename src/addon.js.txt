R"=====(
((function (exports) {
  'use strict';

  const MemberType = {
    Void: 0,
    Bool: 1,
    Int: 2,
    Float: 3,
    EnumerationItem: 4,
    Object: 5,
    Type: 6,
  };

  const StructureType = {
    Singleton: 0,
    Array: 1,
    Struct: 2,
    ExternUnion: 3,
    TaggedUnion: 4,
    ErrorUnion: 5,
    Enumeration: 6,
    Optional: 7,
    Pointer: 8,
    Slice: 9,
    Opaque: 10,
  };

  function getTypeName(type, isSigned, bitSize) {
    if (type === MemberType.Int) {
      return `${bitSize <= 32 ? '' : 'Big' }${isSigned ? 'Int' : 'Uint'}${bitSize}`;
    } else if (type === MemberType.Float) {
      return `Float${bitSize}`;
    } else if (type === MemberType.Bool) {
      return `Bool`;
    } else if (type === MemberType.Void) {
      return `Null`;
    }
  }
    
  function getIntRange(isSigned, bitSize) {
    if (bitSize <= 32) {
      const max = 2 ** (isSigned ? bitSize - 1 : bitSize) - 1;
      const min = (isSigned) ? -(2 ** (bitSize - 1)) : 0;
      return { min, max };
    } else {
      bitSize = BigInt(bitSize);
      const max = 2n ** (isSigned ? bitSize - 1n : bitSize) - 1n;
      const min = (isSigned) ? -(2n ** (bitSize - 1n)) : 0n;
      return { min, max };
    }
  }

  function getPrimitive(type, bitSize) {
    if (type === MemberType.Int) {
      if (bitSize <= 32) {
        return Number;
      } else {
        return BigInt;
      }
    } else if (type === MemberType.Float) {
      return Number;
    } else if (type === MemberType.Bool) {
      return Boolean;
    }
  }

  function obtainBitAlignFunction(bitPos, bitSize, toAligned) {
    if (bitPos + bitSize <= 8) {
      const mask = (2 ** bitSize) - 1;
      if (toAligned) {
        // from single byte
        return function(dest, src, offset) {
          const n = src.getUint8(offset);
          const b = (n >> bitPos) & mask;
          dest.setUint8(0, b);
        };
      } else {
        // to single byte
        const destMask = 0xFF ^ (mask << bitPos);
        return function(dest, src, offset) {
          const n = src.getUint8(0);
          const d = dest.getUint8(offset);
          const b = (d & destMask) | ((n & mask) << bitPos);
          dest.setUint8(offset, b);
        };
      }
    } else {
      const leadBits = 8 - bitPos;
      const leadMask = (2 ** leadBits) - 1;
      if (toAligned) {
        const trailBits = bitSize % 8;
        const trailMask = (2 ** trailBits) - 1;  
        return function(dest, src, offset) {
          let i = offset, j = 0;
          let n = src.getUint8(i++), b;
          let bitBuf = (n >> bitPos) & leadMask; 
          let bitCount = leadBits;
          let remaining = bitSize;
          do {
            if (remaining > bitCount) {
              n = src.getUint8(i++);
              bitBuf = bitBuf | (n << bitCount);  
              //bitCount += 8;
            }
            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
            dest.setUint8(j++, b);
            bitBuf >>= 8;
            //bitCount -= 8;
            remaining -= 8;
          } while (remaining > 0);
        }
      } else {
        const trailBits = (bitSize - leadBits) % 8;
        const trailMask = (2 ** trailBits) - 1;  
        const destMask1 = 0xFF ^ (leadMask << bitPos);
        const destMask2 = 0xFF ^ trailMask;
        return function(dest, src, offset) {
          let i = 0, j = offset;
          // preserve bits ahead of bitPos
          let d = dest.getUint8(j), n, b;
          let bitBuf = d & destMask1;
          let bitCount = bitPos;
          let remaining = bitSize + bitCount;
          do {
            if (remaining > bitCount) {
              n = src.getUint8(i++);
              bitBuf = bitBuf | (n << bitCount);
              bitCount += 8;
            }
            if (remaining >= 8) {
              b = bitBuf & 0xFF;
            } else {
              // preserve bits at the destination sitting behind the trailing bits 
              d = dest.getUint8(j);
              b = (d & destMask2) | (bitBuf & trailMask);
            }
            dest.setUint8(j++, b);
            bitBuf >>= 8;
            bitCount -= 8;
            remaining -= 8;
          } while (remaining > 0);
        }
      }
    }
  }

  function obtainCopyFunction(size) {
    return (size & 0x03) ? copy1 : copy4;
  }

  function copy1(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i++) {
      dest.setInt8(i, src.getInt8(i));
    }
  }

  function copy4(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i += 4) {
      dest.setInt32(i, src.getInt32(i));
    }
  }

  /*
  function showBits(object) {
    const bitObj = {};
    for (const [ name, value ] of Object.entries(object)) {
      const s = value.toString(2);
      bitObj[name] = s.padStart(Math.ceil(s.length / 8) * 8, '0');
    }
    console.log(bitObj);
  }
  */

  function throwOverflow(isSigned, bitSize, value) {
    const typeName = getTypeName(MemberType.Int, isSigned, bitSize);
    throw new TypeError(`${typeName} cannot represent value '${value}'`);
  }

  function throwSizeMismatch(actual, expected) {
    throw new TypeError(`Struct size mismatch: ${actual} != ${expected}`);
  }

  function throwBufferExpected(size) {
    throw new TypeError(`Expect an ArrayBuffer or DataView with a byte length of ${size}`);
  }

  function throwOutOfBound(length, align, index) {
    throw new RangeError(`Illegal array index: ${index}`);
  }

  function throwNotNull() {
    throw new RangeError(`Property can only be null`);
  }

  function rethrowRangeError(err, length, align, index) {
    if (err instanceof RangeError) {
      throwOutOfBound(length, align, index);
    } else {
      throw err;
    }
  }

  function throwNoNewEnum() {
    throw new TypeError(`Cannot create new enum item\nCall function without the use of "new" to obtain an enum object`);
  }

  function throwInvalidEnum(value) {
    throw new TypeError(`Value given does not correspond to an enum item: ${value}`);
  }

  function throwEnumExpected(constructor) {
    throw new TypeError(`Enum item expected: ${constructor.name}`);
  }

  function throwInvalidType(constructor) {
    throw new TypeError(`Object of specific type expected: ${constructor.name}`);
  }

  const MEMORY = Symbol('memory');
  const SLOTS = Symbol('slots');
  const SYNC = Symbol('SYNC');
  const SOURCE$1 = Symbol('SOURCE');

  const TYPED_ARRAY = Symbol('typedArray');
  const ENUM_INDEX = Symbol('enumIndex');
  const ENUM_ITEMS = Symbol('enumItems');

  function obtainDataViewGetter({ type, isSigned, bitOffset, bitSize, byteSize }) {
    const bitPos = bitOffset & 0x07;
    const name = getMethodName('get', type, isSigned, bitPos, bitSize, byteSize);
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    }
    if (methodCache[name]) {
      return methodCache[name];
    }
    let fn;
    if (byteSize !== 0) {
      if (type === MemberType.Int) {
        if (bitSize < 64) {
          // actual number of bits needed when stored byte-aligned
          const typeName = getTypeName(type, isSigned, byteSize * 8);
          const get = DataView.prototype[`get${typeName}`];
          if (isSigned) {
            const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
            const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n; 
            fn = function(offset, littleEndian) {
              const n = get.call(this, offset, littleEndian);
              return (n & valueMask) - (n & signMask);
            };
          } else {
            const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n; 
            fn = function(offset, littleEndian) {
              const n = get.call(this, offset, littleEndian);
              return n & valueMask;
            };
          }
        } else {
          const getWord = DataView.prototype.getBigUint64;
          const wordCount = Math.ceil(bitSize / 64);
          const get = function(offset, littleEndian) {
            let n = 0n;
            if (littleEndian) {
              for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
                const w = getWord.call(this, j, littleEndian);
                n = (n << 64n) | w;
              }
            } else {
              for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
                const w = getWord.call(this, j, littleEndian);
                n = (n << 64n) | w;
              }
            }
            return n;
          };
          if (isSigned) {
            const signMask = 2n ** BigInt(bitSize - 1);
            const valueMask = signMask - 1n; 
            fn = function(offset, littleEndian) {
              const n = get.call(this, offset, littleEndian);
              return (n & valueMask) - (n & signMask);
            };
          } else {
            const valueMask =  (2n ** BigInt(bitSize)) - 1n; 
            fn = function(offset, littleEndian) {
              const n = get.call(this, offset, littleEndian);
              return n & valueMask;
            };
          }
        }
      } else if (type === MemberType.Float) {
        if (bitSize === 16) {
          const dest = new DataView(new ArrayBuffer(4));
          const get = DataView.prototype.getUint16;
          fn = function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            const sign = n >>> 15;
            const exp = (n & 0x7C00) >> 10;
            const frac = n & 0x03FF;
            if (exp === 0) {
              return (sign) ? -0 : 0;
            } else if (exp === 0x1F) {
              if (!frac) {
                return (sign) ? -Infinity : Infinity;
              } else {
                return NaN;
              }
            }
            const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
            dest.setUint32(0, n32, littleEndian);
            return dest.getFloat32(0, littleEndian);
          };
        } else if (bitSize === 80) {
          const dest = new DataView(new ArrayBuffer(8));
          const getWord = DataView.prototype.getBigUint64;
          const get = function(offset, littleEndian) {
            const w1 = getWord.call(this, offset, littleEndian);
            const w2 = getWord.call(this, offset + 8, littleEndian);
            return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;
          };
          fn = function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            const sign = n >> 79n;
            const exp = (n & 0x7FFF0000000000000000n) >> 64n;
            const frac = n & 0x00007FFFFFFFFFFFFFFFn;
            if (exp === 0n) {
              return (sign) ? -0 : 0;
            } else if (exp === 0x7FFFn) {
              if (!frac) {
                return (sign) ? -Infinity : Infinity;
              } else {
                return NaN;
              }
            }
            const n64 = (sign << 63n) | ((exp - 16383n + 1023n) << 52n) | (frac >> 11n);
            dest.setBigUint64(0, n64, littleEndian);
            return dest.getFloat64(0, littleEndian);
          };
        } else if (bitSize === 128) {
          const dest = new DataView(new ArrayBuffer(8));
          const getWord = DataView.prototype.getBigUint64;
          const get = function(offset, littleEndian) {
            const w1 = getWord.call(this, offset, littleEndian);
            const w2 = getWord.call(this, offset + 8, littleEndian);
            return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;
          };
          fn = function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            const sign = n >> 127n;
            const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
            const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
            if (exp === 0n) {
              return (sign) ? -0 : 0;
            } else if (exp === 0x7FFFn) {
              if (!frac) {
                return (sign) ? -Infinity : Infinity;
              } else {
                return NaN;
              }
            }
            const n64 = (sign << 63n) | ((exp - 16383n + 1023n) << 52n) | (frac >> 60n);
            dest.setBigUint64(0, n64, littleEndian);
            return dest.getFloat64(0, littleEndian);
          };
        }
      } else if (type === MemberType.Bool) {
        const typeName = getTypeName(MemberType.Int, true, byteSize * 8);
        const get = DataView.prototype[`get${typeName}`];
        fn = function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      }     
    } else {
      const get = DataView.prototype.getUint8;
      if (type === MemberType.Bool && bitSize === 1) {
        // bitfield--common enough to warrant special handle
        const mask = 1 << bitPos;
        fn = function(offset) {
          const n = get.call(this, offset);
          return !!(n & mask);
        };
      } else if (type === MemberType.Int && bitPos + bitSize <= 8) {
        // sub-8-bit numbers also have real use cases
        if (isSigned) {
          const signMask = 2 ** (bitSize - 1);
          const valueMask = signMask - 1;
          fn = function(offset) {
            const n = get.call(this, offset);
            const s = n >>> bitPos;
            return (s & valueMask) - (s & signMask);
          };
        } else {
          const valueMask = (2 ** bitSize - 1) << bitPos; 
          fn = function(offset) {
            const n = get.call(this, offset);
            const s = n >>> bitPos;
            return s & valueMask;
          };
        }
      } else {
        // pathological usage--handle it anyway by copying the bitSize into a 
        // temporary buffer, bit-aligning the data
        const byteSize = getByteSize(bitSize);
        const dest = new DataView(new ArrayBuffer(byteSize));
        const getAligned = obtainDataViewGetter({ type, bitSize, isSigned, bitOffset: 0, byteSize });
        const copyBits = obtainBitAlignFunction(bitPos, bitSize, true);
        fn = function(offset, littleEndian) {
          copyBits(dest, this, offset);
          return getAligned.call(dest, 0, littleEndian);
        };
      }
    }
    if (!fn) {
      throw new Error(`Missing getter: ${type}`)
    }
    Object.defineProperty(fn, 'name', { value: name, writable: false });
    methodCache[name] = fn;
    return fn;
  }

  function obtainDataViewSetter({ type, bitSize, isSigned, byteSize, bitOffset }) {
    const bitPos = bitOffset & 0x07;
    const name = getMethodName('set', type, isSigned, bitPos, bitSize, byteSize);
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    }
    if (methodCache[name]) {
      return methodCache[name];
    }
    let fn;
    if (byteSize !== 0) {
      if (type === MemberType.Int) {
        if (bitSize < 64) {
          const typeName = getTypeName(type, isSigned, byteSize * 8);
          const set = DataView.prototype[`set${typeName}`];
          if (isSigned) {
            const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
            const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n; 
            fn = function(offset, v, littleEndian) {
              const n = (v < 0) ? signMask | (v & valueMask) : v & valueMask;
              set.call(this, offset, n, littleEndian);
            };
          } else {
            const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1: (2n ** BigInt(bitSize)) - 1n; 
            fn = function(offset, v, littleEndian) {
              const n = v & valueMask;
              set.call(this, offset, n, littleEndian);
            };
          }
        } else {
          const setWord = DataView.prototype.setBigUint64;
          const wordCount = Math.ceil(bitSize / 64);
          const set = function(offset, v, littleEndian) {
            let n = v;
            const mask = 0xFFFFFFFFFFFFFFFFn; 
            if (littleEndian) {
              for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
                const w = n & mask;
                setWord.call(this, j, w, littleEndian);
                n >>= 64n;
              }
            } else {
              n <<= BigInt(wordCount * 64 - bitSize);
              for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
                const w = n & mask;
                setWord.call(this, j, w, littleEndian);
                n >>= 64n;
              }
            }
            return n;
          };
          if (isSigned) {
            const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
            const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n; 
            fn = function(offset, v, littleEndian) {
              const n = (v < 0) ? signMask | (v & valueMask) : v & valueMask;
              set.call(this, offset, n, littleEndian);
            };
          } else {
            const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1: (2n ** BigInt(bitSize)) - 1n; 
            fn = function(offset, v, littleEndian) {
              const n = v & valueMask;
              set.call(this, offset, n, littleEndian);
            };
          }
        }
      } else if (type === MemberType.Float) {
        if (bitSize === 16) {
          const src = new DataView(new ArrayBuffer(4));
          const set = DataView.prototype.setUint16;
          fn = function(offset, v, littleEndian) {
            src.setFloat32(0, v, littleEndian);
            const n = src.getUint32(0, littleEndian);
            const sign = n >>> 31;
            const exp = (n & 0x7F800000) >> 23;
            const frac = n & 0x007FFFFF;
            let n16;
            if (exp === 0) {
              n16 = sign << 15;
            } else if (exp === 0xFF) {
              n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
            } else {
              n16 = sign << 15 | (exp - 127 + 15) << 10 | (frac >> 13);
            }
            set.call(this, offset, n16, littleEndian);
          };
        } else if (bitSize === 80) {
          const src = new DataView(new ArrayBuffer(8));
          const setWord = DataView.prototype.setBigUint64;
          const set = function(offset, v, littleEndian) {
            const w1 = v & 0xFFFFFFFFFFFFFFFFn;
            const w2 = v >> 64n;
            setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);
            setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);
          };
          fn = function(offset, v, littleEndian) {
            src.setFloat64(0, v, littleEndian);
            const n = src.getBigUint64(0, littleEndian);
            const sign = n >> 63n;
            const exp = (n & 0x7FF0000000000000n) >> 52n;
            const frac = n & 0x000FFFFFFFFFFFFFn;
            let n80;
            if (exp === 0n) {
              n80 = sign << 79n | (frac << 11n);
            } else if (exp === 0x07FFn) {
              n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
              //                                                 ^ bit 61                       ^ bit 63 
            } else {
              n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
            }
            set.call(this, offset, n80, littleEndian);
          };
        } else if (bitSize === 128) {
          const src = new DataView(new ArrayBuffer(8));
          const setWord = DataView.prototype.setBigUint64;
          const set = function(offset, v, littleEndian) {
            const w1 = v & 0xFFFFFFFFFFFFFFFFn;
            const w2 = v >> 64n;
            setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);
            setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);
          };
          fn = function(offset, v, littleEndian) {
            src.setFloat64(0, v, littleEndian);
            const n = src.getBigUint64(0, littleEndian);
            const sign = n >> 63n;
            const exp = (n & 0x7FF0000000000000n) >> 52n;
            const frac = n & 0x000FFFFFFFFFFFFFn;
            let n128;
            if (exp === 0n) {
              n128 = sign << 127n | (frac << 60n);
            } else if (exp === 0x07FFn) {
              n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
            } else {
              n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
            }
            set.call(this, offset, n128, littleEndian);
          };
        }
      } else if (type === MemberType.Bool) {
        const typeName = getTypeName(MemberType.Int, true, byteSize * 8);
        const set = DataView.prototype[`set${typeName}`];
        fn = function(offset, v, littleEndian) {
          set.call(this, offset, v ? 1 : 0, littleEndian);
        };
      }
    } else {
      const get = DataView.prototype.getInt8;
      const set = DataView.prototype.setInt8;
      if (type === MemberType.Bool && bitSize === 1) {
        const mask = 1 << bitPos;
        fn = function(offset, value) {
          const n = get.call(this, offset);
          const b = (value) ? n | mask : n & ~mask;
          set.call(this, offset, b);
        };
      } else if (type === MemberType.Int && bitPos + bitSize <= 8) {
        if (isSigned) {
          const signMask = 2 ** (bitSize - 1);        
          const valueMask = signMask - 1;
          const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
          fn = function(offset, v) {
            let b = get.call(this, offset);
            const n = (v < 0) ? signMask | (v & valueMask) : v & valueMask;
            b = (b & outsideMask) | (n << bitPos);
            set.call(this, offset, b);
          };
        } else {
          const valueMask = (2 ** bitSize) - 1; 
          const outsideMask = 0xFF ^ (valueMask << bitPos);
          fn = function(offset, value) {
            const n = get.call(this, offset);
            const v = value & valueMask;
            const b = (n & outsideMask) | (v << bitPos);
            set.call(this, offset, b);
          };
        }
      } else {
        const byteSize = getByteSize(bitSize);
        const src = new DataView(new ArrayBuffer(byteSize));
        const setAligned = obtainDataViewSetter({ type, isSigned, bitOffset: 0, bitSize, byteSize });
        const applyBits = obtainBitAlignFunction(bitPos, bitSize, false);
        fn = function(offset, value, littleEndian) {
          setAligned.call(src, 0, value, littleEndian);
          applyBits(this, src, offset);
        };
      }
    }
    if (!fn) {
      throw new Error(`Missing setter: ${type}`)
    }
    Object.defineProperty(fn, 'name', { value: name, writable: false });
    methodCache[name] = fn;
    return fn;
  }

  function obtainDataView(arg, size, multiple = false) {
    let dv;
    if (arg instanceof DataView) {
      dv = arg;
    } else if (arg instanceof ArrayBuffer || arg instanceof SharedArrayBuffer) {
      dv = new DataView(arg);
    } else {
      throwBufferExpected(size);
    }
    if (multiple) {
      if (dv.byteLength % size !== 0) {
        throwSizeMismatch(dv.byteLength, size);
      }
    } else {
      if (dv.byteLength !== size) {
        throwSizeMismatch(dv.byteLength, size);
      } 
    }
    return dv;
  }

  function getDataView() {
    return this[MEMORY];
  }

  function getMethodName(prefix, type, isSigned, bitPos, bitSize, byteSize) {
    const typeName = getTypeName(type, isSigned, bitSize);
    const suffix = (byteSize === 0) ? `Bit${bitPos}` : ``;
    return `${prefix}${typeName}${suffix}`;
  }

  function getByteSize(bitSize) {
    return [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  }
    
  const methodCache = {};

  function obtainGetter(member, options) {
    const {
      littleEndian = true,
      runtimeSafety = true,
    } = options;
    let fn;
    switch (member.type) {
      case MemberType.Bool:
      case MemberType.Int:
      case MemberType.Float: {
        // get value from buffer through DataView
        const { bitOffset } = member;
        const offset = bitOffset >> 3;
        const get = obtainDataViewGetter(member);
        fn = function() { 
          return get.call(this[MEMORY], offset, littleEndian);
        };
      } break;
      case MemberType.Void: {
        fn = function() { 
          return null;
        }; 
      } break;
      case MemberType.EnumerationItem: {
        const { bitOffset, structure } = member;
        const offset = bitOffset >> 3;
        const get = obtainDataViewGetter({ ...member, type: MemberType.Int });
        if (runtimeSafety) {
          fn = function() {
            const { constructor } = structure;
            const value = get.call(this[MEMORY], offset, littleEndian);
            // the enumeration constructor returns the singleton object for the value
            const object = constructor(value);
            if (!object) {
              throwInvalidEnum(value);
            }
            return object;
          }; 
        } else {
          fn = function() {
            const value = get.call(this[MEMORY], offset, littleEndian);
            return constructor(value);
          }; 
        }
      } break;
      case MemberType.Object: {
        // automatically dereference pointer
        const { structure, slot } = member;
        if (structure.type === StructureType.Pointer) {
          const { instance: { members: [ target ] } } = structure;
          if (target.structure.type === StructureType.Singleton) {
            fn = function() { 
              const pointer = this[SLOTS][slot];
              const object = pointer['*'];
              return object.get() 
            };  
          } else {
            fn = function() { 
              const pointer = this[SLOTS][slot];
              const object = pointer['*'];
              return object;
            };  
          }
        } else {
          fn = function() { 
            const object = this[SLOTS][slot];
            return object;
          }; 
        }
      } break;
    }
    return fn;
  }

  function obtainSetter(member, options) {
    const {
      littleEndian = true,
      runtimeSafety = true,
    } = options;
    let fn;
    switch (member.type) {
      case MemberType.Bool:
      case MemberType.Int:
      case MemberType.Float: {
        // change buffer through DataView
        const set = obtainDataViewSetter(member);
        const { type, bitOffset } = member;
        const offset = bitOffset >> 3;
        if (runtimeSafety && type === MemberType.Int) {
          const { isSigned, bitSize } = member;
          const { min, max } = getIntRange(isSigned, bitSize);
          fn = function(v) { 
            if (v < min || v > max) {
              throwOverflow(isSigned, bitSize, v);
            }
            set.call(this[MEMORY], offset, v, littleEndian);
          };
        } else {
          fn = function(v) { 
            set.call(this[MEMORY], offset, v, littleEndian);
          };
        }
      } break;
      case MemberType.Void: {
        if (runtimeSafety) {
          fn = function(v) { 
            if (v != null) {
              throwNotNull();
            }
          };
        } else {
          fn = function() {};
        }
      } break;
      case MemberType.EnumerationItem: {
        const { bitOffset, structure } = member;
        const offset = bitOffset >> 3;
        const set = obtainDataViewSetter({ ...member, type: MemberType.Int });
        fn = function(v) {
          const { constructor } = structure;
          if (!(v instanceof constructor)) {
            throwEnumExpected(constructor);
          }
          set.call(this[MEMORY], offset, v.valueOf(), littleEndian);
        }; 
      }
      case MemberType.Object: {
        const { slot, structure, isConst } = member;
        if (structure.type === StructureType.Pointer) {
          if (isConst) {
            break;
          }
          const { instance: { members: [ target ] } } = structure;
          if (target.structure.type === StructureType.Singleton) {
            fn = function(v) { 
              const pointer = this[SLOTS][slot];
              const object = pointer['*'];
              object.set(v); 
            };
          } else {
            fn = function(v) { 
              const pointer = this[SLOTS][slot];            
              pointer['*'] = v;
            };
          }
        } else {
          fn = function(v) {
            const { constructor, copier } = structure;
            if (!(v instanceof constructor)) {
              v = new constructor(v);
            }
            const object = this[SLOTS][slot];
            copier(object, v);
          };  
        }
      } break;
    }
    return fn;
  }

  function obtainArrayLengthGetter(member, options) {
    const { byteSize } = member;
    let fn = function() {
      const dv = this[MEMORY];
      return dv.byteLength / byteSize;
    };
    return fn;
  }

  function obtainArrayGetter(member, options) {
    const {
      littleEndian = true,
    } = options;
    let fn;
    switch (member.type) {
      case MemberType.Bool:
      case MemberType.Int:
      case MemberType.Float: {
        const { byteSize } = member;
        const get = obtainDataViewGetter(member);
        fn = function(index) {
          const dv = this[MEMORY];
          const offset = index * byteSize;
          try {
            return get.call(dv, offset, littleEndian) ;
          } catch {
            throwOutOfBound(dv.byteLength, byteSize, index);
          }
        };
      } break;
      case MemberType.Object: {
        const { byteSize } = member;
        return function(index) { 
          const child = this[SLOTS][index];
          if (!child) {
            throwOutOfBound(dv.byteLength, byteSize, index);
          }
          return slots[index]; 
        };
      }  }
    return fn;
  }

  function obtainArraySetter(member, options) {
    const {
      littleEndian = true,
      runtimeSafety = true,
    } = options;
    let fn;
    switch (member.type) {
      case MemberType.Bool:
      case MemberType.Int:
      case MemberType.Float: {
        // change buffer through DataView
        const set = obtainDataViewSetter(member);
        const { type } = member;
        if (runtimeSafety && type === MemberType.Int) {
          const { isSigned, bitSize, byteSize } = member;
          const { min, max } = getIntRange(isSigned, bitSize);
          fn = function(index, v) { 
            if (v < min || v > max) {
              throwOverflow(isSigned, bitSize, v);
            }
            const offset = index * byteSize;
            const dv = this[MEMORY];
            try {
              set.call(dv, offset, v, littleEndian);
            } catch (err) {
              rethrowRangeError(err, dv.byteLength, byteSize, index);
            }
          };
        } else {
          fn = function(index, v) { 
            const offset = index * byteSize;
            const dv = this[MEMORY];
            try {
              set.call(dv, offset, v, littleEndian);
            } catch (err) {
              rethrowRangeError(err, dv.byteLength, byteSize, index);
            }
          };
        }
      } break;
      case MemberType.Object: {
        const { structure, byteSize } = member;
        const { constructor, copier } = structure;
        fn = function(index, v) {
          if (!(v instanceof constructor)) {
            v = new constructor(v);
          }
          this[SLOTS][index];
          if (!child) {
            throwOutOfBound(dv.byteLength, byteSize, index);
          }
          copier(child, v);
        };  
      } break;
    }
    return fn;
  }

  function getArrayIterator() {
    const self = this;
    const length = this.length;
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < length) {
          value = self.get(index);
          done = false;
          index++;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function obtainPointerGetter(member, options) {
    let fn;
    if (member.type === MemberType.Object) {
      const { structure, slot } = member;
      if (structure.type === StructureType.Pointer) {
        // get pointer from slot
        fn = function() { 
          const pointer = this[SOURCE$1][SLOTS][slot];
          return pointer;
        };
      }
    }
    return fn;
  }

  function obtainPointerSetter(member, options) {
    let fn;
    if (member.type === MemberType.Object) {
      const { structure, slot } = member;
      if (structure.type === StructureType.Pointer) {
        // set pointer itself
        fn = function(v) { 
          const { constructor, copier } = structure;
          if (!(v instanceof constructor)) {
            throwInvalidType(constructor);
          }
          copier(this[SOURCE$1][SLOTS][slot], v);
        };
      }
    }
    return fn;
  }

  function obtainPointerArrayGetter(member, options) {
    let fn;
    if (member.type === MemberType.Object) {
      const { structure } = member;
      if (structure.type === StructureType.Pointer) {
        fn = function(index) { 
          const pointer = this[SOURCE$1][SLOTS][index];
          return pointer;
        };
      }
    }
    return fn;
  }

  function obtainPointerArraySetter(member, options) {
    let fn;
    if (member.type === MemberType.Object) {
      const { structure } = member;
      if (structure.type === StructureType.Pointer) {
        fn = function(index, v) { 
          const { constructor, copier } = structure;
          if (!(v instanceof constructor)) {
            throwInvalidType(constructor);
          }
          const object = this[SOURCE$1][SLOTS][index];
          copier(object, v);
        };
      }
    }
    return fn;
  }

  function obtainPointerArrayLengthGetter(member, options) {
    let fn = function() {
      return this[SOURCE$1].length;
    };
    return fn;
  }

  function obtainTypedArrayGetter(members) {
    const hash = {};
    for (const { type, isSigned, bitSize, byteSize } of members) {
      if (type === MemberType.Int || type === MemberType.Float) {
        const typeName = getTypeName(type, isSigned, bitSize);
        const constructor = typedArrays[typeName];
        if (!constructor) {
          return;
        }
        hash[typeName] = constructor;
      } else {
        return;
      }
    }
    const entries = Object.entries(hash);
    if (entries.length !== 1) {
      return;
    }
    const [ typeName, constructor ] = entries[0];
    if (typedArrayGetters[typeName]) {
      return typedArrayGetters[typeName];
    }
    const { byteSize } = members[0];
    const fn = function() {
      if (!this[TYPED_ARRAY]) {
        const dv = this[MEMORY];
        this[TYPED_ARRAY] = new constructor(dv.buffer, dv.byteOffset, dv.byteLength / byteSize);
      }
      return this[TYPED_ARRAY];
    };
    typedArrayGetters[typeName] = fn;
    return fn;
  }

  const typedArrayGetters = {};

  const typedArrays = {
    Int8: Int8Array,
    Uint8: Uint8Array,
    Int16: Int16Array,
    Uint16: Uint16Array,
    Int32: Int32Array,
    Uint32: Uint32Array,
    Int64: BigInt64Array,
    Uint64: BigUint64Array,
    Float32: Float32Array,
    Float64: Float64Array,
  };

  const globalSlots = {};

  function invokeThunk(thunk, args) {
    thunk.call(args, globalSlots, SLOTS, MEMORY, SYNC);
  }

  function invokeFactory(thunk) {
    const args = { [SLOTS]: {} };
    thunk.call(args, globalSlots, SLOTS, MEMORY, SYNC);
    return args[SLOTS][0].constructor;
  }

  function getArgumentBuffers(args) {
    const buffers = [];
    const included = new WeakMap();
    const scanned = new WeakMap();
    const scan = (object) => {
      if (scanned.get(object)) {
        return;
      }
      const memory = object[MEMORY];
      if (memory.buffer instanceof ArrayBuffer) {
        if (!included.get(memory.buffer)) {
          buffers.push(memory.buffer);
          included.set(memory.buffer, true);
        }
      }
      scanned.set(object, true);
      const slots = object[SLOTS];
      if (slots) {
        for (const child of Object.values(slots)) {
          scan(child);
        }
      }
    };
    scan(args);
    return buffers;
  }

  function beginStructure(def, options = {}) {
    const {
      type,
      name,
      size,
    } = def;
    return { 
      constructor: null, 
      copier: null,
      type, 
      name,
      size, 
      instance: {
        members: [],
        template: null,
      },
      static: {
        members: [],
        template: null,
      },
      methods: [],
      options,
    };
  }

  function attachMember(s, def) {
    const target = (def.isStatic) ? s.static : s.instance;
    target.members.push(def);
  }

  function attachMethod(s, def) {
    s.methods.push(def);
  }

  function attachTemplate(s, def) {
    const target = (def.isStatic) ? s.static : s.instance;
    target.template = def.template;
  }

  function finalizeStructure(s) {
    try {
      switch (s.type) {
        case StructureType.Singleton: 
          return finalizeSingleton(s);
        case StructureType.Array:
          return finalizeArray(s);
        case StructureType.Struct:
        case StructureType.ExternUnion:
          return finalizeStruct(s);
        case StructureType.TaggedUnion:
          // TODO
          return null;
        case StructureType.Enumeration:
          return finalizeEnumeration(s);
        case StructureType.Pointer:
          return finalizePointer(s);
        case StructureType.Slice:
          // TODO
          return null; 
      } 
    } catch (err) {
      console.error(err);
      throw err;
    }
  }

  function finalizeSingleton(s) {
    const { 
      size,
      name,
      instance: {
        members: [ member ],
      },
      options,
    } = s;
    const primitive = getPrimitive(member.type, member.bitSize);
    const get = obtainGetter(member, options);
    const set = obtainSetter(member, options);
    const copy = obtainCopyFunction(size);
    s.copier = function (dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        // new operation--expect matching primitive
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = obtainDataView(arg, size);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      if (creating) {
        if (primitive !== undefined) {
          if (arg !== undefined) {
            this.set(primitive(arg));
          } 
        }
      } else {
        return self;
      }
    };
    if (name) {
      Object.defineProperty(constructor, 'name', { value: name, writable: false });
    }
    Object.defineProperties(constructor.prototype, {
      get: { value: get, configurable: true, writable: true },
      set: { value: set, configurable: true, writable: true },
      [Symbol.toPrimitive]: { value: get, configurable: true, writable: true },
    });
    return constructor;
  }

  function finalizeArray(s) {
    const {
      size,
      name,
      instance: {
        members: [ member ],
      },
      options,
    } = s; 
    const copy = obtainCopyFunction(size); 
    const get = obtainArrayGetter(member, options);
    const set = obtainArraySetter(member, options);
    const getLength = obtainArrayLengthGetter(member);
    const getPointer = obtainPointerArrayGetter(member);
    const setPointer = obtainPointerArraySetter(member);
    const getPointerLength = obtainPointerArrayLengthGetter();
    s.copier = function(dest, src) {
      copy(dest[MEMORY], src[MEMORY]);   
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = obtainDataView(arg, size);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      if (!creating) {
        return self;
      }
    };
    if (name) {
      Object.defineProperties(constructor, {
        name: { value: name, writable: false }
      });
    }
    Object.defineProperties(constructor.prototype, {
      get: { value: get, configurable: true, writable: true },
      set: { value: set, configurable: true, writable: true },
      length: { get: getLength, configurable: true },
      [Symbol.iterator]: { value: getArrayIterator, configurable: true },
    });
    if (getPointer) {
      const ptrSourceProto = Object.defineProperties({}, {
        get: { value: getPointer, configurable: true, writable: true },
        set: { value: setPointer, configurable: true, writable: true },
        length: { get: getPointerLength, configurable: true },
        [Symbol.iterator]: { value: getArrayIterator, configurable: true },
      });
      const get = function() {
        const ptrSource = Object.create(ptrSourceProto);
        ptrSource[SOURCE] = this;
        return ptrSource;
      };
      Object.defineProperties(constructor.prototype, {
        '&': { get, configurable: true, enumerable: true, writable: false }
      });
    }
    attachDataViewAccessors(s);
    return constructor;
  }

  function finalizeStruct(s) {
    const { 
      size,
      name,
      instance: {
        members,
        template,
      },
      options,
    } = s;
    const copy = obtainCopyFunction(size);
    const descriptors = {};
    for (const member of members) {
      const get = obtainGetter(member, options);
      const set = obtainSetter(member, options);
      descriptors[member.name] = { get, set, configurable: true, enumerable: true };
    }
    // pointer
    const ptrDescriptors = {};
    for (const member of members) {
      const get = obtainPointerGetter(member);
      const set = obtainPointerSetter(member);
      if (get) {
        ptrDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
      }
    }
    const hasSlots = !!members.find(m => m.type === MemberType.Object);
    const copier = s.copier = function(dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      if (hasSlots) {
        Object.assign(dest[SLOTS], src[SLOTS]);
      }
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        // new operation--expect an object
        // TODO: validate argument
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = obtainDataView(arg, size);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      Object.defineProperties(self, descriptors);
      if (hasSlots) {
        Object.defineProperties(self, {
          [SLOTS]: { value: {} },
        });  
      } 
      if (creating) {
        if (template) {
          copier(this, template);
        }
        if (arg) {
          for (const [ key, value ] of Object.entries(arg)) {
            this[key] = value;
          }
        }
      } else {
        return self;
      }
    };
    if (name) {
      Object.defineProperties(constructor, {
        name: { value: name, writable: false }
      });
    }
    if (Object.keys(ptrDescriptors).length > 0) {
      const ptrSourceProto = Object.defineProperties({}, ptrDescriptors);
      const get = function() {
        const ptrSource = Object.create(ptrSourceProto);
        ptrSource[SOURCE] = this;
        return ptrSource;
      };
      Object.defineProperties(constructor.prototype, {
        '&': { get, configurable: true, enumerable: true },
      });
    }
    attachDataViewAccessors(s);
    attachStaticMembers(s);
    attachMethods(s);
    return constructor;
  }
  function finalizeEnumeration(s) {
    const { 
      name,
      instance: {
        members,
        template,
      },
      options,
    } = s;
    const primitive = getPrimitive(members[0].type, members[0].bitSize);
    const getValue = obtainArrayGetter(members[0], options);
    const count = members.length;
    const items = {};
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      if (creating) {
        // the "constructor" is only used to convert a number into an enum object
        // new enum items cannot be created
        throwNoNewEnum();    
      }
      let index = -1;
      if (isSequential) {
        // normal enums start at 0 and go up, so the value is the index 
        index = Number(arg);
      } else {
        // it's not sequential, so we need to compare values
        // casting just in case the enum is BigInt
        const v = primitive(arg);
        for (let i = 0; i < count; i++) {
          const value = getValue.call(constructor, i);
          if (value === v) {
            index = i;
            break;
          }
        }
      }
      // return the enum object (created down below)
      return items[index];
    };
    if (name) {
      Object.defineProperties(constructor, {
        name: { value: name, writable: false }
      });
    }
    // attach the numeric values to the class as its binary data
    // this allows us to reuse the array getter
    Object.defineProperties(constructor, {
      [MEMORY]: { value: template[MEMORY] },
      [ENUM_ITEMS]: { value: items },
    });
    const valueOf = function() { 
      const index = this[ENUM_INDEX] ;
      return getValue.call(constructor, index);
    };
    Object.defineProperties(constructor.prototype, {
      [Symbol.toPrimitive]: { value: valueOf, configurable: true, writable: true },    
      // so we don't get an empty object when JSON.stringify() is used
      toJSON: { value: valueOf, configurable: true, writable: true },
    });
    // now that the class has the right hidden properties, getValue() will work 
    // scan the array to see if the enum's numeric representation is sequential
    const isSequential = (() => {
      // try-block in the event that the enum has bigInt items 
      try {
        for (let i = 0; i < count; i++) {
          if (get.call(constructor, i) !== i) {
            return false;
          }
        }
        return true;
      } catch (err) {      
        return false;
      }
    })();
    // attach the enum items to the constructor and the reloc object
    for (const [ index, { name } ] of members.entries()) {
      // can't use the constructor since it would throw
      const item = Object.create(constructor.prototype);
      Object.defineProperties(item, {
        [ENUM_INDEX]: { value: index },
      });
      Object.defineProperties(constructor, {
        [name]: { value: item, configurable: true, enumerable: true, writable: true },
      });
      items[index] = item;
    }
    attachStaticMembers(s);
    attachMethods(s);
    return constructor;
  }
  function finalizePointer(s) {
    const { 
      size,
      name,
      instance: {
        members: [ member ],
      },
      options,
    } = s;
    const get = obtainGetter(member, options);
    const set = obtainSetter(member, options);
    const copy = obtainCopyFunction(size);
    s.copier = function (dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      Object.assign(dest[SLOTS], src[SLOTS]);
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      const slots = { 0: null };
      if (creating) {
        self = this;
        dv = new DataView(new ArrayBuffer(size));
        // TODO: validate arg
      } else {
        self = Object.create(constructor.prototype);
        dv = obtainDataView(arg, size);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
        [SLOTS]: { value: slots },
        [SYNC]: { value: false, writable: true },
      });
      if (creating) {
        slots[0] = arg;
      } else {
        return self;
      }
    };
    if (name) {
      Object.defineProperties(constructor, {
        name: { value: name, writable: false }
      });
    }
    Object.defineProperties(constructor.prototype, {
      '*': { get, set, configurable: true, enumerable: true },
    });
    return constructor;
  }

  function attachStaticMembers(s) {
    const {
      constructor,
      static: {
        members,
        template,
      },
      options,
    } = s;
    if (!template) {
      return;
    }
    const descriptors = {
      [SLOTS]: { value: template[SLOTS] },
    };
    for (const member of members) {
      const get = obtainGetter(member, options);
      const set = obtainSetter(member, options);
      descriptors[member.name] = { get, set, configurable: true, enumerable: true };
    }  Object.defineProperties(constructor, descriptors);
  }

  function attachMethods(s) {
    const { 
      constructor,
      methods,
    } = s;
    for (const method of methods) {
      const {
        name,
        argStruct,   
        thunk,
        isStaticOnly,
      } = method;
      const f = function(...args) {
        const { constructor } = argStruct;
        const a = new constructor();
        for (const [ index, arg ] of args.entries()) {
          if (arg !== undefined) {
            a[index] = arg;
          }
        }
        invokeThunk(thunk, a);
        return a.retval;
      };
      Object.defineProperties(f, {
        name: { value: name, writable: false },
      });
      Object.defineProperties(constructor, { 
        [name]: { value: f, configurable: true, enumerable: true, writable: true },
      });
      if (!isStaticOnly) {
        const m = function(...args) {
          const { constructor } = argStruct;
          const a = new constructor();
          a[0] = this;
          for (const [ index, arg ] of args.entries()) {
            if (arg !== undefined) {
              a[index + 1] = arg;
            }
          }
          invokeThunk(thunk, a);
          return a.retval;
        };
        Object.defineProperties(m, {
          name: { value: name, writable: false }, 
        });
        Object.defineProperties(constructor.prototype, {
          [name]: { value: m, configurable: true, writable: true },
        });
      } 
    }
  }

  function attachDataViewAccessors(s) {
    const {
      constructor: {
        prototype,
      },
      instance: {
        members
      },
    } = s;
    if (!Object.getOwnPropertyDescriptor(prototype, 'dataView')) {
      Object.defineProperties(prototype, { 
        dataView: { get: getDataView, configurable: true, enumerable: true },
      });
    }
    const getTypedArray = obtainTypedArrayGetter(members);
    if (getTypedArray && !Object.getOwnPropertyDescriptor(prototype, 'typedArray')) {
      Object.defineProperties(prototype, {
        typedArray: { get: getTypedArray, configurable: true, enumerable: true },
      });
    }
  }

  exports.attachMember = attachMember;
  exports.attachMethod = attachMethod;
  exports.attachMethods = attachMethods;
  exports.attachStaticMembers = attachStaticMembers;
  exports.attachTemplate = attachTemplate;
  exports.beginStructure = beginStructure;
  exports.finalizePointer = finalizePointer;
  exports.finalizeStructure = finalizeStructure;
  exports.getArgumentBuffers = getArgumentBuffers;
  exports.globalSlots = globalSlots;
  exports.invokeFactory = invokeFactory;

  return exports;

})({}))
)====="
