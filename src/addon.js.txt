R"=====(
((function (exports) {
  'use strict';

  const MEMORY = Symbol('memory');
  const SLOTS = Symbol('slots');
  const ZIG = Symbol('ZIG');

  const TYPED_ARRAY = Symbol('typedArray');
  const ENUM_INDEX = Symbol('enumIndex');
  const ENUM_ITEMS = Symbol('enumItems');
  const ERROR_INDEX = Symbol('errorIndex');

  function getBitAlignFunction(bitPos, bitSize, toAligned) {
    if (bitPos + bitSize <= 8) {
      const mask = (2 ** bitSize) - 1;
      if (toAligned) {
        // from single byte
        return function(dest, src, offset) {
          const n = src.getUint8(offset);
          const b = (n >> bitPos) & mask;
          dest.setUint8(0, b);
        };
      } else {
        // to single byte
        const destMask = 0xFF ^ (mask << bitPos);
        return function(dest, src, offset) {
          const n = src.getUint8(0);
          const d = dest.getUint8(offset);
          const b = (d & destMask) | ((n & mask) << bitPos);
          dest.setUint8(offset, b);
        };
      }
    } else {
      const leadBits = 8 - bitPos;
      const leadMask = (2 ** leadBits) - 1;
      if (toAligned) {
        const trailBits = bitSize % 8;
        const trailMask = (2 ** trailBits) - 1;
        return function(dest, src, offset) {
          let i = offset, j = 0;
          let n = src.getUint8(i++), b;
          let bitBuf = (n >> bitPos) & leadMask;
          let bitCount = leadBits;
          let remaining = bitSize;
          do {
            if (remaining > bitCount) {
              n = src.getUint8(i++);
              bitBuf = bitBuf | (n << bitCount);
              //bitCount += 8;
            }
            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
            dest.setUint8(j++, b);
            bitBuf >>= 8;
            //bitCount -= 8;
            remaining -= 8;
          } while (remaining > 0);
        }
      } else {
        const trailBits = (bitSize - leadBits) % 8;
        const trailMask = (2 ** trailBits) - 1;
        const destMask1 = 0xFF ^ (leadMask << bitPos);
        const destMask2 = 0xFF ^ trailMask;
        return function(dest, src, offset) {
          let i = 0, j = offset;
          // preserve bits ahead of bitPos
          let d = dest.getUint8(j), n, b;
          let bitBuf = d & destMask1;
          let bitCount = bitPos;
          let remaining = bitSize + bitCount;
          do {
            if (remaining > bitCount) {
              n = src.getUint8(i++);
              bitBuf = bitBuf | (n << bitCount);
              bitCount += 8;
            }
            if (remaining >= 8) {
              b = bitBuf & 0xFF;
            } else {
              // preserve bits at the destination sitting behind the trailing bits
              d = dest.getUint8(j);
              b = (d & destMask2) | (bitBuf & trailMask);
            }
            dest.setUint8(j++, b);
            bitBuf >>= 8;
            bitCount -= 8;
            remaining -= 8;
          } while (remaining > 0);
        }
      }
    }
  }

  function getCopyFunction(size) {
    return (size & 0x03) ? copy1 : copy4;
  }

  function copy1(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i++) {
      dest.setInt8(i, src.getInt8(i));
    }
  }

  function copy4(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i += 4) {
      dest.setInt32(i, src.getInt32(i));
    }
  }

  /*
  function showBits(object) {
    const bitObj = {};
    for (const [ name, value ] of Object.entries(object)) {
      const s = value.toString(2);
      bitObj[name] = s.padStart(Math.ceil(s.length / 8) * 8, '0');
    }
    console.log(bitObj);
  }
  */

  function getDataViewBoolAccessor(access, member) {
    return cacheMethod(access, member, () => {
      const { byteSize } = member;
      if (byteSize === undefined) {
        return undefined;
      }
      const typeName = getTypeName({ type: MemberType.Int, isSigned: true, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? 1 : 0, littleEndian);
        };
      }
    });
  }

  function getDataViewBoolAccessorEx(access, member) {
    return cacheMethod(access, member, () => {
      if (isByteAligned(member)) {
        return getDataViewBoolAccessor(access, member);
      }
      const { bitOffset } = member;
      const bitPos = bitOffset & 0x07;
      const mask = 1 << bitPos;
      const get = DataView.prototype.getInt8;
      if (access === 'get') {
        return function(offset) {
          const n = get.call(this, offset);
          return !!(n & mask);
        };
      } else {
        const set = DataView.prototype.setInt8;
        return function(offset, value) {
          const n = get.call(this, offset);
          const b = (value) ? n | mask : n & ~mask;
          set.call(this, offset, b);
        };
      }
    });
  }

  function getDataViewIntAccessorEx(access, member) {
    return cacheMethod(access, member, (name) => {
      if (DataView.prototype[name]) {
        return DataView.prototype[name];
      }
      if (isByteAligned(member)) {
        return defineAlignedIntAccessor(access, member)
      } else {
        return defineUnalignedIntAccessor(access, member);
      }
    });
  }

  function getDataViewFloatAccessorEx(access, member) {
    return cacheMethod(access, member, (name) => {
      if (DataView.prototype[name]) {
        return DataView.prototype[name];
      }
      if (isByteAligned(member)) {
        return defineAlignedFloatAccessor(access, member)
      } else {
        return defineUnalignedFloatAccessor(access, member);
      }
    });
  }

  function getDataView(structure, arg) {
    let dv;
    if (arg instanceof DataView) {
      dv = arg;
    } else if (arg instanceof ArrayBuffer || arg instanceof SharedArrayBuffer) {
      dv = new DataView(arg);
    } else {
      throwBufferExpected(structure);
    }
    const { type, size } = structure;
    if (type === StructureType.Slice) {
      if (dv.byteLength % size !== 0) {
        throwSizeMismatch(structure, dv);
      }
    } else {
      if (dv.byteLength !== size) {
        throwSizeMismatch(structure, dv);
      }
    }
    return dv;
  }

  function isBuffer(arg) {
    return (arg instanceof DataView || arg instanceof ArrayBuffer || arg instanceof SharedArrayBuffer);
  }

  function getTypeName({ type, isSigned, bitSize }) {
    if (type === MemberType.Int) {
      return `${bitSize <= 32 ? '' : 'Big' }${isSigned ? 'Int' : 'Uint'}${bitSize}`;
    } else if (type === MemberType.Float) {
      return `Float${bitSize}`;
    } else if (type === MemberType.Bool) {
      return `Bool`;
    } else if (type === MemberType.Void) {
      return `Null`;
    }
  }

  function addDataViewAccessor(s) {
    const {
      constructor: {
        prototype,
      },
      instance: {
        members
      },
    } = s;
    const get = function() {
      return this[MEMORY];
    };
    Object.defineProperties(prototype, {
      dataView: { get, configurable: true, enumerable: true },
    });
  }

  function defineAlignedIntAccessor(access, member) {
    const { isSigned, bitSize, byteSize } = member;
    if (bitSize < 64) {
      // actual number of bits needed when stored aligned
      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });
      const get = DataView.prototype[`get${typeName}`];
      const set = DataView.prototype[`set${typeName}`];
      if (isSigned) {
        const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
        const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
        if (access === 'get') {
          return function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            return (n & valueMask) - (n & signMask);
          };
        } else {
          return function(offset, value, littleEndian) {
            const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
            set.call(this, offset, n, littleEndian);
          };
        }
      } else {
        const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
        if (access === 'get') {
          return function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            return n & valueMask;
          };
        } else {
          return function(offset, value, littleEndian) {
            const n = value & valueMask;
            set.call(this, offset, n, littleEndian);
          };
        }
      }
    } else {
      // larger than 64 bits
      const getWord = DataView.prototype.getBigUint64;
      const setWord = DataView.prototype.setBigUint64;
      const wordCount = Math.ceil(bitSize / 64);
      const get = function(offset, littleEndian) {
        let n = 0n;
        if (littleEndian) {
          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
            const w = getWord.call(this, j, littleEndian);
            n = (n << 64n) | w;
          }
        } else {
          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
            const w = getWord.call(this, j, littleEndian);
            n = (n << 64n) | w;
          }
        }
        return n;
      };
      const set = function(offset, value, littleEndian) {
        let n = value;
        const mask = 0xFFFFFFFFFFFFFFFFn;
        if (littleEndian) {
          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
            const w = n & mask;
            setWord.call(this, j, w, littleEndian);
            n >>= 64n;
          }
        } else {
          n <<= BigInt(wordCount * 64 - bitSize);
          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
            const w = n & mask;
            setWord.call(this, j, w, littleEndian);
            n >>= 64n;
          }
        }
        return n;
      };
      if (isSigned) {
        const signMask = 2n ** BigInt(bitSize - 1);
        const valueMask = signMask - 1n;
        if (access === 'get') {
          return function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            return (n & valueMask) - (n & signMask);
          };
        } else {
          return function(offset, value, littleEndian) {
            const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
            set.call(this, offset, n, littleEndian);
          };
        }
      } else {
        const valueMask = (2n ** BigInt(bitSize)) - 1n;
        if (access === 'get') {
          return function(offset, littleEndian) {
            const n = get.call(this, offset, littleEndian);
            return n & valueMask;
          };
        } else {
          return function(offset, value, littleEndian) {
            const n = value & valueMask;
            set.call(this, offset, n, littleEndian);
          };
        }
      }
    }
  }

  function defineUnalignedIntAccessor(access, member) {
    const { isSigned, bitSize, bitOffset } = member;
    const bitPos = bitOffset & 0x07;
    if (bitPos + bitSize <= 8) {
      const set = DataView.prototype.setUint8;
      const get = DataView.prototype.getUint8;
      // sub-8-bit numbers have real use cases
      if (isSigned) {
        const signMask = 2 ** (bitSize - 1);
        const valueMask = signMask - 1;
        if (access === 'get') {
          return function(offset) {
            const n = get.call(this, offset);
            const s = n >>> bitPos;
            return (s & valueMask) - (s & signMask);
          };
        } else {
          const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
          return function(offset, value) {
            let b = get.call(this, offset);
            const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
            b = (b & outsideMask) | (n << bitPos);
            set.call(this, offset, b);
          };
        }
      } else {
        const valueMask = (2 ** bitSize - 1);
        if (access === 'get') {
          return function(offset) {
            const n = get.call(this, offset);
            const s = n >>> bitPos;
            return s & valueMask;
          };
        } else {
          const outsideMask = 0xFF ^ (valueMask << bitPos);
          return function(offset, value) {
            const n = get.call(this, offset);
            const b = (n & outsideMask) | ((value & valueMask) << bitPos);
            set.call(this, offset, b);
          };
        }
      }
    }
    return defineUnalignedAccessorUsing(access, member, getDataViewIntAccessorEx);
  }

  function defineAlignedFloatAccessor(access, member) {
    const { bitSize } = member;
    if (bitSize === 16) {
      const buf = new DataView(new ArrayBuffer(4));
      const set = DataView.prototype.setUint16;
      const get = DataView.prototype.getUint16;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = get.call(this, offset, littleEndian);
          const sign = n >>> 15;
          const exp = (n & 0x7C00) >> 10;
          const frac = n & 0x03FF;
          if (exp === 0) {
            return (sign) ? -0 : 0;
          } else if (exp === 0x1F) {
            if (!frac) {
              return (sign) ? -Infinity : Infinity;
            } else {
              return NaN;
            }
          }
          const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
          buf.setUint32(0, n32, littleEndian);
          return buf.getFloat32(0, littleEndian);
        }
      } else {
        return function(offset, value, littleEndian) {
          buf.setFloat32(0, value, littleEndian);
          const n = buf.getUint32(0, littleEndian);
          const sign = n >>> 31;
          const exp = (n & 0x7F800000) >> 23;
          const frac = n & 0x007FFFFF;
          const exp16 = (exp - 127 + 15);
          let n16;
          if (exp === 0) {
            n16 = sign << 15;
          } else if (exp === 0xFF) {
            n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
          } else if (exp16 >= 31) {
            n16 = sign << 15 | 0x1F << 10;
          } else {
            n16 = sign << 15 | exp16 << 10 | (frac >> 13);
          }
          set.call(this, offset, n16, littleEndian);
        }
      }
    } else if (bitSize === 80) {
      const buf = new DataView(new ArrayBuffer(8));
      const setWord = DataView.prototype.setBigUint64;
      const getWord = DataView.prototype.getBigUint64;
      const get = function(offset, littleEndian) {
        const w1 = getWord.call(this, offset, littleEndian);
        const w2 = getWord.call(this, offset + 8, littleEndian);
        return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;
      };
      const set = function(offset, value, littleEndian) {
        const w1 = value & 0xFFFFFFFFFFFFFFFFn;
        const w2 = value >> 64n;
        setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);
        setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);
      };
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = get.call(this, offset, littleEndian);
          const sign = n >> 79n;
          const exp = (n & 0x7FFF0000000000000000n) >> 64n;
          const frac = n & 0x00007FFFFFFFFFFFFFFFn;
          if (exp === 0n) {
            return (sign) ? -0 : 0;
          } else if (exp === 0x7FFFn) {
            if (!frac) {
              return (sign) ? -Infinity : Infinity;
            } else {
              return NaN;
            }
          }
          const exp64 = exp - 16383n + 1023n;
          if (exp64 >= 2047n) {
            return (sign) ? -Infinity : Infinity;
          }
          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n);
          buf.setBigUint64(0, n64, littleEndian);
          return buf.getFloat64(0, littleEndian);
        }
      } else {
        return function(offset, value, littleEndian) {
          buf.setFloat64(0, value, littleEndian);
          const n = buf.getBigUint64(0, littleEndian);
          const sign = n >> 63n;
          const exp = (n & 0x7FF0000000000000n) >> 52n;
          const frac = n & 0x000FFFFFFFFFFFFFn;
          let n80;
          if (exp === 0n) {
            n80 = sign << 79n | (frac << 11n);
          } else if (exp === 0x07FFn) {
            n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
            //                                                 ^ bit 61                       ^ bit 63
          } else {
            n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
          }
          set.call(this, offset, n80, littleEndian);
        }
      }
    } else if (bitSize === 128) {
      const buf = new DataView(new ArrayBuffer(8));
      const getWord = DataView.prototype.getBigUint64;
      const setWord = DataView.prototype.setBigUint64;
      const get = function(offset, littleEndian) {
        const w1 = getWord.call(this, offset, littleEndian);
        const w2 = getWord.call(this, offset + 8, littleEndian);
        return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;
      };
      const set = function(offset, value, littleEndian) {
        const w1 = value & 0xFFFFFFFFFFFFFFFFn;
        const w2 = value >> 64n;
        setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);
        setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);
      };
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = get.call(this, offset, littleEndian);
          const sign = n >> 127n;
          const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
          const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
          if (exp === 0n) {
            return (sign) ? -0 : 0;
          } else if (exp === 0x7FFFn) {
            if (!frac) {
              return (sign) ? -Infinity : Infinity;
            } else {
              return NaN;
            }
          }
          const exp64 = exp - 16383n + 1023n;
          if (exp64 >= 2047n) {
            return (sign) ? -Infinity : Infinity;
          }
          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n);
          buf.setBigUint64(0, n64, littleEndian);
          return buf.getFloat64(0, littleEndian);
        }
      } else {
        return function(offset, value, littleEndian) {
          buf.setFloat64(0, value, littleEndian);
          const n = buf.getBigUint64(0, littleEndian);
          const sign = n >> 63n;
          const exp = (n & 0x7FF0000000000000n) >> 52n;
          const frac = n & 0x000FFFFFFFFFFFFFn;
          let n128;
          if (exp === 0n) {
            n128 = sign << 127n | (frac << 60n);
          } else if (exp === 0x07FFn) {
            n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
          } else {
            n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
          }
          set.call(this, offset, n128, littleEndian);
        }
      }
    }
  }

  function defineUnalignedFloatAccessor(access, member) {
    return defineUnalignedAccessorUsing(access, member, getDataViewFloatAccessorEx);
  }

  function defineUnalignedAccessorUsing(access, member, getDataViewAccessor) {
    // pathological usage scenario--handle it anyway by copying the bitSize into a
    // temporary buffer, bit-aligning the data
    const { bitSize, bitOffset } = member;
    const bitPos = bitOffset & 0x07;
    const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
    const buf = new DataView(new ArrayBuffer(byteSize));
    if (access === 'get') {
      const getAligned = getDataViewAccessor('get', { ...member, byteSize });
      const copyBits = getBitAlignFunction(bitPos, bitSize, true);
      return function(offset, littleEndian) {
        copyBits(buf, this, offset);
        return getAligned.call(buf, 0, littleEndian);
      };
    } else {
      const setAligned = getDataViewAccessor('set', { ...member, byteSize });
      const applyBits = getBitAlignFunction(bitPos, bitSize, false);
      return function(offset, value, littleEndian) {
        setAligned.call(buf, 0, value, littleEndian);
        applyBits(this, buf, offset);
      };
    }
  }

  function cacheMethod(access, member, cb) {
    const { bitOffset, byteSize } = member;
    const bitPos = bitOffset & 0x07;
    const typeName = getTypeName(member);
    const suffix = isByteAligned(member) ? `` : `Bit${bitPos}`;
    const name = `${access}${typeName}${suffix}`;
    var fn = methodCache[name];
    if (!fn) {
      fn = methodCache[name] = cb(name);
      if (fn && !fn.name) {
        Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
      }
    }
    return fn;
  }

  const methodCache = {};

  function finalizePrimitive(s) {
    const {
      size,
      instance: {
        members: [ member ],
      },
      options,
    } = s;
    const primitive = getPrimitiveClass(member);
    const copy = getCopyFunction(size);
    s.copier = function (dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        // new operation--expect matching primitive
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = getDataView(s, arg);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      if (creating) {
        if (primitive !== undefined) {
          if (arg !== undefined) {
            this.set(primitive(arg));
          }
        }
      } else {
        return self;
      }
    };
    const { get, set } = getAccessors(member, options);
    Object.defineProperties(constructor.prototype, {
      get: { value: get, configurable: true, writable: true },
      set: { value: set, configurable: true, writable: true },
      [Symbol.toPrimitive]: { value: get, configurable: true, writable: true },
    });
    return constructor;
  }

  function getIntRange({ isSigned, bitSize }) {
    if (bitSize <= 32) {
      const max = 2 ** (isSigned ? bitSize - 1 : bitSize) - 1;
      const min = (isSigned) ? -(2 ** (bitSize - 1)) : 0;
      return { min, max };
    } else {
      bitSize = BigInt(bitSize);
      const max = 2n ** (isSigned ? bitSize - 1n : bitSize) - 1n;
      const min = (isSigned) ? -(2n ** (bitSize - 1n)) : 0n;
      return { min, max };
    }
  }

  function getPrimitiveClass({ type, bitSize }) {
    if (type === MemberType.Int) {
      if (bitSize <= 32) {
        return Number;
      } else {
        return BigInt;
      }
    } else if (type === MemberType.Float) {
      return Number;
    } else if (type === MemberType.Bool) {
      return Boolean;
    }
  }

  function addTypedArrayAccessor(s) {
    const {
      constructor,
      instance: {
        members: [ member ],
      }
    } = s;
    if (process.env.NODE_ENV !== 'production') {
      /* c8 ignore next 3 */
      if (s.type !== StructureType.Array && s.type !== StructureType.Slice) {
        throw new Error('Only arrays can have typed array accessor');
      }
    }
    const TypedArray = getTypedArrayClass(member);
    if (TypedArray) {
      const get = function() {
        if (!this[TYPED_ARRAY]) {
          const dv = this[MEMORY];
          this[TYPED_ARRAY] = new TypedArray(dv.buffer, dv.byteOffset, this.length);
        }
        return this[TYPED_ARRAY];
      };
      Object.defineProperties(constructor.prototype, {
        typedArray: { get, configurable: true },
      });
    }
  }

  function getTypedArrayClass(member) {
    const typeName = getTypeName(member);
    return TypedArrays[typeName];
  }

  const TypedArrays = {
    Int8: Int8Array,
    Uint8: Uint8Array,
    Int16: Int16Array,
    Uint16: Uint16Array,
    Int32: Int32Array,
    Uint32: Uint32Array,
    Int64: BigInt64Array,
    Uint64: BigUint64Array,
    Float32: Float32Array,
    Float64: Float64Array,
  };

  function finalizeArray(s) {
    const {
      type,
      size,
      instance: {
        members: [ member ],
      },
      options,
    } = s;
    if (process.env.NODE_DEV !== 'production') {
      /* c8 ignore next 6 */
      if (member.bitOffset !== undefined) {
        throw new Error(`bitOffset must be undefined for array member`);
      }
      if (member.slot !== undefined) {
        throw new Error(`slot must be undefined for array member`);
      }
    }
    const copy = getCopyFunction(size);
    const objectMember = (member.type === MemberType.Object) ? member : null;
    s.copier = function(dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      if (objectMember) {
        dest[SLOTS] = { ...src[SLOTS] };
      }
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = getDataView(s, arg);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      if (objectMember) {
        const slots = {};
        const { structure: { constructor }, byteSize } = objectMember;
        const recv = (this === ZIG) ? this : null;
        for (let slot = 0, offset = 0, len = dv.byteLength; offset < len; slot++, offset += byteSize) {
          const childDV = new DataView(dv.buffer, offset, byteSize);
          slots[slot] = constructor.call(recv, childDV);
        }
        Object.defineProperties(self, {
          [SLOTS]: { value: slots, writable: true },
        });
      }
      if (creating) ; else {
        return self;
      }
    };
    const { get, set } = getAccessors(member, options);
    let lengthDescriptor;
    if (type == StructureType.Slice) {
      const get = getArrayLengthGetter(size);
      lengthDescriptor = { get, configurable: true };
    } else {
      const length = size / member.byteSize;
      lengthDescriptor = { value: length, configurable: true };
    }
    Object.defineProperties(constructor.prototype, {
      get: { value: get, configurable: true, writable: true },
      set: { value: set, configurable: true, writable: true },
      length: lengthDescriptor,
      [Symbol.iterator]: { value: getArrayIterator, configurable: true },
    });
    addTypedArrayAccessor(s);
    return constructor;
  }

  function getArrayLengthGetter(size) {
    const shift = getShift(size);
    if (shift !== undefined) {
      // use shift where possible
      return function() {
        return this[MEMORY].byteLength >> shift;
      };
    } else {
      return function() {
        return this[MEMORY].byteLength / size;
      };
    }
  }

  function getShift(size) {
    for (let i = 0, j = 2 ** i; j <= size; i++, j = 2 ** i) {
      if (j === size) {
        return i;
      }
    }
  }

  function getArrayIterator() {
    const self = this;
    const length = this.length;
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < length) {
          value = self.get(index);
          done = false;
          index++;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function addStaticMembers(s) {
    const {
      constructor,
      static: {
        members,
        template,
      },
      options,
    } = s;
    const descriptors = {
      [SLOTS]: { value: template?.[SLOTS] },
    };
    for (const member of members) {
      const { get, set } = getAccessors(member, options);
      descriptors[member.name] = { get, set, configurable: true, enumerable: true };
    }  Object.defineProperties(constructor, descriptors);
  }

  function finalizeStruct(s) {
    const {
      size,
      instance: {
        members,
        template,
      },
      options,
    } = s;
    const isArgStruct = (s.type === StructureType.ArgStruct);
    const copy = getCopyFunction(size);
    const descriptors = {};
    for (const member of members) {
      const isArgument = isArgStruct && !isNaN(parseInt(member.name));
      const { get, set } = getAccessors(member, { autoDeref: !isArgument, ...options });
      descriptors[member.name] = { get, set, configurable: true, enumerable: true };
    }
    const objectMembers = members.filter(m => m.type === MemberType.Object);
    const copier = s.copier = function(dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      if (objectMembers.length > 0) {
        dest[SLOTS] = { ...src[SLOTS] };
      }
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        // new operation--expect an object
        // TODO: validate argument
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = getDataView(s, arg);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      Object.defineProperties(self, descriptors);
      if (objectMembers.length > 0) {
        // create child objects
        const recv = (this === ZIG) ? this : null;
        const slots = {};
        for (const { structure: { constructor }, bitOffset, byteSize, slot } of objectMembers) {
          const offset = bitOffset >> 3;
          const childDV = new DataView(dv.buffer, offset, byteSize);
          slots[slot] = constructor.call(recv, childDV);
        }
        Object.defineProperties(self, {
          [SLOTS]: { value: slots, writable: true },
        });
      }
      if (creating) {
        if (template) {
          copier(this, template);
        }
        if (arg) {
          for (const [ key, value ] of Object.entries(arg)) {
            this[key] = value;
          }
        }
      } else {
        return self;
      }
    };
    if (!isArgStruct) {
      // TODO: addPointerAccessors(s);
      addDataViewAccessor(s);
      addStaticMembers(s);
      addMethods(s);
    }
    return constructor;
  }

  function finalizeErrorUnion(s) {
    const {
      name,
      size,
      instance: { members },
      options,
    } = s;
    const copy = getCopyFunction(size);
    const hasObject = !!members.find(m => m.type === MemberType.Object);
    s.copier = function (dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      if (hasObject) {
        dest[SLOTS] = { ...src[SLOTS] };
      }
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        // new operation
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = getDataView(s, arg);
      }
      /* TODO: handle struct */
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      if (creating) {
        this.set(arg);
      } else {
        return self;
      }
    };
    const { get, set } = getErrorUnionAccessors(members, options);
    Object.defineProperties(constructor.prototype, {
      get: { value: get, configurable: true, writable: true },
      set: { value: set, configurable: true, writable: true },
    });
    return constructor;
  }

  function getErrorUnionAccessors(members, options) {
    const { get: getValue, set: setValue } = getAccessors(members[0], options);
    const { get: getError, set: setError } = getAccessors(members[1], options);
    const { structure } = members[1];
    return {
      get: function() {
        const errorNumber = getError.call(this);
        if (errorNumber !== 0) {
          const { constructor } = structure;
          const err = constructor(errorNumber);
          if (!err) {
            throwUnknownErrorNumber(structure, errorNumber);
          }
          throw err;
        } else {
          return getValue.call(this);
        }
      },
      set: function(value) {
        let errorNumber;
        if (value instanceof Error) {
          const { constructor } = structure;
          if (!(value instanceof constructor)) {
            throwNotInErrorSet(structure);
          }
          errorNumber = Number(value);
          value = null;
        }
        setValue.call(this, value);
        setError.call(this, errorNumber);
      },
    };
  }

  function finalizeErrorSet(s) {
    const {
      name,
      instance: {
        members,
      },
    } = s;
    const errors = {};
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      if (creating) {
        throwNoNewError(s);
      }
      const index = Number(arg);
      return errors[index];
    };
    Object.setPrototypeOf(constructor.prototype, Error.prototype);
    const valueOf = function() { return this[ERROR_INDEX] };
    const toStringTag = function() { return 'Error' };
    Object.defineProperties(constructor.prototype, {
      // provide a way to retrieve the error index
      [Symbol.toPrimitive]: { value: valueOf, configurable: true, writable: true },
      // ensure that libraries that rely on the string tag for type detection will
      // correctly identify the object as an error
      [Symbol.toStringTag]: { get: toStringTag, configurable: true },
    });
    // attach the errors to the constructor and the
    for (const [ index, { name, slot } ] of members.entries()) {
      // can't use the constructor since it would throw
      const error = Object.create(constructor.prototype);
      const message = decamelizeErrorName(name);
      Object.defineProperties(error, {
        message: { value: message, configurable: true, enumerable: true, writable: false },
        [ERROR_INDEX]: { value: slot },
      });
      Object.defineProperties(constructor, {
        [name]: { value: error, configurable: true, enumerable: true, writable: true },
      });
      errors[slot] = error;
    }
    return constructor;
  }

  function finalizeEnumeration(s) {
    const {
      instance: {
        members,
        template,
      },
      options,
    } = s;
    if (process.env.NODE_DEV !== 'production') {
      /* c8 ignore next 5 */
      for (const member of members) {
        if (member.bitOffset !== undefined) {
          throw new Error(`bitOffset must be undefined for enumeration member`);
        }
      }
    }
    const primitive = getPrimitiveClass(members[0]);
    const { get: getValue } = getAccessors(members[0], options);
    const count = members.length;
    const items = {};
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      if (creating) {
        // the "constructor" is only used to convert a number into an enum object
        // new enum items cannot be created
        throwNoNewEnum(s);
      }
      let index = -1;
      if (isSequential) {
        // normal enums start at 0 and go up, so the value is the index
        index = Number(arg);
      } else {
        // values aren't sequential, so we need to compare values
        // casting just in case the enum is BigInt
        const given = primitive(arg);
        for (let i = 0; i < count; i++) {
          const value = getValue.call(constructor, i);
          if (value === given) {
            index = i;
            break;
          }
        }
      }
      // return the enum object (created down below)
      return items[index];
    };
    // attach the numeric values to the class as its binary data
    // this allows us to reuse the array getter
    Object.defineProperties(constructor, {
      [MEMORY]: { value: template[MEMORY] },
      [ENUM_ITEMS]: { value: items },
    });
    const valueOf = function() {
      const index = this[ENUM_INDEX] ;
      return getValue.call(constructor, index);
    };
    Object.defineProperties(constructor.prototype, {
      [Symbol.toPrimitive]: { value: valueOf, configurable: true, writable: true },
      // so we don't get an empty object when JSON.stringify() is used
      toJSON: { value: valueOf, configurable: true, writable: true },
    });
    // now that the class has the right hidden properties, getValue() will work
    // scan the array to see if the enum's numeric representation is sequential
    const isSequential = (() => {
      // try-block in the event that the enum has bigInt items
      try {
        for (let i = 0; i < count; i++) {
          if (getValue.call(constructor, i) !== i) {
            return false;
          }
        }
        return true;
        /* c8 ignore next 3 */
      } catch (err) {
        return false;
      }
    })();
    // attach the enum items to the constructor
    for (const [ index, { name } ] of members.entries()) {
      // can't use the constructor since it would throw
      const item = Object.create(constructor.prototype);
      Object.defineProperties(item, {
        [ENUM_INDEX]: { value: index },
      });
      Object.defineProperties(constructor, {
        [name]: { value: item, configurable: true, enumerable: true, writable: true },
      });
      items[index] = item;
    }
    addStaticMembers(s);
    addMethods(s);
    return constructor;
  }

  function finalizeOptional(s) {
    const {
      size,
      instance: { members },
      options,
    } = s;
    const copy = getCopyFunction(size);
    const objectMember = members.find(m => m.type === MemberType.Object);
    s.copier = function (dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      if (objectMember) {
        dest[SLOTS] = { ...src[SLOTS] };
      }
    };
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      if (creating) {
        // new operation
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = getDataView(s, arg);
      }
      /* TODO: handle struct */
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
      });
      if (creating) {
        this.set(arg);
      } else {
        return self;
      }
    };
    const { get, set } = getOptionalAccessors(members, options);
    Object.defineProperties(constructor.prototype, {
      get: { value: get, configurable: true, writable: true },
      set: { value: set, configurable: true, writable: true },
    });
    return constructor;
  }

  function getOptionalAccessors(members, options) {
    const { get: getValue, set: setValue } = getAccessors(members[0], options);
    const { get: getPresent, set: setPresent } = getAccessors(members[1], options);
    return {
      get: function() {
        const present = getPresent.call(this);
        if (present) {
          return getValue.call(this);
        } else {
          return null;
        }
      },
      set: function(value) {
        setPresent.call(this, value != null);
        setValue.call(this, value);
      },
    };
  }

  function finalizePointer(s) {
    const {
      size,
      instance: {
        members: [ member ],
      },
      options,
    } = s;
    const { get, set } = getAccessors(member, options);
    const copy = getCopyFunction(size);
    s.copier = function (dest, src) {
      copy(dest[MEMORY], src[MEMORY]);
      dest[SLOTS] = { ...src[SLOTS] };
    };
    const { structure: target } = member;
    target.type === StructureType.Slice;
    const constructor = s.constructor = function(arg) {
      const creating = this instanceof constructor;
      let self, dv;
      const slots = { 0: null };
      if (creating) {
        self = this;
        dv = new DataView(new ArrayBuffer(size));
      } else {
        self = Object.create(constructor.prototype);
        dv = getDataView(s, arg);
      }
      Object.defineProperties(self, {
        [MEMORY]: { value: dv },
        [SLOTS]: { value: slots, writable: true },
        // a boolean value indicating whether Zig currently owns the pointer
        [ZIG]: { value: this === ZIG, writable: true },
      });
      if (creating) {
        const { constructor } = target;
        if (!(arg instanceof constructor)) {
          const recv = (this === ZIG) ? this : null;
          arg = isBuffer(arg) ? constructor.call(recv, arg) : new constructor(arg);
        }
        slots[0] = arg;
      } else {
        return self;
      }
    };
    Object.defineProperties(constructor.prototype, {
      '*': { get, set, configurable: true, enumerable: true },
    });
    return constructor;
  }

  const StructureType = {
    Primitive: 0,
    Array: 1,
    Struct: 2,
    ExternUnion: 3,
    TaggedUnion: 4,
    ErrorUnion: 5,
    ErrorSet: 6,
    Enumeration: 7,
    Optional: 8,
    Pointer: 9,
    Slice: 10,
    Opaque: 11,
    ArgStruct: 12,
  };

  const factories$1 = Array(Object.values(StructureType).length);

  function usePrimitive() {
    factories$1[StructureType.Primitive] = finalizePrimitive;
  }

  function useArray() {
    factories$1[StructureType.Array] = finalizeArray;
  }

  function useStruct() {
    factories$1[StructureType.Struct] = finalizeStruct;
  }

  function useExternUnion() {
    factories$1[StructureType.ExternUnion] = finalizeStruct;
  }

  function useErrorUnion() {
    factories$1[StructureType.ErrorUnion] = finalizeErrorUnion;
  }

  function useErrorSet() {
    factories$1[StructureType.ErrorSet] = finalizeErrorSet;
  }

  function useEnumeration() {
    factories$1[StructureType.Enumeration] = finalizeEnumeration;
  }

  function useOptional() {
    factories$1[StructureType.Optional] = finalizeOptional;
  }

  function usePointer() {
    factories$1[StructureType.Pointer] = finalizePointer;

  }
  function useSlice() {
    factories$1[StructureType.Slice] = finalizeArray;
  }
  function useOpaque() {
    factories$1[StructureType.Opaque] = finalizeStruct;
  }

  function useArgStruct() {
    factories$1[StructureType.ArgStruct] = finalizeStruct;
  }

  function beginStructure(def, options = {}) {
    const {
      type,
      name,
      size,
    } = def;
    return {
      constructor: null,
      copier: null,
      type,
      name,
      size,
      instance: {
        members: [],
        template: null,
      },
      static: {
        members: [],
        template: null,
      },
      methods: [],
      options,
    };
  }

  function attachMember(s, def) {
    const target = (def.isStatic) ? s.static : s.instance;
    target.members.push(def);
  }

  function attachMethod(s, def) {
    s.methods.push(def);
  }

  function attachTemplate(s, def) {
    const target = (def.isStatic) ? s.static : s.instance;
    target.template = def.template;
  }

  function finalizeStructure(s) {
    try {
      const f = factories$1[s.type];
      if (process.env.NODE_ENV !== 'production') {
        /* c8 ignore next 10 */
        if (typeof(f) !== 'function') {
          let typeName;
          for (const [ name, value ] of Object.entries(StructureType)) {
            if (value === s.type) {
              typeName = name;
              break;
            }
          }
          throw new Error(`No factory for ${typeName}: ${f}`);
        }
      }
      const constructor = f(s);
      if (constructor) {
        Object.defineProperty(constructor, 'name', { value: s.name, writable: false });
      }
      return constructor;
      /* c8 ignore next 4 */
    } catch (err) {
      console.error(err);
      throw err;
    }
  }

  const MemberType = {
    Void: 0,
    Bool: 1,
    Int: 2,
    Float: 3,
    EnumerationItem: 4,
    Object: 5,
    Type: 6,
  };

  const factories = Array(Object.values(MemberType).length);

  function useVoid() {
    factories[MemberType.Void] = getVoidAccessor;
  }

  function useBoolEx() {
    factories[MemberType.Bool] = getBoolAccessorEx;
  }

  function useIntEx() {
    factories[MemberType.Int] = getIntAccessorEx;
  }

  function useFloatEx() {
    factories[MemberType.Float] = getFloatAccessorEx;
  }

  function useEnumerationItemEx() {
    factories[MemberType.EnumerationItem] = getEnumerationItemAccessorEx;
  }

  function useObject() {
    factories[MemberType.Object] = getObjectAccessor;
  }

  function isByteAligned({ bitOffset, bitSize, byteSize }) {
    return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
  }

  function useType() {
    factories[MemberType.Type] = getTypeAccessor;
  }

  function getAccessors(member, options = {}) {
    const f = factories[member.type];
    if (process.env.NODE_ENV !== 'production') {
      /* c8 ignore next 10 */
      if (typeof(f) !== 'function') {
        let typeName;
        for (const [ name, value ] of Object.entries(MemberType)) {
          if (value === member.type) {
            typeName = name;
            break;
          }
        }
        throw new Error(`No factory for ${typeName}: ${f}`);
      }
    }
    return {
      get: f('get', member, options),
      set: f('set', member, options)
    };
  }

  function getVoidAccessor(type, member, options) {
    const { runtimeSafety } = options;
    if (type === 'get') {
      return function() {
        return null;
      };
    } else {
      if (runtimeSafety) {
        return function(value) {
          if (value != null) {
            throwNotNull(member);
          }
        };
        } else {
        return function() {};
      }
    }
  }

  function getBoolAccessorEx(access, member, options) {
    return getAccessorUsing(access, member, options, getDataViewBoolAccessorEx)
  }

  function getIntAccessorEx(access, member, options) {
    const getDataViewAccessor = addRuntimeCheck(options, getDataViewIntAccessorEx);
    return getAccessorUsing(access, member, options, getDataViewAccessor)
  }

  function addRuntimeCheck(options, getDataViewAccessor) {
    return function (access, member) {
      const {
        runtimeSafety = true,
      } = options;
      const accessor = getDataViewAccessor(access, member);
      if (runtimeSafety && access === 'set') {
        const { min, max } = getIntRange(member);
        return function(offset, value, littleEndian) {
          if (value < min || value > max) {
            throwOverflow(member, value);
          }
          accessor.call(this, offset, value, littleEndian);
        };
      }
      return accessor;
    };
  }

  function getFloatAccessorEx(access, member, options) {
    return getAccessorUsing(access, member, options, getDataViewFloatAccessorEx)
  }

  function getEnumerationItemAccessorEx(access, member, options) {
    const getDataViewAccessor = addEnumerationLookup(getDataViewIntAccessorEx);
    return getAccessorUsing(access, member, options, getDataViewAccessor) ;
  }

  function addEnumerationLookup(getDataViewIntAccessor) {
    return function(access, member) {
      const accessor = getDataViewIntAccessor(access, { ...member, type: MemberType.Int });
      const { structure } = member;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const { constructor } = structure;
          const value = accessor.call(this, offset, littleEndian);
          // the enumeration constructor returns the object for the int value
          const object = constructor(value);
          if (!object) {
            throwInvalidEnum(value);
          }
          return object;
        };
      } else {
        return function(offset, value, littleEndian) {
          const { constructor } = structure;
          if (!(value instanceof constructor)) {
            throwEnumExpected(constructor);
          }
          accessor.call(this, offset, value.valueOf(), littleEndian);
        };
      }
    };
  }

  function getObjectAccessor(access, member, options) {
    // automatically dereference pointer
    const {
      autoDeref = true,
    } = options;
    const { structure, slot } = member;
    switch (structure.type) {
      case StructureType.ErrorUnion:
      case StructureType.Optional: {
        if (slot !== undefined) {
          if (access === 'get') {
            return function() {
              const object = this[SLOTS][slot];
              return object.get();
            };
          } else {
            return function(value) {
              const object = this[SLOTS][slot];
              return object.set(value);
            };
          }
        } else {
          if (access === 'get') {
            return function(index) {
              const object = this[SLOTS][index];
              return object.get();
            };
          } else {
            return function(index, value) {
              const object = this[SLOTS][index];
              return object.set(value);
            };
          }
        }
      }
      case StructureType.Pointer: {
        if (autoDeref) {
          const { instance: { members: [ target ] } } = structure;
          const { isConst } = member;
          if (target.structure.type === StructureType.Primitive) {
            if (slot !== undefined) {
              if (access === 'get') {
                return function() {
                  const pointer = this[SLOTS][slot];
                  const object = pointer['*'];
                  return object.get()
                };
              } else {
                return (isConst) ? undefined : function(value) {
                  const pointer = this[SLOTS][slot];
                  const object = pointer['*'];
                  object.set(value);
                };
              }
            } else {
              // array accessors
              if (access === 'get') {
                return function(index) {
                  const pointer = this[SLOTS][index];
                  const object = pointer['*'];
                  return object.get()
                };
              } else {
                return (isConst) ? undefined : function(index, value) {
                  const pointer = this[SLOTS][index];
                  const object = pointer['*'];
                  object.set(value);
                };
              }
            }
          } else {
            if (slot !== undefined) {
              if (access === 'get') {
                return function() {
                  const pointer = this[SLOTS][slot];
                  const object = pointer['*'];
                  return object;
                };
              } else {
                return (isConst) ? undefined : function(value) {
                  const pointer = this[SLOTS][slot];
                  pointer['*'] = value;
                };
              }
            } else {
              // array accessors
              if (access === 'get') {
                return function(index) {
                  const pointer = this[SLOTS][index];
                  const object = pointer['*'];
                  return object;
                };
              } else {
                return (isConst) ? undefined : function(index, value) {
                  const pointer = this[SLOTS][index];
                  pointer['*'] = value;
                };
              }
            }
          }
        }
      }
      default: {
        if (slot !== undefined) {
          if (access === 'get') {
            return function() {
              const object = this[SLOTS][slot];
              return object;
            };
          } else {
            return function(value) {
              const { constructor, copier } = structure;
              if (!(value instanceof constructor)) {
                value = new constructor(value);
              }
              const object = this[SLOTS][slot];
              copier(object, value);
            };
          }
        } else {
          // array accessors
          if (access === 'get') {
            return function(index) {
              const object = this[SLOTS][index];
              return object;
            };
          } else {
            return function(index, value) {
              const { constructor, copier } = structure;
              if (!(value instanceof constructor)) {
                value = new constructor(value);
              }
              const object = this[SLOTS][index];
              copier(object, value);
            };
          }
        }
      }
    }
  }

  function getTypeAccessor(type, member, options) {
    const { structure } = member;
    if (type === 'get') {
      return function() {
        const { constructor } = structure;
        return constructor;
      };
    }
  }

  function getAccessorUsing(access, member, options, getDataViewAccessor) {
    const {
      runtimeSafety = true,
      littleEndian = true,
    } = options;
    const { type, bitOffset, byteSize } = member;
    const accessor = getDataViewAccessor(access, member);
    if (bitOffset !== undefined) {
      const offset = bitOffset >> 3;
      if (access === 'get') {
        return function() {
          return accessor.call(this[MEMORY], offset, littleEndian);
        };
      } else {
        return function(value) {
          return accessor.call(this[MEMORY], offset, value, littleEndian);
        }
      }
    } else {
      if (access === 'get') {
        return function(index) {
          try {
            return accessor.call(this[MEMORY], index * byteSize, littleEndian);
          } catch (err) {
            rethrowRangeError(member, index, err);
          }
        };
      } else {
        return function(index, value) {
          try {
            return accessor.call(this[MEMORY], index * byteSize, value, littleEndian);
          } catch (err) {
            rethrowRangeError(member, index, err);
          }
        }
      }
    }
  }

  function throwSizeMismatch(structure, dv) {
    const { type, name, size } = structure;
    const actual = dv.byteLength;
    const s = (size > 1) ? 's' : '';
    if (type === StructureType.Slice) {
      throw new TypeError(`${name} has elements that are ${size} byte${s} in length, received ${actual}`);
    } else {
      throw new TypeError(`${name} has ${size} byte${s}, received ${actual}`);
    }
  }

  function throwBufferExpected(structure) {
    const { size } = structure;
    throw new TypeError(`Expecting an ArrayBuffer or DataView ${size} byte(s) in length`);
  }

  function throwInvalidEnum(structure, value) {
    const { name } = structure;
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${value}`);
  }

  function throwEnumExpected(structure) {
    const { name } = structure;
    throw new TypeError(`Enum item expected: ${name}`);
  }

  function throwNoNewEnum(structure) {
    const { name } = structure;
    throw new TypeError(`Cannot create new enum item\nCall ${name} without the use of "new" to obtain an enum object`);
  }

  function throwNoNewError(structure) {
    const { name } = structure;
    throw new TypeError(`Cannot create new error\nCall ${name} without the use of "new" to obtain an error object`);
  }

  function throwNotInErrorSet(structure) {
    const { name } = structure;
    throw new TypeError(`Error given is not a part of error set ${name}`);
  }

  function throwUnknownErrorNumber(structure, number) {
    const { name } = structure;
    throw new TypeError(`Error number does not corresponds to any error in error set ${name}: #${number}`);
  }

  function throwOverflow(member, value) {
    const typeName = getTypeName(member);
    throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
  }

  function throwOutOfBound(member, index) {
    const { name } = member;
    throw new RangeError(`Index exceeds the size of ${name}: ${index}`);
  }

  function rethrowRangeError(member, index, err) {
    if (err instanceof RangeError) {
      throwOutOfBound(member, index);
    } else {
      throw err;
    }
  }

  function throwNotNull(member) {
    const { name } = member;
    throw new RangeError(`Property ${name} can only be null`);
  }

  function throwZigError(name) {
    throw new Error(decamelizeErrorName(name));
  }

  function decamelizeErrorName(name) {
    // use a try block in case Unicode regex fails
    try {
      const lc = name.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu, (m0, m1, m2) => {
        if (m1.length === 1) {
          return ` ${m1.toLocaleLowerCase()}${m2}`;
        } else {
          if (m2) {
            const acronym = m1.substring(0, m1.length - 1);
            const letter = m1.charAt(m1.length - 1).toLocaleLowerCase();
            return ` ${acronym} ${letter}${m2}`;
          } else {
            return ` ${m1}`;
          }
        }
      }).trimStart();
      return lc.charAt(0).toLocaleUpperCase() + lc.substring(1);
      /* c8 ignore next 3 */
    } catch (err) {
      return name;
    }
  }

  function addMethods(s) {
    const {
      constructor,
      methods,
    } = s;
    for (const method of methods) {
      const {
        name,
        argStruct,
        thunk,
        isStaticOnly,
      } = method;
      const f = function(...args) {
        const { constructor } = argStruct;
        const a = new constructor();
        for (const [ index, arg ] of args.entries()) {
          if (arg !== undefined) {
            a[index] = arg;
          }
        }
        invokeThunk(thunk, a);
        return a.retval;
      };
      Object.defineProperties(f, {
        name: { value: name, writable: false },
      });
      Object.defineProperties(constructor, {
        [name]: { value: f, configurable: true, enumerable: true, writable: true },
      });
      if (!isStaticOnly) {
        const m = function(...args) {
          const { constructor } = argStruct;
          const a = new constructor();
          a[0] = this;
          for (const [ index, arg ] of args.entries()) {
            if (arg !== undefined) {
              a[index + 1] = arg;
            }
          }
          invokeThunk(thunk, a);
          return a.retval;
        };
        Object.defineProperties(m, {
          name: { value: name, writable: false },
        });
        Object.defineProperties(constructor.prototype, {
          [name]: { value: m, configurable: true, writable: true },
        });
      }
    }
  }

  const globalSlots = {};

  function invokeThunk(thunk, args) {
    // pass the argument object as the this/recv variable
    // while the slots and symbols are passed as arguments
    const err = thunk.call(args, globalSlots, SLOTS, MEMORY, ZIG);
    // errors returned by exported Zig functions are normally written into the
    // argument object and get thrown when we access its retval property (a zig error union)
    // error strings returned by the thunk are due to problems in the thunking process
    // (i.e. bugs in export.zig)
    if (err) {
      throwZigError(err);
    }
  }

  // enable all member types (including extend types)
  useVoid();
  useBoolEx();
  useIntEx();
  useFloatEx();
  useEnumerationItemEx();
  useObject();
  useType();

  // enable all structure types
  usePrimitive();
  useArray();
  useStruct();
  useExternUnion();
  useErrorUnion();
  useErrorSet();
  useEnumeration();
  useOptional();
  usePointer();
  useSlice();
  useOpaque();
  useArgStruct();

  function log(...args) {
    console.log(...args);
  }

  function invokeFactory(thunk) {
    // our C++ code cannot call invokeThunk() directly since it doesn't have the symbol SLOTS
    // yet and therefore cannot create (or read from) the argument object
    const args = { [SLOTS]: {} };
    invokeThunk(thunk, args);
    return args[SLOTS][0].constructor;
  }

  function getArgumentBuffers(args) {
    const buffers = [];
    const included = new WeakMap();
    const scanned = new WeakMap();
    const scan = (object) => {
      if (!object || scanned.get(object)) {
        return;
      }
      const memory = object[MEMORY];
      if (memory && memory.buffer instanceof ArrayBuffer) {
        if (!included.get(memory.buffer)) {
          buffers.push(memory.buffer);
          included.set(memory.buffer, true);
        }
      }
      scanned.set(object, true);
      const slots = object[SLOTS];
      if (slots) {
        for (const child of Object.values(slots)) {
          scan(child);
        }
      }
    };
    scan(args);
    return buffers;
  }

  exports.attachMember = attachMember;
  exports.attachMethod = attachMethod;
  exports.attachTemplate = attachTemplate;
  exports.beginStructure = beginStructure;
  exports.finalizeStructure = finalizeStructure;
  exports.getArgumentBuffers = getArgumentBuffers;
  exports.invokeFactory = invokeFactory;
  exports.log = log;

  return exports;

})({}))
)====="
