import { execFileSync, execSync, exec } from 'child_process';
import { statSync, lstatSync, openSync, writeSync, closeSync, readFileSync, writeFileSync, chmodSync, unlinkSync, mkdirSync, readdirSync, rmdirSync } from 'fs';
import { stat, lstat, open, readFile, writeFile, chmod, unlink, mkdir, readdir, rmdir } from 'fs/promises';
import os from 'os';
import { sep, dirname, parse, join, basename, resolve } from 'path';
import { fileURLToPath } from 'url';
import { createHash } from 'crypto';

const MEMORY$a = Symbol('memory');
const SLOTS$a = Symbol('slots');
const PARENT$a = Symbol('parent');
const NAME$a = Symbol('name');
const CLASS$2 = Symbol('class');
const PROPS$a = Symbol('props');
const GETTER$a = Symbol('getter');
const SETTER$a = Symbol('setter');
const LOCATION_GETTER$a = Symbol('addressGetter');
const FIXED_LOCATION$a = Symbol('fixedLocation');
const SIZE$a = Symbol('size');
const ALIGN$a = Symbol('align');
const POINTER$a = Symbol('pointer');
const CONST$a = Symbol('const');
const COPIER$a = Symbol('copier');
const NORMALIZER$a = Symbol('normalizer');
const VIVIFICATOR$a = Symbol('vivificator');
const POINTER_VISITOR$a = Symbol('pointerVisitor');
const ENVIRONMENT$a = Symbol('environment');
const ATTRIBUTES = Symbol('attributes');
const MORE$a = Symbol('more');

function getMemoryCopier$a(size, multiple = false) {
  const copy = getCopyFunction$a(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$a.call(this);
    restoreMemory$a.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$a];
    const dest = this[MEMORY$a];
    copy(dest, src);
  };
}

function getCopyFunction$a(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$a[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$a;
  if (!(size & 0x03)) return copy4x$a;
  if (!(size & 0x01)) return copy2x$a;
  return copy1x$a;
}

const copiers$a = {
  1: copy1$a,
  2: copy2$a,
  4: copy4$a,
  8: copy8$a,
  16: copy16$a,
  32: copy32$a,
};

function copy1x$a(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$a(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$a(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$a(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$a(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$a(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$a(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$a(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$a(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$a(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function restoreMemory$a() {
  const dv = this[MEMORY$a];
  const source = dv[MEMORY$a];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$a] = source;
  this[MEMORY$a] = newDV;
  return true;
}

const decoders$a = {};

function decodeText$a(arrays, encoding = 'utf-8') {
  let decoder = decoders$a[encoding];
  if (!decoder) {
    decoder = decoders$a[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function getValueOf$a() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$a];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$a = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$a = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$a() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$a];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        if (typeof(result?.toJSON) === 'function') {
          result = result.toJSON();
        }      
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$a <= value && value <= INT_MAX$a) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function handleError$a(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function always$a() {
  return true;
}

function normalizeStruct$a(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$a.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$a(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$a.bind(this, options),
    length: this[PROPS$a].length,
  };
}

function getStructIterator$a(options) { 
  const entries = getStructEntries$a.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$a(options) {
  const self = this;
  const props = this[PROPS$a];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$a(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$k(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$a.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$a];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$a(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$a][slot] = constructor.call(PARENT$a, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$k(structure, visitorOptions = {}) {
  const {
    isChildActive = always$a,
    isChildMutable = always$a,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$a,
      isMutable = always$a,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$a]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$a][slot] ?? (vivificate ? this[VIVIFICATOR$a](slot) : null);
      if (child) {
        child[POINTER_VISITOR$a](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$a(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$a.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$a] = dv;
    if (hasObject) {
      this[SLOTS$a] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$a(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$a(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$a(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$a(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$a]: { value: getMemoryCopier$a(byteSize) },
    [VIVIFICATOR$a]: hasObject && { value: getChildVivificator$k(structure) },
    [POINTER_VISITOR$a]: hasPointer && { value: getPointerVisitor$k(structure, { isChildMutable }) },
  });
  defineProperties$a(constructor, {
    [ALIGN$a]: { value: align },
    [SIZE$a]: { value: byteSize },
  });
  return constructor;
}

function appendEnumeration$2(enumeration, name, item) {
  if (name !== undefined) {
    // enum can have static variables 
    if (item instanceof enumeration) {
      // attach name to item so tagged union code can quickly find it
      defineProperties$a(item, { [NAME$a]: { value: name } });  
      // call toPrimitive directly since enum can be bigint or number
      const index = item[Symbol.toPrimitive]();
      defineProperties$a(enumeration, {
        [index]: { value: item },
        [name]: { value: item },
      });      
    }
  } else {
    // non-exhaustive enum
    defineProperties$a(enumeration, { [MORE$a]: { value: true } });
  }
}

function getPrimitiveClass$a({ type, bitSize }) {
  if (type === MemberType$a.Int || type === MemberType$a.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$a.Float) {
    return Number;
  } else if (type === MemberType$a.Bool) {
    return Boolean;
  }
}

const StructureType$a = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$w = {};

function useArgStruct$a() {
  factories$w[StructureType$a.ArgStruct] = defineArgStruct$a;
}

function getStructureFactory(type) {
  const f = factories$w[type];
  return f;
}

function flagMemberUsage(member, features) {
  const { type } = member;
  switch (type) {
    case MemberType$a.Bool:
      features.useBool = true;
      if (!isByteAligned$a(member)) {
        features.useExtendedBool = true;
      }
      break;
    case MemberType$a.Int:
      features.useInt = true;
      if(!isByteAligned$a(member) || !hasStandardIntSize(member)) {
        features.useExtendedInt = true;
      }
      break;
    case MemberType$a.Uint:
      features.useUint = true;
      if(!isByteAligned$a(member) || !hasStandardIntSize(member)) {
        features.useExtendedUint = true;
      }
      break;
    case MemberType$a.Float:
      features.useFloat = true;
      if (!isByteAligned$a(member) || !hasStandardFloatSize(member)) {
        features.useExtendedFloat = true;
      }
      break;
    case MemberType$a.Object:
      features.useObject = true;
      break;
    case MemberType$a.Void:
      features.useVoid = true;
      break;
    case MemberType$a.Null:
      features.useNull = true;
      break;
    case MemberType$a.Undefined:
      features.useUndefined = true;
      break;
    case MemberType$a.Type:
      features.useType = true;
      break;
    case MemberType$a.Comptime:
      features.useComptime = true;
      break;
    case MemberType$a.Static:
      features.useStatic = true;
      break;
    case MemberType$a.Literal:
      features.useLiteral = true;
      break;
  }
}

function flagStructureUsage(structure, features) {
  const { type } = structure;
  const [ name ] = Object.entries(StructureType$a).find(a => a[1] === type);
  features[`use${name}`] = true;
  for (const members of [ structure.instance.members, structure.static.members ]) {
    for (const member of members) {
      flagMemberUsage(member, features);
    }
  }
}

function getFeaturesUsed(structures) {
  const features = {};
  for (const structure of structures) {
    flagStructureUsage(structure, features);
  }
  return Object.keys(features);
}

function defineProperties$a(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function findAllObjects(structures, SLOTS) {
  const list = [];
  const found = new Map();
  const find = (object) => {
    if (!object || found.get(object)) {
      return;
    }
    found.set(object, true);
    list.push(object);
    if (object[SLOTS]) {
      for (const child of Object.values(object[SLOTS])) {
        find(child);         
      }
    }
  };
  for (const structure of structures) {
    find(structure.instance.template);
    find(structure.static.template);
  }
  return list;
}

let currentGlobalSet$2;

function appendErrorSet(errorSet, name, es) {
  // our Zig export code places error set instance into the static template, which we can't 
  // use since all errors need to have the same parent class; here we get the error number 
  // and create the actual error object if hasn't been created already for an earlier set
  const number = es[GETTER$a]('number');
  let error = currentGlobalSet$2[number];
  if (!error) {
    const errorClass = errorSet[CLASS$2];
    error = new errorClass(name, number);
  }
  const string = String(error);
  const descriptors = {
    [number]: { value: error },
    [string]: { value: error },
    [name]: { value: error },
  };
  defineProperties$a(errorSet, descriptors);
  defineProperties$a(currentGlobalSet$2, descriptors); 
  // add name to prop list
  currentGlobalSet$2[PROPS$a].push(name);
}

function resetGlobalErrorSet() {
  currentGlobalSet$2 = undefined;
}

function throwArgumentCountMismatch$a(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$a(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwOutOfBound$a(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$a(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$a(member, index);
  } else {
    throw err;
  }
}

function throwNotOnByteBoundary$a(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwZigError(name) {
  throw new Error(deanimalizeErrorName$2(name));
}

function deanimalizeErrorName$2(name) {
  // deal with snake_case first
  let s = name.replace(/_/g, ' ');
  // then camelCase, using a try block in case Unicode regex fails
  try {
    s = s.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu, (m0, m1, m2) => {
      if (m1.length === 1) {
        return ` ${m1.toLocaleLowerCase()}${m2}`;
      } else {
        if (m2) {
          const acronym = m1.substring(0, m1.length - 1);
          const letter = m1.charAt(m1.length - 1).toLocaleLowerCase();
          return ` ${acronym} ${letter}${m2}`;
        } else {
          return ` ${m1}`;
        }
      }
    }).trimStart();
    /* c8 ignore next 2 */
  } catch (err) {
  }
  return s.charAt(0).toLocaleUpperCase() + s.substring(1);
}

function getBoolAccessor$a(access, member) {
  return cacheMethod$a(access, member, () => {
    if (isByteAligned$a(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$a({ type: MemberType$a.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$a(access, member);
    }
  });
}

const factories$v = {};

function getExtendedTypeAccessor$a(access, member) {
  const f = factories$v[member.type];
  return f(access, member);
}

function getTypeName$a(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$a.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$a.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$a.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$a.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$a.Void) {
    return `Null`;
  }
}

const methodCache$a = {};

function cacheMethod$a(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$a(member);
  const suffix = isByteAligned$a(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$a.Int || type === MemberType$a.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$a[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$a(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$a[name] = fn;
  }
  return fn;
}

const MemberType$a = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  Object: 5,
  Type: 6,
  Comptime: 7,
  Static: 8,
  Literal: 9,
  Null: 10,
  Undefined: 11,
};

function isReadOnly$a(type) {
  switch (type) {
    case MemberType$a.Type:
    case MemberType$a.Comptime:
    case MemberType$a.Literal:
      return true;
    default:
      return false;
  }
}

const factories$u = {};

function useBool$a() {
  factories$u[MemberType$a.Bool] = getBoolDescriptor$a;
}

function useObject$a() {
  factories$u[MemberType$a.Object] = getObjectDescriptor$a;
}

function isByteAligned$a({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function hasStandardIntSize({ bitSize }) {
  return bitSize === 8 || bitSize === 16 || bitSize === 32 || bitSize === 64;
}

function hasStandardFloatSize({ bitSize }) {
  return bitSize === 32 || bitSize === 64;
}

function getDescriptor$a(member, env) {
  const f = factories$u[member.type];
  return f(member, env);
}

function getBoolDescriptor$a(member, env) {
  return getDescriptorUsing$a(member, env, getBoolAccessor$a)
}

function isValueExpected$a(structure) {
  switch (structure.type) {
    case StructureType$a.Primitive:
    case StructureType$a.ErrorUnion:
    case StructureType$a.Optional:
    case StructureType$a.Enumeration:
    case StructureType$a.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$a(slot) {
  const object = this[SLOTS$a][slot] ?? this[VIVIFICATOR$a](slot);
  return object[GETTER$a]();
}

function getObject$a(slot) {
  const object = this[SLOTS$a][slot] ?? this[VIVIFICATOR$a](slot);
  return object;
}

function setValue$a(slot, value) {
  const object = this[SLOTS$a][slot] ?? this[VIVIFICATOR$a](slot);
  object[SETTER$a](value);
}

function bindSlot$a(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$a(member, env) {
  const { structure, slot } = member;
  return bindSlot$a(slot, {
    get: isValueExpected$a(structure) ? getValue$a : getObject$a,
    set: setValue$a,
  });
}

function getDescriptorUsing$a(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$a], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$a.call(this)) {
            return getter.call(this[MEMORY$a], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$a], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$a.call(this)) {
            return setter.call(this[MEMORY$a], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$a], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$a.call(this)) {
            return getter.call(this[MEMORY$a], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$a(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$a], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$a.call(this)) {
            return setter.call(this[MEMORY$a], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$a(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function generateCode(definition, params) {
  const { structures } = definition;
  const {
    runtimeURL,
    binarySource = null,
    topLevelAwait = true,
    omitExports = false,
    declareFeatures = false,
    addonDir = null,
  } = params;
  const features = (declareFeatures) ? getFeaturesUsed(structures) : [];
  const exports = getExports(structures);
  const lines = [];
  const add = manageIndentation(lines);
  add(`import {`);
  for (const name of [ 'createEnvironment', ...features ]) {
    add(`${name},`);
  }
  add(`} from ${JSON.stringify(runtimeURL)};`);
  // reduce file size by only including code of features actually used
  // dead-code remover will take out code not referenced here
  add(`\n// activate features`);
  for (const feature of features) {
    add(`${feature}();`);
  }
  // write out the structures as object literals 
  addStructureDefinitions(lines, definition);
  add(`\n// create runtime environment`);
  add(`const env = createEnvironment(${addonDir ? JSON.stringify({ addonDir }, undefined, 2) : null});`);
  add(`const __zigar = env.getControlObject();`);
  add(`\n// recreate structures`);
  add(`env.recreateStructures(structures, options);`);
  if (binarySource) {
    add(`\n// initiate loading and compilation of WASM bytecodes`);
    add(`const source = ${binarySource};`);
    add(`env.loadModule(source)`);
    // if top level await is used, we don't need to write changes into fixed memory buffers
    add(`env.linkVariables(${!topLevelAwait});`);
  }
  add(`\n// export root namespace and its methods and constants`);
  add(`const { constructor } = root;`);
  if (!omitExports) {
    add(`export { constructor as default, __zigar }`);
    // the first two exports are default and __zigar
    const exportables = exports.slice(2);
    if (exportables.length > 0) {
      add(`export const {`);
      for (const name of exportables) {
        add(`${name},`);
      }
      add(`} = constructor;`);
    }
  }
  if (topLevelAwait && binarySource) {
    add(`await __zigar.init();`);
  }
  const code = lines.join('\n');
  return { code, exports, structures };
}

function addStructureDefinitions(lines, definition) {
  const { structures, options, keys } = definition;
  const { MEMORY, SLOTS, CONST } = keys;
  const add = manageIndentation(lines);
  const defaultStructure = {
    constructor: null,
    typedArray: null,
    type: StructureType$a.Primitive,
    name: undefined,
    byteSize: 0,
    align: 0,
    isConst: false,
    hasPointer: false,
    instance: {
      members: [],
      methods: [],
      template: null,
    },
    static: {
      members: [],
      methods: [],
      template: null,
    },
  };
  add(`\n// structure defaults`);
  add(`const s = {`);
  for (const [ name, value ] of Object.entries(defaultStructure)) {
    switch (name) {
      case 'instance':
      case 'static':
        add(`${name}: {`);
        for (const [ name2, value2 ] of Object.entries(value)) {
          add(`${name2}: ${JSON.stringify(value2)},`);
        }
        add(`},`);
        break;
      default:
        add(`${name}: ${JSON.stringify(value)},`);
    }
  }
  add(`};`);
  const defaultMember = {
    type: MemberType$a.Void,
    isRequired: false,
  };
  add(`\n// member defaults`);
  add(`const m = {`);
  for (const [ name, value ] of Object.entries(defaultMember)) {
    add(`${name}: ${JSON.stringify(value)},`);
  }
  add(`};`);
  // create empty objects first, to allow objects to reference each other
  add(``);
  const structureNames = new Map();
  const structureMap = new Map();
  for (const [ index, structure ] of structures.entries()) {
    const varname = `s${index}`;
    structureNames.set(structure, varname);
    structureMap.set(structure.constructor, structure);
  }
  for (const slice of chunk(structureNames.values(), 10)) {
    add(`const ${slice.map(n => `${n} = {}`).join(', ')};`);
  }
  const objects = findAllObjects(structures, SLOTS);
  const objectNames = new Map();
  const views = [];
  for (const [ index, object ] of objects.entries()) {
    const varname = `o${index}`;
    objectNames.set(object, varname);
    if (object[MEMORY]) {
      views.push(object[MEMORY]);
    }
  }
  for (const slice of chunk(objectNames.values(), 10)) {
    add(`const ${slice.map(n => `${n} = {}`).join(', ')};`);
  }
  // define buffers
  const arrayBufferNames = new Map();
  for (const [ index, dv ] of views.entries()) {
    if (!arrayBufferNames.get(dv.buffer)) {
      const varname = `a${index}`;
      arrayBufferNames.set(dv.buffer, varname);
      if (dv.buffer.byteLength > 0) {
        const ta = new Uint8Array(dv.buffer);
        add(`const ${varname} = new Uint8Array([ ${ta.join(', ')} ]);`);
      } else {
        add(`const ${varname} = new Uint8Array();`);
      }
    }
  }
  // add properties to objects
  if (objects.length > 0) {
    add('\n// define objects');    
    for (const object of objects) {
      const varname = objectNames.get(object);
      const structure = structureMap.get(object.constructor);
      const { [MEMORY]: dv, [SLOTS]: slots } = object;
      add(`Object.assign(${varname}, {`);
      if (structure) {
        add(`structure: ${structureNames.get(structure)},`);
      }
      if (dv) {
        const buffer = arrayBufferNames.get(dv.buffer);
        const pairs = [ `array: ${buffer}` ];
        if (dv.byteLength < dv.buffer.byteLength) {
          pairs.push(`offset: ${dv.byteOffset}`);
          pairs.push(`length: ${dv.byteLength}`);
        }
        add(`memory: { ${pairs.join(', ')} },`);
        if (dv.hasOwnProperty('reloc')) {
          add(`reloc: ${dv.reloc},`);
          if (object[CONST]) {
            add(`const: true,`);
          }
        }
      }
      const entries = (slots) ? Object.entries(slots).filter(a => a[1]) : [];
      if (entries.length > 0) {
        add(`slots: {`);
        const pairs = entries.map(([slot, child]) => `${slot}: ${objectNames.get(child)}`);
        for (const slice of chunk(pairs, 10)) {
          add(slice.join(', ') + ',');
        }
        add(`},`);
      }
      add(`});`);
    }
  }
  const methods = [];
  for (const structure of structures) {
    // add static members; instance methods are also static methods, so
    // we don't need to add them separately
    methods.push(...structure.static.methods);
  }
  const methodNames = new Map();
  if (methods.length > 0) {
    add(`\n// define functions`);
    for (const [ index, method ] of methods.entries()) {
      const varname = `f${index}`;
      methodNames.set(method, varname);
      add(`const ${varname} = {`);
      for (const [ name, value ] of Object.entries(method)) {
        switch (name) {
          case 'argStruct':
            add(`${name}: ${structureNames.get(value)},`);
            break;
          default:
            add(`${name}: ${JSON.stringify(value)},`);
        }
      }
      add(`};`);
    }
  }
  add('\n// define structures');
  for (const structure of structures) {
    const varname = structureNames.get(structure);
    add(`Object.assign(${varname}, {`);
    add(`...s,`);
    for (const [ name, value ] of Object.entries(structure)) {
      if (isDifferent(value, defaultStructure[name])) {
        switch (name) {
          case 'constructor':
          case 'typedArray':
          case 'sentinel':
            break;
          case 'instance':
          case 'static': {
            const { methods, members, template } = value;
            add(`${name}: {`);
            add(`members: [`);
            for (const member of members) {
              add(`{`);
              add(`...m,`);
              for (const [ name, value ] of Object.entries(member)) {
                if (isDifferent(value, defaultMember[name])) {
                  switch (name) {
                    case 'structure':
                      add(`${name}: ${structureNames.get(value)},`);
                      break;
                    default:
                      add(`${name}: ${JSON.stringify(value)},`);
                  }
                }
              }
              add(`},`);
            }
            add(`],`);
            add(`methods: [`);
            for (const slice of chunk(methods, 10)) {
              add(slice.map(m => methodNames.get(m)).join(', ') + ',');
            }
            add(`],`);
            if (template) {
              add(`template: ${objectNames.get(template)}`);
            }
            add(`},`);
          } break;
          default:
            add(`${name}: ${JSON.stringify(value)},`);
        }
      }
    }
    add(`});`);
  }
  add(`const structures = [`);
  for (const slice of chunk([ ...structureNames.values() ], 10)) {
    add(slice.join(', ') + ',');
  }
  add(`];`);
  const root = structures[structures.length - 1];
  add(`const root = ${structureNames.get(root)};`);
  add(`const options = {`);
  for (const [ name, value ] of Object.entries(options)) {
    add(`${name}: ${value},`);
  }
  add(`};`);
  return lines;
}

function getExports(structures) {
  const root = structures[structures.length - 1];
  const { constructor } = root;
  const exportables = [];
  // export only members whose names are legal JS identifiers
  const legal = /^[$\w]+$/;
  for (const method of root.static.methods) {
    if (legal.test(method.name)) {
      exportables.push(method.name);
    }
  }
  for (const member of root.static.members) {
    // only read-only properties are exportable
    if (isReadOnly$a(member.type) && legal.test(member.name)) {
      try {
        // make sure that getter wouldn't throw (possible with error union)
        constructor[member.name];
        exportables.push(member.name);
      } catch (err) {
      }
    }
  }
  return [ 'default', '__zigar', ...exportables ];
}

function manageIndentation(lines) {
  let indent = 0;
  return (s) => {
    if (/^\s*[\]\}]/.test(s)) {
      indent--;
    }
    const lastLine = lines[lines.length - 1];
    if ((lastLine?.endsWith('[') && s.startsWith(']')) 
     || (lastLine?.endsWith('{') && s.startsWith('}'))) {
      lines[lines.length - 1] += s;
    } else {
      lines.push(' '.repeat(indent * 2) + s);
    }
    if (/[\[\{]\s*$/.test(s)) {
      indent++;
    }
  };
}

function isDifferent(value, def) {
  if (value === def) {
    return false;
  }
  if (def == null) {
    return value != null;
  }
  if (typeof(def) === 'object' && typeof(value) === 'object') {
    const valueKeys = Object.keys(value);
    const defKeys = Object.keys(def);
    if (valueKeys.length !== defKeys.length) {
      return true;
    }
    for (const key of defKeys) {
      if (isDifferent(value[key], def[key])) {
        return true;
      }
    }
    return false;
  }
  return true;
}

function* chunk(arr, n) {
  if (!Array.isArray(arr)) {
    arr = [ ...arr ];
  }
  for (let i = 0; i < arr.length; i += n) {
    yield arr.slice(i, i + n);
  }
}

async function findFile(path, follow = true) {
  try {
    return await (follow ? stat(path) : lstat(path));
  } catch (err) {
  }
}

function findFileSync(path, follow = true) {
  try {
    return follow ? statSync(path) : lstatSync(path);
  } catch (err) {
  }
}

async function findMatchingFiles(dir, re) {
  const map = new Map();
  const scanned = new Map();
  const scan = async (dir) => {
    /* c8 ignore next 3 */
    if (scanned.get(dir)) {
      return;
    } 
    scanned.set(dir, true);
    try {
      const list = await readdir(dir);
      for (const name of list) {
        if (name.startsWith('.') || name === 'node_modules' || name === 'zig-cache') {
          continue;
        }
        const path = join(dir, name);
        const info = await findFile(path);
        if (info?.isDirectory()) {
          await scan(path);
        } else if (info?.isFile() && re.test(name)) {
          map.set(path, info);
        }
      }
      /* c8 ignore next 2 */
    } catch (err) {
    }
  };
  await scan(dir);
  return map;
}

function findMatchingFilesSync(dir, re) {
  const map = new Map();
  const scanned = new Map();
  const scan = (dir) => {
    /* c8 ignore next 3 */
    if (scanned.get(dir)) {
      return;
    } 
    scanned.set(dir, true);
    try {
      const list = readdirSync(dir);
      for (const name of list) {
        if (name.startsWith('.') || name === 'node_modules' || name === 'zig-cache') {
          continue;
        }
        const path = join(dir, name);
        const info = findFileSync(path);
        if (info?.isDirectory()) {
          scan(path);
        } else if (info?.isFile() && re.test(name)) {
          map.set(path, info);
        }
      }
      /* c8 ignore next 2 */
    } catch (err) {
    }
  };
  scan(dir);
  return map;
}

async function acquireLock(pidPath, staleTime) {
  while (true)   {
    try {
      await createDirectory(dirname(pidPath));
      const handle = await open(pidPath, 'wx');
      handle.write(`${process.pid}`);
      handle.close();
      break;
    } catch (err) {
      if (err.code === 'EEXIST') {
        if (checkPidFile(pidPath, staleTime)) {
          await delay(250);
          continue;
        }
      } else {
        throw err;
      }
    }
  }
}

function acquireLockSync(pidPath, staleTime) {
  while (true)   {
    try {
      createDirectorySync(dirname(pidPath));
      const handle = openSync(pidPath, 'wx');
      writeSync(handle, `${process.pid}`);
      closeSync(handle);
      break;
    } catch (err) {
      if (err.code === 'EEXIST') {
        if (checkPidFile(pidPath, staleTime)) {
          delaySync(250);
        }
      } else {
        throw err;
      }
    }
  }
}

async function releaseLock(pidPath) {
  await deleteFile(pidPath);
}

function releaseLockSync(pidPath) {
  deleteFileSync(pidPath);
}

function checkPidFile(pidPath, staleTime = 60000 * 5) {
  let stale = false;
  try {
    const pid = loadFileSync(pidPath);
    if (os.platform() === 'win32') {
      execSync(`tasklist /nh /fi "pid eq ${pid}" | findstr .exe`, { stdio: 'pipe' }).toString();
    } else {
      execSync(`ps -p ${pid}`).toString();
    }
    const last = findFileSync(pidPath)?.mtime || 0;
    const diff = new Date() - last;
    if (diff > staleTime) {
      stale = true;
    }
  } catch (err) {
    stale = true;
  }
  if (stale) {
    deleteFileSync(pidPath);
  }
  return !stale;
}

async function copyFile(srcPath, dstPath) {
  const info = await stat(srcPath);
  const data = await readFile(srcPath);
  await writeFile(dstPath, data);
  await chmod(dstPath, info.mode);
}

function copyFileSync(srcPath, dstPath) {
  const info = statSync(srcPath);
  const data = readFileSync(srcPath);
  writeFileSync(dstPath, data);
  chmodSync(dstPath, info.mode);
}

async function loadFile(path, def) {
  try {
    return await readFile(path, 'utf8');
  } catch (err) {
    return def;
  }
}

function loadFileSync(path, def) {
  try {
    return readFileSync(path, 'utf8');
  } catch (err) {
    return def;
  }
}

async function deleteFile(path) {
  try {
    await unlink(path);
  } catch (err) {
    if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {
      throw err;
    }
  }
}

function deleteFileSync(path) {
  try {
    unlinkSync(path);
  } catch (err) {
    if (err.code !== 'ENOENT' && err.code !== 'ENOTDIR') {
      throw err;
    }
  }
}

async function createDirectory(path) {
  const exists = await findDirectory(path);
  if (!exists) {
    const { root, dir } = parse(path);
    await createDirectory(dir);
    try {
      await mkdir(path);
    } catch (err) {
      /* c8 ignore next 3 */
      if (err.code != 'EEXIST') {
        throw err;
      }
    }
  }
}

function createDirectorySync(path) {
  const exists = findDirectorySync(path);
  if (!exists) {
    const { root, dir } = parse(path);
    createDirectorySync(dir);
    try {
      mkdirSync(path);
    } catch (err) {
      /* c8 ignore next 3 */
      if (err.code != 'EEXIST') {
        throw err;
      }
    }
  }
}

async function findDirectory(path) {
  return findFile(path);
}

function findDirectorySync(path) {
  return findFileSync(path);
}

async function deleteDirectory(dir) {
  try {
    const list = await readdir(dir);
    for (const name of list) {
      const path = join(dir, name);
      const info = await findFile(path, false);
      if (info?.isDirectory()) {
        await deleteDirectory(path);
      } else if (info) {
        await deleteFile(path);
      }
    }
    await rmdir(dir);
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }
}

function deleteDirectorySync(dir) {
  try {
    const list = readdirSync(dir);
    for (const name of list) {
      const path = join(dir, name);
      const info = findFileSync(path, false);
      if (info?.isDirectory()) {
        deleteDirectorySync(path);
      } else if (info) {
        deleteFileSync(path);
      }
    }
    rmdirSync(dir);
  } catch (err) {
    if (err.code !== 'ENOENT') {
      throw err;
    }
  }
}

async function delay(ms) {
  await new Promise(r => setTimeout(r, ms));
}

function delaySync(ms) {   
  const buffer = new SharedArrayBuffer(8);
  const ta = new BigInt64Array(buffer);
  Atomics.wait(ta, 0, 0n, ms);
}

function md5(text) {
  const hash = createHash('md5');
  hash.update(text);
  return hash.digest('hex');
}

let isGNU;

function getPlatform() {
  let platform = os.platform();
  if (platform === 'linux') {
    // differentiate glibc from musl
    if (isGNU === undefined) {
      /* c8 ignore next 3 */
      if (process.versions?.electron || process.__nwjs) {
        isGNU = true;
      } else {
        try {
          execFileSync('getconf', [ 'GNU_LIBC_VERSION' ], { stdio: 'pipe' });
          isGNU = true;
          /* c8 ignore next 3 */
        } catch (err) {
          isGNU = false;
        }  
      }
    }
    /* c8 ignore next 3 */
    if (!isGNU) {
      platform += '-musl';
    }
  }
  return platform;
}

function getArch() {
  return os.arch();
}

function normalizePath(url) {
  let archive;
  const parts = fileURLToPath(url).split(sep).map((part) => {
    if (part === 'app.asar') {
      archive = 'asar';
      return part + '.unpacked';
    }
    return part;
  });
  const path = parts.join(sep);
  return { path, archive }
}

async function compile(srcPath, modPath, options) {
  const srcInfo = (srcPath) ? await findFile(srcPath) : null;
  if (srcInfo === undefined) {
    throw new Error(`Source file not found: ${srcPath}`);
  }
  if (srcInfo?.isDirectory()) {
    srcPath = join(srcPath, '?');
  }
  const config = createConfig(srcPath, modPath, options);
  const { moduleDir, outputPath } = config;
  let changed = false;
  if (srcPath) {
    const srcFileMap = await findMatchingFiles(moduleDir, /.\..*$/);
    // see if the (re-)compilation is necessary
    const soInfo = await findFile(outputPath);
    if (soInfo) {
      for (const [ name, info ] of srcFileMap) {
        if (info.mtime > soInfo.mtime) {
          changed = true;
          break;
        }
      }
    } else {
      changed = true;
    }
    if (!changed) {
      // rebuild when exporter or build files have changed
      const zigFolder = absolute('../zig');
      const zigFileMap = await findMatchingFiles(zigFolder, /\.zig$/);
      for (const [ path, info ] of zigFileMap) {
        if (info.mtime > soInfo.mtime) {
          changed = true;
          break;
        }
      }
    }
    if (changed) {
      // add custom build file
      for (const [ path, info ] of srcFileMap) {
        switch (basename(path)) {
          case 'build.zig':
            config.buildFilePath = path;
            break;
          case 'build.zig.zon':
            config.packageConfigPath = path;
            break;
        }
      }
      const { zigCmd, moduleBuildDir } = config;
      // only one process can compile a given file at a time
      const pidPath = `${moduleBuildDir}.pid`;
      await acquireLock(pidPath);
      try {
        // create config file
        await createProject(config, moduleBuildDir);
        // then run the compiler
        await runCompiler(zigCmd, moduleBuildDir);
      } finally {
        if (config.clean) {
          await deleteDirectory(moduleBuildDir);
        }
        await releaseLock(pidPath);
      }
    }   
  }
  return { outputPath, changed }
}

function compileSync(srcPath, modPath, options) {
  const srcInfo = (srcPath) ? findFileSync(srcPath) : null;
  if (srcInfo === undefined) {
    throw new Error(`Source file not found: ${srcPath}`);
  }
  if (srcInfo?.isDirectory()) {
    srcPath = join(srcPath, '?');
  }
  const config = createConfig(srcPath, modPath, options);
  const { moduleDir, outputPath } = config;
  let changed = false;
  if (srcPath) {
    const srcFileMap = findMatchingFilesSync(moduleDir, /.\..*$/);
    // see if the (re-)compilation is necessary
    const soInfo = findFileSync(outputPath);
    if (soInfo) {
      for (const [ path, info ] of srcFileMap) {
        if (info.mtime > soInfo.mtime) {
          changed = true;
          break;
        }
      }
    } else {
      changed = true;
    }
    if (!changed) {
      // rebuild when exporter or build files have changed
      const zigFolder = absolute('../zig');
      const zigFileMap = findMatchingFilesSync(zigFolder, /\.zig$/);
      for (const [ path, info ] of zigFileMap) {
        if (info.mtime > soInfo.mtime) {
          changed = true;
          break;
        }
      }
    }
    if (changed) {
      // add custom build file
      for (const [ path, info ] of srcFileMap) {
        switch (basename(path)) {
          case 'build.zig':
            config.buildFilePath = path;
            break;
          case 'build.zig.zon':
            config.packageConfigPath = path;
            break;
        }
      }
      const { zigCmd, moduleBuildDir } = config;
      // only one process can compile a given file at a time
      const pidPath = `${moduleBuildDir}.pid`;
      acquireLockSync(pidPath);
      try {
        // create config file
        createProjectSync(config, moduleBuildDir);
        // then run the compiler   
        runCompilerSync(zigCmd, moduleBuildDir);
      } finally {
        if (config.clean) {
          deleteDirectorySync(moduleBuildDir);
        }
        releaseLockSync(pidPath);
      }
    } 
  }
  return { outputPath, changed }
}

async function runCompiler(zigCmd, soBuildDir) {
  const options = {
    cwd: soBuildDir,
    windowsHide: true,
  };
  return new Promise((resolve, reject) => {
    exec(zigCmd, options, (err, stdout, stderr) => {
      if (err) {
        const log = stderr;
        if (log) {
          const logPath = join(soBuildDir, 'log');
          writeFile(logPath, log);
          err = new Error(`Zig compilation failed\n\n${log}`);
        }
        reject(err);
      } else {
        resolve();
      }
    });
  });
}

function runCompilerSync(zigCmd, soBuildDir) {
  const options = {
    cwd: soBuildDir,
    windowsHide: true,
    stdio: 'pipe',
  };
  try {
    execSync(zigCmd, options);
  } catch (err) {
    const log = err.stderr;
    if (log) {
      const logPath = join(soBuildDir, 'log');
      writeFileSync(logPath, log);
    }
    throw new Error(`Zig compilation failed\n\n${log}`);
  }
}

function formatProjectConfig(config) {
  const lines = [];
  const fields = [ 
    'moduleName', 'modulePath', 'moduleDir', 'exporterPath', 'stubPath', 'outputPath', 
    'useLibc', 'isWASM',
  ];  
  for (const [ name, value ] of Object.entries(config)) {
    if (fields.includes(name)) {
      const snakeCase = name.replace(/[A-Z]+/g, m => '_' + m.toLowerCase());
      lines.push(`pub const ${snakeCase} = ${JSON.stringify(value)};`);
    }
  }
  return lines.join('\n');
}

async function createProject(config, dir) {
  await createDirectory(dir);
  const content = formatProjectConfig(config);
  const cfgFilePath = join(dir, 'build-cfg.zig');
  await writeFile(cfgFilePath, content);
  const buildFilePath = join(dir, 'build.zig');
  await copyFile(config.buildFilePath, buildFilePath);
  if (config.packageConfigPath) {
    const packageConfigPath = join(dir, 'build.zig.zon');
    await copyFile(config.packageConfigPath, packageConfigPath);
  }
}

function createProjectSync(config, dir) {
  createDirectorySync(dir);
  const content = formatProjectConfig(config);
  const cfgFilePath = join(dir, 'build-cfg.zig');
  writeFileSync(cfgFilePath, content);
  const buildFilePath = join(dir, 'build.zig');
  copyFileSync(config.buildFilePath, buildFilePath);
  if (config.packageConfigPath) {
    const packageConfigPath = join(dir, 'build.zig.zon');
    copyFileSync(config.packageConfigPath, packageConfigPath);
  }
}

const cwd = process.cwd();

function getCachePath(options) {
  const {
    cacheDir = join(cwd, 'zigar-cache'),
  } = options;
  return cacheDir;
}

function getModuleCachePath(srcPath, options) {
  const {
    optimize,
  } = options;
  const src = parse(srcPath);
  const folder = basename(src.dir).slice(0, 16).trim() + '-' + md5(src.dir).slice(0, 8);
  const cacheDir = getCachePath(options);
  return join(cacheDir, folder, optimize, `${src.name}.zigar`);
}

function createConfig(srcPath, modPath, options = {}) {
  const {
    platform = getPlatform(),
    arch = getArch(),
    optimize = 'Debug',
    isWASM = false,
    useLibc = isWASM ? false : true,
    clean = false,
    buildDir = join(os.tmpdir(), 'zigar-build'),
    zigCmd = (() => {
      // translate from names used by Node to those used by Zig
      const cpuArchs = {
        arm: 'arm',
        arm64: 'aarch64',
        ia32: 'x86',
        loong64: 'loong64',
        mips: 'mips',
        mipsel: 'mipsel',
        ppc: 'powerpc',
        ppc64: 'powerpc64',
        s390: undefined,
        s390x: 's390x',
        x64: 'x86_64',
      };
      const osTags = {
        aix: 'aix',
        darwin: 'macos',
        freebsd: 'freebsd',
        linux: 'linux-gnu',
        openbsd: 'openbsd',
        sunos: 'solaris',
        win32: 'windows',
      };
      const cpuArch = cpuArchs[arch] ?? arch;
      const osTag = osTags[platform] ?? platform;
      const args = [
        `build`,
        `-Doptimize=${optimize}`,
        `-Dtarget=${cpuArch}-${osTag}`,        
      ];
      return `zig ${args.join(' ')}`;
    })(),
  } = options;
  const suffix = isWASM ? 'wasm' : 'c';
  const src = parse(srcPath ?? '');
  const mod = parse(modPath ?? '');
  const moduleName = mod.name || src.name;
  const modulePath = (src.name !== '?') ? srcPath : undefined;
  const moduleDir = src.dir;
  const modulePrefix = basename(moduleName).slice(0, 16);
  const moduleHash = md5(`${moduleDir}/${moduleName}`).slice(0, 8);
  const moduleBuildDir = join(buildDir, modulePrefix + '-' + moduleHash);   
  const outputPath = (() => {
    if (!modPath && isWASM) {
      // save output in build folder
      return join(moduleBuildDir, optimize, `${src.name}.wasm`);
    } else {
      const extensions = {
        darwin: 'dylib',
        win32: 'dll',
      };
      const ext = extensions[platform] || 'so';
      return join(modPath, `${platform}.${arch}.${ext}`);
    }  
  })();
  const exporterPath = absolute(`../zig/exporter-${suffix}.zig`);
  const stubPath = absolute(`../zig/stub-${suffix}.zig`);
  const buildFilePath = absolute(`../zig/build.zig`);
  return {
    platform,
    arch,
    optimize,
    moduleName,
    modulePath,
    moduleDir,
    moduleBuildDir,
    exporterPath,
    stubPath,
    buildFilePath,
    packageConfigPath: undefined,
    outputPath,
    clean,
    zigCmd,
    useLibc,
    isWASM,
  };
}

function absolute(relpath) {
  // import.meta.url don't always yield the right URL when transpiled to CommonJS
  // just use __dirname as it's going to be there
  /* c8 ignore next 2 */
  if (typeof(__dirname) === 'string') {
    return resolve(__dirname, relpath);
  } else {
    return fileURLToPath(new URL(relpath, import.meta.url));
  }
}

const optionsForCompile = {
  optimize: {
    type: 'string',
    enum: [ 'Debug', 'ReleaseSmall', 'ReleaseFast', 'ReleaseSafe' ],
    title: 'Zig optimization mode',
  },
  omitFunctions: {
    type: 'boolean',
    title: 'Omit all Zig functions',
  },
  omitVariables: {
    type: 'boolean',
    title: 'Omit all variables',
  },
  omitExports: {
    type: 'boolean',
    title: 'Omit export statements',
  },
  useLibc: {
    type: 'boolean',
    title: 'Link in C standard library',
  },
  topLevelAwait: {
    type: 'boolean',
    title: 'Use top-level await to load WASM file',
  },
  buildDir: {
    type: 'string',
    title: 'Root directory where temporary build directories are placed',
  },
  cacheDir: {
    type: 'string',
    title: 'Directory where compiled library files are placed',
  },
  zigCmd: {
    type: 'string',
    title: 'Zig command used to build libraries',
  },
  sourceFiles: {
    type: 'object',
    title: 'Map of modules to source files/directories',
  },
  clean: {
    type: 'boolean',
    title: 'Remove temporary build directory after compilation finishes',
  },
  targets: {
    type: 'object',
    title: 'List of cross-compilation targets',
  },
};

const optionsForTranspile = {
  useReadFile: {
    type: 'boolean',
    title: 'Enable the use of readFile() to Load WASM file when library is used in Node.js',
  },
  embedWASM: {
    type: 'boolean',
    title: 'Embed WASM file in JavaScript source code',
  },
  stripWASM: {
    type: 'boolean',
    title: 'Remove unnecessary code from WASM file',
  },
  keepNames: {
    type: 'boolean',
    title: 'Keep names of function in WASM binary when stripping',
  },
};

const allOptions = {
  ...optionsForCompile,
  ...optionsForTranspile,
};

function extractOptions(searchParams, availableOptions) {
  const options = {};
  const names = Object.keys(availableOptions);
  for (const [ name, string ] of searchParams) {
    const key = getCamelCase(name, names);
    const option = availableOptions[key];
    if (!option) {
      throwUnknownOption(name);
    }
    if (key === 'optimize') {
      options[key] = getCamelCase(string, [ 'Debug', 'ReleaseSafe', 'ReleaseFast', 'ReleaseSmall' ]);
    } else {
      switch (option.type) {
        case 'boolean': 
          options[key] = !!parseInt(string);
          break;
        case 'number': 
          options[key] = parseInt(string);
          break;
        default: 
          options[key] = string;
      }
    }
  }
  return options;
}

function getCamelCase(name, names) {
  for (const nameCC of names) {
    const nameSC = nameCC.replace(/([a-z])([A-Z])/g, '$1_$2').toLowerCase();
    const nameKC = nameSC.replace(/_/g, '-');
    if (name === nameKC || name === nameSC || name === nameCC) {
      return nameCC;
    }
  }
  return name;
}

function throwUnknownOption(key) {
  const adjective = (allOptions[key]) ? 'Unavailable' : 'Unrecognized';
  throw new Error(`${adjective} option: ${key}`);
}

async function findConfigFile(name, dir) {
  const path = join(dir, name);
  const info = await findFile(path);
  if (info?.isFile()) {
    return path;
  } else {
    const parent = dirname(dir);
    if (parent !== dir) {
      return findConfigFile(name, parent);
    }
  }
}

function findConfigFileSync(name, dir) {
  const path = join(dir, name);
  const info = findFileSync(path);
  if (info?.isFile()) {
    return path;
  } else {
    const parent = dirname(dir);
    if (parent !== dir) {
      return findConfigFileSync(name, parent);
    }
  }
}

async function loadConfigFile(cfgPath, availableOptions) {
  const text = await loadFile(cfgPath);
  return processConfigFile(text, cfgPath, availableOptions);
}

function loadConfigFileSync(cfgPath, availableOptions) {
  const text = loadFileSync(cfgPath);
  return processConfigFile(text, cfgPath, availableOptions);
}

function processConfigFile(text, cfgPath, availableOptions) {
  const options = JSON.parse(text);
  for (const [ key, value ] of Object.entries(options)) {
    const option = availableOptions[key];
    if (!option) {
      throwUnknownOption(key);
    }
    if (typeof(value) !== option.type) {
      throw new Error(`${key} is expected to be a ${option.type}, received: ${value}`);
    }
  }
  options.sourceFiles = getAbsoluteMapping(options.sourceFiles, dirname(cfgPath));
  return options;
}

function getAbsoluteMapping(sourceFiles, cfgDir) {
  if (!sourceFiles) {
    return;
  }
  const map = {};
  for (const [ module, source ] of Object.entries(sourceFiles)) {
    const modulePath = resolve(cfgDir, module);
    const sourcePath = resolve(cfgDir, source);
    map[modulePath] = sourcePath;
  }
  return map;
}

function findSourceFile$1(modulePath, options) {
  const { sourceFiles } = options;
  return sourceFiles?.[modulePath]; 
}

function addMethods(s, env) {
  const add = (target, { methods }, pushThis) => {
    const descriptors = {};
    const re = /^(get|set)\s+([\s\S]+)/;
    for (const method of methods) {
      const f = env.createCaller(method, pushThis);
      const m = re.exec(f.name);
      if (m) {
        // getter/setter
        const type = m[1], propName = m[2];
        const argRequired = (type === 'get') ? 0 : 1;
        const argCount = getArgumentCount(method, pushThis);
        // need to match arg count, since instance methods also show up as static methods
        if (argCount === argRequired) {
          let descriptor = descriptors[propName];
          if (!descriptor) {
            descriptor = descriptors[propName] = { configurable: true, enumerable: true };
          }
          descriptor[type] = f; 
        }
      } else {
        descriptors[f.name] = { value: f, configurable: true, writable: true };
      }
    }
    defineProperties$a(target, descriptors);
  };
  add(s.constructor, s.static, false);
  add(s.constructor.prototype, s.instance, true);
}

function getArgumentCount(method, pushThis) {
  const { argStruct: { instance: { members } } } = method;  
  return members.length - (pushThis ? 2 : 1);
}

function addStaticMembers(structure, env) {
  const {
    type,
    constructor,
    static: { members, template },
  } = structure;
  const descriptors = {};
  for (const member of members) {
    descriptors[member.name] = getDescriptor$a(member, env);
  }
  defineProperties$a(constructor, {
    valueOf: { value: getValueOf$a },
    toJSON: { value: convertToJSON$a },
    ...descriptors,
    [Symbol.iterator]: { value: getStructIterator$a },
    // static variables are objects stored in the static template's slots
    [SLOTS$a]: template ? { value: template[SLOTS$a] } : undefined,
    // anyerror would have props already
    [PROPS$a]: !constructor[PROPS$a] ? { value: members.map(m => m.name) } : undefined,
    [NORMALIZER$a]: { value: normalizeStruct$a },
  });
  if (type === StructureType$a.Enumeration) {
    for (const { name, slot } of members) {
      appendEnumeration$2(constructor, name, constructor[SLOTS$a][slot]);
    }
  } else if (type === StructureType$a.ErrorSet) {
    for (const { name, slot } of members) {
      appendErrorSet(constructor, name, constructor[SLOTS$a][slot]);
    }
  }
}

class Environment {
  context;
  contextStack = [];
  consolePending = [];
  consoleTimeout = 0;
  viewMap = new WeakMap();
  initPromise;
  abandoned = false;
  released = false;
  littleEndian = true;
  runtimeSafety = true;
  comptime = false;
  /* COMPTIME-ONLY */
  slotNumbers = {};
  slots = {};
  structures = [];
  /* COMPTIME-ONLY-END */
  imports;
  console = globalThis.console;

  /*
  Functions to be defined in subclass:

  getBufferAddress(buffer: ArrayBuffer): bigint|number {
    // return a buffer's address
  }
  allocateHostMemory(len: number, align: number): DataView {
    // allocate memory and remember its address
  }
  allocateShadowMemory(len: number, align: number): DataView {
    // allocate memory for shadowing objects
  }
  freeHostMemory(address: bigint|number, len: number, align: number): void {
    // free previously allocated memory
  }
  freeShadowMemory(address: bigint|number, len: number, align: number): void {
    // free memory allocated for shadow
  }
  allocateFixedMemory(len: number, align: number): DataView {
    // allocate fixed memory and keep a reference to it
  }
  freeFixedMemory(address: bigint|number, len: number, align: number): void {
    // free previously allocated fixed memory return the reference
  }
  obtainFixedView(address: bigint|number, len: number): DataView {
    // obtain a data view of memory at given address
  }
  releaseFixedView(dv: DataView): void {
    // release allocated memory stored in data view, doing nothing if data view 
    // does not contain fixed memory or if memory is static
  }
  inFixedMemory(object: object): boolean {
    // return true/false depending on whether object is in fixed memory
  }
  copyBytes(dst: DataView, address: bigint|number, len: number): void {
    // copy memory at given address into destination view
  }
  findSentinel(address: bigint|number, bytes: DataView): number {
    // return offset where sentinel value is found
  }
  getMemoryOffset(address: bigint|number) number {
    // return offset of address relative to start of module memory
  }
  recreateAddress(reloc: number) number {
    // recreate address of memory belonging to module
  }

  getTargetAddress(target: object, cluster: object|undefined) {
    // return the address of target's buffer if correctly aligned
  }
  */

  startContext() {
    if (this.context) {
      this.contextStack.push(this.context);
    }
    this.context = new CallContext();
  }

  endContext() {
    this.context = this.contextStack.pop();
  }

  allocateMemory(len, align = 0, fixed = false) {
    if (fixed) {
      return this.allocateFixedMemory(len, align);
    } else {
      return this.allocateRelocMemory(len, align);
    }
  }

  allocateRelocMemory(len, align) {
    return this.obtainView(new ArrayBuffer(len), 0, len);
  }

  registerMemory(dv, targetDV = null, targetAlign = undefined) {
    const { memoryList } = this.context;
    const address = this.getViewAddress(dv);
    const index = findMemoryIndex(memoryList, address);
    memoryList.splice(index, 0, { address, dv, len: dv.byteLength, targetDV, targetAlign });
    return address;
  }

  unregisterMemory(address) {
    const { memoryList } = this.context;
    const index = findMemoryIndex(memoryList, address);
    const prev = memoryList[index - 1];
    if (prev?.address === address) {
      memoryList.splice(index - 1, 1);
    }
  }

  findMemory(address, len) {
    // check for null address (=== can't be used since address can be both number and bigint)
    if (this.context) {
      const { memoryList } = this.context;
      const index = findMemoryIndex(memoryList, address);
      const entry = memoryList[index - 1];
      if (entry?.address === address && entry.len === len) {
        return entry.targetDV ?? entry.dv;
      } else if (entry?.address <= address && address < add(entry.address, entry.len)) {
        const offset = Number(address - entry.address);
        const targetDV = entry.targetDV ?? entry.dv;
        const isOpaque = len === undefined;
        if (isOpaque) {
          len = targetDV.byteLength - offset;
        }
        const dv = this.obtainView(targetDV.buffer, targetDV.byteOffset + offset, len);
        if (isOpaque) {
          // opaque structure--need to save the alignment 
          dv[ALIGN$a] = entry.targetAlign;
        }
        return dv;
      }
    }
    // not found in any of the buffers we've seen--assume it's fixed memory
    return this.obtainFixedView(address, len ?? 0);
  }

  getViewAddress(dv) {
    const address = this.getBufferAddress(dv.buffer);
    return add(address, dv.byteOffset);
  }

  obtainView(buffer, offset, len) {
    let entry = this.viewMap.get(buffer);
    if (!entry) {
      const dv = new DataView(buffer, offset, len);
      this.viewMap.set(buffer, dv);
      return dv;
    } 
    if (entry instanceof DataView) {
      // only one view created thus far--see if that's the matching one 
      if (entry.byteOffset === offset && entry.byteLength === len) {
        return entry;
      } else {
        // no, need to replace the entry with a hash keyed by `offset:len`
        const dv = entry;
        const key = `${dv.byteOffset}:${dv.byteLength}`;
        entry = { [key]: dv };
        this.viewMap.set(buffer, entry);
      }
    }
    const key = `${offset}:${len}`;
    let dv = entry[key];
    if (!dv) {
      dv = entry[key] = new DataView(buffer, offset, len);
    }
    return dv;
  }

  captureView(address, len, copy) {
    if (copy) {
      // copy content into reloctable memory
      const dv = this.allocateRelocMemory(len, 0);
      if (len > 0) {
        this.copyBytes(dv, address, len);
      }
      return dv;
    } else {
      // link into fixed memory
      return this.obtainFixedView(address, len);
    }
  }

  castView(structure, dv, writable) {
    const { constructor, hasPointer } = structure;
    const object = constructor.call(ENVIRONMENT$a, dv, { writable });
    if (hasPointer) {
      // acquire targets of pointers
      this.acquirePointerTargets(object);
    }
    return object;
  }

  /* COMPTIME-ONLY */
  getSlotNumber(scope, key) {
    let slotNumber = this.slotNumbers[scope];
    if (!slotNumber) {
      slotNumber = this.slotNumbers[scope] = { next: 0, map: {} };
    }
    let slot = slotNumber.map[key];
    if (slot === undefined) {
      slot = slotNumber.map[key] = slotNumber.next++;
    }
    return slot;
  }
  
  readSlot(target, slot) {
    const slots = target ? target[SLOTS$a] : this.slots;
    return slots?.[slot];
  }

  writeSlot(target, slot, value) {
    const slots = target ? target[SLOTS$a] : this.slots;
    if (slots) {
      slots[slot] = value;
    }
  }

  createTemplate(dv) {
    return {
      [MEMORY$a]: dv,
      [SLOTS$a]: {}
    };
  }

  beginStructure(def) {
    const {
      type,
      name,
      length,
      byteSize,
      align,
      isConst,
      hasPointer,
    } = def;
    return {
      constructor: null,
      typedArray: null,
      type,
      name,
      length,
      byteSize,
      align,
      isConst,
      hasPointer,
      instance: {
        members: [],
        methods: [],
        template: null,
      },
      static: {
        members: [],
        methods: [],
        template: null,
      },
    };
  }

  attachMember(structure, member, isStatic = false) {
    const target = (isStatic) ? structure.static : structure.instance;
    target.members.push(member);
  }

  attachMethod(structure, method, isStaticOnly = false) {
    structure.static.methods.push(method);
    if (!isStaticOnly) {
      structure.instance.methods.push(method);
    }
  }

  attachTemplate(structure, template, isStatic = false) {
    const target = (isStatic) ? structure.static : structure.instance;
    target.template = template;
  }

  endStructure(structure) {
    this.structures.push(structure);
    this.finalizeStructure(structure);
    for (const structure of this.structures) {
      this.acquireDefaultPointers(structure);
    }
  }

  defineFactoryArgStruct() {
    useBool$a();
    useObject$a();
    useArgStruct$a();
    const options = this.beginStructure({
      type: StructureType$a.Struct,
      name: 'Options',
      byteSize: 2,
      hasPointer: false,
    });
    this.attachMember(options, {
      type: MemberType$a.Bool,
      name: 'omitFunctions',
      bitOffset: 0,
      bitSize: 1,
      byteSize: 1,      
    });
    this.attachMember(options, {
      type: MemberType$a.Bool,
      name: 'omitVariables',
      bitOffset: 8,
      bitSize: 1,
      byteSize: 1,      
    });
    this.finalizeShape(options);
    const structure = this.beginStructure({
      type: StructureType$a.ArgStruct,
      name: 'factory',
      byteSize: 2,
      hasPointer: false,
    });
    this.attachMember(structure, {
      type: MemberType$a.Object,
      name: '0',
      bitOffset: 0,
      bitSize: 16,
      byteSize: 2,
      slot: 0,
      structure: options,
    });
    this.attachMember(structure, {
      type: MemberType$a.Void,
      name: 'retval',
      bitOffset: 16,
      bitSize: 0,
      byteSize: 0
    });
    this.finalizeShape(structure);
    return structure.constructor;
  }

  acquireStructures(options) {
    const {
      omitFunctions = false,
      omitVariables = isElectron(),
    } = options;
    resetGlobalErrorSet();
    const thunkId = this.getFactoryThunk();
    const ArgStruct = this.defineFactoryArgStruct();
    const args = new ArgStruct([ { omitFunctions, omitVariables } ]);
    this.comptime = true;
    this.invokeThunk(thunkId, args);
    this.comptime = false;
  }

  getRootModule() {
    const root = this.structures[this.structures.length - 1];
    return root.constructor;
  }

  hasMethods() {
    // all methods are static, so there's no need to check instance methods
    return !!this.structures.find(s => s.static.methods.length > 0);
  }

  exportStructures() {
    this.prepareObjectsForExport();
    const { structures, runtimeSafety, littleEndian } = this;
    return { 
      structures, 
      options: { runtimeSafety, littleEndian }, 
      keys: { MEMORY: MEMORY$a, SLOTS: SLOTS$a, CONST: CONST$a } 
    };
  }

  prepareObjectsForExport() {
    const objects = findAllObjects(this.structures, SLOTS$a);    
    const list = [];
    for (const object of objects) {
      if (object[MEMORY$a]) {
        if (this.inFixedMemory(object)) {
          // replace fixed memory
          const dv = object[MEMORY$a];
          const address = this.getViewAddress(dv);
          const offset = this.getMemoryOffset(address);
          const len = dv.byteLength;
          const relocDV = this.captureView(address, len, true);
          relocDV.reloc = offset;
          object[MEMORY$a] = relocDV;
          list.push({ offset, len, owner: object, replaced: false });
        }
      }
    }
    // larger memory blocks come first
    list.sort((a, b) => b.len - a.len);
    for (const a of list) {
      if (!a.replaced) {
        for (const b of list) {
          if (a !== b && !b.replaced) {
            if (a.offset <= b.offset && b.offset < a.offset + a.len) {
              // B is inside A--replace it with a view of A's buffer
              const dv = a.owner[MEMORY$a];
              const pos = b.offset - a.offset + dv.byteOffset;
              const newDV = this.obtainView(dv.buffer, pos, b.len);
              newDV.reloc = b.offset;
              b.owner[MEMORY$a] = newDV;
              b.replaced = true;
            }
          }
        }  
      }
    }
  }  

  useStructures() {
    const module = this.getRootModule();
    // add fixed memory object to list so they can be unlinked
    const objects = findAllObjects(this.structures, SLOTS$a);    
    for (const object of objects) {
      if (object[MEMORY$a] && this.inFixedMemory(object)) {
        this.variables.push({ object });
      }
    }
    // clear comptime-only variables
    this.slots = {};
    this.structures = [];
    module.__zigar = this.getControlObject();
    return module;
  }
  /* COMPTIME-ONLY-END */

  finalizeShape(structure) {
    const f = getStructureFactory(structure.type);
    const constructor = f(structure, this);
    if (typeof(constructor) === 'function') {
      defineProperties$a(constructor, {
        name: { value: structure.name, configurable: true },
      });
      if (!constructor.prototype.hasOwnProperty(Symbol.toStringTag)) {
        defineProperties$a(constructor.prototype, {
          [Symbol.toStringTag]: { value: structure.name, configurable: true },
        });
      }
    }
  }

  finalizeStructure(structure) {
    addStaticMembers(structure, this);
    addMethods(structure, this);
  }

  createCaller(method, useThis) {
    const { name, argStruct, thunkId } = method;
    const { constructor } = argStruct;
    const self = this;
    let f;
    if (useThis) {
      f = function(...args) {
        return self.invokeThunk(thunkId, new constructor([ this, ...args ]));
      };
    } else {
      f = function(...args) {
        return self.invokeThunk(thunkId, new constructor(args));
      };
    }
    Object.defineProperty(f, 'name', { value: name });
    return f;
  }


  getShadowAddress(target, cluster) {
    if (cluster) {
      const dv = target[MEMORY$a];
      if (cluster.address === undefined) {
        const shadow = this.createClusterShadow(cluster);
        cluster.address = this.getViewAddress(shadow[MEMORY$a]);
      }
      return add(cluster.address, dv.byteOffset);
    } else {
      const shadow = this.createShadow(target);
      return this.getViewAddress(shadow[MEMORY$a]);
    }
  }

  createShadow(object) {
    const dv = object[MEMORY$a];
    // use the alignment of the structure; in the case of an opaque pointer's target,
    // try to the alignment specified when the memory was allocated
    const align = object.constructor[ALIGN$a] ?? dv[ALIGN$a];
    const shadow = Object.create(object.constructor.prototype);
    const shadowDV = shadow[MEMORY$a] = this.allocateShadowMemory(dv.byteLength, align);
    shadow[ATTRIBUTES] = {
      address: this.getViewAddress(shadowDV),
      len: shadowDV.byteLength,
      align,
    };
    return this.addShadow(shadow, object, align);
  }

  addShadow(shadow, object, align) {
    let { shadowMap } = this.context;
    if (!shadowMap) {
      shadowMap = this.context.shadowMap = new Map();
    }
    shadowMap.set(shadow, object);
    this.registerMemory(shadow[MEMORY$a], object[MEMORY$a], align);
    return shadow;
  }

  removeShadow(dv) {
    const { shadowMap } = this.context;
    if (shadowMap) {
      for (const [ shadow ] of shadowMap) {
        if (shadow[MEMORY$a] === dv) {
          shadowMap.delete(shadow);
          break;
        }
      }
    }
  }

  updateShadows() {
    const { shadowMap } = this.context;
    if (!shadowMap) {
      return;
    }
    for (const [ shadow, object ] of shadowMap) {
      shadow[COPIER$a](object);
    }
  }

  updateShadowTargets() {
    const { shadowMap } = this.context;
    if (!shadowMap) {
      return;
    }
    for (const [ shadow, object ] of shadowMap) {
      object[COPIER$a](shadow);
    }
  }

  releaseShadows() {
    const { shadowMap } = this.context;
    if (!shadowMap) {
      return;
    }
    for (const [ shadow ] of shadowMap) {
      const { address, len, align } = shadow[ATTRIBUTES];
      this.freeShadowMemory(address, len, align);
    }
  }

  acquirePointerTargets(args) {
    const env = this;
    const pointerMap = new Map();
    const callback = function({ isActive, isMutable }) {
      const pointer = this[POINTER$a];
      if (pointerMap.get(pointer)) {
        return;
      } else {
        pointerMap.set(pointer, true);
      }
      const writable = !pointer.constructor.const;
      const currentTarget = pointer[SLOTS$a][0];
      let newTarget, location;
      if (isActive(this)) {
        const Target = pointer.constructor.child;
        if (!currentTarget || isMutable(this)) {
          // obtain address and length from memory
          location = pointer[LOCATION_GETTER$a]();
          if (!isInvalidAddress(location.address)) {
            // get view of memory that pointer points to
            const len = (Target[SIZE$a] !== undefined) ? location.length * Target[SIZE$a] : undefined;
            const dv = env.findMemory(location.address, len);
            // create the target
            newTarget = Target.call(ENVIRONMENT$a, dv, { writable });
          } else {
            newTarget = null;
          }
        } else {
          newTarget = currentTarget;
        }
      }
      // acquire objects pointed to by pointers in target
      currentTarget?.[POINTER_VISITOR$a]?.(callback, { vivificate: true, isMutable: () => writable });
      if (newTarget !== currentTarget) {
        newTarget?.[POINTER_VISITOR$a]?.(callback, { vivificate: true, isMutable: () => writable });
        pointer[SLOTS$a][0] = newTarget;
        if (env.inFixedMemory(pointer)) {
          pointer[FIXED_LOCATION$a] = location;
        }
      }
    };
    args[POINTER_VISITOR$a](callback, { vivificate: true });
  }

  /* COMPTIME-ONLY */
  acquireDefaultPointers(structure) {
    const { constructor, hasPointer, instance: { template } } = structure;
    if (hasPointer && template && template[MEMORY$a]) {
      // create a placeholder for retrieving default pointers
      const placeholder = Object.create(constructor.prototype);
      placeholder[MEMORY$a] = template[MEMORY$a];
      placeholder[SLOTS$a] = template[SLOTS$a];
      this.acquirePointerTargets(placeholder);
    }
  }
  /* COMPTIME-ONLY-END */
}

class CallContext {
  pointerProcessed = new Map();
  memoryList = [];
  shadowMap = null;
  /* WASM-ONLY */
  call = 0;
  /* WASM-ONLY-END */
}

function findSortedIndex(array, value, cb) {
  let low = 0;
  let high = array.length;
  if (high === 0) {
    return 0;
  }
  while (low < high) {
    const mid = Math.floor((low + high) / 2);
    const value2 = cb(array[mid]);
    if (value2 <= value) {
      low = mid + 1;
    } else {
      high = mid;
    }
  }
  return high;
}

function findMemoryIndex(array, address) {
  return findSortedIndex(array, address, m => m.address);
}

function add(address, len) {
  return address + ((typeof(address) === 'bigint') ? BigInt(len) : len);
}

function isInvalidAddress(address) {
  if (typeof(address) === 'bigint') {
    return address === 0xaaaaaaaaaaaaaaaan;
  } else {
    return address === 0xaaaaaaaa;
  }
}

function isElectron() {
  return typeof(process) === 'object'
      && typeof(process?.versions) === 'object' 
      && !!process.versions?.electron;
}

class WebAssemblyEnvironment extends Environment {
  imports = {
    getFactoryThunk: { argType: '', returnType: 'i' },
    allocateExternMemory: { argType: 'ii', returnType: 'i' },
    freeExternMemory: { argType: 'iii' },
    allocateShadowMemory: { argType: 'cii', returnType: 'v' },
    freeShadowMemory: { argType: 'ciii' },
    runThunk: { argType: 'iv', returnType: 'v' },
    isRuntimeSafetyActive: { argType: '', returnType: 'b' },
  };
  exports = {
    allocateHostMemory: { argType: 'ii', returnType: 'v' },
    freeHostMemory: { argType: 'iii' },
    captureString: { argType: 'ii', returnType: 'v' },
    captureView: { argType: 'iib', returnType: 'v' },
    castView: { argType: 'vvb', returnType: 'v' },
    getSlotNumber: { argType: 'ii', returnType: 'i' },
    readSlot: { argType: 'vi', returnType: 'v' },
    writeSlot: { argType: 'viv' },
    getViewAddress: { argType: 'v', returnType: 'i' },
    beginDefinition: { returnType: 'v' },
    insertInteger: { argType: 'vsi', alias: 'insertProperty' },
    insertBoolean: { argType: 'vsb', alias: 'insertProperty' },
    insertString: { argType: 'vss', alias: 'insertProperty' },
    insertObject: { argType: 'vsv', alias: 'insertProperty' },
    beginStructure: { argType: 'v', returnType: 'v' },
    attachMember: { argType: 'vvb' },
    attachMethod: { argType: 'vvb' },
    createTemplate: { argType: 'v', returnType: 'v' },
    attachTemplate: { argType: 'vvb' },
    finalizeShape: { argType: 'v' },
    endStructure: { argType: 'v' },
    startCall: { argType: 'iv', returnType: 'i' },
    endCall: { argType: 'iv', returnType: 'i' },
  };
  nextValueIndex = 1;
  valueTable = { 0: null };
  valueIndices = new Map;
  memory = null;
  // WASM is always little endian
  littleEndian = true;

  allocateHostMemory(len, align) {
    // allocate memory in both JavaScript and WASM space
    const constructor = { [ALIGN$a]: align };
    const copier = getMemoryCopier$a(len);
    const dv = this.allocateRelocMemory(len, align);
    const shadowDV = this.allocateShadowMemory(len, align);
    // create a shadow for the relocatable memory
    const object = { constructor, [MEMORY$a]: dv, [COPIER$a]: copier };
    const shadow = { constructor, [MEMORY$a]: shadowDV, [COPIER$a]: copier };
    shadow[ATTRIBUTES] = { address: this.getViewAddress(shadowDV), len, align };
    this.addShadow(shadow, object, align);
    return shadowDV;
  }

  freeHostMemory(address, len, align) {
    const dv = this.findMemory(address, len);
    this.removeShadow(dv);
    this.unregisterMemory(address);
    this.freeShadowMemory(address, len, align);
  }

  getBufferAddress(buffer) {
    return 0;
  }

  allocateFixedMemory(len, align) {
    if (len === 0) {
      return new DataView(this.memory.buffer, 0, 0);
    }
    const address = this.allocateExternMemory(len, align);
    const dv = this.obtainFixedView(address, len);
    dv[ALIGN$a] = align;
    return dv;
  }

  freeFixedMemory(address, len, align) {
    if (len === 0) {
      return;
    }
    this.freeExternMemory(address, len, align);
  }

  obtainFixedView(address, len) {
    const { memory } = this;
    if (len === 0 && address === -1431655766) { // 0xAAAAAAAA
      address = 0;
    }
    const dv = this.obtainView(memory.buffer, address, len);
    dv[MEMORY$a] = { memory, address, len };
    return dv;
  }

  releaseFixedView(dv) {
    dv.buffer;
    const address = dv.byteOffset;
    const len = dv.byteLength;
    // only allocated memory would have align attached
    const align = dv[ALIGN$a];
    if (align !== undefined) {
      this.freeFixedMemory(address, len, align);
    }
  }

  inFixedMemory(object) {
    // reconnect any detached buffer before checking
    if (!this.memory) {
      return false;
    }
    restoreMemory$a.call(object);
    return object[MEMORY$a].buffer === this.memory.buffer;
  }

  copyBytes(dst, address, len) {
    const { memory } = this;
    const src = new DataView(memory.buffer, address, len);
    const copy = getCopyFunction$a(len);
    copy(dst, src);
  }

  findSentinel(address, bytes) {
    const { memory } = this;
    const len = bytes.byteLength;
    const end = memory.buffer.byteLength - len + 1;
    for (let i = address; i < end; i += len) {
      const dv = new DataView(memory.buffer, i, len);
      let match = true;
      for (let j = 0; j < len; j++) {
        const a = dv.getUint8(j);
        const b = bytes.getUint8(j);
        if (a !== b) {
          match = false;
          break;
        }
      }
      if (match) {
        return (i - address) / len;
      }
    }
  }

  captureString(address, len) {
    const { buffer } = this.memory;
    const ta = new Uint8Array(buffer, address, len);
    return decodeText$a(ta);
  }

  getTargetAddress(target, cluster) {
    if (this.inFixedMemory(target)) {
      return this.getViewAddress(target[MEMORY$a]);
    }
    if (target[MEMORY$a].byteLength === 0) {
      // it's a null pointer/empty slice
      return 0;
    }
    // relocatable buffers always need shadowing
    return false;
  }

  clearExchangeTable() {
    if (this.nextValueIndex !== 1) {
      this.nextValueIndex = 1;
      this.valueTable = { 0: null };
      this.valueIndices = new Map();
    }
  }

  getObjectIndex(object) {
    if (object) {
      let index = this.valueIndices.get(object);
      if (index === undefined) {
        index = this.nextValueIndex++;
        this.valueIndices.set(object, index);
        this.valueTable[index] = object;
      }
      return index;
    } else {
      return 0;
    }
  }

  fromWebAssembly(type, arg) {
    switch (type) {
      case 'v':
      case 's': return this.valueTable[arg];
      case 'i': return arg;
      case 'b': return !!arg;
    }
  }

  toWebAssembly(type, arg) {
    switch (type) {
      case 'v':
      case 's': return this.getObjectIndex(arg);
      case 'i': return arg;
      case 'b': return arg ? 1 : 0;
    }
  }

  exportFunction(fn, argType = '', returnType = '') {
    if (!fn) {
      return () => {};
    }
    return (...args) => {
      args = args.map((arg, i) => this.fromWebAssembly(argType.charAt(i), arg));
      const retval = fn.apply(this, args);
      return this.toWebAssembly(returnType, retval);
    };
  }

  importFunction(fn, argType = '', returnType = '') {
    let needCallContext = false;
    if (argType.startsWith('c')) {
      needCallContext = true;
      argType = argType.slice(1);
    }
    return (...args) => {
      args = args.map((arg, i) => this.toWebAssembly(argType.charAt(i), arg));
      if (needCallContext) {
        args = [ this.context.call, ...args ];
      }
      const retval = fn.apply(this, args);
      return this.fromWebAssembly(returnType, retval);
    };
  }

  exportFunctions() {
    const imports = {};
    for (const [ name, { argType, returnType, alias } ] of Object.entries(this.exports)) {
      const fn = this[alias ?? name];
      imports[`_${name}`] = this.exportFunction(fn, argType, returnType);
    }
    return imports;
  }

  importFunctions(exports) {
    for (const [ name, fn ] of Object.entries(exports)) {
      const info = this.imports[name];
      if (info) {
        const { argType, returnType } = info;
        this[name] = this.importFunction(fn, argType, returnType);
      }
    }
  }

  async instantiateWebAssembly(source) {
    const res = await source;
    const env = this.exportFunctions();
    const wasi = this.getWASI();
    const imports = { env, wasi_snapshot_preview1: wasi };
    if (res[Symbol.toStringTag] === 'Response') {
      return WebAssembly.instantiateStreaming(res, imports);
    } else {
      return WebAssembly.instantiate(res, imports);
    }
  }

  loadModule(source) {
    return this.initPromise = (async () => {
      const { instance } = await this.instantiateWebAssembly(source);
      const { memory, _initialize } = instance.exports;
      this.importFunctions(instance.exports);
      this.trackInstance(instance);
      this.runtimeSafety = this.isRuntimeSafetyActive();
      this.memory = memory;
      _initialize?.();
    })();
  }

  trackInstance(instance) {
    // use WeakRef to detect whether web-assembly instance has been gc'ed
    const ref = new WeakRef(instance);
    Object.defineProperty(this, 'released', { get: () => !ref.deref(), enumerable: true });
  }

  linkVariables(writeBack) {
    // linkage occurs when WASM compilation is complete and functions have been imported
    // nothing needs to happen when WASM is not used
    if (this.initPromise) {
      this.initPromise = this.initPromise.then(() => super.linkVariables(writeBack));
    }
  }

  /* COMPTIME-ONLY */
  beginDefinition() {
    return {};
  }

  insertProperty(def, name, value) {
    def[name] = value;
  }
  /* COMPTIME-ONLY-END */

  getMemoryOffset(address) {
    // WASM address space starts at 0
    return address;
  }

  recreateAddress(reloc) {
    return reloc;
  }

  startCall(call, args) {
    this.startContext();
    // call context, used by allocateShadowMemory and freeShadowMemory
    this.context.call = call;
    if (args[POINTER_VISITOR$a]) {
      this.updatePointerAddresses(args);
    }
    // return address of shadow for argumnet struct
    const address = this.getShadowAddress(args);
    this.updateShadows();
    return address;
  }

  endCall(call, args) {
    this.updateShadowTargets();
    if (args[POINTER_VISITOR$a]) {
      this.acquirePointerTargets(args);
    }
    this.releaseShadows();
    // restore the previous context if there's one
    this.endContext();
    if (!this.context && this.flushConsole) {
      this.flushConsole();
    }
  }

  async runThunk(thunkId, args) {
    // wait for compilation
    await this.initPromise;
    // invoke runThunk() from WASM code
    return this.runThunk(thunkId, args);
  }

  invokeThunk(thunkId, args) {
    // wasm-exporter.zig will invoke startCall() with the context address and the args
    // we can't do pointer fix up here since we need the context in order to allocate
    // memory from the WebAssembly allocator; pointer target acquisition will happen in
    // endCall()
    const err = this.runThunk(thunkId, args);
    // errors returned by exported Zig functions are normally written into the
    // argument object and get thrown when we access its retval property (a zig error union)
    // error strings returned by the thunk are due to problems in the thunking process
    // (i.e. bugs in export.zig)
    if (err) {
      if (err[Symbol.toStringTag] === 'Promise') {
        // getting a promise, WASM is not yet ready
        // wait for fulfillment, then either return result or throw
        return err.then((err) => {
          if (err) {
            throwZigError(err);
          }
          return args.retval;
        });
      } else {
        throwZigError(err);
      }
    }
    return args.retval;
  }

  getWASI() {
    return { 
      proc_exit: (rval) => {
      },
      fd_write: (fd, iovs_ptr, iovs_count, written_ptr) => {
        if (fd === 1 || fd === 2) {
          const dv = new DataView(this.memory.buffer);
          let written = 0;
          for (let i = 0, p = iovs_ptr; i < iovs_count; i++, p += 8) {
            const buf_ptr = dv.getUint32(p, true);
            const buf_len = dv.getUint32(p + 4, true);
            const buf = new DataView(this.memory.buffer, buf_ptr, buf_len);
            this.writeToConsole(buf);
            written += buf_len;
          }
          dv.setUint32(written_ptr, written, true);
          return 0;            
        } else {
          return 1;
        }
      },
      random_get: (buf, buf_len) => {
        const dv = new DataView(this.memory.buffer);
        for (let i = 0; i < buf_len; i++) {
          dv.setUint8(Math.floor(256 * Math.random()));
        }
        return 0;
      },
    };
  }
}

/* COMPTIME-ONLY */

// useAllMemberTypes();
// useAllStructureTypes();
// useAllExtendedTypes();
/* COMPTIME-ONLY-END */

function createEnvironment(source) {
  return new WebAssemblyEnvironment();
}

BigInt(Number.MAX_SAFE_INTEGER);
BigInt(Number.MIN_SAFE_INTEGER);

process.cwd();

function findSourceFile(modulePath, options) {
  const { sourceFiles } = options;
  return sourceFiles?.[modulePath]; 
}

BigInt(Number.MAX_SAFE_INTEGER);
BigInt(Number.MIN_SAFE_INTEGER);

process.cwd();

BigInt(Number.MAX_SAFE_INTEGER);
BigInt(Number.MIN_SAFE_INTEGER);

process.cwd();

BigInt(Number.MAX_SAFE_INTEGER);
BigInt(Number.MIN_SAFE_INTEGER);

process.cwd();

BigInt(Number.MAX_SAFE_INTEGER);
BigInt(Number.MIN_SAFE_INTEGER);

process.cwd();

const MEMORY$9 = Symbol('memory');
const SLOTS$9 = Symbol('slots');
const PARENT$9 = Symbol('parent');
const NAME$9 = Symbol('name');
const CLASS$1 = Symbol('class');
const TAG$9 = Symbol('tag');
const PROPS$9 = Symbol('props');
const GETTER$9 = Symbol('getter');
const SETTER$9 = Symbol('setter');
const ELEMENT_GETTER$9 = Symbol('elementGetter');
const ELEMENT_SETTER$9 = Symbol('elementSetter');
const LOCATION_GETTER$9 = Symbol('addressGetter');
const LOCATION_SETTER$9 = Symbol('addressSetter');
const TARGET_GETTER$9 = Symbol('targetGetter');
const TARGET_SETTER$9 = Symbol('targetSetter');
const FIXED_LOCATION$9 = Symbol('fixedLocation');
const PROP_GETTERS$9 = Symbol('propGetters');
const PROP_SETTERS$9 = Symbol('propSetters');
const ALL_KEYS$9 = Symbol('allKeys');
const LENGTH$9 = Symbol('length');
const PROXY$9 = Symbol('proxy');
const COMPAT$9 = Symbol('compat');
const SIZE$9 = Symbol('size');
const ALIGN$9 = Symbol('align');
const ARRAY$9 = Symbol('array');
const POINTER$9 = Symbol('pointer');
const CONST$9 = Symbol('const');
const CONST_PROTOTYPE$9 = Symbol('constProto');
const COPIER$9 = Symbol('copier');
const RESETTER$9 = Symbol('resetter');
const NORMALIZER$9 = Symbol('normalizer');
const VIVIFICATOR$9 = Symbol('vivificator');
const POINTER_VISITOR$9 = Symbol('pointerVisitor');
const ENVIRONMENT$9 = Symbol('environment');
const MORE$9 = Symbol('more');

function getDestructor$9(env) {
  return function() {
    const dv = this[MEMORY$9];
    this[MEMORY$9] = null;
    if (this[SLOTS$9]) {
      this[SLOTS$9] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$9(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$9(size, multiple = false) {
  const copy = getCopyFunction$9(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$9.call(this);
    restoreMemory$9.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$9];
    const dest = this[MEMORY$9];
    copy(dest, src);
  };
}

function getCopyFunction$9(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$9[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$9;
  if (!(size & 0x03)) return copy4x$9;
  if (!(size & 0x01)) return copy2x$9;
  return copy1x$9;
}

const copiers$9 = {
  1: copy1$9,
  2: copy2$9,
  4: copy4$9,
  8: copy8$9,
  16: copy16$9,
  32: copy32$9,
};

function copy1x$9(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$9(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$9(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$9(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$9(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$9(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$9(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$9(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$9(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$9(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$9(offset, size) {
  const reset = getResetFunction$9(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$9.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$9];
    reset(dest, offset, size);
  };
}

function getResetFunction$9(size) {
  const resetter = resetters$9[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$9;
  if (!(size & 0x03)) return reset4x$9;
  if (!(size & 0x01)) return reset2x$9;
  return reset1x$9;
}

const resetters$9 = {
  1: reset1$9,
  2: reset2$9,
  4: reset4$9,
  8: reset8$9,
  16: reset16$9,
  32: reset32$9,
};

function reset1x$9(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$9(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$9(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$9(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$9(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$9(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$9(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$9(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$9(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$9(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$9() {
  const dv = this[MEMORY$9];
  const source = dv[MEMORY$9];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$9] = source;
  this[MEMORY$9] = newDV;
  return true;
}

const decoders$9 = {};
const encoders$9 = {};

function decodeText$9(arrays, encoding = 'utf-8') {
  let decoder = decoders$9[encoding];
  if (!decoder) {
    decoder = decoders$9[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$9(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$9[encoding];
      if (!encoder) {
        encoder = encoders$9[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$9(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$9(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$9() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$9];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$9 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$9 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$9() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$9];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        if (typeof(result?.toJSON) === 'function') {
          result = result.toJSON();
        }      
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$9 <= value && value <= INT_MAX$9) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$9(cb, options) {
  const value = handleError$9(() => this.$, options);
  return cb(value);
}

function handleError$9(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$9(structure, handlers = {}) {
  return markAsSpecial$9({
    get() {
      /* WASM-ONLY */
      restoreMemory$9.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$9];
    },
    set(dv) {
      checkDataView$9(dv);
      setDataView$9.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$9(structure, handlers = {}) {
  return markAsSpecial$9({
    get() {
      return encodeBase64$9(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$9('string', str);
      }
      const dv = decodeBase64$9(str);
      setDataView$9.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$9(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$9({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$9(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$9('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$9(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$9.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$9(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$9({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$9(ta, typedArray)) {
        throwTypeMismatch$9(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$9.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$9({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$9(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$9.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$9.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$9({
    type: MemberType$9.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$9({
    type: MemberType$9.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$9];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$9]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$9]);
        const target = Target.call(ENVIRONMENT$9, dv, { writable: !isConst });
        this[SLOTS$9][0] = target;
        this[FIXED_LOCATION$9] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$9][0] ?? throwNullPointer$9();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$9]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$9] = loc;
      } else {
        throwFixedMemoryTargetRequired$9();
      }
    }
    this[SLOTS$9][0] = arg;
  };
  const getTarget = isValueExpected$9(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$9]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$9][0] ?? throwNullPointer$9();
    return object[SETTER$9](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$9 || this === PARENT$9) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$9(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$9();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$j;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$9, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$9(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$9(structure, arg);
      }
      arg = arg[SLOTS$9][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$9.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$9]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$9]) {
        throwReadOnlyTarget$9(structure);       
      }
    } else if (isCompatible$9(arg, Target)) {
      // autocast to target type
      const dv = getDataView$9(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$9]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$9(arg?.buffer)) {
          warnImplicitArrayCreation$9(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$9(structure, arg);
    }
    this[TARGET_SETTER$9](arg);
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$9, set: initializer },
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [TARGET_GETTER$9]: { value: getTargetObject },
    [TARGET_SETTER$9]: { value: setTargetObject },
    [LOCATION_GETTER$9]: { value: addressGetter },
    [LOCATION_SETTER$9]: { value: addressSetter },
    [POINTER_VISITOR$9]: { value: visitPointer$9 },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [VIVIFICATOR$9]: { value: throwNullPointer$9 },
    [NORMALIZER$9]: { value: normalizePointer$9 },
    [FIXED_LOCATION$9]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$9(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$9() {
  return this[PROXY$9];
}

function copyPointer$9({ source }) {
  const target = source[SLOTS$9][0];
  if (target) {
    this[TARGET_SETTER$9](target);
  }
}

function resetPointer$9({ isActive }) {
  if (this[SLOTS$9][0] && !isActive(this)) {
    this[SLOTS$9][0] = undefined;
  }
}

function disablePointer$9() {
  const disabledProp = { get: throwInaccessiblePointer$9, set: throwInaccessiblePointer$9 };
  const disabledFunc = { value: throwInaccessiblePointer$9 };
  defineProperties$9(this[POINTER$9], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$9]: disabledFunc,
    [SETTER$9]: disabledFunc,
    [TARGET_GETTER$9]: disabledFunc,
  });
}

function visitPointer$9(fn, options = {}) {
  const {
    source,
    isActive = always$9,
    isMutable = always$9,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$9(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$j = {
  get(pointer, name) {
    if (name === POINTER$9) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$9]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$9]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$9]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$9]();
      return name in target;
    }
  },
};

function always$9() {
  return true;
}

function never$9() {
  return false;
}

function defineStructShape$9(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$9(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$9.Object);
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$9](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$9(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$9, set: initializer },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$9 },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$j(structure) },
    [POINTER_VISITOR$9]: hasPointer && { value: getPointerVisitor$j(structure, always$9) },
    [NORMALIZER$9]: { value: normalizeStruct$9 },
    [PROPS$9]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$9(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$9.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$9(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$9.bind(this, options),
    length: this[PROPS$9].length,
  };
}

function getStructIterator$9(options) { 
  const entries = getStructEntries$9.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$9(options) {
  const self = this;
  const props = this[PROPS$9];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$9(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$j(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$9.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$9];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$9(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$9][slot] = constructor.call(PARENT$9, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$j(structure, visitorOptions = {}) {
  const {
    isChildActive = always$9,
    isChildMutable = always$9,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$9,
      isMutable = always$9,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$9]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$9][slot] ?? (vivificate ? this[VIVIFICATOR$9](slot) : null);
      if (child) {
        child[POINTER_VISITOR$9](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$9(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$9.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$9] = dv;
    if (hasObject) {
      this[SLOTS$9] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$9(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$9(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$9(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$9(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$j(structure) },
    [POINTER_VISITOR$9]: hasPointer && { value: getPointerVisitor$j(structure, { isChildMutable }) },
  });
  defineProperties$9(constructor, {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  });
  return constructor;
}

function defineArray$9(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$9(member, env);
  const hasStringProp = canBeString$9(member);
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$9](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$9(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$9(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$9(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$9(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$9;
  const constructor = structure.constructor = createConstructor$9(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$9(member);
  const hasObject = member.type === MemberType$9.Object;
  const instanceDescriptors = {
    $: { get: getProxy$9, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    string: hasStringProp && getStringDescriptor$9(structure),
    typedArray: typedArray && getTypedArrayDescriptor$9(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$9 },
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [Symbol.iterator]: { value: getArrayIterator$9 },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$i(structure) },
    [POINTER_VISITOR$9]: hasPointer && { value: getPointerVisitor$i() },
    [NORMALIZER$9]: { value: normalizeArray$9 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$9]: { value: getCompatibleTags$9(structure) },
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$9() {
  const proxy = new Proxy(this, proxyHandlers$i);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$9, { value: proxy }); 
  return proxy;
}

function canBeString$9(member) {
  return member.type === MemberType$9.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$9(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$9.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$9() {
  const self = this[ARRAY$9] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$9(options) {
  const self = this[ARRAY$9] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$9(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$9(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$9.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$i(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$9];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$9][index] = constructor.call(PARENT$9, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$i(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$9,
      isMutable = always$9,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$9][i];
      }
      const child = this[SLOTS$9][i] ?? (vivificate ? this[VIVIFICATOR$9](i) : null);
      if (child) {
        child[POINTER_VISITOR$9](cb, childOptions);
      }
    }
  };
}

function transformIterable$9(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$i = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$9]) {
            array[ELEMENT_GETTER$9] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$9];
        case 'set':
          if (!array[ELEMENT_SETTER$9]) {
            array[ELEMENT_SETTER$9] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$9];
        case ARRAY$9:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$9] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$9] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$9];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$9];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$9);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$9(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get, set } = getDescriptor$9(member, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$9(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      let item = constructor[arg];
      if (!item) {
        if (constructor[MORE$9] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = new constructor(undefined);
          debugger;        
          set.call(item, arg, 'number');
          appendEnumeration$1(constructor, `${arg}`, item);
        }
      }
      return item;
    } else if (arg instanceof constructor) {
      return arg;
    } else if (arg?.[TAG$9] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$9];
    } else if (!getDataView$9(structure, arg, env)) {
      throwInvalidInitializer$9(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$9(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$9] : get.call(this, 'number');
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    typedArray: typedArray && getTypedArrayDescriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [NORMALIZER$9]: { value: normalizeEnumerationItem$9 },
  };
  const staticDescriptors = {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$9(cb) {
  return cb(this.$[NAME$9]);
}

function appendEnumeration$1(enumeration, name, item) {
  if (name !== undefined) {
    // enum can have static variables 
    if (item instanceof enumeration) {
      // attach name to item so tagged union code can quickly find it
      defineProperties$9(item, { [NAME$9]: { value: name } });  
      // call toPrimitive directly since enum can be bigint or number
      const index = item[Symbol.toPrimitive]();
      defineProperties$9(enumeration, {
        [index]: { value: item },
        [name]: { value: item },
      });      
    }
  } else {
    // non-exhaustive enum
    defineProperties$9(enumeration, { [MORE$9]: { value: true } });
  }
}

function defineErrorUnion$9(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$9(members[0], env);
  const { get: getError, set: setError } = getDescriptor$9(members[1], env);
  const get = function() {
    const errNum = getError.call(this, 'number');
    if (errNum) {
      throw getError.call(this);
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$9.Void;
  const TargetError = members[1].structure.constructor[CLASS$1];
  const isChildActive = function() {
    return !getError.call(this, 'number');
  };
  const clearValue = function() {
    this[RESETTER$9]();
    this[POINTER_VISITOR$9]?.(resetPointer$9);
  };
  const hasObject = !!members.find(m => m.type === MemberType$9.Object);
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$9](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, 'number');
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$9(structure);
        } else if (isErrorJSON$1(arg)) {
          setError.call(this, arg);
          clearValue.call(this);
        } else if (arg && typeof(arg) === 'object') {
          if (propApplier.call(this, arg) === 0) {
            throw err;
          }
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$9(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [RESETTER$9]: { value: getMemoryResetter$9(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$j(structure) },
    [POINTER_VISITOR$9]: hasPointer && { value: getPointerVisitor$j(structure, { isChildActive }) },
    [NORMALIZER$9]: { value: normalizeValue$9 },
  };
  const staticDescriptors = {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$9(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$9(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$9(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [NORMALIZER$9]: { value: normalizeOpaque$9 },
  };
  const staticDescriptors = {
    [COMPAT$9]: { value: getCompatibleTags$9(structure) },
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$9(cb) {
  return {};
}

function defineOptional$9(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$9(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$9(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$9]?.(resetPointer$9);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$9.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$9](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$9]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$9]?.(resetPointer$9);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$9.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$9]: !hasPointer && { value: getMemoryResetter$9(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$j(structure) },
    [POINTER_VISITOR$9]: hasPointer && { value: getPointerVisitor$j(structure, { isChildActive }) },
    [NORMALIZER$9]: { value: normalizeValue$9 },
  };
  const staticDescriptors = {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function definePrimitive$9(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$9(member, env);
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$9](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$9(member);
          throwInvalidInitializer$9(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$9(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    typedArray: typedArray && getTypedArrayDescriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [NORMALIZER$9]: { value: normalizeValue$9 },
  };
  const staticDescriptors = {
    [COMPAT$9]: { value: getCompatibleTags$9(structure) },
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$9(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$9.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$9({ type, bitSize }) {
  if (type === MemberType$9.Int || type === MemberType$9.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$9.Float) {
    return Number;
  } else if (type === MemberType$9.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$9(member) {
  const Primitive = getPrimitiveClass$9(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function defineSlice$9(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$9(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$9(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$9(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$9] = dv;
    this[LENGTH$9] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$9]) {
      throwArrayLengthMismatch$9(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$9]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$9](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$9(arg);
      if (!this[MEMORY$9]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$9] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$9(structure, arg, !this[MEMORY$9]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$9(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$9(structure, arg);
    }
  };
  const finalizer = createArrayProxy$9;
  const constructor = structure.constructor = createConstructor$9(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$9(member);
  const hasObject = member.type === MemberType$9.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$9, set: initializer },
    length: { get: getLength$9 },
    dataView: getDataViewDescriptor$9(structure, shapeHandlers),
    base64: getBase64Descriptor$9(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$9(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$9(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$9 },
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [Symbol.iterator]: { value: getArrayIterator$9 },
    [COPIER$9]: { value: getMemoryCopier$9(elementSize, true) },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$i(structure) },
    [POINTER_VISITOR$9]: hasPointer && { value: getPointerVisitor$i() },
    [NORMALIZER$9]: { value: normalizeArray$9 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$9]: { value: getCompatibleTags$9(structure) },
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: elementSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$9() {
  return this[LENGTH$9];
}

function getSentinel$9(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$9(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$9(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$9(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$9(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$9(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$9(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$9(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$9].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$9(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$9];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$9(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$9.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$9.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$9(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$9];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$9(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$9(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$9]?.(resetPointer$9);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$9(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$9]?.(resetPointer$9);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$9](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$9(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$9(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$9(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$9](disablePointer$9, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$9(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$9;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$9.Object);
  const instanceDescriptors = {
    $: { get: getSelf$9, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$9 },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [TAG$9]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$9]: hasObject && { value: getChildVivificator$j(structure) },
    [POINTER_VISITOR$9]: hasAnyPointer && { value: getPointerVisitor$j(structure, { isChildActive }) },
    [PROP_GETTERS$9]: { value: memberValueGetters },
    [NORMALIZER$9]: { value: normalizeUnion$9 },
    [PROPS$9]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$9];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$9(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$9.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$9(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$9.bind(this, options),
    length: this[PROPS$9].length,
  };
}

function getUnionIterator$9(options) { 
  const entries = getUnionEntries$9.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$9(options) {
  const self = this;
  const props = this[PROPS$9];
  const getters = this[PROP_GETTERS$9];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$9(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$9(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$9({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$9](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$9(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$9][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$9(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$9(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$9(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$9(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$9, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    typedArray: typedArray && getTypedArrayDescriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    entries: { value: getVectorEntries$9 },
    delete: { value: getDestructor$9(structure) },
    [Symbol.iterator]: { value: getVectorIterator$9 },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [NORMALIZER$9]: { value: normalizeVector$9 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$9]: { value: getCompatibleTags$9(structure) },
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$9(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$9.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$9() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$9() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$9() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$9.bind(this),
    length: this.length,
  };
}

const StructureType$9 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$t = Array(Object.values(StructureType$9).length);

function usePrimitive$9() {
  factories$t[StructureType$9.Primitive] = definePrimitive$9;
}

function useArray$9() {
  factories$t[StructureType$9.Array] = defineArray$9;
}

function useStruct$9() {
  factories$t[StructureType$9.Struct] = defineStructShape$9;
}

function usePackedStruct$9() {
  factories$t[StructureType$9.PackedStruct] = defineStructShape$9;
}

function useExternStruct$9() {
  factories$t[StructureType$9.ExternStruct] = defineStructShape$9;
}

function useArgStruct$9() {
  factories$t[StructureType$9.ArgStruct] = defineArgStruct$9;
}

function useExternUnion$9() {
  factories$t[StructureType$9.ExternUnion] = defineUnionShape$9;
}

function useBareUnion$9() {
  factories$t[StructureType$9.BareUnion] = defineUnionShape$9;
}

function useTaggedUnion$9() {
  factories$t[StructureType$9.TaggedUnion] = defineUnionShape$9;
}

function useErrorUnion$9() {
  factories$t[StructureType$9.ErrorUnion] = defineErrorUnion$9;
}

function useErrorSet$9() {
  factories$t[StructureType$9.ErrorSet] = defineErrorSet$9;
  useErrorSetTransform$1();
}

function useEnumeration$9() {
  factories$t[StructureType$9.Enumeration] = defineEnumerationShape$9;
  useEnumerationTransform$1();
}

function useOptional$9() {
  factories$t[StructureType$9.Optional] = defineOptional$9;
}

function usePointer$9() {
  factories$t[StructureType$9.Pointer] = definePointer$9;
  useUint$9();
}

function useSlice$9() {
  factories$t[StructureType$9.Slice] = defineSlice$9;
}

function useVector$9() {
  factories$t[StructureType$9.Vector] = defineVector$9;
}

function useOpaque$9() {
  factories$t[StructureType$9.Opaque] = defineOpaque$9;
}

function defineProperties$9(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$9 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$9, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$9]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$9(constructor.prototype, { 
    [CONST$9]: { value: false },
    [ALL_KEYS$9]: { value: Object.keys(propSetters) },
    [SETTER$9]: { value: set },
    [GETTER$9]: { value: get },
    [PROP_SETTERS$9]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$9(constructor, {
    [CONST_PROTOTYPE$9]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$9(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$9]: { value: true },
    [SETTER$9]: { value: throwReadOnly$9 },
    [VIVIFICATOR$9]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$9(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$9(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$9]) {
    const comptimeMembers = members.filter(m => isReadOnly$9(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$9();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$9(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$9] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$9]; 
      } else {
        self[MEMORY$9] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$9(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$9]);
      if (shapeDefiner) {
        setDataView$9.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$9] = dv;
      }
      if (hasSlots) {
        self[SLOTS$9] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$9](copyPointer$9, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$9][slot] = template[SLOTS$9][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$9]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$9(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$9];
    const allKeys = this[ALL_KEYS$9];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$9(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$9(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$9]) {
          this[COPIER$9](template);
        }
        this[POINTER_VISITOR$9]?.(copyPointer$9, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$9(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$9.Object:
      case MemberType$9.Comptime:
      case MemberType$9.Type:
      case MemberType$9.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$9() {
  return this;
}

function useAllStructureTypes$9() {
  usePrimitive$9();
  useArray$9();
  useStruct$9();
  useExternStruct$9();
  usePackedStruct$9();
  useArgStruct$9();
  useExternUnion$9();
  useBareUnion$9();
  useTaggedUnion$9();
  useErrorUnion$9();
  useErrorSet$9();
  useEnumeration$9();
  useOptional$9();
  usePointer$9();
  useSlice$9();
  useVector$9();
  useOpaque$9();
}

let ObjectCache$9 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

let currentGlobalSet$1;
let currentErrorClass$1;

function defineErrorSet$9(structure, env) {
  const {
    name,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  if (!currentErrorClass$1) {
    currentErrorClass$1 = class ZigError extends ZigErrorBase$1 {};
    currentGlobalSet$1 = defineErrorSet$9({ ...structure, name: 'anyerror' }, env);
  } 
  if (currentGlobalSet$1 && name === 'anyerror') {
    structure.constructor = currentGlobalSet$1;
    structure.typedArray = getTypedArrayClass$9(member);
    return currentGlobalSet$1;
  }
  const errorClass = currentErrorClass$1;
  const { get, set } = getDescriptor$9(member, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$9(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor[CLASS$1]) {
      set.call(this, arg);
    } else if (arg && typeof(arg) === 'object' && !isErrorJSON$1(arg)) {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$9(structure, expected, arg);
      }  
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[arg];
    } else if (arg instanceof constructor[CLASS$1]) {
      return constructor[Number(arg)];
    } else if (isErrorJSON$1(arg)) {
      return constructor[`Error: ${arg.error}`];
    } else if (!getDataView$9(structure, arg, env)) {
      throwInvalidInitializer$9(structure, expected, arg);
    } else {
      return false;
    }
  };
  // items are inserted when static members get attached in static.js
  const constructor = structure.constructor = createConstructor$9(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$9(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$9(structure),
    base64: getBase64Descriptor$9(structure),
    typedArray: typedArray && getTypedArrayDescriptor$9(structure),
    valueOf: { value: getValueOf$9 },
    toJSON: { value: convertToJSON$9 },
    delete: { value: getDestructor$9(env) },
    [COPIER$9]: { value: getMemoryCopier$9(byteSize) },
    [NORMALIZER$9]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$9]: { value: align },
    [SIZE$9]: { value: byteSize },
    [CLASS$1]: { value: errorClass },
    // the PROPS array is normally set in static.js; it needs to be set here for anyerror 
    // so we can add names to it as error sets are defined
    [PROPS$9]: (name === 'anyerror') ? { value: [] } : undefined,
  };
  return attachDescriptors$9(constructor, instanceDescriptors, staticDescriptors);
}

function isErrorJSON$1(arg) {
  return typeof(arg) === 'object' && typeof(arg.error) === 'string' && Object.keys(arg).length === 1  ;
}

let ZigErrorBase$1 = class ZigErrorBase extends Error {
  constructor(name, number) {
    super(deanimalizeErrorName$1(name));
    this.number = number;
  }

  [Symbol.toPrimitive](hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return this.number;
    }
  }  

  toJSON() {
    return { error: this.message };
  }
};

function throwNoInitializer$9(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$9(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$9.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$9.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$9(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$9);
  if (typedArray) {
    acceptable.push(addArticle$9(typedArray.name));
  }
  if (type === StructureType$9.Slice) {
    throw new TypeError(`Expecting ${formatList$9(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$9(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$9(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$9(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number' || isErrorJSON$1(arg)) {
    if (isErrorJSON$1(arg)) {
      arg = `{ error: ${JSON.stringify(arg.error)} }`;
    }
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$9(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$9(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$9(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$9(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$9(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$9(type));
    }
  } else {
    acceptable.push(addArticle$9(expected));
  }
  const received = getDescription$9(arg);
  throw new TypeError(`${name} expects ${formatList$9(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$9(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$9(member);
  if (primitive) {
    let object;
    switch (member.structure?.type) {
      case StructureType$9.Enumeration: object = 'enum item'; break;
      case StructureType$9.ErrorSet: object = 'error'; break;
      default: object = primitive;
    }
    acceptable.push(`array of ${object}s`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$9.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$9(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$9(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$9(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$9(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$9(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$9(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$9(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$9(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$9(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$9(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$9(expected, arg) {
  const received = getDescription$9(arg);
  throw new TypeError(`Expected ${addArticle$9(expected)}, received ${received}`)
}

function throwInaccessiblePointer$9() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$9() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$9(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$9(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$9(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$9(member, value) {
  const typeName = getTypeName$9(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$9(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$9(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$9(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$9(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$9(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$9() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$9(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$9(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$9(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$9(structure, arg) {
  const created = addArticle$9(structure.typedArray.name);
  const source = addArticle$9(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function deanimalizeErrorName$1(name) {
  // deal with snake_case first
  let s = name.replace(/_/g, ' ');
  // then camelCase, using a try block in case Unicode regex fails
  try {
    s = s.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu, (m0, m1, m2) => {
      if (m1.length === 1) {
        return ` ${m1.toLocaleLowerCase()}${m2}`;
      } else {
        if (m2) {
          const acronym = m1.substring(0, m1.length - 1);
          const letter = m1.charAt(m1.length - 1).toLocaleLowerCase();
          return ` ${acronym} ${letter}${m2}`;
        } else {
          return ` ${m1}`;
        }
      }
    }).trimStart();
    /* c8 ignore next 2 */
  } catch (err) {
  }
  return s.charAt(0).toLocaleUpperCase() + s.substring(1);
}

function getDescription$9(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$9(s);
}

function addArticle$9(noun) {
  return `${article$9(noun)} ${noun}`;
}

function article$9(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$9(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$9(access, member) {
  return cacheMethod$9(access, member, () => {
    if (isByteAligned$9(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$9({ type: MemberType$9.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$9(access, member);
    }
  });
}

function getNumericAccessor$9(access, member) {
  return cacheMethod$9(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$9(access, member);
    }
  });
}

const factories$s = {};

function useExtendedBool$9() {
  factories$s[MemberType$9.Bool] = getExtendedBoolAccessor$9;
}

function useExtendedInt$9() {
  factories$s[MemberType$9.Int] = getExtendedIntAccessor$9;
}

function useExtendedUint$9() {
  factories$s[MemberType$9.Uint] = getExtendedUintAccessor$9;
}

function useExtendedFloat$9() {
  factories$s[MemberType$9.Float] = getExtendedFloatAccessor$9;
}

function getExtendedTypeAccessor$9(access, member) {
  const f = factories$s[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$9(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$9(access, member) {
  if (isByteAligned$9(member)) {
    return getAlignedIntAccessor$9(access, member)
  } else {
    return getUnalignedIntAccessor$9(access, member);
  }
}

function getExtendedUintAccessor$9(access, member) {
  if (isByteAligned$9(member)) {
    return getAlignedUintAccessor$9(access, member)
  } else {
    return getUnalignedUintAccessor$9(access, member);
  }
}

function getExtendedFloatAccessor$9(access, member) {
  if (isByteAligned$9(member)) {
    return getAlignedFloatAccessor$9(access, member)
  } else {
    return getUnalignedFloatAccessor$9(access, member);
  }
}

function getDataView$9(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$9];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$9.Array || type === StructureType$9.Slice || type === StructureType$9.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$9(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$9.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$9(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$9(dv, structure);
  }
  return dv;
}

function checkDataView$9(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$9('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$9(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$9.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$9(structure, dv);
  }
}

function setDataView$9(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$9.Slice;
  if (!this[MEMORY$9]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$9(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$9]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$9](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$9(structure, dv, this);
    }
    const source = { [MEMORY$9]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$9](source); 
  }
}

function findElements$9(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$9(structure, arg, env) {
  const dv = getDataView$9(structure, arg, env);
  if (!dv) {
    throwBufferExpected$9(structure);
  }
  return dv;
}

function getTypedArrayClass$9(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$9.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$9.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$9.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$9.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$9(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$9(arg, constructor) {
  const tags = constructor[COMPAT$9];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$9(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$9(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$9(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$9(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$9.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$9.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$9.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$9.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$9.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$9(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$9(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$9({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$9(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$9(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$9({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$9(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$9(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$9(access, member);
}

function getUnalignedUintAccessor$9(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$9(access, member);
}

function getAlignedFloatAccessor$9(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$9(access, member) {
  return getUnalignedNumericAccessor$9(access, member);
}

function getUnalignedNumericAccessor$9(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$9('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$9(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$9('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$9(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$9 = {};

function cacheMethod$9(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$9(member);
  const suffix = isByteAligned$9(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$9.Int || type === MemberType$9.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$9[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$9(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$9[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$9() {
  useExtendedBool$9();
  useExtendedInt$9();
  useExtendedUint$9();
  useExtendedFloat$9();
}

const MemberType$9 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  Object: 5,
  Type: 6,
  Comptime: 7,
  Static: 8,
  Literal: 9,
  Null: 10,
  Undefined: 11,
};

function isReadOnly$9(type) {
  switch (type) {
    case MemberType$9.Type:
    case MemberType$9.Comptime:
    case MemberType$9.Literal:
      return true;
    default:
      return false;
  }
}

const factories$r = {};

function useVoid$9() {
  factories$r[MemberType$9.Void] = getVoidDescriptor$9;
}

function useBool$9() {
  factories$r[MemberType$9.Bool] = getBoolDescriptor$9;
}

function useInt$9() {
  factories$r[MemberType$9.Int] = getIntDescriptor$9;
}

function useUint$9() {
  factories$r[MemberType$9.Uint] = getUintDescriptor$9;
}

function useFloat$9() {
  factories$r[MemberType$9.Float] = getFloatDescriptor$9;
}

function useObject$9() {
  factories$r[MemberType$9.Object] = getObjectDescriptor$9;
}

function useType$9() {
  factories$r[MemberType$9.Type] = getTypeDescriptor$9;
}

function useComptime$9() {
  factories$r[MemberType$9.Comptime] = getComptimeDescriptor$9;
}

function useStatic$9() {
  factories$r[MemberType$9.Static] = getStaticDescriptor$9;
}

function useLiteral$9() {
  factories$r[MemberType$9.Literal] = getLiteralDescriptor$9;
}

function useNull$9() {
  factories$r[MemberType$9.Null] = getNullDescriptor$9;
}

function useUndefined$9() {
  factories$r[MemberType$9.Undefined] = getUndefinedDescriptor$9;
}

const transformers$1 = {};

function useEnumerationTransform$1() {
  transformers$1[StructureType$9.Enumeration] = transformEnumerationDescriptor$1;
}

function useErrorSetTransform$1() {
  transformers$1[StructureType$9.ErrorSet] = transformErrorSetDescriptor$1;
}

function isByteAligned$9({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$9(member, env) {
  const f = factories$r[member.type];
  return f(member, env);
}

function transformDescriptor$1(descriptor, member) {
  const { structure } = member;
  const t = transformers$1[structure?.type];
  return (t) ? t(descriptor, structure) : descriptor;
}

function getVoidDescriptor$9(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$9(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$9(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$9(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$9(member, env) {
  return getDescriptorUsing$9(member, env, getBoolAccessor$9)
}

function getIntDescriptor$9(member, env) {
  const getDataViewAccessor = addRuntimeCheck$9(env, getNumericAccessor$9);
  const descriptor = getDescriptorUsing$9(member, env, getDataViewAccessor);
  return transformDescriptor$1(descriptor, member);
}

function getUintDescriptor$9(member, env) {
  const getDataViewAccessor = addRuntimeCheck$9(env, getNumericAccessor$9);
  const descriptor = getDescriptorUsing$9(member, env, getDataViewAccessor);
  return transformDescriptor$1(descriptor, member);
}

function addRuntimeCheck$9(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$9(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$9(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$9(member, env) {
  return getDescriptorUsing$9(member, env, getNumericAccessor$9)
}

function transformEnumerationDescriptor$1(int, structure) {  
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = constructor(value);
    if (!item) {
      throwEnumExpected$9(structure, value);
    }
    return item
  };
  return {
    get: (int.get.length === 0) 
    ? function getEnum(hint) {
        const value = int.get.call(this);
        if (hint === 'number') {
          return value;
        }
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = int.get.call(this, index);
        return findEnum(value);
      },
    set: (int.set.length === 1) 
    ? function setEnum(value, hint) {
        if (hint !== 'number') {
          const item = findEnum(value);
          // call Symbol.toPrimitive directly as enum can be bigint or number
          value = item[Symbol.toPrimitive]();
        }
        int.set.call(this, value);
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        int.set.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function transformErrorSetDescriptor$1(int, structure) {
  const findError = function(value) {
    const { constructor } = structure;
    const item = constructor(value);
    if (!item) {
      if (value instanceof Error) {
        throwNotInErrorSet$9(structure);
      } else {
        throwErrorExpected$9(structure, value);
      }
    } 
    return item
  };
  return {
    get: (int.get.length === 0) 
    ? function getError(hint) {
        const value = int.get.call(this);
        if (hint === 'number') {
          return value;
        }
        return findError(value);
      }
    : function getErrorElement(index) {
        const value = int.get.call(this, index);
        return findError(value);
      },
    set: (int.set.length === 1) 
    ? function setError(value, hint) {
        if (hint !== 'number') {
          const item = findError(value);
          value = Number(item);
        }
        int.set.call(this, value);
      }
    : function setError(index, value) {
        const item = findError(value);
        value = Number(item);
        int.set.call(this, index, value);
      },
  };
}

function isValueExpected$9(structure) {
  switch (structure.type) {
    case StructureType$9.Primitive:
    case StructureType$9.ErrorUnion:
    case StructureType$9.Optional:
    case StructureType$9.Enumeration:
    case StructureType$9.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$9(slot) {
  const object = this[SLOTS$9][slot] ?? this[VIVIFICATOR$9](slot);
  return object[GETTER$9]();
}

function getObject$9(slot) {
  const object = this[SLOTS$9][slot] ?? this[VIVIFICATOR$9](slot);
  return object;
}

function setValue$9(slot, value) {
  const object = this[SLOTS$9][slot] ?? this[VIVIFICATOR$9](slot);
  object[SETTER$9](value);
}

function bindSlot$9(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$9(member, env) {
  const { structure, slot } = member;
  return bindSlot$9(slot, {
    get: isValueExpected$9(structure) ? getValue$9 : getObject$9,
    set: setValue$9,
  });
}

function getType$9(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$9][slot];
  return structure?.constructor;
}

function getTypeDescriptor$9(member, env) {
  const { slot } = member;
  return bindSlot$9(slot, { get: getType$9 });
}

function getComptimeDescriptor$9(member, env) {
  const { slot, structure } = member;
  return bindSlot$9(slot, {
    get: isValueExpected$9(structure) ? getValue$9 : getObject$9,
  });
}

function getStaticDescriptor$9(member, env) {
  const { slot, structure } = member;
  return bindSlot$9(slot, {
    get: isValueExpected$9(structure) ? getValue$9 : getObject$9,
    set: setValue$9,
  });
}

function getLiteral$9(slot) {
  const object = this[SLOTS$9][slot];
  return object.string;
}

function getLiteralDescriptor$9(member, env) {
  const { slot } = member;
  return bindSlot$9(slot, { get: getLiteral$9 });
}

function getDescriptorUsing$9(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$9], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$9.call(this)) {
            return getter.call(this[MEMORY$9], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$9], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$9.call(this)) {
            return setter.call(this[MEMORY$9], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$9], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$9.call(this)) {
            return getter.call(this[MEMORY$9], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$9(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$9], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$9.call(this)) {
            return setter.call(this[MEMORY$9], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$9(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$9() {
  useVoid$9();
  useNull$9();
  useUndefined$9();
  useBool$9();
  useInt$9();
  useUint$9();
  useFloat$9();
  useObject$9();
  useType$9();
  useComptime$9();
  useStatic$9();
  useLiteral$9();
}

process.cwd();

useAllMemberTypes$9();
useAllStructureTypes$9();
useAllExtendedTypes$9();

const MEMORY$8 = Symbol('memory');
const SLOTS$8 = Symbol('slots');
const PARENT$8 = Symbol('parent');
const NAME$8 = Symbol('name');
const CLASS = Symbol('class');
const TAG$8 = Symbol('tag');
const PROPS$8 = Symbol('props');
const GETTER$8 = Symbol('getter');
const SETTER$8 = Symbol('setter');
const ELEMENT_GETTER$8 = Symbol('elementGetter');
const ELEMENT_SETTER$8 = Symbol('elementSetter');
const LOCATION_GETTER$8 = Symbol('addressGetter');
const LOCATION_SETTER$8 = Symbol('addressSetter');
const TARGET_GETTER$8 = Symbol('targetGetter');
const TARGET_SETTER$8 = Symbol('targetSetter');
const FIXED_LOCATION$8 = Symbol('fixedLocation');
const PROP_GETTERS$8 = Symbol('propGetters');
const PROP_SETTERS$8 = Symbol('propSetters');
const ALL_KEYS$8 = Symbol('allKeys');
const LENGTH$8 = Symbol('length');
const PROXY$8 = Symbol('proxy');
const COMPAT$8 = Symbol('compat');
const SIZE$8 = Symbol('size');
const ALIGN$8 = Symbol('align');
const ARRAY$8 = Symbol('array');
const POINTER$8 = Symbol('pointer');
const CONST$8 = Symbol('const');
const CONST_PROTOTYPE$8 = Symbol('constProto');
const COPIER$8 = Symbol('copier');
const RESETTER$8 = Symbol('resetter');
const NORMALIZER$8 = Symbol('normalizer');
const VIVIFICATOR$8 = Symbol('vivificator');
const POINTER_VISITOR$8 = Symbol('pointerVisitor');
const ENVIRONMENT$8 = Symbol('environment');
const MORE$8 = Symbol('more');

function getDestructor$8(env) {
  return function() {
    const dv = this[MEMORY$8];
    this[MEMORY$8] = null;
    if (this[SLOTS$8]) {
      this[SLOTS$8] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$8(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$8(size, multiple = false) {
  const copy = getCopyFunction$8(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$8.call(this);
    restoreMemory$8.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$8];
    const dest = this[MEMORY$8];
    copy(dest, src);
  };
}

function getCopyFunction$8(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$8[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$8;
  if (!(size & 0x03)) return copy4x$8;
  if (!(size & 0x01)) return copy2x$8;
  return copy1x$8;
}

const copiers$8 = {
  1: copy1$8,
  2: copy2$8,
  4: copy4$8,
  8: copy8$8,
  16: copy16$8,
  32: copy32$8,
};

function copy1x$8(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$8(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$8(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$8(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$8(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$8(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$8(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$8(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$8(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$8(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$8(offset, size) {
  const reset = getResetFunction$8(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$8.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$8];
    reset(dest, offset, size);
  };
}

function getResetFunction$8(size) {
  const resetter = resetters$8[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$8;
  if (!(size & 0x03)) return reset4x$8;
  if (!(size & 0x01)) return reset2x$8;
  return reset1x$8;
}

const resetters$8 = {
  1: reset1$8,
  2: reset2$8,
  4: reset4$8,
  8: reset8$8,
  16: reset16$8,
  32: reset32$8,
};

function reset1x$8(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$8(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$8(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$8(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$8(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$8(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$8(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$8(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$8(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$8(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$8() {
  const dv = this[MEMORY$8];
  const source = dv[MEMORY$8];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$8] = source;
  this[MEMORY$8] = newDV;
  return true;
}

const decoders$8 = {};
const encoders$8 = {};

function decodeText$8(arrays, encoding = 'utf-8') {
  let decoder = decoders$8[encoding];
  if (!decoder) {
    decoder = decoders$8[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$8(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$8[encoding];
      if (!encoder) {
        encoder = encoders$8[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$8(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$8(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$8() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$8];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$8 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$8 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$8() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$8];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        if (typeof(result?.toJSON) === 'function') {
          result = result.toJSON();
        }      
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$8 <= value && value <= INT_MAX$8) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$8(cb, options) {
  const value = handleError$8(() => this.$, options);
  return cb(value);
}

function handleError$8(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$8(structure, handlers = {}) {
  return markAsSpecial$8({
    get() {
      /* WASM-ONLY */
      restoreMemory$8.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$8];
    },
    set(dv) {
      checkDataView$8(dv);
      setDataView$8.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$8(structure, handlers = {}) {
  return markAsSpecial$8({
    get() {
      return encodeBase64$8(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$8('string', str);
      }
      const dv = decodeBase64$8(str);
      setDataView$8.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$8(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$8({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$8(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$8('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$8(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$8.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$8(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$8({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$8(ta, typedArray)) {
        throwTypeMismatch$8(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$8.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$8({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$8(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$8.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$8.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$8({
    type: MemberType$8.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$8({
    type: MemberType$8.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$8];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$8]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$8]);
        const target = Target.call(ENVIRONMENT$8, dv, { writable: !isConst });
        this[SLOTS$8][0] = target;
        this[FIXED_LOCATION$8] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$8][0] ?? throwNullPointer$8();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$8]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$8] = loc;
      } else {
        throwFixedMemoryTargetRequired$8();
      }
    }
    this[SLOTS$8][0] = arg;
  };
  const getTarget = isValueExpected$8(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$8]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$8][0] ?? throwNullPointer$8();
    return object[SETTER$8](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$8 || this === PARENT$8) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$8(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$8();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$h;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$8, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$8(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$8(structure, arg);
      }
      arg = arg[SLOTS$8][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$8.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$8]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$8]) {
        throwReadOnlyTarget$8(structure);       
      }
    } else if (isCompatible$8(arg, Target)) {
      // autocast to target type
      const dv = getDataView$8(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$8]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$8(arg?.buffer)) {
          warnImplicitArrayCreation$8(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$8(structure, arg);
    }
    this[TARGET_SETTER$8](arg);
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$8, set: initializer },
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [TARGET_GETTER$8]: { value: getTargetObject },
    [TARGET_SETTER$8]: { value: setTargetObject },
    [LOCATION_GETTER$8]: { value: addressGetter },
    [LOCATION_SETTER$8]: { value: addressSetter },
    [POINTER_VISITOR$8]: { value: visitPointer$8 },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [VIVIFICATOR$8]: { value: throwNullPointer$8 },
    [NORMALIZER$8]: { value: normalizePointer$8 },
    [FIXED_LOCATION$8]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$8(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$8() {
  return this[PROXY$8];
}

function copyPointer$8({ source }) {
  const target = source[SLOTS$8][0];
  if (target) {
    this[TARGET_SETTER$8](target);
  }
}

function resetPointer$8({ isActive }) {
  if (this[SLOTS$8][0] && !isActive(this)) {
    this[SLOTS$8][0] = undefined;
  }
}

function disablePointer$8() {
  const disabledProp = { get: throwInaccessiblePointer$8, set: throwInaccessiblePointer$8 };
  const disabledFunc = { value: throwInaccessiblePointer$8 };
  defineProperties$8(this[POINTER$8], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$8]: disabledFunc,
    [SETTER$8]: disabledFunc,
    [TARGET_GETTER$8]: disabledFunc,
  });
}

function visitPointer$8(fn, options = {}) {
  const {
    source,
    isActive = always$8,
    isMutable = always$8,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$8(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$h = {
  get(pointer, name) {
    if (name === POINTER$8) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$8]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$8]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$8]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$8]();
      return name in target;
    }
  },
};

function always$8() {
  return true;
}

function never$8() {
  return false;
}

function defineStructShape$8(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$8(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$8.Object);
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$8](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$8(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$8, set: initializer },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$8 },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$h(structure) },
    [POINTER_VISITOR$8]: hasPointer && { value: getPointerVisitor$h(structure, always$8) },
    [NORMALIZER$8]: { value: normalizeStruct$8 },
    [PROPS$8]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$8(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$8.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$8(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$8.bind(this, options),
    length: this[PROPS$8].length,
  };
}

function getStructIterator$8(options) { 
  const entries = getStructEntries$8.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$8(options) {
  const self = this;
  const props = this[PROPS$8];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$8(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$h(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$8.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$8];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$8(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$8][slot] = constructor.call(PARENT$8, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$h(structure, visitorOptions = {}) {
  const {
    isChildActive = always$8,
    isChildMutable = always$8,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$8,
      isMutable = always$8,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$8]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$8][slot] ?? (vivificate ? this[VIVIFICATOR$8](slot) : null);
      if (child) {
        child[POINTER_VISITOR$8](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$8(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$8.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$8] = dv;
    if (hasObject) {
      this[SLOTS$8] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$8(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$8(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$8(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$8(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$h(structure) },
    [POINTER_VISITOR$8]: hasPointer && { value: getPointerVisitor$h(structure, { isChildMutable }) },
  });
  defineProperties$8(constructor, {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  });
  return constructor;
}

function defineArray$8(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$8(member, env);
  const hasStringProp = canBeString$8(member);
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$8](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$8(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$8(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$8(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$8(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$8;
  const constructor = structure.constructor = createConstructor$8(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$8(member);
  const hasObject = member.type === MemberType$8.Object;
  const instanceDescriptors = {
    $: { get: getProxy$8, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    string: hasStringProp && getStringDescriptor$8(structure),
    typedArray: typedArray && getTypedArrayDescriptor$8(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$8 },
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [Symbol.iterator]: { value: getArrayIterator$8 },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$g(structure) },
    [POINTER_VISITOR$8]: hasPointer && { value: getPointerVisitor$g() },
    [NORMALIZER$8]: { value: normalizeArray$8 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$8]: { value: getCompatibleTags$8(structure) },
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$8() {
  const proxy = new Proxy(this, proxyHandlers$g);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$8, { value: proxy }); 
  return proxy;
}

function canBeString$8(member) {
  return member.type === MemberType$8.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$8(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$8.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$8() {
  const self = this[ARRAY$8] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$8(options) {
  const self = this[ARRAY$8] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$8(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$8(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$8.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$g(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$8];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$8][index] = constructor.call(PARENT$8, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$g(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$8,
      isMutable = always$8,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$8][i];
      }
      const child = this[SLOTS$8][i] ?? (vivificate ? this[VIVIFICATOR$8](i) : null);
      if (child) {
        child[POINTER_VISITOR$8](cb, childOptions);
      }
    }
  };
}

function transformIterable$8(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$g = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$8]) {
            array[ELEMENT_GETTER$8] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$8];
        case 'set':
          if (!array[ELEMENT_SETTER$8]) {
            array[ELEMENT_SETTER$8] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$8];
        case ARRAY$8:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$8] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$8] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$8];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$8];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$8);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$8(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get, set } = getDescriptor$8(member, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$8(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      let item = constructor[arg];
      if (!item) {
        if (constructor[MORE$8] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = new constructor(undefined);
          debugger;        
          set.call(item, arg, 'number');
          appendEnumeration(constructor, `${arg}`, item);
        }
      }
      return item;
    } else if (arg instanceof constructor) {
      return arg;
    } else if (arg?.[TAG$8] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$8];
    } else if (!getDataView$8(structure, arg, env)) {
      throwInvalidInitializer$8(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$8(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$8] : get.call(this, 'number');
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    typedArray: typedArray && getTypedArrayDescriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [NORMALIZER$8]: { value: normalizeEnumerationItem$8 },
  };
  const staticDescriptors = {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$8(cb) {
  return cb(this.$[NAME$8]);
}

function appendEnumeration(enumeration, name, item) {
  if (name !== undefined) {
    // enum can have static variables 
    if (item instanceof enumeration) {
      // attach name to item so tagged union code can quickly find it
      defineProperties$8(item, { [NAME$8]: { value: name } });  
      // call toPrimitive directly since enum can be bigint or number
      const index = item[Symbol.toPrimitive]();
      defineProperties$8(enumeration, {
        [index]: { value: item },
        [name]: { value: item },
      });      
    }
  } else {
    // non-exhaustive enum
    defineProperties$8(enumeration, { [MORE$8]: { value: true } });
  }
}

function defineErrorUnion$8(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$8(members[0], env);
  const { get: getError, set: setError } = getDescriptor$8(members[1], env);
  const get = function() {
    const errNum = getError.call(this, 'number');
    if (errNum) {
      throw getError.call(this);
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$8.Void;
  const TargetError = members[1].structure.constructor[CLASS];
  const isChildActive = function() {
    return !getError.call(this, 'number');
  };
  const clearValue = function() {
    this[RESETTER$8]();
    this[POINTER_VISITOR$8]?.(resetPointer$8);
  };
  const hasObject = !!members.find(m => m.type === MemberType$8.Object);
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$8](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, 'number');
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$8(structure);
        } else if (isErrorJSON(arg)) {
          setError.call(this, arg);
          clearValue.call(this);
        } else if (arg && typeof(arg) === 'object') {
          if (propApplier.call(this, arg) === 0) {
            throw err;
          }
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$8(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [RESETTER$8]: { value: getMemoryResetter$8(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$h(structure) },
    [POINTER_VISITOR$8]: hasPointer && { value: getPointerVisitor$h(structure, { isChildActive }) },
    [NORMALIZER$8]: { value: normalizeValue$8 },
  };
  const staticDescriptors = {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$8(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$8(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$8(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [NORMALIZER$8]: { value: normalizeOpaque$8 },
  };
  const staticDescriptors = {
    [COMPAT$8]: { value: getCompatibleTags$8(structure) },
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$8(cb) {
  return {};
}

function defineOptional$8(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$8(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$8(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$8]?.(resetPointer$8);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$8.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$8](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$8]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$8]?.(resetPointer$8);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$8.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$8]: !hasPointer && { value: getMemoryResetter$8(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$h(structure) },
    [POINTER_VISITOR$8]: hasPointer && { value: getPointerVisitor$h(structure, { isChildActive }) },
    [NORMALIZER$8]: { value: normalizeValue$8 },
  };
  const staticDescriptors = {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function definePrimitive$8(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$8(member, env);
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$8](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$8(member);
          throwInvalidInitializer$8(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$8(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    typedArray: typedArray && getTypedArrayDescriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [NORMALIZER$8]: { value: normalizeValue$8 },
  };
  const staticDescriptors = {
    [COMPAT$8]: { value: getCompatibleTags$8(structure) },
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$8(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$8.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$8({ type, bitSize }) {
  if (type === MemberType$8.Int || type === MemberType$8.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$8.Float) {
    return Number;
  } else if (type === MemberType$8.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$8(member) {
  const Primitive = getPrimitiveClass$8(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function defineSlice$8(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$8(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$8(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$8(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$8] = dv;
    this[LENGTH$8] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$8]) {
      throwArrayLengthMismatch$8(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$8]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$8](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$8(arg);
      if (!this[MEMORY$8]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$8] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$8(structure, arg, !this[MEMORY$8]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$8(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$8(structure, arg);
    }
  };
  const finalizer = createArrayProxy$8;
  const constructor = structure.constructor = createConstructor$8(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$8(member);
  const hasObject = member.type === MemberType$8.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$8, set: initializer },
    length: { get: getLength$8 },
    dataView: getDataViewDescriptor$8(structure, shapeHandlers),
    base64: getBase64Descriptor$8(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$8(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$8(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$8 },
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [Symbol.iterator]: { value: getArrayIterator$8 },
    [COPIER$8]: { value: getMemoryCopier$8(elementSize, true) },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$g(structure) },
    [POINTER_VISITOR$8]: hasPointer && { value: getPointerVisitor$g() },
    [NORMALIZER$8]: { value: normalizeArray$8 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$8]: { value: getCompatibleTags$8(structure) },
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: elementSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$8() {
  return this[LENGTH$8];
}

function getSentinel$8(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$8(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$8(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$8(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$8(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$8(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$8(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$8(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$8].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$8(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$8];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$8(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$8.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$8.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$8(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$8];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$8(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$8(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$8]?.(resetPointer$8);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$8(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$8]?.(resetPointer$8);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$8](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$8(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$8(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$8(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$8](disablePointer$8, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$8(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$8;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$8.Object);
  const instanceDescriptors = {
    $: { get: getSelf$8, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$8 },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [TAG$8]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$8]: hasObject && { value: getChildVivificator$h(structure) },
    [POINTER_VISITOR$8]: hasAnyPointer && { value: getPointerVisitor$h(structure, { isChildActive }) },
    [PROP_GETTERS$8]: { value: memberValueGetters },
    [NORMALIZER$8]: { value: normalizeUnion$8 },
    [PROPS$8]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$8];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$8(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$8.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$8(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$8.bind(this, options),
    length: this[PROPS$8].length,
  };
}

function getUnionIterator$8(options) { 
  const entries = getUnionEntries$8.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$8(options) {
  const self = this;
  const props = this[PROPS$8];
  const getters = this[PROP_GETTERS$8];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$8(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$8(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$8({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$8](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$8(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$8][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$8(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$8(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$8(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$8(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$8, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    typedArray: typedArray && getTypedArrayDescriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    entries: { value: getVectorEntries$8 },
    delete: { value: getDestructor$8(structure) },
    [Symbol.iterator]: { value: getVectorIterator$8 },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [NORMALIZER$8]: { value: normalizeVector$8 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$8]: { value: getCompatibleTags$8(structure) },
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$8(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$8.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$8() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$8() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$8() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$8.bind(this),
    length: this.length,
  };
}

const StructureType$8 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$q = Array(Object.values(StructureType$8).length);

function usePrimitive$8() {
  factories$q[StructureType$8.Primitive] = definePrimitive$8;
}

function useArray$8() {
  factories$q[StructureType$8.Array] = defineArray$8;
}

function useStruct$8() {
  factories$q[StructureType$8.Struct] = defineStructShape$8;
}

function usePackedStruct$8() {
  factories$q[StructureType$8.PackedStruct] = defineStructShape$8;
}

function useExternStruct$8() {
  factories$q[StructureType$8.ExternStruct] = defineStructShape$8;
}

function useArgStruct$8() {
  factories$q[StructureType$8.ArgStruct] = defineArgStruct$8;
}

function useExternUnion$8() {
  factories$q[StructureType$8.ExternUnion] = defineUnionShape$8;
}

function useBareUnion$8() {
  factories$q[StructureType$8.BareUnion] = defineUnionShape$8;
}

function useTaggedUnion$8() {
  factories$q[StructureType$8.TaggedUnion] = defineUnionShape$8;
}

function useErrorUnion$8() {
  factories$q[StructureType$8.ErrorUnion] = defineErrorUnion$8;
}

function useErrorSet$8() {
  factories$q[StructureType$8.ErrorSet] = defineErrorSet$8;
  useErrorSetTransform();
}

function useEnumeration$8() {
  factories$q[StructureType$8.Enumeration] = defineEnumerationShape$8;
  useEnumerationTransform();
}

function useOptional$8() {
  factories$q[StructureType$8.Optional] = defineOptional$8;
}

function usePointer$8() {
  factories$q[StructureType$8.Pointer] = definePointer$8;
  useUint$8();
}

function useSlice$8() {
  factories$q[StructureType$8.Slice] = defineSlice$8;
}

function useVector$8() {
  factories$q[StructureType$8.Vector] = defineVector$8;
}

function useOpaque$8() {
  factories$q[StructureType$8.Opaque] = defineOpaque$8;
}

function defineProperties$8(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$8 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$8, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$8]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$8(constructor.prototype, { 
    [CONST$8]: { value: false },
    [ALL_KEYS$8]: { value: Object.keys(propSetters) },
    [SETTER$8]: { value: set },
    [GETTER$8]: { value: get },
    [PROP_SETTERS$8]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$8(constructor, {
    [CONST_PROTOTYPE$8]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$8(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$8]: { value: true },
    [SETTER$8]: { value: throwReadOnly$8 },
    [VIVIFICATOR$8]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$8(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$8(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$8]) {
    const comptimeMembers = members.filter(m => isReadOnly$8(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$8();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$8(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$8] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$8]; 
      } else {
        self[MEMORY$8] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$8(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$8]);
      if (shapeDefiner) {
        setDataView$8.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$8] = dv;
      }
      if (hasSlots) {
        self[SLOTS$8] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$8](copyPointer$8, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$8][slot] = template[SLOTS$8][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$8]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$8(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$8];
    const allKeys = this[ALL_KEYS$8];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$8(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$8(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$8]) {
          this[COPIER$8](template);
        }
        this[POINTER_VISITOR$8]?.(copyPointer$8, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$8(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$8.Object:
      case MemberType$8.Comptime:
      case MemberType$8.Type:
      case MemberType$8.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$8() {
  return this;
}

function useAllStructureTypes$8() {
  usePrimitive$8();
  useArray$8();
  useStruct$8();
  useExternStruct$8();
  usePackedStruct$8();
  useArgStruct$8();
  useExternUnion$8();
  useBareUnion$8();
  useTaggedUnion$8();
  useErrorUnion$8();
  useErrorSet$8();
  useEnumeration$8();
  useOptional$8();
  usePointer$8();
  useSlice$8();
  useVector$8();
  useOpaque$8();
}

let ObjectCache$8 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

let currentGlobalSet;
let currentErrorClass;

function defineErrorSet$8(structure, env) {
  const {
    name,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  if (!currentErrorClass) {
    currentErrorClass = class ZigError extends ZigErrorBase {};
    currentGlobalSet = defineErrorSet$8({ ...structure, name: 'anyerror' }, env);
  } 
  if (currentGlobalSet && name === 'anyerror') {
    structure.constructor = currentGlobalSet;
    structure.typedArray = getTypedArrayClass$8(member);
    return currentGlobalSet;
  }
  const errorClass = currentErrorClass;
  const { get, set } = getDescriptor$8(member, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$8(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor[CLASS]) {
      set.call(this, arg);
    } else if (arg && typeof(arg) === 'object' && !isErrorJSON(arg)) {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$8(structure, expected, arg);
      }  
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[arg];
    } else if (arg instanceof constructor[CLASS]) {
      return constructor[Number(arg)];
    } else if (isErrorJSON(arg)) {
      return constructor[`Error: ${arg.error}`];
    } else if (!getDataView$8(structure, arg, env)) {
      throwInvalidInitializer$8(structure, expected, arg);
    } else {
      return false;
    }
  };
  // items are inserted when static members get attached in static.js
  const constructor = structure.constructor = createConstructor$8(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$8(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$8(structure),
    base64: getBase64Descriptor$8(structure),
    typedArray: typedArray && getTypedArrayDescriptor$8(structure),
    valueOf: { value: getValueOf$8 },
    toJSON: { value: convertToJSON$8 },
    delete: { value: getDestructor$8(env) },
    [COPIER$8]: { value: getMemoryCopier$8(byteSize) },
    [NORMALIZER$8]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$8]: { value: align },
    [SIZE$8]: { value: byteSize },
    [CLASS]: { value: errorClass },
    // the PROPS array is normally set in static.js; it needs to be set here for anyerror 
    // so we can add names to it as error sets are defined
    [PROPS$8]: (name === 'anyerror') ? { value: [] } : undefined,
  };
  return attachDescriptors$8(constructor, instanceDescriptors, staticDescriptors);
}

function isErrorJSON(arg) {
  return typeof(arg) === 'object' && typeof(arg.error) === 'string' && Object.keys(arg).length === 1  ;
}

class ZigErrorBase extends Error {
  constructor(name, number) {
    super(deanimalizeErrorName(name));
    this.number = number;
  }

  [Symbol.toPrimitive](hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return this.number;
    }
  }  

  toJSON() {
    return { error: this.message };
  }
}

function throwNoInitializer$8(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$8(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$8.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$8.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$8(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$8);
  if (typedArray) {
    acceptable.push(addArticle$8(typedArray.name));
  }
  if (type === StructureType$8.Slice) {
    throw new TypeError(`Expecting ${formatList$8(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$8(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$8(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$8(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number' || isErrorJSON(arg)) {
    if (isErrorJSON(arg)) {
      arg = `{ error: ${JSON.stringify(arg.error)} }`;
    }
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$8(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$8(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$8(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$8(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$8(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$8(type));
    }
  } else {
    acceptable.push(addArticle$8(expected));
  }
  const received = getDescription$8(arg);
  throw new TypeError(`${name} expects ${formatList$8(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$8(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$8(member);
  if (primitive) {
    let object;
    switch (member.structure?.type) {
      case StructureType$8.Enumeration: object = 'enum item'; break;
      case StructureType$8.ErrorSet: object = 'error'; break;
      default: object = primitive;
    }
    acceptable.push(`array of ${object}s`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$8.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$8(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$8(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$8(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$8(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$8(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$8(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$8(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$8(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$8(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$8(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$8(expected, arg) {
  const received = getDescription$8(arg);
  throw new TypeError(`Expected ${addArticle$8(expected)}, received ${received}`)
}

function throwInaccessiblePointer$8() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$8() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$8(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$8(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$8(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$8(member, value) {
  const typeName = getTypeName$8(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$8(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$8(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$8(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$8(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$8(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$8() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$8(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$8(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$8(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$8(structure, arg) {
  const created = addArticle$8(structure.typedArray.name);
  const source = addArticle$8(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function deanimalizeErrorName(name) {
  // deal with snake_case first
  let s = name.replace(/_/g, ' ');
  // then camelCase, using a try block in case Unicode regex fails
  try {
    s = s.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu, (m0, m1, m2) => {
      if (m1.length === 1) {
        return ` ${m1.toLocaleLowerCase()}${m2}`;
      } else {
        if (m2) {
          const acronym = m1.substring(0, m1.length - 1);
          const letter = m1.charAt(m1.length - 1).toLocaleLowerCase();
          return ` ${acronym} ${letter}${m2}`;
        } else {
          return ` ${m1}`;
        }
      }
    }).trimStart();
    /* c8 ignore next 2 */
  } catch (err) {
  }
  return s.charAt(0).toLocaleUpperCase() + s.substring(1);
}

function getDescription$8(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$8(s);
}

function addArticle$8(noun) {
  return `${article$8(noun)} ${noun}`;
}

function article$8(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$8(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$8(access, member) {
  return cacheMethod$8(access, member, () => {
    if (isByteAligned$8(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$8({ type: MemberType$8.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$8(access, member);
    }
  });
}

function getNumericAccessor$8(access, member) {
  return cacheMethod$8(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$8(access, member);
    }
  });
}

const factories$p = {};

function useExtendedBool$8() {
  factories$p[MemberType$8.Bool] = getExtendedBoolAccessor$8;
}

function useExtendedInt$8() {
  factories$p[MemberType$8.Int] = getExtendedIntAccessor$8;
}

function useExtendedUint$8() {
  factories$p[MemberType$8.Uint] = getExtendedUintAccessor$8;
}

function useExtendedFloat$8() {
  factories$p[MemberType$8.Float] = getExtendedFloatAccessor$8;
}

function getExtendedTypeAccessor$8(access, member) {
  const f = factories$p[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$8(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$8(access, member) {
  if (isByteAligned$8(member)) {
    return getAlignedIntAccessor$8(access, member)
  } else {
    return getUnalignedIntAccessor$8(access, member);
  }
}

function getExtendedUintAccessor$8(access, member) {
  if (isByteAligned$8(member)) {
    return getAlignedUintAccessor$8(access, member)
  } else {
    return getUnalignedUintAccessor$8(access, member);
  }
}

function getExtendedFloatAccessor$8(access, member) {
  if (isByteAligned$8(member)) {
    return getAlignedFloatAccessor$8(access, member)
  } else {
    return getUnalignedFloatAccessor$8(access, member);
  }
}

function getDataView$8(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$8];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$8.Array || type === StructureType$8.Slice || type === StructureType$8.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$8(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$8.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$8(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$8(dv, structure);
  }
  return dv;
}

function checkDataView$8(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$8('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$8(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$8.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$8(structure, dv);
  }
}

function setDataView$8(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$8.Slice;
  if (!this[MEMORY$8]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$8(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$8]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$8](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$8(structure, dv, this);
    }
    const source = { [MEMORY$8]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$8](source); 
  }
}

function findElements$8(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$8(structure, arg, env) {
  const dv = getDataView$8(structure, arg, env);
  if (!dv) {
    throwBufferExpected$8(structure);
  }
  return dv;
}

function getTypedArrayClass$8(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$8.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$8.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$8.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$8.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$8(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$8(arg, constructor) {
  const tags = constructor[COMPAT$8];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$8(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$8(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$8(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$8(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$8.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$8.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$8.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$8.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$8.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$8(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$8(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$8({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$8(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$8(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$8({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$8(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$8(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$8(access, member);
}

function getUnalignedUintAccessor$8(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$8(access, member);
}

function getAlignedFloatAccessor$8(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$8(access, member) {
  return getUnalignedNumericAccessor$8(access, member);
}

function getUnalignedNumericAccessor$8(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$8('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$8(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$8('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$8(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$8 = {};

function cacheMethod$8(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$8(member);
  const suffix = isByteAligned$8(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$8.Int || type === MemberType$8.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$8[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$8(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$8[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$8() {
  useExtendedBool$8();
  useExtendedInt$8();
  useExtendedUint$8();
  useExtendedFloat$8();
}

const MemberType$8 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  Object: 5,
  Type: 6,
  Comptime: 7,
  Static: 8,
  Literal: 9,
  Null: 10,
  Undefined: 11,
};

function isReadOnly$8(type) {
  switch (type) {
    case MemberType$8.Type:
    case MemberType$8.Comptime:
    case MemberType$8.Literal:
      return true;
    default:
      return false;
  }
}

const factories$o = {};

function useVoid$8() {
  factories$o[MemberType$8.Void] = getVoidDescriptor$8;
}

function useBool$8() {
  factories$o[MemberType$8.Bool] = getBoolDescriptor$8;
}

function useInt$8() {
  factories$o[MemberType$8.Int] = getIntDescriptor$8;
}

function useUint$8() {
  factories$o[MemberType$8.Uint] = getUintDescriptor$8;
}

function useFloat$8() {
  factories$o[MemberType$8.Float] = getFloatDescriptor$8;
}

function useObject$8() {
  factories$o[MemberType$8.Object] = getObjectDescriptor$8;
}

function useType$8() {
  factories$o[MemberType$8.Type] = getTypeDescriptor$8;
}

function useComptime$8() {
  factories$o[MemberType$8.Comptime] = getComptimeDescriptor$8;
}

function useStatic$8() {
  factories$o[MemberType$8.Static] = getStaticDescriptor$8;
}

function useLiteral$8() {
  factories$o[MemberType$8.Literal] = getLiteralDescriptor$8;
}

function useNull$8() {
  factories$o[MemberType$8.Null] = getNullDescriptor$8;
}

function useUndefined$8() {
  factories$o[MemberType$8.Undefined] = getUndefinedDescriptor$8;
}

const transformers = {};

function useEnumerationTransform() {
  transformers[StructureType$8.Enumeration] = transformEnumerationDescriptor;
}

function useErrorSetTransform() {
  transformers[StructureType$8.ErrorSet] = transformErrorSetDescriptor;
}

function isByteAligned$8({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$8(member, env) {
  const f = factories$o[member.type];
  return f(member, env);
}

function transformDescriptor(descriptor, member) {
  const { structure } = member;
  const t = transformers[structure?.type];
  return (t) ? t(descriptor, structure) : descriptor;
}

function getVoidDescriptor$8(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$8(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$8(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$8(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$8(member, env) {
  return getDescriptorUsing$8(member, env, getBoolAccessor$8)
}

function getIntDescriptor$8(member, env) {
  const getDataViewAccessor = addRuntimeCheck$8(env, getNumericAccessor$8);
  const descriptor = getDescriptorUsing$8(member, env, getDataViewAccessor);
  return transformDescriptor(descriptor, member);
}

function getUintDescriptor$8(member, env) {
  const getDataViewAccessor = addRuntimeCheck$8(env, getNumericAccessor$8);
  const descriptor = getDescriptorUsing$8(member, env, getDataViewAccessor);
  return transformDescriptor(descriptor, member);
}

function addRuntimeCheck$8(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$8(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$8(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$8(member, env) {
  return getDescriptorUsing$8(member, env, getNumericAccessor$8)
}

function transformEnumerationDescriptor(int, structure) {  
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = constructor(value);
    if (!item) {
      throwEnumExpected$8(structure, value);
    }
    return item
  };
  return {
    get: (int.get.length === 0) 
    ? function getEnum(hint) {
        const value = int.get.call(this);
        if (hint === 'number') {
          return value;
        }
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = int.get.call(this, index);
        return findEnum(value);
      },
    set: (int.set.length === 1) 
    ? function setEnum(value, hint) {
        if (hint !== 'number') {
          const item = findEnum(value);
          // call Symbol.toPrimitive directly as enum can be bigint or number
          value = item[Symbol.toPrimitive]();
        }
        int.set.call(this, value);
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        int.set.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function transformErrorSetDescriptor(int, structure) {
  const findError = function(value) {
    const { constructor } = structure;
    const item = constructor(value);
    if (!item) {
      if (value instanceof Error) {
        throwNotInErrorSet$8(structure);
      } else {
        throwErrorExpected$8(structure, value);
      }
    } 
    return item
  };
  return {
    get: (int.get.length === 0) 
    ? function getError(hint) {
        const value = int.get.call(this);
        if (hint === 'number') {
          return value;
        }
        return findError(value);
      }
    : function getErrorElement(index) {
        const value = int.get.call(this, index);
        return findError(value);
      },
    set: (int.set.length === 1) 
    ? function setError(value, hint) {
        if (hint !== 'number') {
          const item = findError(value);
          value = Number(item);
        }
        int.set.call(this, value);
      }
    : function setError(index, value) {
        const item = findError(value);
        value = Number(item);
        int.set.call(this, index, value);
      },
  };
}

function isValueExpected$8(structure) {
  switch (structure.type) {
    case StructureType$8.Primitive:
    case StructureType$8.ErrorUnion:
    case StructureType$8.Optional:
    case StructureType$8.Enumeration:
    case StructureType$8.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$8(slot) {
  const object = this[SLOTS$8][slot] ?? this[VIVIFICATOR$8](slot);
  return object[GETTER$8]();
}

function getObject$8(slot) {
  const object = this[SLOTS$8][slot] ?? this[VIVIFICATOR$8](slot);
  return object;
}

function setValue$8(slot, value) {
  const object = this[SLOTS$8][slot] ?? this[VIVIFICATOR$8](slot);
  object[SETTER$8](value);
}

function bindSlot$8(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$8(member, env) {
  const { structure, slot } = member;
  return bindSlot$8(slot, {
    get: isValueExpected$8(structure) ? getValue$8 : getObject$8,
    set: setValue$8,
  });
}

function getType$8(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$8][slot];
  return structure?.constructor;
}

function getTypeDescriptor$8(member, env) {
  const { slot } = member;
  return bindSlot$8(slot, { get: getType$8 });
}

function getComptimeDescriptor$8(member, env) {
  const { slot, structure } = member;
  return bindSlot$8(slot, {
    get: isValueExpected$8(structure) ? getValue$8 : getObject$8,
  });
}

function getStaticDescriptor$8(member, env) {
  const { slot, structure } = member;
  return bindSlot$8(slot, {
    get: isValueExpected$8(structure) ? getValue$8 : getObject$8,
    set: setValue$8,
  });
}

function getLiteral$8(slot) {
  const object = this[SLOTS$8][slot];
  return object.string;
}

function getLiteralDescriptor$8(member, env) {
  const { slot } = member;
  return bindSlot$8(slot, { get: getLiteral$8 });
}

function getDescriptorUsing$8(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$8], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$8.call(this)) {
            return getter.call(this[MEMORY$8], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$8], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$8.call(this)) {
            return setter.call(this[MEMORY$8], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$8], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$8.call(this)) {
            return getter.call(this[MEMORY$8], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$8(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$8], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$8.call(this)) {
            return setter.call(this[MEMORY$8], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$8(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$8() {
  useVoid$8();
  useNull$8();
  useUndefined$8();
  useBool$8();
  useInt$8();
  useUint$8();
  useFloat$8();
  useObject$8();
  useType$8();
  useComptime$8();
  useStatic$8();
  useLiteral$8();
}

process.cwd();

useAllMemberTypes$8();
useAllStructureTypes$8();
useAllExtendedTypes$8();

const MEMORY$7 = Symbol('memory');
const SLOTS$7 = Symbol('slots');
const PARENT$7 = Symbol('parent');
const NAME$7 = Symbol('name');
const TAG$7 = Symbol('tag');
const ITEMS$7 = Symbol('items');
const PROPS$7 = Symbol('props');
const GETTER$7 = Symbol('getter');
const SETTER$7 = Symbol('setter');
const ELEMENT_GETTER$7 = Symbol('elementGetter');
const ELEMENT_SETTER$7 = Symbol('elementSetter');
const LOCATION_GETTER$7 = Symbol('addressGetter');
const LOCATION_SETTER$7 = Symbol('addressSetter');
const TARGET_GETTER$7 = Symbol('targetGetter');
const TARGET_SETTER$7 = Symbol('targetSetter');
const FIXED_LOCATION$7 = Symbol('fixedLocation');
const PROP_GETTERS$7 = Symbol('propGetters');
const PROP_SETTERS$7 = Symbol('propSetters');
const ALL_KEYS$7 = Symbol('allKeys');
const LENGTH$7 = Symbol('length');
const PROXY$7 = Symbol('proxy');
const COMPAT$7 = Symbol('compat');
const SIZE$7 = Symbol('size');
const ALIGN$7 = Symbol('align');
const ARRAY$7 = Symbol('array');
const POINTER$7 = Symbol('pointer');
const CONST$7 = Symbol('const');
const CONST_PROTOTYPE$7 = Symbol('constProto');
const COPIER$7 = Symbol('copier');
const RESETTER$7 = Symbol('resetter');
const NORMALIZER$7 = Symbol('normalizer');
const VIVIFICATOR$7 = Symbol('vivificator');
const POINTER_VISITOR$7 = Symbol('pointerVisitor');
const ENVIRONMENT$7 = Symbol('environment');
const MORE$7 = Symbol('more');

function getDestructor$7(env) {
  return function() {
    const dv = this[MEMORY$7];
    this[MEMORY$7] = null;
    if (this[SLOTS$7]) {
      this[SLOTS$7] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$7(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$7(size, multiple = false) {
  const copy = getCopyFunction$7(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$7.call(this);
    restoreMemory$7.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$7];
    const dest = this[MEMORY$7];
    copy(dest, src);
  };
}

function getCopyFunction$7(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$7[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$7;
  if (!(size & 0x03)) return copy4x$7;
  if (!(size & 0x01)) return copy2x$7;
  return copy1x$7;
}

const copiers$7 = {
  1: copy1$7,
  2: copy2$7,
  4: copy4$7,
  8: copy8$7,
  16: copy16$7,
  32: copy32$7,
};

function copy1x$7(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$7(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$7(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$7(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$7(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$7(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$7(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$7(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$7(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$7(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$7(offset, size) {
  const reset = getResetFunction$7(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$7.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$7];
    reset(dest, offset, size);
  };
}

function getResetFunction$7(size) {
  const resetter = resetters$7[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$7;
  if (!(size & 0x03)) return reset4x$7;
  if (!(size & 0x01)) return reset2x$7;
  return reset1x$7;
}

const resetters$7 = {
  1: reset1$7,
  2: reset2$7,
  4: reset4$7,
  8: reset8$7,
  16: reset16$7,
  32: reset32$7,
};

function reset1x$7(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$7(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$7(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$7(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$7(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$7(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$7(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$7(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$7(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$7(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$7() {
  const dv = this[MEMORY$7];
  const source = dv[MEMORY$7];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$7] = source;
  this[MEMORY$7] = newDV;
  return true;
}

const decoders$7 = {};
const encoders$7 = {};

function decodeText$7(arrays, encoding = 'utf-8') {
  let decoder = decoders$7[encoding];
  if (!decoder) {
    decoder = decoders$7[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$7(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$7[encoding];
      if (!encoder) {
        encoder = encoders$7[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$7(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$7(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$7() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$7];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$7 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$7 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$7() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$7];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$7 <= value && value <= INT_MAX$7) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$7(cb, options) {
  const value = handleError$7(() => this.$, options);
  return cb(value);
}

function handleError$7(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$7(structure, handlers = {}) {
  return markAsSpecial$7({
    get() {
      /* WASM-ONLY */
      restoreMemory$7.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$7];
    },
    set(dv) {
      checkDataView$7(dv);
      setDataView$7.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$7(structure, handlers = {}) {
  return markAsSpecial$7({
    get() {
      return encodeBase64$7(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$7('string', str);
      }
      const dv = decodeBase64$7(str);
      setDataView$7.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$7(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$7({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$7(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$7('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$7(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$7.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$7(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$7({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$7(ta, typedArray)) {
        throwTypeMismatch$7(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$7.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$7({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$7.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$7.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$7({
    type: MemberType$7.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$7({
    type: MemberType$7.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$7];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$7]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$7]);
        const target = Target.call(ENVIRONMENT$7, dv, { writable: !isConst });
        this[SLOTS$7][0] = target;
        this[FIXED_LOCATION$7] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$7][0] ?? throwNullPointer$7();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$7]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$7] = loc;
      } else {
        throwFixedMemoryTargetRequired$7();
      }
    }
    this[SLOTS$7][0] = arg;
  };
  const getTarget = isValueExpected$7(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$7]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$7][0] ?? throwNullPointer$7();
    return object[SETTER$7](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$7 || this === PARENT$7) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$7(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$7();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$f;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$7, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$7(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$7(structure, arg);
      }
      arg = arg[SLOTS$7][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$7.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$7]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$7]) {
        throwReadOnlyTarget$7(structure);       
      }
    } else if (isCompatible$7(arg, Target)) {
      // autocast to target type
      const dv = getDataView$7(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$7]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$7(arg?.buffer)) {
          warnImplicitArrayCreation$7(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$7(structure, arg);
    }
    this[TARGET_SETTER$7](arg);
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$7, set: initializer },
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [TARGET_GETTER$7]: { value: getTargetObject },
    [TARGET_SETTER$7]: { value: setTargetObject },
    [LOCATION_GETTER$7]: { value: addressGetter },
    [LOCATION_SETTER$7]: { value: addressSetter },
    [POINTER_VISITOR$7]: { value: visitPointer$7 },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [VIVIFICATOR$7]: { value: throwNullPointer$7 },
    [NORMALIZER$7]: { value: normalizePointer$7 },
    [FIXED_LOCATION$7]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$7(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$7() {
  return this[PROXY$7];
}

function copyPointer$7({ source }) {
  const target = source[SLOTS$7][0];
  if (target) {
    this[TARGET_SETTER$7](target);
  }
}

function resetPointer$7({ isActive }) {
  if (this[SLOTS$7][0] && !isActive(this)) {
    this[SLOTS$7][0] = undefined;
  }
}

function disablePointer$7() {
  const disabledProp = { get: throwInaccessiblePointer$7, set: throwInaccessiblePointer$7 };
  const disabledFunc = { value: throwInaccessiblePointer$7 };
  defineProperties$7(this[POINTER$7], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$7]: disabledFunc,
    [SETTER$7]: disabledFunc,
    [TARGET_GETTER$7]: disabledFunc,
  });
}

function visitPointer$7(fn, options = {}) {
  const {
    source,
    isActive = always$7,
    isMutable = always$7,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$7(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$f = {
  get(pointer, name) {
    if (name === POINTER$7) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$7]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$7]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$7]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$7]();
      return name in target;
    }
  },
};

function always$7() {
  return true;
}

function never$7() {
  return false;
}

function defineStructShape$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$7(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$7.Object);
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$7](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$7(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$7, set: initializer },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$7 },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$f(structure) },
    [POINTER_VISITOR$7]: hasPointer && { value: getPointerVisitor$f(structure, always$7) },
    [NORMALIZER$7]: { value: normalizeStruct$7 },
    [PROPS$7]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$7(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$7.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$7(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$7.bind(this, options),
    length: this[PROPS$7].length,
  };
}

function getStructIterator$7(options) { 
  const entries = getStructEntries$7.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$7(options) {
  const self = this;
  const props = this[PROPS$7];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$7(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$f(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$7.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$7];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$7(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$7][slot] = constructor.call(PARENT$7, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$f(structure, visitorOptions = {}) {
  const {
    isChildActive = always$7,
    isChildMutable = always$7,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$7,
      isMutable = always$7,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$7]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$7][slot] ?? (vivificate ? this[VIVIFICATOR$7](slot) : null);
      if (child) {
        child[POINTER_VISITOR$7](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$7.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$7] = dv;
    if (hasObject) {
      this[SLOTS$7] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$7(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$7(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$7(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$7(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$f(structure) },
    [POINTER_VISITOR$7]: hasPointer && { value: getPointerVisitor$f(structure, { isChildMutable }) },
  });
  defineProperties$7(constructor, {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  });
  return constructor;
}

function defineArray$7(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$7(member, env);
  const hasStringProp = canBeString$7(member);
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$7](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$7(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$7(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$7(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$7(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$7;
  const constructor = structure.constructor = createConstructor$7(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$7(member);
  const hasObject = member.type === MemberType$7.Object;
  const instanceDescriptors = {
    $: { get: getProxy$7, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    string: hasStringProp && getStringDescriptor$7(structure),
    typedArray: typedArray && getTypedArrayDescriptor$7(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$7 },
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [Symbol.iterator]: { value: getArrayIterator$7 },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$e(structure) },
    [POINTER_VISITOR$7]: hasPointer && { value: getPointerVisitor$e() },
    [NORMALIZER$7]: { value: normalizeArray$7 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$7]: { value: getCompatibleTags$7(structure) },
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$7() {
  const proxy = new Proxy(this, proxyHandlers$e);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$7, { value: proxy }); 
  return proxy;
}

function canBeString$7(member) {
  return member.type === MemberType$7.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$7(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$7.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$7() {
  const self = this[ARRAY$7] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$7(options) {
  const self = this[ARRAY$7] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$7(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$7(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$7.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$e(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$7];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$7][index] = constructor.call(PARENT$7, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$e(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$7,
      isMutable = always$7,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$7][i];
      }
      const child = this[SLOTS$7][i] ?? (vivificate ? this[VIVIFICATOR$7](i) : null);
      if (child) {
        child[POINTER_VISITOR$7](cb, childOptions);
      }
    }
  };
}

function transformIterable$7(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$e = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$7]) {
            array[ELEMENT_GETTER$7] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$7];
        case 'set':
          if (!array[ELEMENT_SETTER$7]) {
            array[ELEMENT_SETTER$7] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$7];
        case ARRAY$7:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$7] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$7] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$7];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$7];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$7);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$7(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$7(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$7({ ...member, type: MemberType$7.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$7(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$7];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$7] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$7(item, { [NAME$7]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$7] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$7];
    } else if (!getDataView$7(structure, arg, env)) {
      throwInvalidInitializer$7(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$7(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$7] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    typedArray: typedArray && getTypedArrayDescriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [NORMALIZER$7]: { value: normalizeEnumerationItem$7 },
  };
  const staticDescriptors = {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
    [ITEMS$7]: { value: {} },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$7(cb) {
  return cb(this.$[NAME$7]);
}

function defineErrorSet$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$7(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$7({ ...member, type: MemberType$7.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$7(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$7][arg];
    } else if (!getDataView$7(structure, arg, env)) {
      throwInvalidInitializer$7(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$7.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$7(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    typedArray: typedArray && getTypedArrayDescriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [NORMALIZER$7]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
    [ITEMS$7]: { value: {} },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$7;

function getGlobalErrorSet$7() {
  return globalErrorSet$7;
}

function defineErrorUnion$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$7(members[0], env);
  const { get: getError, set: setError } = getDescriptor$7(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$7.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$7() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$7]();
    this[POINTER_VISITOR$7]?.(resetPointer$7);
  };
  const hasObject = !!members.find(m => m.type === MemberType$7.Object);
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$7](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$7(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$7(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [RESETTER$7]: { value: getMemoryResetter$7(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$f(structure) },
    [POINTER_VISITOR$7]: hasPointer && { value: getPointerVisitor$f(structure, { isChildActive }) },
    [NORMALIZER$7]: { value: normalizeValue$7 },
  };
  const staticDescriptors = {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$7(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$7(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$7(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [NORMALIZER$7]: { value: normalizeOpaque$7 },
  };
  const staticDescriptors = {
    [COMPAT$7]: { value: getCompatibleTags$7(structure) },
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$7(cb) {
  return {};
}

function defineOptional$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$7(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$7(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$7]?.(resetPointer$7);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$7.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$7](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$7]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$7]?.(resetPointer$7);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$7.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$7]: !hasPointer && { value: getMemoryResetter$7(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$f(structure) },
    [POINTER_VISITOR$7]: hasPointer && { value: getPointerVisitor$f(structure, { isChildActive }) },
    [NORMALIZER$7]: { value: normalizeValue$7 },
  };
  const staticDescriptors = {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$7(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$7(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$7(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$7(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$7] = dv;
    this[LENGTH$7] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$7]) {
      throwArrayLengthMismatch$7(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$7]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$7](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$7(arg);
      if (!this[MEMORY$7]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$7] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$7(structure, arg, !this[MEMORY$7]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$7(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$7(structure, arg);
    }
  };
  const finalizer = createArrayProxy$7;
  const constructor = structure.constructor = createConstructor$7(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$7(member);
  const hasObject = member.type === MemberType$7.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$7, set: initializer },
    length: { get: getLength$7 },
    dataView: getDataViewDescriptor$7(structure, shapeHandlers),
    base64: getBase64Descriptor$7(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$7(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$7(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$7 },
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [Symbol.iterator]: { value: getArrayIterator$7 },
    [COPIER$7]: { value: getMemoryCopier$7(elementSize, true) },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$e(structure) },
    [POINTER_VISITOR$7]: hasPointer && { value: getPointerVisitor$e() },
    [NORMALIZER$7]: { value: normalizeArray$7 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$7]: { value: getCompatibleTags$7(structure) },
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: elementSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$7() {
  return this[LENGTH$7];
}

function getSentinel$7(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$7(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$7(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$7(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$7(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$7(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$7(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$7(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$7].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$7(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$7];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$7(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$7.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$7.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$7(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$7];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$7(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$7(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$7]?.(resetPointer$7);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$7(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$7]?.(resetPointer$7);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$7](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$7(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$7(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$7(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$7](disablePointer$7, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$7(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$7;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$7.Object);
  const instanceDescriptors = {
    $: { get: getSelf$7, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$7 },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [TAG$7]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$7]: hasObject && { value: getChildVivificator$f(structure) },
    [POINTER_VISITOR$7]: hasAnyPointer && { value: getPointerVisitor$f(structure, { isChildActive }) },
    [PROP_GETTERS$7]: { value: memberValueGetters },
    [NORMALIZER$7]: { value: normalizeUnion$7 },
    [PROPS$7]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$7];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$7(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$7.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$7(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$7.bind(this, options),
    length: this[PROPS$7].length,
  };
}

function getUnionIterator$7(options) { 
  const entries = getUnionEntries$7.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$7(options) {
  const self = this;
  const props = this[PROPS$7];
  const getters = this[PROP_GETTERS$7];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$7(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$7(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$7({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$7](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$7(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$7][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$7(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$7(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$7(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$7, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    typedArray: typedArray && getTypedArrayDescriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    entries: { value: getVectorEntries$7 },
    delete: { value: getDestructor$7(structure) },
    [Symbol.iterator]: { value: getVectorIterator$7 },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [NORMALIZER$7]: { value: normalizeVector$7 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$7]: { value: getCompatibleTags$7(structure) },
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$7(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$7.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$7() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$7() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$7() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$7.bind(this),
    length: this.length,
  };
}

const StructureType$7 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$n = Array(Object.values(StructureType$7).length);

function usePrimitive$7() {
  factories$n[StructureType$7.Primitive] = definePrimitive$7;
}

function useArray$7() {
  factories$n[StructureType$7.Array] = defineArray$7;
}

function useStruct$7() {
  factories$n[StructureType$7.Struct] = defineStructShape$7;
}

function usePackedStruct$7() {
  factories$n[StructureType$7.PackedStruct] = defineStructShape$7;
}

function useExternStruct$7() {
  factories$n[StructureType$7.ExternStruct] = defineStructShape$7;
}

function useArgStruct$7() {
  factories$n[StructureType$7.ArgStruct] = defineArgStruct$7;
}

function useExternUnion$7() {
  factories$n[StructureType$7.ExternUnion] = defineUnionShape$7;
}

function useBareUnion$7() {
  factories$n[StructureType$7.BareUnion] = defineUnionShape$7;
}

function useTaggedUnion$7() {
  factories$n[StructureType$7.TaggedUnion] = defineUnionShape$7;
}

function useErrorUnion$7() {
  factories$n[StructureType$7.ErrorUnion] = defineErrorUnion$7;
}

function useErrorSet$7() {
  factories$n[StructureType$7.ErrorSet] = defineErrorSet$7;
}

function useEnumeration$7() {
  factories$n[StructureType$7.Enumeration] = defineEnumerationShape$7;
}

function useOptional$7() {
  factories$n[StructureType$7.Optional] = defineOptional$7;
}

function usePointer$7() {
  factories$n[StructureType$7.Pointer] = definePointer$7;
}

function useSlice$7() {
  factories$n[StructureType$7.Slice] = defineSlice$7;
}

function useVector$7() {
  factories$n[StructureType$7.Vector] = defineVector$7;
}

function useOpaque$7() {
  factories$n[StructureType$7.Opaque] = defineOpaque$7;
}

function defineProperties$7(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$7 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$7, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$7]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$7(constructor.prototype, { 
    [CONST$7]: { value: false },
    [ALL_KEYS$7]: { value: Object.keys(propSetters) },
    [SETTER$7]: { value: set },
    [GETTER$7]: { value: get },
    [PROP_SETTERS$7]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$7(constructor, {
    [CONST_PROTOTYPE$7]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$7(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$7]: { value: true },
    [SETTER$7]: { value: throwReadOnly$7 },
    [VIVIFICATOR$7]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$7(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$7(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$7]) {
    const comptimeMembers = members.filter(m => isReadOnly$7(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$7();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$7(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$7] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$7]; 
      } else {
        self[MEMORY$7] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$7(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$7]);
      if (shapeDefiner) {
        setDataView$7.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$7] = dv;
      }
      if (hasSlots) {
        self[SLOTS$7] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$7](copyPointer$7, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$7][slot] = template[SLOTS$7][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$7]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$7(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$7];
    const allKeys = this[ALL_KEYS$7];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$7(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$7(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$7]) {
          this[COPIER$7](template);
        }
        this[POINTER_VISITOR$7]?.(copyPointer$7, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$7(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$7.Object:
      case MemberType$7.Comptime:
      case MemberType$7.Type:
      case MemberType$7.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$7() {
  return this;
}

function useAllStructureTypes$7() {
  usePrimitive$7();
  useArray$7();
  useStruct$7();
  useExternStruct$7();
  usePackedStruct$7();
  useArgStruct$7();
  useExternUnion$7();
  useBareUnion$7();
  useTaggedUnion$7();
  useErrorUnion$7();
  useErrorSet$7();
  useEnumeration$7();
  useOptional$7();
  usePointer$7();
  useSlice$7();
  useVector$7();
  useOpaque$7();
}

let ObjectCache$7 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$7(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$7(member, env);
  const propApplier = createPropertyApplier$7(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$7](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$7(member);
          throwInvalidInitializer$7(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$7(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$7(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$7(structure),
    base64: getBase64Descriptor$7(structure),
    typedArray: typedArray && getTypedArrayDescriptor$7(structure),
    valueOf: { value: getValueOf$7 },
    toJSON: { value: convertToJSON$7 },
    delete: { value: getDestructor$7(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$7]: { value: getMemoryCopier$7(byteSize) },
    [NORMALIZER$7]: { value: normalizeValue$7 },
  };
  const staticDescriptors = {
    [COMPAT$7]: { value: getCompatibleTags$7(structure) },
    [ALIGN$7]: { value: align },
    [SIZE$7]: { value: byteSize },
  };
  return attachDescriptors$7(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$7(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$7.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$7({ type, bitSize }) {
  if (type === MemberType$7.Int || type === MemberType$7.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$7.Float) {
    return Number;
  } else if (type === MemberType$7.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$7(member) {
  const Primitive = getPrimitiveClass$7(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$7(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$7(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$7.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$7.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$7(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$7);
  if (typedArray) {
    acceptable.push(addArticle$7(typedArray.name));
  }
  if (type === StructureType$7.Slice) {
    throw new TypeError(`Expecting ${formatList$7(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$7(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$7(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$7(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$7(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$7(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$7(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$7(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$7(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$7(type));
    }
  } else {
    acceptable.push(addArticle$7(expected));
  }
  const received = getDescription$7(arg);
  throw new TypeError(`${name} expects ${formatList$7(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$7(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$7(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$7.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$7.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$7(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$7(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$7(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$7(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$7(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$7(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$7(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$7(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$7(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$7(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$7(expected, arg) {
  const received = getDescription$7(arg);
  throw new TypeError(`Expected ${addArticle$7(expected)}, received ${received}`)
}

function throwInaccessiblePointer$7() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$7() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$7(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$7(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$7(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$7(member, value) {
  const typeName = getTypeName$7(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$7(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$7(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$7(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$7(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$7(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$7() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$7(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$7(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$7(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$7(structure, arg) {
  const created = addArticle$7(structure.typedArray.name);
  const source = addArticle$7(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$7(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$7(s);
}

function addArticle$7(noun) {
  return `${article$7(noun)} ${noun}`;
}

function article$7(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$7(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$7(access, member) {
  return cacheMethod$7(access, member, () => {
    if (isByteAligned$7(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$7({ type: MemberType$7.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$7(access, member);
    }
  });
}

function getNumericAccessor$7(access, member) {
  return cacheMethod$7(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$7(access, member);
    }
  });
}

const factories$m = {};

function useExtendedBool$7() {
  factories$m[MemberType$7.Bool] = getExtendedBoolAccessor$7;
}

function useExtendedInt$7() {
  factories$m[MemberType$7.Int] = getExtendedIntAccessor$7;
}

function useExtendedUint$7() {
  factories$m[MemberType$7.Uint] = getExtendedUintAccessor$7;
}

function useExtendedFloat$7() {
  factories$m[MemberType$7.Float] = getExtendedFloatAccessor$7;
}

function getExtendedTypeAccessor$7(access, member) {
  const f = factories$m[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$7(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$7(access, member) {
  if (isByteAligned$7(member)) {
    return getAlignedIntAccessor$7(access, member)
  } else {
    return getUnalignedIntAccessor$7(access, member);
  }
}

function getExtendedUintAccessor$7(access, member) {
  if (isByteAligned$7(member)) {
    return getAlignedUintAccessor$7(access, member)
  } else {
    return getUnalignedUintAccessor$7(access, member);
  }
}

function getExtendedFloatAccessor$7(access, member) {
  if (isByteAligned$7(member)) {
    return getAlignedFloatAccessor$7(access, member)
  } else {
    return getUnalignedFloatAccessor$7(access, member);
  }
}

function getDataView$7(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$7];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$7.Array || type === StructureType$7.Slice || type === StructureType$7.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$7(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$7.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$7(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$7(dv, structure);
  }
  return dv;
}

function checkDataView$7(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$7('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$7(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$7.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$7(structure, dv);
  }
}

function setDataView$7(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$7.Slice;
  if (!this[MEMORY$7]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$7(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$7]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$7](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$7(structure, dv, this);
    }
    const source = { [MEMORY$7]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$7](source); 
  }
}

function findElements$7(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$7(structure, arg, env) {
  const dv = getDataView$7(structure, arg, env);
  if (!dv) {
    throwBufferExpected$7(structure);
  }
  return dv;
}

function getTypedArrayClass$7(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$7.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$7.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$7.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$7.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$7(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$7(arg, constructor) {
  const tags = constructor[COMPAT$7];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$7(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$7(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$7(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$7(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$7.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$7.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$7.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$7.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$7.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$7(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$7(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$7({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$7(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$7(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$7({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$7(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$7(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$7(access, member);
}

function getUnalignedUintAccessor$7(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$7(access, member);
}

function getAlignedFloatAccessor$7(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$7(access, member) {
  return getUnalignedNumericAccessor$7(access, member);
}

function getUnalignedNumericAccessor$7(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$7('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$7(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$7('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$7(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$7 = {};

function cacheMethod$7(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$7(member);
  const suffix = isByteAligned$7(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$7.Int || type === MemberType$7.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$7[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$7(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$7[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$7() {
  useExtendedBool$7();
  useExtendedInt$7();
  useExtendedUint$7();
  useExtendedFloat$7();
}

const MemberType$7 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$7(type) {
  switch (type) {
    case MemberType$7.Type:
    case MemberType$7.Comptime:
    case MemberType$7.Literal:
      return true;
    default:
      return false;
  }
}

const factories$l = {};

function useVoid$7() {
  factories$l[MemberType$7.Void] = getVoidDescriptor$7;
}

function useBool$7() {
  factories$l[MemberType$7.Bool] = getBoolDescriptor$7;
}

function useInt$7() {
  factories$l[MemberType$7.Int] = getIntDescriptor$7;
}

function useUint$7() {
  factories$l[MemberType$7.Uint] = getUintDescriptor$7;
}

function useFloat$7() {
  factories$l[MemberType$7.Float] = getFloatDescriptor$7;
}

function useEnumerationItem$7() {
  factories$l[MemberType$7.EnumerationItem] = getEnumerationItemDescriptor$7;
}

function useError$7() {
  factories$l[MemberType$7.Error] = getErrorDescriptor$7;
}

function useObject$7() {
  factories$l[MemberType$7.Object] = getObjectDescriptor$7;
}

function useType$7() {
  factories$l[MemberType$7.Type] = getTypeDescriptor$7;
}

function useComptime$7() {
  factories$l[MemberType$7.Comptime] = getComptimeDescriptor$7;
}

function useStatic$7() {
  factories$l[MemberType$7.Static] = getStaticDescriptor$7;
}

function useLiteral$7() {
  factories$l[MemberType$7.Literal] = getLiteralDescriptor$7;
}

function useNull$7() {
  factories$l[MemberType$7.Null] = getNullDescriptor$7;
}

function useUndefined$7() {
  factories$l[MemberType$7.Undefined] = getUndefinedDescriptor$7;
}

function isByteAligned$7({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$7(member, env) {
  const f = factories$l[member.type];
  return f(member, env);
}

function getVoidDescriptor$7(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$7(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$7(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$7(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$7(member, env) {
  return getDescriptorUsing$7(member, env, getBoolAccessor$7)
}

function getIntDescriptor$7(member, env) {
  const getDataViewAccessor = addRuntimeCheck$7(env, getNumericAccessor$7);
  return getDescriptorUsing$7(member, env, getDataViewAccessor)
}

function getUintDescriptor$7(member, env) {
  const getDataViewAccessor = addRuntimeCheck$7(env, getNumericAccessor$7);
  return getDescriptorUsing$7(member, env, getDataViewAccessor)
}

function addRuntimeCheck$7(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$7(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$7(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$7(member, env) {
  return getDescriptorUsing$7(member, env, getNumericAccessor$7)
}

function getValueDescriptor$7(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$7(valueMember, env);
}

function getEnumerationItemDescriptor$7(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$7(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$7(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$7(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$7(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$7();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$7(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$7(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$7(structure) {
  switch (structure.type) {
    case StructureType$7.Primitive:
    case StructureType$7.ErrorUnion:
    case StructureType$7.Optional:
    case StructureType$7.Enumeration:
    case StructureType$7.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$7(slot) {
  const object = this[SLOTS$7][slot] ?? this[VIVIFICATOR$7](slot);
  return object[GETTER$7]();
}

function getObject$7(slot) {
  const object = this[SLOTS$7][slot] ?? this[VIVIFICATOR$7](slot);
  return object;
}

function setValue$7(slot, value) {
  const object = this[SLOTS$7][slot] ?? this[VIVIFICATOR$7](slot);
  object[SETTER$7](value);
}

function bindSlot$7(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$7(member, env) {
  const { structure, slot } = member;
  return bindSlot$7(slot, {
    get: isValueExpected$7(structure) ? getValue$7 : getObject$7,
    set: setValue$7,
  });
}

function getType$7(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$7][slot];
  return structure?.constructor;
}

function getTypeDescriptor$7(member, env) {
  const { slot } = member;
  return bindSlot$7(slot, { get: getType$7 });
}

function getComptimeDescriptor$7(member, env) {
  const { slot, structure } = member;
  return bindSlot$7(slot, {
    get: isValueExpected$7(structure) ? getValue$7 : getObject$7,
  });
}

function getStaticDescriptor$7(member, env) {
  const { slot, structure } = member;
  return bindSlot$7(slot, {
    get: isValueExpected$7(structure) ? getValue$7 : getObject$7,
    set: setValue$7,
  });
}

function getLiteral$7(slot) {
  const object = this[SLOTS$7][slot];
  return object.string;
}

function getLiteralDescriptor$7(member, env) {
  const { slot } = member;
  return bindSlot$7(slot, { get: getLiteral$7 });
}

function getDescriptorUsing$7(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$7], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$7.call(this)) {
            return getter.call(this[MEMORY$7], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$7], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$7.call(this)) {
            return setter.call(this[MEMORY$7], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$7], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$7.call(this)) {
            return getter.call(this[MEMORY$7], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$7(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$7], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$7.call(this)) {
            return setter.call(this[MEMORY$7], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$7(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$7() {
  useVoid$7();
  useNull$7();
  useUndefined$7();
  useBool$7();
  useInt$7();
  useUint$7();
  useFloat$7();
  useEnumerationItem$7();
  useError$7();
  useObject$7();
  useType$7();
  useComptime$7();
  useStatic$7();
  useLiteral$7();
}

process.cwd();

useAllMemberTypes$7();
useAllStructureTypes$7();
useAllExtendedTypes$7();

const MEMORY$6 = Symbol('memory');
const SLOTS$6 = Symbol('slots');
const PARENT$6 = Symbol('parent');
const NAME$6 = Symbol('name');
const TAG$6 = Symbol('tag');
const ITEMS$6 = Symbol('items');
const PROPS$6 = Symbol('props');
const GETTER$6 = Symbol('getter');
const SETTER$6 = Symbol('setter');
const ELEMENT_GETTER$6 = Symbol('elementGetter');
const ELEMENT_SETTER$6 = Symbol('elementSetter');
const LOCATION_GETTER$6 = Symbol('addressGetter');
const LOCATION_SETTER$6 = Symbol('addressSetter');
const TARGET_GETTER$6 = Symbol('targetGetter');
const TARGET_SETTER$6 = Symbol('targetSetter');
const FIXED_LOCATION$6 = Symbol('fixedLocation');
const PROP_GETTERS$6 = Symbol('propGetters');
const PROP_SETTERS$6 = Symbol('propSetters');
const ALL_KEYS$6 = Symbol('allKeys');
const LENGTH$6 = Symbol('length');
const PROXY$6 = Symbol('proxy');
const COMPAT$6 = Symbol('compat');
const SIZE$6 = Symbol('size');
const ALIGN$6 = Symbol('align');
const ARRAY$6 = Symbol('array');
const POINTER$6 = Symbol('pointer');
const CONST$6 = Symbol('const');
const CONST_PROTOTYPE$6 = Symbol('constProto');
const COPIER$6 = Symbol('copier');
const RESETTER$6 = Symbol('resetter');
const NORMALIZER$6 = Symbol('normalizer');
const VIVIFICATOR$6 = Symbol('vivificator');
const POINTER_VISITOR$6 = Symbol('pointerVisitor');
const ENVIRONMENT$6 = Symbol('environment');
const MORE$6 = Symbol('more');

function getDestructor$6(env) {
  return function() {
    const dv = this[MEMORY$6];
    this[MEMORY$6] = null;
    if (this[SLOTS$6]) {
      this[SLOTS$6] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$6(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$6(size, multiple = false) {
  const copy = getCopyFunction$6(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$6.call(this);
    restoreMemory$6.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$6];
    const dest = this[MEMORY$6];
    copy(dest, src);
  };
}

function getCopyFunction$6(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$6[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$6;
  if (!(size & 0x03)) return copy4x$6;
  if (!(size & 0x01)) return copy2x$6;
  return copy1x$6;
}

const copiers$6 = {
  1: copy1$6,
  2: copy2$6,
  4: copy4$6,
  8: copy8$6,
  16: copy16$6,
  32: copy32$6,
};

function copy1x$6(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$6(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$6(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$6(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$6(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$6(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$6(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$6(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$6(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$6(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$6(offset, size) {
  const reset = getResetFunction$6(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$6.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$6];
    reset(dest, offset, size);
  };
}

function getResetFunction$6(size) {
  const resetter = resetters$6[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$6;
  if (!(size & 0x03)) return reset4x$6;
  if (!(size & 0x01)) return reset2x$6;
  return reset1x$6;
}

const resetters$6 = {
  1: reset1$6,
  2: reset2$6,
  4: reset4$6,
  8: reset8$6,
  16: reset16$6,
  32: reset32$6,
};

function reset1x$6(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$6(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$6(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$6(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$6(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$6(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$6(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$6(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$6(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$6(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$6() {
  const dv = this[MEMORY$6];
  const source = dv[MEMORY$6];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$6] = source;
  this[MEMORY$6] = newDV;
  return true;
}

const decoders$6 = {};
const encoders$6 = {};

function decodeText$6(arrays, encoding = 'utf-8') {
  let decoder = decoders$6[encoding];
  if (!decoder) {
    decoder = decoders$6[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$6(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$6[encoding];
      if (!encoder) {
        encoder = encoders$6[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$6(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$6(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$6() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$6];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$6 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$6 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$6() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$6];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$6 <= value && value <= INT_MAX$6) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$6(cb, options) {
  const value = handleError$6(() => this.$, options);
  return cb(value);
}

function handleError$6(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$6(structure, handlers = {}) {
  return markAsSpecial$6({
    get() {
      /* WASM-ONLY */
      restoreMemory$6.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$6];
    },
    set(dv) {
      checkDataView$6(dv);
      setDataView$6.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$6(structure, handlers = {}) {
  return markAsSpecial$6({
    get() {
      return encodeBase64$6(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$6('string', str);
      }
      const dv = decodeBase64$6(str);
      setDataView$6.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$6(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$6({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$6(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$6('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$6(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$6.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$6(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$6({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$6(ta, typedArray)) {
        throwTypeMismatch$6(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$6.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$6({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$6.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$6.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$6({
    type: MemberType$6.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$6({
    type: MemberType$6.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$6];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$6]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$6]);
        const target = Target.call(ENVIRONMENT$6, dv, { writable: !isConst });
        this[SLOTS$6][0] = target;
        this[FIXED_LOCATION$6] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$6][0] ?? throwNullPointer$6();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$6]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$6] = loc;
      } else {
        throwFixedMemoryTargetRequired$6();
      }
    }
    this[SLOTS$6][0] = arg;
  };
  const getTarget = isValueExpected$6(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$6]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$6][0] ?? throwNullPointer$6();
    return object[SETTER$6](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$6 || this === PARENT$6) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$6(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$6();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$d;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$6, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$6(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$6(structure, arg);
      }
      arg = arg[SLOTS$6][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$6.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$6]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$6]) {
        throwReadOnlyTarget$6(structure);       
      }
    } else if (isCompatible$6(arg, Target)) {
      // autocast to target type
      const dv = getDataView$6(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$6]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$6(arg?.buffer)) {
          warnImplicitArrayCreation$6(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$6(structure, arg);
    }
    this[TARGET_SETTER$6](arg);
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$6, set: initializer },
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [TARGET_GETTER$6]: { value: getTargetObject },
    [TARGET_SETTER$6]: { value: setTargetObject },
    [LOCATION_GETTER$6]: { value: addressGetter },
    [LOCATION_SETTER$6]: { value: addressSetter },
    [POINTER_VISITOR$6]: { value: visitPointer$6 },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [VIVIFICATOR$6]: { value: throwNullPointer$6 },
    [NORMALIZER$6]: { value: normalizePointer$6 },
    [FIXED_LOCATION$6]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$6(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$6() {
  return this[PROXY$6];
}

function copyPointer$6({ source }) {
  const target = source[SLOTS$6][0];
  if (target) {
    this[TARGET_SETTER$6](target);
  }
}

function resetPointer$6({ isActive }) {
  if (this[SLOTS$6][0] && !isActive(this)) {
    this[SLOTS$6][0] = undefined;
  }
}

function disablePointer$6() {
  const disabledProp = { get: throwInaccessiblePointer$6, set: throwInaccessiblePointer$6 };
  const disabledFunc = { value: throwInaccessiblePointer$6 };
  defineProperties$6(this[POINTER$6], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$6]: disabledFunc,
    [SETTER$6]: disabledFunc,
    [TARGET_GETTER$6]: disabledFunc,
  });
}

function visitPointer$6(fn, options = {}) {
  const {
    source,
    isActive = always$6,
    isMutable = always$6,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$6(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$d = {
  get(pointer, name) {
    if (name === POINTER$6) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$6]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$6]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$6]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$6]();
      return name in target;
    }
  },
};

function always$6() {
  return true;
}

function never$6() {
  return false;
}

function defineStructShape$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$6(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$6.Object);
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$6](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$6(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$6, set: initializer },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$6 },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$d(structure) },
    [POINTER_VISITOR$6]: hasPointer && { value: getPointerVisitor$d(structure, always$6) },
    [NORMALIZER$6]: { value: normalizeStruct$6 },
    [PROPS$6]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$6(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$6.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$6(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$6.bind(this, options),
    length: this[PROPS$6].length,
  };
}

function getStructIterator$6(options) { 
  const entries = getStructEntries$6.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$6(options) {
  const self = this;
  const props = this[PROPS$6];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$6(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$d(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$6.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$6];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$6(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$6][slot] = constructor.call(PARENT$6, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$d(structure, visitorOptions = {}) {
  const {
    isChildActive = always$6,
    isChildMutable = always$6,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$6,
      isMutable = always$6,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$6]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$6][slot] ?? (vivificate ? this[VIVIFICATOR$6](slot) : null);
      if (child) {
        child[POINTER_VISITOR$6](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$6.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$6] = dv;
    if (hasObject) {
      this[SLOTS$6] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$6(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$6(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$6(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$6(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$d(structure) },
    [POINTER_VISITOR$6]: hasPointer && { value: getPointerVisitor$d(structure, { isChildMutable }) },
  });
  defineProperties$6(constructor, {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  });
  return constructor;
}

function defineArray$6(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$6(member, env);
  const hasStringProp = canBeString$6(member);
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$6](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$6(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$6(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$6(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$6(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$6;
  const constructor = structure.constructor = createConstructor$6(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$6(member);
  const hasObject = member.type === MemberType$6.Object;
  const instanceDescriptors = {
    $: { get: getProxy$6, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    string: hasStringProp && getStringDescriptor$6(structure),
    typedArray: typedArray && getTypedArrayDescriptor$6(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$6 },
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [Symbol.iterator]: { value: getArrayIterator$6 },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$c(structure) },
    [POINTER_VISITOR$6]: hasPointer && { value: getPointerVisitor$c() },
    [NORMALIZER$6]: { value: normalizeArray$6 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$6]: { value: getCompatibleTags$6(structure) },
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$6() {
  const proxy = new Proxy(this, proxyHandlers$c);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$6, { value: proxy }); 
  return proxy;
}

function canBeString$6(member) {
  return member.type === MemberType$6.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$6(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$6.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$6() {
  const self = this[ARRAY$6] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$6(options) {
  const self = this[ARRAY$6] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$6(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$6(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$6.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$c(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$6];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$6][index] = constructor.call(PARENT$6, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$c(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$6,
      isMutable = always$6,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$6][i];
      }
      const child = this[SLOTS$6][i] ?? (vivificate ? this[VIVIFICATOR$6](i) : null);
      if (child) {
        child[POINTER_VISITOR$6](cb, childOptions);
      }
    }
  };
}

function transformIterable$6(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$c = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$6]) {
            array[ELEMENT_GETTER$6] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$6];
        case 'set':
          if (!array[ELEMENT_SETTER$6]) {
            array[ELEMENT_SETTER$6] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$6];
        case ARRAY$6:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$6] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$6] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$6];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$6];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$6);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$6(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$6(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$6({ ...member, type: MemberType$6.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$6(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$6];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$6] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$6(item, { [NAME$6]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$6] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$6];
    } else if (!getDataView$6(structure, arg, env)) {
      throwInvalidInitializer$6(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$6(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$6] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    typedArray: typedArray && getTypedArrayDescriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [NORMALIZER$6]: { value: normalizeEnumerationItem$6 },
  };
  const staticDescriptors = {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
    [ITEMS$6]: { value: {} },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$6(cb) {
  return cb(this.$[NAME$6]);
}

function defineErrorSet$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$6(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$6({ ...member, type: MemberType$6.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$6(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$6][arg];
    } else if (!getDataView$6(structure, arg, env)) {
      throwInvalidInitializer$6(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$6.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$6(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    typedArray: typedArray && getTypedArrayDescriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [NORMALIZER$6]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
    [ITEMS$6]: { value: {} },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$6;

function getGlobalErrorSet$6() {
  return globalErrorSet$6;
}

function defineErrorUnion$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$6(members[0], env);
  const { get: getError, set: setError } = getDescriptor$6(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$6.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$6() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$6]();
    this[POINTER_VISITOR$6]?.(resetPointer$6);
  };
  const hasObject = !!members.find(m => m.type === MemberType$6.Object);
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$6](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$6(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$6(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [RESETTER$6]: { value: getMemoryResetter$6(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$d(structure) },
    [POINTER_VISITOR$6]: hasPointer && { value: getPointerVisitor$d(structure, { isChildActive }) },
    [NORMALIZER$6]: { value: normalizeValue$6 },
  };
  const staticDescriptors = {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$6(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$6(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$6(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [NORMALIZER$6]: { value: normalizeOpaque$6 },
  };
  const staticDescriptors = {
    [COMPAT$6]: { value: getCompatibleTags$6(structure) },
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$6(cb) {
  return {};
}

function defineOptional$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$6(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$6(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$6]?.(resetPointer$6);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$6.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$6](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$6]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$6]?.(resetPointer$6);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$6.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$6]: !hasPointer && { value: getMemoryResetter$6(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$d(structure) },
    [POINTER_VISITOR$6]: hasPointer && { value: getPointerVisitor$d(structure, { isChildActive }) },
    [NORMALIZER$6]: { value: normalizeValue$6 },
  };
  const staticDescriptors = {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$6(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$6(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$6(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$6(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$6] = dv;
    this[LENGTH$6] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$6]) {
      throwArrayLengthMismatch$6(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$6]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$6](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$6(arg);
      if (!this[MEMORY$6]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$6] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$6(structure, arg, !this[MEMORY$6]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$6(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$6(structure, arg);
    }
  };
  const finalizer = createArrayProxy$6;
  const constructor = structure.constructor = createConstructor$6(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$6(member);
  const hasObject = member.type === MemberType$6.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$6, set: initializer },
    length: { get: getLength$6 },
    dataView: getDataViewDescriptor$6(structure, shapeHandlers),
    base64: getBase64Descriptor$6(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$6(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$6(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$6 },
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [Symbol.iterator]: { value: getArrayIterator$6 },
    [COPIER$6]: { value: getMemoryCopier$6(elementSize, true) },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$c(structure) },
    [POINTER_VISITOR$6]: hasPointer && { value: getPointerVisitor$c() },
    [NORMALIZER$6]: { value: normalizeArray$6 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$6]: { value: getCompatibleTags$6(structure) },
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: elementSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$6() {
  return this[LENGTH$6];
}

function getSentinel$6(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$6(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$6(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$6(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$6(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$6(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$6(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$6(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$6].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$6(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$6];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$6(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$6.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$6.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$6(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$6];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$6(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$6(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$6]?.(resetPointer$6);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$6(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$6]?.(resetPointer$6);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$6](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$6(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$6(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$6(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$6](disablePointer$6, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$6(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$6;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$6.Object);
  const instanceDescriptors = {
    $: { get: getSelf$6, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$6 },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [TAG$6]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$6]: hasObject && { value: getChildVivificator$d(structure) },
    [POINTER_VISITOR$6]: hasAnyPointer && { value: getPointerVisitor$d(structure, { isChildActive }) },
    [PROP_GETTERS$6]: { value: memberValueGetters },
    [NORMALIZER$6]: { value: normalizeUnion$6 },
    [PROPS$6]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$6];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$6(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$6.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$6(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$6.bind(this, options),
    length: this[PROPS$6].length,
  };
}

function getUnionIterator$6(options) { 
  const entries = getUnionEntries$6.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$6(options) {
  const self = this;
  const props = this[PROPS$6];
  const getters = this[PROP_GETTERS$6];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$6(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$6(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$6({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$6](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$6(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$6][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$6(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$6(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$6(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$6, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    typedArray: typedArray && getTypedArrayDescriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    entries: { value: getVectorEntries$6 },
    delete: { value: getDestructor$6(structure) },
    [Symbol.iterator]: { value: getVectorIterator$6 },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [NORMALIZER$6]: { value: normalizeVector$6 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$6]: { value: getCompatibleTags$6(structure) },
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$6(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$6.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$6() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$6() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$6() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$6.bind(this),
    length: this.length,
  };
}

const StructureType$6 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$k = Array(Object.values(StructureType$6).length);

function usePrimitive$6() {
  factories$k[StructureType$6.Primitive] = definePrimitive$6;
}

function useArray$6() {
  factories$k[StructureType$6.Array] = defineArray$6;
}

function useStruct$6() {
  factories$k[StructureType$6.Struct] = defineStructShape$6;
}

function usePackedStruct$6() {
  factories$k[StructureType$6.PackedStruct] = defineStructShape$6;
}

function useExternStruct$6() {
  factories$k[StructureType$6.ExternStruct] = defineStructShape$6;
}

function useArgStruct$6() {
  factories$k[StructureType$6.ArgStruct] = defineArgStruct$6;
}

function useExternUnion$6() {
  factories$k[StructureType$6.ExternUnion] = defineUnionShape$6;
}

function useBareUnion$6() {
  factories$k[StructureType$6.BareUnion] = defineUnionShape$6;
}

function useTaggedUnion$6() {
  factories$k[StructureType$6.TaggedUnion] = defineUnionShape$6;
}

function useErrorUnion$6() {
  factories$k[StructureType$6.ErrorUnion] = defineErrorUnion$6;
}

function useErrorSet$6() {
  factories$k[StructureType$6.ErrorSet] = defineErrorSet$6;
}

function useEnumeration$6() {
  factories$k[StructureType$6.Enumeration] = defineEnumerationShape$6;
}

function useOptional$6() {
  factories$k[StructureType$6.Optional] = defineOptional$6;
}

function usePointer$6() {
  factories$k[StructureType$6.Pointer] = definePointer$6;
}

function useSlice$6() {
  factories$k[StructureType$6.Slice] = defineSlice$6;
}

function useVector$6() {
  factories$k[StructureType$6.Vector] = defineVector$6;
}

function useOpaque$6() {
  factories$k[StructureType$6.Opaque] = defineOpaque$6;
}

function defineProperties$6(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$6 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$6, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$6]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$6(constructor.prototype, { 
    [CONST$6]: { value: false },
    [ALL_KEYS$6]: { value: Object.keys(propSetters) },
    [SETTER$6]: { value: set },
    [GETTER$6]: { value: get },
    [PROP_SETTERS$6]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$6(constructor, {
    [CONST_PROTOTYPE$6]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$6(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$6]: { value: true },
    [SETTER$6]: { value: throwReadOnly$6 },
    [VIVIFICATOR$6]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$6(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$6(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$6]) {
    const comptimeMembers = members.filter(m => isReadOnly$6(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$6();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$6(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$6] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$6]; 
      } else {
        self[MEMORY$6] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$6(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$6]);
      if (shapeDefiner) {
        setDataView$6.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$6] = dv;
      }
      if (hasSlots) {
        self[SLOTS$6] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$6](copyPointer$6, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$6][slot] = template[SLOTS$6][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$6]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$6(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$6];
    const allKeys = this[ALL_KEYS$6];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$6(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$6(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$6]) {
          this[COPIER$6](template);
        }
        this[POINTER_VISITOR$6]?.(copyPointer$6, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$6(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$6.Object:
      case MemberType$6.Comptime:
      case MemberType$6.Type:
      case MemberType$6.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$6() {
  return this;
}

function useAllStructureTypes$6() {
  usePrimitive$6();
  useArray$6();
  useStruct$6();
  useExternStruct$6();
  usePackedStruct$6();
  useArgStruct$6();
  useExternUnion$6();
  useBareUnion$6();
  useTaggedUnion$6();
  useErrorUnion$6();
  useErrorSet$6();
  useEnumeration$6();
  useOptional$6();
  usePointer$6();
  useSlice$6();
  useVector$6();
  useOpaque$6();
}

let ObjectCache$6 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$6(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$6(member, env);
  const propApplier = createPropertyApplier$6(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$6](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$6(member);
          throwInvalidInitializer$6(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$6(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$6(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$6(structure),
    base64: getBase64Descriptor$6(structure),
    typedArray: typedArray && getTypedArrayDescriptor$6(structure),
    valueOf: { value: getValueOf$6 },
    toJSON: { value: convertToJSON$6 },
    delete: { value: getDestructor$6(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$6]: { value: getMemoryCopier$6(byteSize) },
    [NORMALIZER$6]: { value: normalizeValue$6 },
  };
  const staticDescriptors = {
    [COMPAT$6]: { value: getCompatibleTags$6(structure) },
    [ALIGN$6]: { value: align },
    [SIZE$6]: { value: byteSize },
  };
  return attachDescriptors$6(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$6(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$6.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$6({ type, bitSize }) {
  if (type === MemberType$6.Int || type === MemberType$6.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$6.Float) {
    return Number;
  } else if (type === MemberType$6.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$6(member) {
  const Primitive = getPrimitiveClass$6(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$6(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$6(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$6.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$6.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$6(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$6);
  if (typedArray) {
    acceptable.push(addArticle$6(typedArray.name));
  }
  if (type === StructureType$6.Slice) {
    throw new TypeError(`Expecting ${formatList$6(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$6(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$6(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$6(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$6(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$6(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$6(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$6(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$6(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$6(type));
    }
  } else {
    acceptable.push(addArticle$6(expected));
  }
  const received = getDescription$6(arg);
  throw new TypeError(`${name} expects ${formatList$6(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$6(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$6(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$6.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$6.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$6(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$6(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$6(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$6(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$6(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$6(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$6(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$6(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$6(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$6(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$6(expected, arg) {
  const received = getDescription$6(arg);
  throw new TypeError(`Expected ${addArticle$6(expected)}, received ${received}`)
}

function throwInaccessiblePointer$6() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$6() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$6(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$6(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$6(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$6(member, value) {
  const typeName = getTypeName$6(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$6(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$6(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$6(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$6(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$6(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$6() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$6(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$6(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$6(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$6(structure, arg) {
  const created = addArticle$6(structure.typedArray.name);
  const source = addArticle$6(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$6(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$6(s);
}

function addArticle$6(noun) {
  return `${article$6(noun)} ${noun}`;
}

function article$6(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$6(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$6(access, member) {
  return cacheMethod$6(access, member, () => {
    if (isByteAligned$6(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$6({ type: MemberType$6.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$6(access, member);
    }
  });
}

function getNumericAccessor$6(access, member) {
  return cacheMethod$6(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$6(access, member);
    }
  });
}

const factories$j = {};

function useExtendedBool$6() {
  factories$j[MemberType$6.Bool] = getExtendedBoolAccessor$6;
}

function useExtendedInt$6() {
  factories$j[MemberType$6.Int] = getExtendedIntAccessor$6;
}

function useExtendedUint$6() {
  factories$j[MemberType$6.Uint] = getExtendedUintAccessor$6;
}

function useExtendedFloat$6() {
  factories$j[MemberType$6.Float] = getExtendedFloatAccessor$6;
}

function getExtendedTypeAccessor$6(access, member) {
  const f = factories$j[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$6(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$6(access, member) {
  if (isByteAligned$6(member)) {
    return getAlignedIntAccessor$6(access, member)
  } else {
    return getUnalignedIntAccessor$6(access, member);
  }
}

function getExtendedUintAccessor$6(access, member) {
  if (isByteAligned$6(member)) {
    return getAlignedUintAccessor$6(access, member)
  } else {
    return getUnalignedUintAccessor$6(access, member);
  }
}

function getExtendedFloatAccessor$6(access, member) {
  if (isByteAligned$6(member)) {
    return getAlignedFloatAccessor$6(access, member)
  } else {
    return getUnalignedFloatAccessor$6(access, member);
  }
}

function getDataView$6(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$6];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$6.Array || type === StructureType$6.Slice || type === StructureType$6.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$6(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$6.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$6(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$6(dv, structure);
  }
  return dv;
}

function checkDataView$6(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$6('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$6(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$6.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$6(structure, dv);
  }
}

function setDataView$6(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$6.Slice;
  if (!this[MEMORY$6]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$6(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$6]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$6](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$6(structure, dv, this);
    }
    const source = { [MEMORY$6]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$6](source); 
  }
}

function findElements$6(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$6(structure, arg, env) {
  const dv = getDataView$6(structure, arg, env);
  if (!dv) {
    throwBufferExpected$6(structure);
  }
  return dv;
}

function getTypedArrayClass$6(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$6.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$6.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$6.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$6.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$6(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$6(arg, constructor) {
  const tags = constructor[COMPAT$6];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$6(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$6(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$6(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$6(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$6.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$6.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$6.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$6.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$6.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$6(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$6(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$6({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$6(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$6(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$6({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$6(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$6(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$6(access, member);
}

function getUnalignedUintAccessor$6(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$6(access, member);
}

function getAlignedFloatAccessor$6(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$6(access, member) {
  return getUnalignedNumericAccessor$6(access, member);
}

function getUnalignedNumericAccessor$6(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$6('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$6(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$6('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$6(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$6 = {};

function cacheMethod$6(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$6(member);
  const suffix = isByteAligned$6(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$6.Int || type === MemberType$6.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$6[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$6(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$6[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$6() {
  useExtendedBool$6();
  useExtendedInt$6();
  useExtendedUint$6();
  useExtendedFloat$6();
}

const MemberType$6 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$6(type) {
  switch (type) {
    case MemberType$6.Type:
    case MemberType$6.Comptime:
    case MemberType$6.Literal:
      return true;
    default:
      return false;
  }
}

const factories$i = {};

function useVoid$6() {
  factories$i[MemberType$6.Void] = getVoidDescriptor$6;
}

function useBool$6() {
  factories$i[MemberType$6.Bool] = getBoolDescriptor$6;
}

function useInt$6() {
  factories$i[MemberType$6.Int] = getIntDescriptor$6;
}

function useUint$6() {
  factories$i[MemberType$6.Uint] = getUintDescriptor$6;
}

function useFloat$6() {
  factories$i[MemberType$6.Float] = getFloatDescriptor$6;
}

function useEnumerationItem$6() {
  factories$i[MemberType$6.EnumerationItem] = getEnumerationItemDescriptor$6;
}

function useError$6() {
  factories$i[MemberType$6.Error] = getErrorDescriptor$6;
}

function useObject$6() {
  factories$i[MemberType$6.Object] = getObjectDescriptor$6;
}

function useType$6() {
  factories$i[MemberType$6.Type] = getTypeDescriptor$6;
}

function useComptime$6() {
  factories$i[MemberType$6.Comptime] = getComptimeDescriptor$6;
}

function useStatic$6() {
  factories$i[MemberType$6.Static] = getStaticDescriptor$6;
}

function useLiteral$6() {
  factories$i[MemberType$6.Literal] = getLiteralDescriptor$6;
}

function useNull$6() {
  factories$i[MemberType$6.Null] = getNullDescriptor$6;
}

function useUndefined$6() {
  factories$i[MemberType$6.Undefined] = getUndefinedDescriptor$6;
}

function isByteAligned$6({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$6(member, env) {
  const f = factories$i[member.type];
  return f(member, env);
}

function getVoidDescriptor$6(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$6(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$6(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$6(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$6(member, env) {
  return getDescriptorUsing$6(member, env, getBoolAccessor$6)
}

function getIntDescriptor$6(member, env) {
  const getDataViewAccessor = addRuntimeCheck$6(env, getNumericAccessor$6);
  return getDescriptorUsing$6(member, env, getDataViewAccessor)
}

function getUintDescriptor$6(member, env) {
  const getDataViewAccessor = addRuntimeCheck$6(env, getNumericAccessor$6);
  return getDescriptorUsing$6(member, env, getDataViewAccessor)
}

function addRuntimeCheck$6(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$6(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$6(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$6(member, env) {
  return getDescriptorUsing$6(member, env, getNumericAccessor$6)
}

function getValueDescriptor$6(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$6(valueMember, env);
}

function getEnumerationItemDescriptor$6(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$6(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$6(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$6(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$6(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$6();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$6(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$6(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$6(structure) {
  switch (structure.type) {
    case StructureType$6.Primitive:
    case StructureType$6.ErrorUnion:
    case StructureType$6.Optional:
    case StructureType$6.Enumeration:
    case StructureType$6.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$6(slot) {
  const object = this[SLOTS$6][slot] ?? this[VIVIFICATOR$6](slot);
  return object[GETTER$6]();
}

function getObject$6(slot) {
  const object = this[SLOTS$6][slot] ?? this[VIVIFICATOR$6](slot);
  return object;
}

function setValue$6(slot, value) {
  const object = this[SLOTS$6][slot] ?? this[VIVIFICATOR$6](slot);
  object[SETTER$6](value);
}

function bindSlot$6(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$6(member, env) {
  const { structure, slot } = member;
  return bindSlot$6(slot, {
    get: isValueExpected$6(structure) ? getValue$6 : getObject$6,
    set: setValue$6,
  });
}

function getType$6(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$6][slot];
  return structure?.constructor;
}

function getTypeDescriptor$6(member, env) {
  const { slot } = member;
  return bindSlot$6(slot, { get: getType$6 });
}

function getComptimeDescriptor$6(member, env) {
  const { slot, structure } = member;
  return bindSlot$6(slot, {
    get: isValueExpected$6(structure) ? getValue$6 : getObject$6,
  });
}

function getStaticDescriptor$6(member, env) {
  const { slot, structure } = member;
  return bindSlot$6(slot, {
    get: isValueExpected$6(structure) ? getValue$6 : getObject$6,
    set: setValue$6,
  });
}

function getLiteral$6(slot) {
  const object = this[SLOTS$6][slot];
  return object.string;
}

function getLiteralDescriptor$6(member, env) {
  const { slot } = member;
  return bindSlot$6(slot, { get: getLiteral$6 });
}

function getDescriptorUsing$6(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$6], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$6.call(this)) {
            return getter.call(this[MEMORY$6], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$6], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$6.call(this)) {
            return setter.call(this[MEMORY$6], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$6], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$6.call(this)) {
            return getter.call(this[MEMORY$6], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$6(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$6], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$6.call(this)) {
            return setter.call(this[MEMORY$6], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$6(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$6() {
  useVoid$6();
  useNull$6();
  useUndefined$6();
  useBool$6();
  useInt$6();
  useUint$6();
  useFloat$6();
  useEnumerationItem$6();
  useError$6();
  useObject$6();
  useType$6();
  useComptime$6();
  useStatic$6();
  useLiteral$6();
}

process.cwd();

useAllMemberTypes$6();
useAllStructureTypes$6();
useAllExtendedTypes$6();

const MEMORY$5 = Symbol('memory');
const SLOTS$5 = Symbol('slots');
const PARENT$5 = Symbol('parent');
const NAME$5 = Symbol('name');
const TAG$5 = Symbol('tag');
const ITEMS$5 = Symbol('items');
const PROPS$5 = Symbol('props');
const GETTER$5 = Symbol('getter');
const SETTER$5 = Symbol('setter');
const ELEMENT_GETTER$5 = Symbol('elementGetter');
const ELEMENT_SETTER$5 = Symbol('elementSetter');
const LOCATION_GETTER$5 = Symbol('addressGetter');
const LOCATION_SETTER$5 = Symbol('addressSetter');
const TARGET_GETTER$5 = Symbol('targetGetter');
const TARGET_SETTER$5 = Symbol('targetSetter');
const FIXED_LOCATION$5 = Symbol('fixedLocation');
const PROP_GETTERS$5 = Symbol('propGetters');
const PROP_SETTERS$5 = Symbol('propSetters');
const ALL_KEYS$5 = Symbol('allKeys');
const LENGTH$5 = Symbol('length');
const PROXY$5 = Symbol('proxy');
const COMPAT$5 = Symbol('compat');
const SIZE$5 = Symbol('size');
const ALIGN$5 = Symbol('align');
const ARRAY$5 = Symbol('array');
const POINTER$5 = Symbol('pointer');
const CONST$5 = Symbol('const');
const CONST_PROTOTYPE$5 = Symbol('constProto');
const COPIER$5 = Symbol('copier');
const RESETTER$5 = Symbol('resetter');
const NORMALIZER$5 = Symbol('normalizer');
const VIVIFICATOR$5 = Symbol('vivificator');
const POINTER_VISITOR$5 = Symbol('pointerVisitor');
const ENVIRONMENT$5 = Symbol('environment');
const MORE$5 = Symbol('more');

function getDestructor$5(env) {
  return function() {
    const dv = this[MEMORY$5];
    this[MEMORY$5] = null;
    if (this[SLOTS$5]) {
      this[SLOTS$5] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$5(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$5(size, multiple = false) {
  const copy = getCopyFunction$5(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$5.call(this);
    restoreMemory$5.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$5];
    const dest = this[MEMORY$5];
    copy(dest, src);
  };
}

function getCopyFunction$5(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$5[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$5;
  if (!(size & 0x03)) return copy4x$5;
  if (!(size & 0x01)) return copy2x$5;
  return copy1x$5;
}

const copiers$5 = {
  1: copy1$5,
  2: copy2$5,
  4: copy4$5,
  8: copy8$5,
  16: copy16$5,
  32: copy32$5,
};

function copy1x$5(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$5(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$5(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$5(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$5(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$5(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$5(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$5(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$5(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$5(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$5(offset, size) {
  const reset = getResetFunction$5(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$5.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$5];
    reset(dest, offset, size);
  };
}

function getResetFunction$5(size) {
  const resetter = resetters$5[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$5;
  if (!(size & 0x03)) return reset4x$5;
  if (!(size & 0x01)) return reset2x$5;
  return reset1x$5;
}

const resetters$5 = {
  1: reset1$5,
  2: reset2$5,
  4: reset4$5,
  8: reset8$5,
  16: reset16$5,
  32: reset32$5,
};

function reset1x$5(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$5(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$5(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$5(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$5(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$5(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$5(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$5(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$5(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$5(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$5() {
  const dv = this[MEMORY$5];
  const source = dv[MEMORY$5];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$5] = source;
  this[MEMORY$5] = newDV;
  return true;
}

const decoders$5 = {};
const encoders$5 = {};

function decodeText$5(arrays, encoding = 'utf-8') {
  let decoder = decoders$5[encoding];
  if (!decoder) {
    decoder = decoders$5[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$5(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$5[encoding];
      if (!encoder) {
        encoder = encoders$5[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$5(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$5(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$5() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$5];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$5 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$5 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$5() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$5];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$5 <= value && value <= INT_MAX$5) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$5(cb, options) {
  const value = handleError$5(() => this.$, options);
  return cb(value);
}

function handleError$5(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$5(structure, handlers = {}) {
  return markAsSpecial$5({
    get() {
      /* WASM-ONLY */
      restoreMemory$5.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$5];
    },
    set(dv) {
      checkDataView$5(dv);
      setDataView$5.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$5(structure, handlers = {}) {
  return markAsSpecial$5({
    get() {
      return encodeBase64$5(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$5('string', str);
      }
      const dv = decodeBase64$5(str);
      setDataView$5.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$5(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$5({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$5(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$5('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$5(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$5.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$5(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$5({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$5(ta, typedArray)) {
        throwTypeMismatch$5(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$5.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$5({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$5.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$5.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$5({
    type: MemberType$5.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$5({
    type: MemberType$5.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$5];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$5]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$5]);
        const target = Target.call(ENVIRONMENT$5, dv, { writable: !isConst });
        this[SLOTS$5][0] = target;
        this[FIXED_LOCATION$5] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$5][0] ?? throwNullPointer$5();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$5]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$5] = loc;
      } else {
        throwFixedMemoryTargetRequired$5();
      }
    }
    this[SLOTS$5][0] = arg;
  };
  const getTarget = isValueExpected$5(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$5]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$5][0] ?? throwNullPointer$5();
    return object[SETTER$5](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$5 || this === PARENT$5) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$5(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$5();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$b;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$5, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$5(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$5(structure, arg);
      }
      arg = arg[SLOTS$5][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$5.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$5]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$5]) {
        throwReadOnlyTarget$5(structure);       
      }
    } else if (isCompatible$5(arg, Target)) {
      // autocast to target type
      const dv = getDataView$5(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$5]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$5(arg?.buffer)) {
          warnImplicitArrayCreation$5(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$5(structure, arg);
    }
    this[TARGET_SETTER$5](arg);
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$5, set: initializer },
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [TARGET_GETTER$5]: { value: getTargetObject },
    [TARGET_SETTER$5]: { value: setTargetObject },
    [LOCATION_GETTER$5]: { value: addressGetter },
    [LOCATION_SETTER$5]: { value: addressSetter },
    [POINTER_VISITOR$5]: { value: visitPointer$5 },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [VIVIFICATOR$5]: { value: throwNullPointer$5 },
    [NORMALIZER$5]: { value: normalizePointer$5 },
    [FIXED_LOCATION$5]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$5(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$5() {
  return this[PROXY$5];
}

function copyPointer$5({ source }) {
  const target = source[SLOTS$5][0];
  if (target) {
    this[TARGET_SETTER$5](target);
  }
}

function resetPointer$5({ isActive }) {
  if (this[SLOTS$5][0] && !isActive(this)) {
    this[SLOTS$5][0] = undefined;
  }
}

function disablePointer$5() {
  const disabledProp = { get: throwInaccessiblePointer$5, set: throwInaccessiblePointer$5 };
  const disabledFunc = { value: throwInaccessiblePointer$5 };
  defineProperties$5(this[POINTER$5], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$5]: disabledFunc,
    [SETTER$5]: disabledFunc,
    [TARGET_GETTER$5]: disabledFunc,
  });
}

function visitPointer$5(fn, options = {}) {
  const {
    source,
    isActive = always$5,
    isMutable = always$5,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$5(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$b = {
  get(pointer, name) {
    if (name === POINTER$5) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$5]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$5]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$5]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$5]();
      return name in target;
    }
  },
};

function always$5() {
  return true;
}

function never$5() {
  return false;
}

function defineStructShape$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$5(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$5.Object);
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$5](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$5(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$5, set: initializer },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$5 },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$b(structure) },
    [POINTER_VISITOR$5]: hasPointer && { value: getPointerVisitor$b(structure, always$5) },
    [NORMALIZER$5]: { value: normalizeStruct$5 },
    [PROPS$5]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$5(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$5.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$5(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$5.bind(this, options),
    length: this[PROPS$5].length,
  };
}

function getStructIterator$5(options) { 
  const entries = getStructEntries$5.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$5(options) {
  const self = this;
  const props = this[PROPS$5];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$5(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$b(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$5.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$5];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$5(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$5][slot] = constructor.call(PARENT$5, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$b(structure, visitorOptions = {}) {
  const {
    isChildActive = always$5,
    isChildMutable = always$5,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$5,
      isMutable = always$5,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$5]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$5][slot] ?? (vivificate ? this[VIVIFICATOR$5](slot) : null);
      if (child) {
        child[POINTER_VISITOR$5](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$5.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$5] = dv;
    if (hasObject) {
      this[SLOTS$5] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$5(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$5(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$5(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$5(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$b(structure) },
    [POINTER_VISITOR$5]: hasPointer && { value: getPointerVisitor$b(structure, { isChildMutable }) },
  });
  defineProperties$5(constructor, {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  });
  return constructor;
}

function defineArray$5(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$5(member, env);
  const hasStringProp = canBeString$5(member);
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$5](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$5(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$5(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$5(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$5(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$5;
  const constructor = structure.constructor = createConstructor$5(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$5(member);
  const hasObject = member.type === MemberType$5.Object;
  const instanceDescriptors = {
    $: { get: getProxy$5, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    string: hasStringProp && getStringDescriptor$5(structure),
    typedArray: typedArray && getTypedArrayDescriptor$5(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$5 },
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [Symbol.iterator]: { value: getArrayIterator$5 },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$a(structure) },
    [POINTER_VISITOR$5]: hasPointer && { value: getPointerVisitor$a() },
    [NORMALIZER$5]: { value: normalizeArray$5 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$5]: { value: getCompatibleTags$5(structure) },
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$5() {
  const proxy = new Proxy(this, proxyHandlers$a);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$5, { value: proxy }); 
  return proxy;
}

function canBeString$5(member) {
  return member.type === MemberType$5.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$5(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$5.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$5() {
  const self = this[ARRAY$5] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$5(options) {
  const self = this[ARRAY$5] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$5(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$5(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$5.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$a(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$5];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$5][index] = constructor.call(PARENT$5, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$a(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$5,
      isMutable = always$5,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$5][i];
      }
      const child = this[SLOTS$5][i] ?? (vivificate ? this[VIVIFICATOR$5](i) : null);
      if (child) {
        child[POINTER_VISITOR$5](cb, childOptions);
      }
    }
  };
}

function transformIterable$5(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$a = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$5]) {
            array[ELEMENT_GETTER$5] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$5];
        case 'set':
          if (!array[ELEMENT_SETTER$5]) {
            array[ELEMENT_SETTER$5] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$5];
        case ARRAY$5:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$5] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$5] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$5];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$5];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$5);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$5(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$5(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$5({ ...member, type: MemberType$5.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$5(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$5];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$5] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$5(item, { [NAME$5]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$5] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$5];
    } else if (!getDataView$5(structure, arg, env)) {
      throwInvalidInitializer$5(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$5(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$5] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    typedArray: typedArray && getTypedArrayDescriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [NORMALIZER$5]: { value: normalizeEnumerationItem$5 },
  };
  const staticDescriptors = {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
    [ITEMS$5]: { value: {} },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$5(cb) {
  return cb(this.$[NAME$5]);
}

function defineErrorSet$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$5(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$5({ ...member, type: MemberType$5.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$5(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$5][arg];
    } else if (!getDataView$5(structure, arg, env)) {
      throwInvalidInitializer$5(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$5.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$5(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    typedArray: typedArray && getTypedArrayDescriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [NORMALIZER$5]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
    [ITEMS$5]: { value: {} },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$5;

function getGlobalErrorSet$5() {
  return globalErrorSet$5;
}

function defineErrorUnion$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$5(members[0], env);
  const { get: getError, set: setError } = getDescriptor$5(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$5.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$5() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$5]();
    this[POINTER_VISITOR$5]?.(resetPointer$5);
  };
  const hasObject = !!members.find(m => m.type === MemberType$5.Object);
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$5](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$5(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$5(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [RESETTER$5]: { value: getMemoryResetter$5(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$b(structure) },
    [POINTER_VISITOR$5]: hasPointer && { value: getPointerVisitor$b(structure, { isChildActive }) },
    [NORMALIZER$5]: { value: normalizeValue$5 },
  };
  const staticDescriptors = {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$5(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$5(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$5(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [NORMALIZER$5]: { value: normalizeOpaque$5 },
  };
  const staticDescriptors = {
    [COMPAT$5]: { value: getCompatibleTags$5(structure) },
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$5(cb) {
  return {};
}

function defineOptional$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$5(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$5(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$5]?.(resetPointer$5);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$5.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$5](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$5]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$5]?.(resetPointer$5);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$5.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$5]: !hasPointer && { value: getMemoryResetter$5(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$b(structure) },
    [POINTER_VISITOR$5]: hasPointer && { value: getPointerVisitor$b(structure, { isChildActive }) },
    [NORMALIZER$5]: { value: normalizeValue$5 },
  };
  const staticDescriptors = {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$5(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$5(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$5(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$5(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$5] = dv;
    this[LENGTH$5] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$5]) {
      throwArrayLengthMismatch$5(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$5]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$5](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$5(arg);
      if (!this[MEMORY$5]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$5] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$5(structure, arg, !this[MEMORY$5]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$5(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$5(structure, arg);
    }
  };
  const finalizer = createArrayProxy$5;
  const constructor = structure.constructor = createConstructor$5(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$5(member);
  const hasObject = member.type === MemberType$5.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$5, set: initializer },
    length: { get: getLength$5 },
    dataView: getDataViewDescriptor$5(structure, shapeHandlers),
    base64: getBase64Descriptor$5(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$5(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$5(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$5 },
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [Symbol.iterator]: { value: getArrayIterator$5 },
    [COPIER$5]: { value: getMemoryCopier$5(elementSize, true) },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$a(structure) },
    [POINTER_VISITOR$5]: hasPointer && { value: getPointerVisitor$a() },
    [NORMALIZER$5]: { value: normalizeArray$5 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$5]: { value: getCompatibleTags$5(structure) },
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: elementSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$5() {
  return this[LENGTH$5];
}

function getSentinel$5(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$5(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$5(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$5(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$5(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$5(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$5(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$5(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$5].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$5(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$5];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$5(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$5.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$5.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$5(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$5];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$5(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$5(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$5]?.(resetPointer$5);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$5(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$5]?.(resetPointer$5);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$5](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$5(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$5(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$5(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$5](disablePointer$5, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$5(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$5;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$5.Object);
  const instanceDescriptors = {
    $: { get: getSelf$5, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$5 },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [TAG$5]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$5]: hasObject && { value: getChildVivificator$b(structure) },
    [POINTER_VISITOR$5]: hasAnyPointer && { value: getPointerVisitor$b(structure, { isChildActive }) },
    [PROP_GETTERS$5]: { value: memberValueGetters },
    [NORMALIZER$5]: { value: normalizeUnion$5 },
    [PROPS$5]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$5];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$5(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$5.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$5(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$5.bind(this, options),
    length: this[PROPS$5].length,
  };
}

function getUnionIterator$5(options) { 
  const entries = getUnionEntries$5.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$5(options) {
  const self = this;
  const props = this[PROPS$5];
  const getters = this[PROP_GETTERS$5];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$5(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$5(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$5({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$5](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$5(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$5][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$5(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$5(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$5(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$5, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    typedArray: typedArray && getTypedArrayDescriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    entries: { value: getVectorEntries$5 },
    delete: { value: getDestructor$5(structure) },
    [Symbol.iterator]: { value: getVectorIterator$5 },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [NORMALIZER$5]: { value: normalizeVector$5 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$5]: { value: getCompatibleTags$5(structure) },
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$5(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$5.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$5() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$5() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$5() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$5.bind(this),
    length: this.length,
  };
}

const StructureType$5 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$h = Array(Object.values(StructureType$5).length);

function usePrimitive$5() {
  factories$h[StructureType$5.Primitive] = definePrimitive$5;
}

function useArray$5() {
  factories$h[StructureType$5.Array] = defineArray$5;
}

function useStruct$5() {
  factories$h[StructureType$5.Struct] = defineStructShape$5;
}

function usePackedStruct$5() {
  factories$h[StructureType$5.PackedStruct] = defineStructShape$5;
}

function useExternStruct$5() {
  factories$h[StructureType$5.ExternStruct] = defineStructShape$5;
}

function useArgStruct$5() {
  factories$h[StructureType$5.ArgStruct] = defineArgStruct$5;
}

function useExternUnion$5() {
  factories$h[StructureType$5.ExternUnion] = defineUnionShape$5;
}

function useBareUnion$5() {
  factories$h[StructureType$5.BareUnion] = defineUnionShape$5;
}

function useTaggedUnion$5() {
  factories$h[StructureType$5.TaggedUnion] = defineUnionShape$5;
}

function useErrorUnion$5() {
  factories$h[StructureType$5.ErrorUnion] = defineErrorUnion$5;
}

function useErrorSet$5() {
  factories$h[StructureType$5.ErrorSet] = defineErrorSet$5;
}

function useEnumeration$5() {
  factories$h[StructureType$5.Enumeration] = defineEnumerationShape$5;
}

function useOptional$5() {
  factories$h[StructureType$5.Optional] = defineOptional$5;
}

function usePointer$5() {
  factories$h[StructureType$5.Pointer] = definePointer$5;
}

function useSlice$5() {
  factories$h[StructureType$5.Slice] = defineSlice$5;
}

function useVector$5() {
  factories$h[StructureType$5.Vector] = defineVector$5;
}

function useOpaque$5() {
  factories$h[StructureType$5.Opaque] = defineOpaque$5;
}

function defineProperties$5(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$5 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$5, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$5]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$5(constructor.prototype, { 
    [CONST$5]: { value: false },
    [ALL_KEYS$5]: { value: Object.keys(propSetters) },
    [SETTER$5]: { value: set },
    [GETTER$5]: { value: get },
    [PROP_SETTERS$5]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$5(constructor, {
    [CONST_PROTOTYPE$5]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$5(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$5]: { value: true },
    [SETTER$5]: { value: throwReadOnly$5 },
    [VIVIFICATOR$5]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$5(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$5(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$5]) {
    const comptimeMembers = members.filter(m => isReadOnly$5(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$5();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$5(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$5] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$5]; 
      } else {
        self[MEMORY$5] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$5(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$5]);
      if (shapeDefiner) {
        setDataView$5.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$5] = dv;
      }
      if (hasSlots) {
        self[SLOTS$5] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$5](copyPointer$5, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$5][slot] = template[SLOTS$5][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$5]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$5(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$5];
    const allKeys = this[ALL_KEYS$5];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$5(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$5(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$5]) {
          this[COPIER$5](template);
        }
        this[POINTER_VISITOR$5]?.(copyPointer$5, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$5(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$5.Object:
      case MemberType$5.Comptime:
      case MemberType$5.Type:
      case MemberType$5.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$5() {
  return this;
}

function useAllStructureTypes$5() {
  usePrimitive$5();
  useArray$5();
  useStruct$5();
  useExternStruct$5();
  usePackedStruct$5();
  useArgStruct$5();
  useExternUnion$5();
  useBareUnion$5();
  useTaggedUnion$5();
  useErrorUnion$5();
  useErrorSet$5();
  useEnumeration$5();
  useOptional$5();
  usePointer$5();
  useSlice$5();
  useVector$5();
  useOpaque$5();
}

let ObjectCache$5 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$5(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$5(member, env);
  const propApplier = createPropertyApplier$5(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$5](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$5(member);
          throwInvalidInitializer$5(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$5(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$5(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$5(structure),
    base64: getBase64Descriptor$5(structure),
    typedArray: typedArray && getTypedArrayDescriptor$5(structure),
    valueOf: { value: getValueOf$5 },
    toJSON: { value: convertToJSON$5 },
    delete: { value: getDestructor$5(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$5]: { value: getMemoryCopier$5(byteSize) },
    [NORMALIZER$5]: { value: normalizeValue$5 },
  };
  const staticDescriptors = {
    [COMPAT$5]: { value: getCompatibleTags$5(structure) },
    [ALIGN$5]: { value: align },
    [SIZE$5]: { value: byteSize },
  };
  return attachDescriptors$5(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$5(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$5.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$5({ type, bitSize }) {
  if (type === MemberType$5.Int || type === MemberType$5.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$5.Float) {
    return Number;
  } else if (type === MemberType$5.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$5(member) {
  const Primitive = getPrimitiveClass$5(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$5(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$5(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$5.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$5.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$5(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$5);
  if (typedArray) {
    acceptable.push(addArticle$5(typedArray.name));
  }
  if (type === StructureType$5.Slice) {
    throw new TypeError(`Expecting ${formatList$5(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$5(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$5(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$5(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$5(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$5(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$5(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$5(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$5(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$5(type));
    }
  } else {
    acceptable.push(addArticle$5(expected));
  }
  const received = getDescription$5(arg);
  throw new TypeError(`${name} expects ${formatList$5(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$5(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$5(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$5.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$5.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$5(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$5(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$5(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$5(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$5(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$5(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$5(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$5(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$5(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$5(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$5(expected, arg) {
  const received = getDescription$5(arg);
  throw new TypeError(`Expected ${addArticle$5(expected)}, received ${received}`)
}

function throwInaccessiblePointer$5() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$5() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$5(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$5(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$5(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$5(member, value) {
  const typeName = getTypeName$5(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$5(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$5(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$5(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$5(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$5(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$5() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$5(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$5(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$5(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$5(structure, arg) {
  const created = addArticle$5(structure.typedArray.name);
  const source = addArticle$5(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$5(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$5(s);
}

function addArticle$5(noun) {
  return `${article$5(noun)} ${noun}`;
}

function article$5(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$5(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$5(access, member) {
  return cacheMethod$5(access, member, () => {
    if (isByteAligned$5(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$5({ type: MemberType$5.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$5(access, member);
    }
  });
}

function getNumericAccessor$5(access, member) {
  return cacheMethod$5(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$5(access, member);
    }
  });
}

const factories$g = {};

function useExtendedBool$5() {
  factories$g[MemberType$5.Bool] = getExtendedBoolAccessor$5;
}

function useExtendedInt$5() {
  factories$g[MemberType$5.Int] = getExtendedIntAccessor$5;
}

function useExtendedUint$5() {
  factories$g[MemberType$5.Uint] = getExtendedUintAccessor$5;
}

function useExtendedFloat$5() {
  factories$g[MemberType$5.Float] = getExtendedFloatAccessor$5;
}

function getExtendedTypeAccessor$5(access, member) {
  const f = factories$g[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$5(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$5(access, member) {
  if (isByteAligned$5(member)) {
    return getAlignedIntAccessor$5(access, member)
  } else {
    return getUnalignedIntAccessor$5(access, member);
  }
}

function getExtendedUintAccessor$5(access, member) {
  if (isByteAligned$5(member)) {
    return getAlignedUintAccessor$5(access, member)
  } else {
    return getUnalignedUintAccessor$5(access, member);
  }
}

function getExtendedFloatAccessor$5(access, member) {
  if (isByteAligned$5(member)) {
    return getAlignedFloatAccessor$5(access, member)
  } else {
    return getUnalignedFloatAccessor$5(access, member);
  }
}

function getDataView$5(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$5];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$5.Array || type === StructureType$5.Slice || type === StructureType$5.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$5(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$5.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$5(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$5(dv, structure);
  }
  return dv;
}

function checkDataView$5(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$5('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$5(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$5.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$5(structure, dv);
  }
}

function setDataView$5(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$5.Slice;
  if (!this[MEMORY$5]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$5(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$5]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$5](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$5(structure, dv, this);
    }
    const source = { [MEMORY$5]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$5](source); 
  }
}

function findElements$5(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$5(structure, arg, env) {
  const dv = getDataView$5(structure, arg, env);
  if (!dv) {
    throwBufferExpected$5(structure);
  }
  return dv;
}

function getTypedArrayClass$5(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$5.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$5.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$5.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$5.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$5(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$5(arg, constructor) {
  const tags = constructor[COMPAT$5];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$5(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$5(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$5(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$5(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$5.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$5.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$5.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$5.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$5.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$5(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$5(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$5({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$5(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$5(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$5({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$5(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$5(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$5(access, member);
}

function getUnalignedUintAccessor$5(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$5(access, member);
}

function getAlignedFloatAccessor$5(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$5(access, member) {
  return getUnalignedNumericAccessor$5(access, member);
}

function getUnalignedNumericAccessor$5(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$5('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$5(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$5('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$5(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$5 = {};

function cacheMethod$5(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$5(member);
  const suffix = isByteAligned$5(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$5.Int || type === MemberType$5.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$5[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$5(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$5[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$5() {
  useExtendedBool$5();
  useExtendedInt$5();
  useExtendedUint$5();
  useExtendedFloat$5();
}

const MemberType$5 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$5(type) {
  switch (type) {
    case MemberType$5.Type:
    case MemberType$5.Comptime:
    case MemberType$5.Literal:
      return true;
    default:
      return false;
  }
}

const factories$f = {};

function useVoid$5() {
  factories$f[MemberType$5.Void] = getVoidDescriptor$5;
}

function useBool$5() {
  factories$f[MemberType$5.Bool] = getBoolDescriptor$5;
}

function useInt$5() {
  factories$f[MemberType$5.Int] = getIntDescriptor$5;
}

function useUint$5() {
  factories$f[MemberType$5.Uint] = getUintDescriptor$5;
}

function useFloat$5() {
  factories$f[MemberType$5.Float] = getFloatDescriptor$5;
}

function useEnumerationItem$5() {
  factories$f[MemberType$5.EnumerationItem] = getEnumerationItemDescriptor$5;
}

function useError$5() {
  factories$f[MemberType$5.Error] = getErrorDescriptor$5;
}

function useObject$5() {
  factories$f[MemberType$5.Object] = getObjectDescriptor$5;
}

function useType$5() {
  factories$f[MemberType$5.Type] = getTypeDescriptor$5;
}

function useComptime$5() {
  factories$f[MemberType$5.Comptime] = getComptimeDescriptor$5;
}

function useStatic$5() {
  factories$f[MemberType$5.Static] = getStaticDescriptor$5;
}

function useLiteral$5() {
  factories$f[MemberType$5.Literal] = getLiteralDescriptor$5;
}

function useNull$5() {
  factories$f[MemberType$5.Null] = getNullDescriptor$5;
}

function useUndefined$5() {
  factories$f[MemberType$5.Undefined] = getUndefinedDescriptor$5;
}

function isByteAligned$5({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$5(member, env) {
  const f = factories$f[member.type];
  return f(member, env);
}

function getVoidDescriptor$5(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$5(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$5(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$5(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$5(member, env) {
  return getDescriptorUsing$5(member, env, getBoolAccessor$5)
}

function getIntDescriptor$5(member, env) {
  const getDataViewAccessor = addRuntimeCheck$5(env, getNumericAccessor$5);
  return getDescriptorUsing$5(member, env, getDataViewAccessor)
}

function getUintDescriptor$5(member, env) {
  const getDataViewAccessor = addRuntimeCheck$5(env, getNumericAccessor$5);
  return getDescriptorUsing$5(member, env, getDataViewAccessor)
}

function addRuntimeCheck$5(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$5(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$5(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$5(member, env) {
  return getDescriptorUsing$5(member, env, getNumericAccessor$5)
}

function getValueDescriptor$5(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$5(valueMember, env);
}

function getEnumerationItemDescriptor$5(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$5(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$5(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$5(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$5(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$5();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$5(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$5(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$5(structure) {
  switch (structure.type) {
    case StructureType$5.Primitive:
    case StructureType$5.ErrorUnion:
    case StructureType$5.Optional:
    case StructureType$5.Enumeration:
    case StructureType$5.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$5(slot) {
  const object = this[SLOTS$5][slot] ?? this[VIVIFICATOR$5](slot);
  return object[GETTER$5]();
}

function getObject$5(slot) {
  const object = this[SLOTS$5][slot] ?? this[VIVIFICATOR$5](slot);
  return object;
}

function setValue$5(slot, value) {
  const object = this[SLOTS$5][slot] ?? this[VIVIFICATOR$5](slot);
  object[SETTER$5](value);
}

function bindSlot$5(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$5(member, env) {
  const { structure, slot } = member;
  return bindSlot$5(slot, {
    get: isValueExpected$5(structure) ? getValue$5 : getObject$5,
    set: setValue$5,
  });
}

function getType$5(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$5][slot];
  return structure?.constructor;
}

function getTypeDescriptor$5(member, env) {
  const { slot } = member;
  return bindSlot$5(slot, { get: getType$5 });
}

function getComptimeDescriptor$5(member, env) {
  const { slot, structure } = member;
  return bindSlot$5(slot, {
    get: isValueExpected$5(structure) ? getValue$5 : getObject$5,
  });
}

function getStaticDescriptor$5(member, env) {
  const { slot, structure } = member;
  return bindSlot$5(slot, {
    get: isValueExpected$5(structure) ? getValue$5 : getObject$5,
    set: setValue$5,
  });
}

function getLiteral$5(slot) {
  const object = this[SLOTS$5][slot];
  return object.string;
}

function getLiteralDescriptor$5(member, env) {
  const { slot } = member;
  return bindSlot$5(slot, { get: getLiteral$5 });
}

function getDescriptorUsing$5(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$5], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$5.call(this)) {
            return getter.call(this[MEMORY$5], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$5], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$5.call(this)) {
            return setter.call(this[MEMORY$5], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$5], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$5.call(this)) {
            return getter.call(this[MEMORY$5], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$5(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$5], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$5.call(this)) {
            return setter.call(this[MEMORY$5], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$5(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$5() {
  useVoid$5();
  useNull$5();
  useUndefined$5();
  useBool$5();
  useInt$5();
  useUint$5();
  useFloat$5();
  useEnumerationItem$5();
  useError$5();
  useObject$5();
  useType$5();
  useComptime$5();
  useStatic$5();
  useLiteral$5();
}

process.cwd();

useAllMemberTypes$5();
useAllStructureTypes$5();
useAllExtendedTypes$5();

const MEMORY$4 = Symbol('memory');
const SLOTS$4 = Symbol('slots');
const PARENT$4 = Symbol('parent');
const NAME$4 = Symbol('name');
const TAG$4 = Symbol('tag');
const ITEMS$4 = Symbol('items');
const PROPS$4 = Symbol('props');
const GETTER$4 = Symbol('getter');
const SETTER$4 = Symbol('setter');
const ELEMENT_GETTER$4 = Symbol('elementGetter');
const ELEMENT_SETTER$4 = Symbol('elementSetter');
const LOCATION_GETTER$4 = Symbol('addressGetter');
const LOCATION_SETTER$4 = Symbol('addressSetter');
const TARGET_GETTER$4 = Symbol('targetGetter');
const TARGET_SETTER$4 = Symbol('targetSetter');
const FIXED_LOCATION$4 = Symbol('fixedLocation');
const PROP_GETTERS$4 = Symbol('propGetters');
const PROP_SETTERS$4 = Symbol('propSetters');
const ALL_KEYS$4 = Symbol('allKeys');
const LENGTH$4 = Symbol('length');
const PROXY$4 = Symbol('proxy');
const COMPAT$4 = Symbol('compat');
const SIZE$4 = Symbol('size');
const ALIGN$4 = Symbol('align');
const ARRAY$4 = Symbol('array');
const POINTER$4 = Symbol('pointer');
const CONST$4 = Symbol('const');
const CONST_PROTOTYPE$4 = Symbol('constProto');
const COPIER$4 = Symbol('copier');
const RESETTER$4 = Symbol('resetter');
const NORMALIZER$4 = Symbol('normalizer');
const VIVIFICATOR$4 = Symbol('vivificator');
const POINTER_VISITOR$4 = Symbol('pointerVisitor');
const ENVIRONMENT$4 = Symbol('environment');
const MORE$4 = Symbol('more');

function getDestructor$4(env) {
  return function() {
    const dv = this[MEMORY$4];
    this[MEMORY$4] = null;
    if (this[SLOTS$4]) {
      this[SLOTS$4] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$4(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$4(size, multiple = false) {
  const copy = getCopyFunction$4(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$4.call(this);
    restoreMemory$4.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$4];
    const dest = this[MEMORY$4];
    copy(dest, src);
  };
}

function getCopyFunction$4(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$4[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$4;
  if (!(size & 0x03)) return copy4x$4;
  if (!(size & 0x01)) return copy2x$4;
  return copy1x$4;
}

const copiers$4 = {
  1: copy1$4,
  2: copy2$4,
  4: copy4$4,
  8: copy8$4,
  16: copy16$4,
  32: copy32$4,
};

function copy1x$4(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$4(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$4(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$4(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$4(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$4(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$4(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$4(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$4(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$4(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$4(offset, size) {
  const reset = getResetFunction$4(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$4.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$4];
    reset(dest, offset, size);
  };
}

function getResetFunction$4(size) {
  const resetter = resetters$4[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$4;
  if (!(size & 0x03)) return reset4x$4;
  if (!(size & 0x01)) return reset2x$4;
  return reset1x$4;
}

const resetters$4 = {
  1: reset1$4,
  2: reset2$4,
  4: reset4$4,
  8: reset8$4,
  16: reset16$4,
  32: reset32$4,
};

function reset1x$4(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$4(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$4(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$4(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$4(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$4(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$4(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$4(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$4(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$4(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$4() {
  const dv = this[MEMORY$4];
  const source = dv[MEMORY$4];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$4] = source;
  this[MEMORY$4] = newDV;
  return true;
}

const decoders$4 = {};
const encoders$4 = {};

function decodeText$4(arrays, encoding = 'utf-8') {
  let decoder = decoders$4[encoding];
  if (!decoder) {
    decoder = decoders$4[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$4(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$4[encoding];
      if (!encoder) {
        encoder = encoders$4[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$4(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$4(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$4() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$4];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$4 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$4 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$4() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$4];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$4 <= value && value <= INT_MAX$4) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$4(cb, options) {
  const value = handleError$4(() => this.$, options);
  return cb(value);
}

function handleError$4(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$4(structure, handlers = {}) {
  return markAsSpecial$4({
    get() {
      /* WASM-ONLY */
      restoreMemory$4.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$4];
    },
    set(dv) {
      checkDataView$4(dv);
      setDataView$4.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$4(structure, handlers = {}) {
  return markAsSpecial$4({
    get() {
      return encodeBase64$4(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$4('string', str);
      }
      const dv = decodeBase64$4(str);
      setDataView$4.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$4(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$4({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$4(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$4('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$4(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$4.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$4(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$4({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$4(ta, typedArray)) {
        throwTypeMismatch$4(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$4.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$4({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$4.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$4.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$4({
    type: MemberType$4.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$4({
    type: MemberType$4.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$4];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$4]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$4]);
        const target = Target.call(ENVIRONMENT$4, dv, { writable: !isConst });
        this[SLOTS$4][0] = target;
        this[FIXED_LOCATION$4] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$4][0] ?? throwNullPointer$4();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$4]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$4] = loc;
      } else {
        throwFixedMemoryTargetRequired$4();
      }
    }
    this[SLOTS$4][0] = arg;
  };
  const getTarget = isValueExpected$4(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$4]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$4][0] ?? throwNullPointer$4();
    return object[SETTER$4](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$4 || this === PARENT$4) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$4(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$4();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$9;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$4, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$4(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$4(structure, arg);
      }
      arg = arg[SLOTS$4][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$4.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$4]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$4]) {
        throwReadOnlyTarget$4(structure);       
      }
    } else if (isCompatible$4(arg, Target)) {
      // autocast to target type
      const dv = getDataView$4(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$4]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$4(arg?.buffer)) {
          warnImplicitArrayCreation$4(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$4(structure, arg);
    }
    this[TARGET_SETTER$4](arg);
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$4, set: initializer },
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [TARGET_GETTER$4]: { value: getTargetObject },
    [TARGET_SETTER$4]: { value: setTargetObject },
    [LOCATION_GETTER$4]: { value: addressGetter },
    [LOCATION_SETTER$4]: { value: addressSetter },
    [POINTER_VISITOR$4]: { value: visitPointer$4 },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [VIVIFICATOR$4]: { value: throwNullPointer$4 },
    [NORMALIZER$4]: { value: normalizePointer$4 },
    [FIXED_LOCATION$4]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$4(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$4() {
  return this[PROXY$4];
}

function copyPointer$4({ source }) {
  const target = source[SLOTS$4][0];
  if (target) {
    this[TARGET_SETTER$4](target);
  }
}

function resetPointer$4({ isActive }) {
  if (this[SLOTS$4][0] && !isActive(this)) {
    this[SLOTS$4][0] = undefined;
  }
}

function disablePointer$4() {
  const disabledProp = { get: throwInaccessiblePointer$4, set: throwInaccessiblePointer$4 };
  const disabledFunc = { value: throwInaccessiblePointer$4 };
  defineProperties$4(this[POINTER$4], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$4]: disabledFunc,
    [SETTER$4]: disabledFunc,
    [TARGET_GETTER$4]: disabledFunc,
  });
}

function visitPointer$4(fn, options = {}) {
  const {
    source,
    isActive = always$4,
    isMutable = always$4,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$4(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$9 = {
  get(pointer, name) {
    if (name === POINTER$4) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$4]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$4]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$4]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$4]();
      return name in target;
    }
  },
};

function always$4() {
  return true;
}

function never$4() {
  return false;
}

function defineStructShape$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$4(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$4.Object);
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$4](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$4(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$4, set: initializer },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$4 },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$9(structure) },
    [POINTER_VISITOR$4]: hasPointer && { value: getPointerVisitor$9(structure, always$4) },
    [NORMALIZER$4]: { value: normalizeStruct$4 },
    [PROPS$4]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$4(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$4.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$4(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$4.bind(this, options),
    length: this[PROPS$4].length,
  };
}

function getStructIterator$4(options) { 
  const entries = getStructEntries$4.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$4(options) {
  const self = this;
  const props = this[PROPS$4];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$4(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$9(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$4.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$4];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$4(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$4][slot] = constructor.call(PARENT$4, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$9(structure, visitorOptions = {}) {
  const {
    isChildActive = always$4,
    isChildMutable = always$4,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$4,
      isMutable = always$4,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$4]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$4][slot] ?? (vivificate ? this[VIVIFICATOR$4](slot) : null);
      if (child) {
        child[POINTER_VISITOR$4](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$4.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$4] = dv;
    if (hasObject) {
      this[SLOTS$4] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$4(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$4(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$4(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$4(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$9(structure) },
    [POINTER_VISITOR$4]: hasPointer && { value: getPointerVisitor$9(structure, { isChildMutable }) },
  });
  defineProperties$4(constructor, {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  });
  return constructor;
}

function defineArray$4(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$4(member, env);
  const hasStringProp = canBeString$4(member);
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$4](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$4(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$4(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$4(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$4(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$4;
  const constructor = structure.constructor = createConstructor$4(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$4(member);
  const hasObject = member.type === MemberType$4.Object;
  const instanceDescriptors = {
    $: { get: getProxy$4, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    string: hasStringProp && getStringDescriptor$4(structure),
    typedArray: typedArray && getTypedArrayDescriptor$4(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$4 },
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [Symbol.iterator]: { value: getArrayIterator$4 },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$8(structure) },
    [POINTER_VISITOR$4]: hasPointer && { value: getPointerVisitor$8() },
    [NORMALIZER$4]: { value: normalizeArray$4 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$4]: { value: getCompatibleTags$4(structure) },
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$4() {
  const proxy = new Proxy(this, proxyHandlers$8);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$4, { value: proxy }); 
  return proxy;
}

function canBeString$4(member) {
  return member.type === MemberType$4.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$4(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$4.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$4() {
  const self = this[ARRAY$4] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$4(options) {
  const self = this[ARRAY$4] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$4(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$4(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$4.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$8(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$4];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$4][index] = constructor.call(PARENT$4, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$8(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$4,
      isMutable = always$4,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$4][i];
      }
      const child = this[SLOTS$4][i] ?? (vivificate ? this[VIVIFICATOR$4](i) : null);
      if (child) {
        child[POINTER_VISITOR$4](cb, childOptions);
      }
    }
  };
}

function transformIterable$4(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$8 = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$4]) {
            array[ELEMENT_GETTER$4] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$4];
        case 'set':
          if (!array[ELEMENT_SETTER$4]) {
            array[ELEMENT_SETTER$4] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$4];
        case ARRAY$4:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$4] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$4] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$4];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$4];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$4);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$4(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$4(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$4({ ...member, type: MemberType$4.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$4(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$4];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$4] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$4(item, { [NAME$4]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$4] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$4];
    } else if (!getDataView$4(structure, arg, env)) {
      throwInvalidInitializer$4(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$4(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$4] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    typedArray: typedArray && getTypedArrayDescriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [NORMALIZER$4]: { value: normalizeEnumerationItem$4 },
  };
  const staticDescriptors = {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
    [ITEMS$4]: { value: {} },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$4(cb) {
  return cb(this.$[NAME$4]);
}

function defineErrorSet$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$4(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$4({ ...member, type: MemberType$4.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$4(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$4][arg];
    } else if (!getDataView$4(structure, arg, env)) {
      throwInvalidInitializer$4(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$4.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$4(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    typedArray: typedArray && getTypedArrayDescriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [NORMALIZER$4]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
    [ITEMS$4]: { value: {} },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$4;

function getGlobalErrorSet$4() {
  return globalErrorSet$4;
}

function defineErrorUnion$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$4(members[0], env);
  const { get: getError, set: setError } = getDescriptor$4(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$4.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$4() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$4]();
    this[POINTER_VISITOR$4]?.(resetPointer$4);
  };
  const hasObject = !!members.find(m => m.type === MemberType$4.Object);
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$4](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$4(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$4(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [RESETTER$4]: { value: getMemoryResetter$4(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$9(structure) },
    [POINTER_VISITOR$4]: hasPointer && { value: getPointerVisitor$9(structure, { isChildActive }) },
    [NORMALIZER$4]: { value: normalizeValue$4 },
  };
  const staticDescriptors = {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$4(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$4(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$4(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [NORMALIZER$4]: { value: normalizeOpaque$4 },
  };
  const staticDescriptors = {
    [COMPAT$4]: { value: getCompatibleTags$4(structure) },
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$4(cb) {
  return {};
}

function defineOptional$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$4(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$4(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$4]?.(resetPointer$4);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$4.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$4](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$4]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$4]?.(resetPointer$4);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$4.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$4]: !hasPointer && { value: getMemoryResetter$4(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$9(structure) },
    [POINTER_VISITOR$4]: hasPointer && { value: getPointerVisitor$9(structure, { isChildActive }) },
    [NORMALIZER$4]: { value: normalizeValue$4 },
  };
  const staticDescriptors = {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$4(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$4(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$4(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$4(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$4] = dv;
    this[LENGTH$4] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$4]) {
      throwArrayLengthMismatch$4(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$4]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$4](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$4(arg);
      if (!this[MEMORY$4]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$4] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$4(structure, arg, !this[MEMORY$4]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$4(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$4(structure, arg);
    }
  };
  const finalizer = createArrayProxy$4;
  const constructor = structure.constructor = createConstructor$4(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$4(member);
  const hasObject = member.type === MemberType$4.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$4, set: initializer },
    length: { get: getLength$4 },
    dataView: getDataViewDescriptor$4(structure, shapeHandlers),
    base64: getBase64Descriptor$4(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$4(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$4(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$4 },
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [Symbol.iterator]: { value: getArrayIterator$4 },
    [COPIER$4]: { value: getMemoryCopier$4(elementSize, true) },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$8(structure) },
    [POINTER_VISITOR$4]: hasPointer && { value: getPointerVisitor$8() },
    [NORMALIZER$4]: { value: normalizeArray$4 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$4]: { value: getCompatibleTags$4(structure) },
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: elementSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$4() {
  return this[LENGTH$4];
}

function getSentinel$4(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$4(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$4(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$4(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$4(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$4(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$4(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$4(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$4].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$4(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$4];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$4(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$4.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$4.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$4(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$4];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$4(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$4(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$4]?.(resetPointer$4);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$4(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$4]?.(resetPointer$4);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$4](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$4(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$4(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$4(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$4](disablePointer$4, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$4(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$4;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$4.Object);
  const instanceDescriptors = {
    $: { get: getSelf$4, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$4 },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [TAG$4]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$4]: hasObject && { value: getChildVivificator$9(structure) },
    [POINTER_VISITOR$4]: hasAnyPointer && { value: getPointerVisitor$9(structure, { isChildActive }) },
    [PROP_GETTERS$4]: { value: memberValueGetters },
    [NORMALIZER$4]: { value: normalizeUnion$4 },
    [PROPS$4]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$4];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$4(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$4.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$4(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$4.bind(this, options),
    length: this[PROPS$4].length,
  };
}

function getUnionIterator$4(options) { 
  const entries = getUnionEntries$4.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$4(options) {
  const self = this;
  const props = this[PROPS$4];
  const getters = this[PROP_GETTERS$4];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$4(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$4(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$4({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$4](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$4(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$4][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$4(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$4(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$4(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$4, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    typedArray: typedArray && getTypedArrayDescriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    entries: { value: getVectorEntries$4 },
    delete: { value: getDestructor$4(structure) },
    [Symbol.iterator]: { value: getVectorIterator$4 },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [NORMALIZER$4]: { value: normalizeVector$4 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$4]: { value: getCompatibleTags$4(structure) },
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$4(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$4.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$4() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$4() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$4() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$4.bind(this),
    length: this.length,
  };
}

const StructureType$4 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$e = Array(Object.values(StructureType$4).length);

function usePrimitive$4() {
  factories$e[StructureType$4.Primitive] = definePrimitive$4;
}

function useArray$4() {
  factories$e[StructureType$4.Array] = defineArray$4;
}

function useStruct$4() {
  factories$e[StructureType$4.Struct] = defineStructShape$4;
}

function usePackedStruct$4() {
  factories$e[StructureType$4.PackedStruct] = defineStructShape$4;
}

function useExternStruct$4() {
  factories$e[StructureType$4.ExternStruct] = defineStructShape$4;
}

function useArgStruct$4() {
  factories$e[StructureType$4.ArgStruct] = defineArgStruct$4;
}

function useExternUnion$4() {
  factories$e[StructureType$4.ExternUnion] = defineUnionShape$4;
}

function useBareUnion$4() {
  factories$e[StructureType$4.BareUnion] = defineUnionShape$4;
}

function useTaggedUnion$4() {
  factories$e[StructureType$4.TaggedUnion] = defineUnionShape$4;
}

function useErrorUnion$4() {
  factories$e[StructureType$4.ErrorUnion] = defineErrorUnion$4;
}

function useErrorSet$4() {
  factories$e[StructureType$4.ErrorSet] = defineErrorSet$4;
}

function useEnumeration$4() {
  factories$e[StructureType$4.Enumeration] = defineEnumerationShape$4;
}

function useOptional$4() {
  factories$e[StructureType$4.Optional] = defineOptional$4;
}

function usePointer$4() {
  factories$e[StructureType$4.Pointer] = definePointer$4;
}

function useSlice$4() {
  factories$e[StructureType$4.Slice] = defineSlice$4;
}

function useVector$4() {
  factories$e[StructureType$4.Vector] = defineVector$4;
}

function useOpaque$4() {
  factories$e[StructureType$4.Opaque] = defineOpaque$4;
}

function defineProperties$4(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$4 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$4, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$4]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$4(constructor.prototype, { 
    [CONST$4]: { value: false },
    [ALL_KEYS$4]: { value: Object.keys(propSetters) },
    [SETTER$4]: { value: set },
    [GETTER$4]: { value: get },
    [PROP_SETTERS$4]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$4(constructor, {
    [CONST_PROTOTYPE$4]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$4(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$4]: { value: true },
    [SETTER$4]: { value: throwReadOnly$4 },
    [VIVIFICATOR$4]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$4(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$4(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$4]) {
    const comptimeMembers = members.filter(m => isReadOnly$4(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$4();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$4(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$4] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$4]; 
      } else {
        self[MEMORY$4] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$4(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$4]);
      if (shapeDefiner) {
        setDataView$4.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$4] = dv;
      }
      if (hasSlots) {
        self[SLOTS$4] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$4](copyPointer$4, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$4][slot] = template[SLOTS$4][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$4]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$4(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$4];
    const allKeys = this[ALL_KEYS$4];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$4(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$4(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$4]) {
          this[COPIER$4](template);
        }
        this[POINTER_VISITOR$4]?.(copyPointer$4, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$4(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$4.Object:
      case MemberType$4.Comptime:
      case MemberType$4.Type:
      case MemberType$4.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$4() {
  return this;
}

function useAllStructureTypes$4() {
  usePrimitive$4();
  useArray$4();
  useStruct$4();
  useExternStruct$4();
  usePackedStruct$4();
  useArgStruct$4();
  useExternUnion$4();
  useBareUnion$4();
  useTaggedUnion$4();
  useErrorUnion$4();
  useErrorSet$4();
  useEnumeration$4();
  useOptional$4();
  usePointer$4();
  useSlice$4();
  useVector$4();
  useOpaque$4();
}

let ObjectCache$4 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$4(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$4(member, env);
  const propApplier = createPropertyApplier$4(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$4](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$4(member);
          throwInvalidInitializer$4(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$4(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$4(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$4(structure),
    base64: getBase64Descriptor$4(structure),
    typedArray: typedArray && getTypedArrayDescriptor$4(structure),
    valueOf: { value: getValueOf$4 },
    toJSON: { value: convertToJSON$4 },
    delete: { value: getDestructor$4(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$4]: { value: getMemoryCopier$4(byteSize) },
    [NORMALIZER$4]: { value: normalizeValue$4 },
  };
  const staticDescriptors = {
    [COMPAT$4]: { value: getCompatibleTags$4(structure) },
    [ALIGN$4]: { value: align },
    [SIZE$4]: { value: byteSize },
  };
  return attachDescriptors$4(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$4(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$4.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$4({ type, bitSize }) {
  if (type === MemberType$4.Int || type === MemberType$4.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$4.Float) {
    return Number;
  } else if (type === MemberType$4.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$4(member) {
  const Primitive = getPrimitiveClass$4(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$4(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$4(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$4.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$4.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$4(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$4);
  if (typedArray) {
    acceptable.push(addArticle$4(typedArray.name));
  }
  if (type === StructureType$4.Slice) {
    throw new TypeError(`Expecting ${formatList$4(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$4(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$4(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$4(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$4(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$4(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$4(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$4(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$4(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$4(type));
    }
  } else {
    acceptable.push(addArticle$4(expected));
  }
  const received = getDescription$4(arg);
  throw new TypeError(`${name} expects ${formatList$4(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$4(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$4(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$4.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$4.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$4(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$4(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$4(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$4(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$4(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$4(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$4(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$4(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$4(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$4(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$4(expected, arg) {
  const received = getDescription$4(arg);
  throw new TypeError(`Expected ${addArticle$4(expected)}, received ${received}`)
}

function throwInaccessiblePointer$4() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$4() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$4(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$4(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$4(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$4(member, value) {
  const typeName = getTypeName$4(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$4(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$4(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$4(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$4(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$4(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$4() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$4(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$4(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$4(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$4(structure, arg) {
  const created = addArticle$4(structure.typedArray.name);
  const source = addArticle$4(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$4(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$4(s);
}

function addArticle$4(noun) {
  return `${article$4(noun)} ${noun}`;
}

function article$4(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$4(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$4(access, member) {
  return cacheMethod$4(access, member, () => {
    if (isByteAligned$4(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$4({ type: MemberType$4.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$4(access, member);
    }
  });
}

function getNumericAccessor$4(access, member) {
  return cacheMethod$4(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$4(access, member);
    }
  });
}

const factories$d = {};

function useExtendedBool$4() {
  factories$d[MemberType$4.Bool] = getExtendedBoolAccessor$4;
}

function useExtendedInt$4() {
  factories$d[MemberType$4.Int] = getExtendedIntAccessor$4;
}

function useExtendedUint$4() {
  factories$d[MemberType$4.Uint] = getExtendedUintAccessor$4;
}

function useExtendedFloat$4() {
  factories$d[MemberType$4.Float] = getExtendedFloatAccessor$4;
}

function getExtendedTypeAccessor$4(access, member) {
  const f = factories$d[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$4(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$4(access, member) {
  if (isByteAligned$4(member)) {
    return getAlignedIntAccessor$4(access, member)
  } else {
    return getUnalignedIntAccessor$4(access, member);
  }
}

function getExtendedUintAccessor$4(access, member) {
  if (isByteAligned$4(member)) {
    return getAlignedUintAccessor$4(access, member)
  } else {
    return getUnalignedUintAccessor$4(access, member);
  }
}

function getExtendedFloatAccessor$4(access, member) {
  if (isByteAligned$4(member)) {
    return getAlignedFloatAccessor$4(access, member)
  } else {
    return getUnalignedFloatAccessor$4(access, member);
  }
}

function getDataView$4(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$4];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$4.Array || type === StructureType$4.Slice || type === StructureType$4.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$4(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$4.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$4(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$4(dv, structure);
  }
  return dv;
}

function checkDataView$4(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$4('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$4(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$4.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$4(structure, dv);
  }
}

function setDataView$4(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$4.Slice;
  if (!this[MEMORY$4]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$4(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$4]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$4](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$4(structure, dv, this);
    }
    const source = { [MEMORY$4]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$4](source); 
  }
}

function findElements$4(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$4(structure, arg, env) {
  const dv = getDataView$4(structure, arg, env);
  if (!dv) {
    throwBufferExpected$4(structure);
  }
  return dv;
}

function getTypedArrayClass$4(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$4.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$4.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$4.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$4.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$4(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$4(arg, constructor) {
  const tags = constructor[COMPAT$4];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$4(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$4(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$4(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$4(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$4.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$4.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$4.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$4.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$4.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$4(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$4(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$4({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$4(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$4(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$4({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$4(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$4(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$4(access, member);
}

function getUnalignedUintAccessor$4(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$4(access, member);
}

function getAlignedFloatAccessor$4(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$4(access, member) {
  return getUnalignedNumericAccessor$4(access, member);
}

function getUnalignedNumericAccessor$4(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$4('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$4(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$4('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$4(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$4 = {};

function cacheMethod$4(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$4(member);
  const suffix = isByteAligned$4(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$4.Int || type === MemberType$4.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$4[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$4(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$4[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$4() {
  useExtendedBool$4();
  useExtendedInt$4();
  useExtendedUint$4();
  useExtendedFloat$4();
}

const MemberType$4 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$4(type) {
  switch (type) {
    case MemberType$4.Type:
    case MemberType$4.Comptime:
    case MemberType$4.Literal:
      return true;
    default:
      return false;
  }
}

const factories$c = {};

function useVoid$4() {
  factories$c[MemberType$4.Void] = getVoidDescriptor$4;
}

function useBool$4() {
  factories$c[MemberType$4.Bool] = getBoolDescriptor$4;
}

function useInt$4() {
  factories$c[MemberType$4.Int] = getIntDescriptor$4;
}

function useUint$4() {
  factories$c[MemberType$4.Uint] = getUintDescriptor$4;
}

function useFloat$4() {
  factories$c[MemberType$4.Float] = getFloatDescriptor$4;
}

function useEnumerationItem$4() {
  factories$c[MemberType$4.EnumerationItem] = getEnumerationItemDescriptor$4;
}

function useError$4() {
  factories$c[MemberType$4.Error] = getErrorDescriptor$4;
}

function useObject$4() {
  factories$c[MemberType$4.Object] = getObjectDescriptor$4;
}

function useType$4() {
  factories$c[MemberType$4.Type] = getTypeDescriptor$4;
}

function useComptime$4() {
  factories$c[MemberType$4.Comptime] = getComptimeDescriptor$4;
}

function useStatic$4() {
  factories$c[MemberType$4.Static] = getStaticDescriptor$4;
}

function useLiteral$4() {
  factories$c[MemberType$4.Literal] = getLiteralDescriptor$4;
}

function useNull$4() {
  factories$c[MemberType$4.Null] = getNullDescriptor$4;
}

function useUndefined$4() {
  factories$c[MemberType$4.Undefined] = getUndefinedDescriptor$4;
}

function isByteAligned$4({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$4(member, env) {
  const f = factories$c[member.type];
  return f(member, env);
}

function getVoidDescriptor$4(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$4(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$4(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$4(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$4(member, env) {
  return getDescriptorUsing$4(member, env, getBoolAccessor$4)
}

function getIntDescriptor$4(member, env) {
  const getDataViewAccessor = addRuntimeCheck$4(env, getNumericAccessor$4);
  return getDescriptorUsing$4(member, env, getDataViewAccessor)
}

function getUintDescriptor$4(member, env) {
  const getDataViewAccessor = addRuntimeCheck$4(env, getNumericAccessor$4);
  return getDescriptorUsing$4(member, env, getDataViewAccessor)
}

function addRuntimeCheck$4(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$4(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$4(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$4(member, env) {
  return getDescriptorUsing$4(member, env, getNumericAccessor$4)
}

function getValueDescriptor$4(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$4(valueMember, env);
}

function getEnumerationItemDescriptor$4(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$4(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$4(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$4(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$4(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$4();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$4(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$4(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$4(structure) {
  switch (structure.type) {
    case StructureType$4.Primitive:
    case StructureType$4.ErrorUnion:
    case StructureType$4.Optional:
    case StructureType$4.Enumeration:
    case StructureType$4.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$4(slot) {
  const object = this[SLOTS$4][slot] ?? this[VIVIFICATOR$4](slot);
  return object[GETTER$4]();
}

function getObject$4(slot) {
  const object = this[SLOTS$4][slot] ?? this[VIVIFICATOR$4](slot);
  return object;
}

function setValue$4(slot, value) {
  const object = this[SLOTS$4][slot] ?? this[VIVIFICATOR$4](slot);
  object[SETTER$4](value);
}

function bindSlot$4(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$4(member, env) {
  const { structure, slot } = member;
  return bindSlot$4(slot, {
    get: isValueExpected$4(structure) ? getValue$4 : getObject$4,
    set: setValue$4,
  });
}

function getType$4(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$4][slot];
  return structure?.constructor;
}

function getTypeDescriptor$4(member, env) {
  const { slot } = member;
  return bindSlot$4(slot, { get: getType$4 });
}

function getComptimeDescriptor$4(member, env) {
  const { slot, structure } = member;
  return bindSlot$4(slot, {
    get: isValueExpected$4(structure) ? getValue$4 : getObject$4,
  });
}

function getStaticDescriptor$4(member, env) {
  const { slot, structure } = member;
  return bindSlot$4(slot, {
    get: isValueExpected$4(structure) ? getValue$4 : getObject$4,
    set: setValue$4,
  });
}

function getLiteral$4(slot) {
  const object = this[SLOTS$4][slot];
  return object.string;
}

function getLiteralDescriptor$4(member, env) {
  const { slot } = member;
  return bindSlot$4(slot, { get: getLiteral$4 });
}

function getDescriptorUsing$4(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$4], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$4.call(this)) {
            return getter.call(this[MEMORY$4], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$4], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$4.call(this)) {
            return setter.call(this[MEMORY$4], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$4], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$4.call(this)) {
            return getter.call(this[MEMORY$4], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$4(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$4], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$4.call(this)) {
            return setter.call(this[MEMORY$4], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$4(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$4() {
  useVoid$4();
  useNull$4();
  useUndefined$4();
  useBool$4();
  useInt$4();
  useUint$4();
  useFloat$4();
  useEnumerationItem$4();
  useError$4();
  useObject$4();
  useType$4();
  useComptime$4();
  useStatic$4();
  useLiteral$4();
}

process.cwd();

useAllMemberTypes$4();
useAllStructureTypes$4();
useAllExtendedTypes$4();

const MEMORY$3 = Symbol('memory');
const SLOTS$3 = Symbol('slots');
const PARENT$3 = Symbol('parent');
const NAME$3 = Symbol('name');
const TAG$3 = Symbol('tag');
const ITEMS$3 = Symbol('items');
const PROPS$3 = Symbol('props');
const GETTER$3 = Symbol('getter');
const SETTER$3 = Symbol('setter');
const ELEMENT_GETTER$3 = Symbol('elementGetter');
const ELEMENT_SETTER$3 = Symbol('elementSetter');
const LOCATION_GETTER$3 = Symbol('addressGetter');
const LOCATION_SETTER$3 = Symbol('addressSetter');
const TARGET_GETTER$3 = Symbol('targetGetter');
const TARGET_SETTER$3 = Symbol('targetSetter');
const FIXED_LOCATION$3 = Symbol('fixedLocation');
const PROP_GETTERS$3 = Symbol('propGetters');
const PROP_SETTERS$3 = Symbol('propSetters');
const ALL_KEYS$3 = Symbol('allKeys');
const LENGTH$3 = Symbol('length');
const PROXY$3 = Symbol('proxy');
const COMPAT$3 = Symbol('compat');
const SIZE$3 = Symbol('size');
const ALIGN$3 = Symbol('align');
const ARRAY$3 = Symbol('array');
const POINTER$3 = Symbol('pointer');
const CONST$3 = Symbol('const');
const CONST_PROTOTYPE$3 = Symbol('constProto');
const COPIER$3 = Symbol('copier');
const RESETTER$3 = Symbol('resetter');
const NORMALIZER$3 = Symbol('normalizer');
const VIVIFICATOR$3 = Symbol('vivificator');
const POINTER_VISITOR$3 = Symbol('pointerVisitor');
const ENVIRONMENT$3 = Symbol('environment');
const MORE$3 = Symbol('more');

function getDestructor$3(env) {
  return function() {
    const dv = this[MEMORY$3];
    this[MEMORY$3] = null;
    if (this[SLOTS$3]) {
      this[SLOTS$3] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$3(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$3(size, multiple = false) {
  const copy = getCopyFunction$3(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$3.call(this);
    restoreMemory$3.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$3];
    const dest = this[MEMORY$3];
    copy(dest, src);
  };
}

function getCopyFunction$3(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$3[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$3;
  if (!(size & 0x03)) return copy4x$3;
  if (!(size & 0x01)) return copy2x$3;
  return copy1x$3;
}

const copiers$3 = {
  1: copy1$3,
  2: copy2$3,
  4: copy4$3,
  8: copy8$3,
  16: copy16$3,
  32: copy32$3,
};

function copy1x$3(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$3(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$3(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$3(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$3(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$3(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$3(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$3(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$3(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$3(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$3(offset, size) {
  const reset = getResetFunction$3(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$3.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$3];
    reset(dest, offset, size);
  };
}

function getResetFunction$3(size) {
  const resetter = resetters$3[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$3;
  if (!(size & 0x03)) return reset4x$3;
  if (!(size & 0x01)) return reset2x$3;
  return reset1x$3;
}

const resetters$3 = {
  1: reset1$3,
  2: reset2$3,
  4: reset4$3,
  8: reset8$3,
  16: reset16$3,
  32: reset32$3,
};

function reset1x$3(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$3(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$3(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$3(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$3(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$3(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$3(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$3(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$3(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$3(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$3() {
  const dv = this[MEMORY$3];
  const source = dv[MEMORY$3];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$3] = source;
  this[MEMORY$3] = newDV;
  return true;
}

const decoders$3 = {};
const encoders$3 = {};

function decodeText$3(arrays, encoding = 'utf-8') {
  let decoder = decoders$3[encoding];
  if (!decoder) {
    decoder = decoders$3[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$3(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$3[encoding];
      if (!encoder) {
        encoder = encoders$3[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$3(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$3(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$3() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$3];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$3 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$3 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$3() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$3];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$3 <= value && value <= INT_MAX$3) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$3(cb, options) {
  const value = handleError$3(() => this.$, options);
  return cb(value);
}

function handleError$3(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$3(structure, handlers = {}) {
  return markAsSpecial$3({
    get() {
      /* WASM-ONLY */
      restoreMemory$3.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$3];
    },
    set(dv) {
      checkDataView$3(dv);
      setDataView$3.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$3(structure, handlers = {}) {
  return markAsSpecial$3({
    get() {
      return encodeBase64$3(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$3('string', str);
      }
      const dv = decodeBase64$3(str);
      setDataView$3.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$3(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$3({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$3(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$3('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$3(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$3.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$3(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$3({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$3(ta, typedArray)) {
        throwTypeMismatch$3(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$3.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$3({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$3.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$3.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$3({
    type: MemberType$3.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$3({
    type: MemberType$3.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$3];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$3]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$3]);
        const target = Target.call(ENVIRONMENT$3, dv, { writable: !isConst });
        this[SLOTS$3][0] = target;
        this[FIXED_LOCATION$3] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$3][0] ?? throwNullPointer$3();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$3]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$3] = loc;
      } else {
        throwFixedMemoryTargetRequired$3();
      }
    }
    this[SLOTS$3][0] = arg;
  };
  const getTarget = isValueExpected$3(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$3]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$3][0] ?? throwNullPointer$3();
    return object[SETTER$3](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$3 || this === PARENT$3) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$3(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$3();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$7;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$3, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$3(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$3(structure, arg);
      }
      arg = arg[SLOTS$3][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$3.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$3]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$3]) {
        throwReadOnlyTarget$3(structure);       
      }
    } else if (isCompatible$3(arg, Target)) {
      // autocast to target type
      const dv = getDataView$3(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$3]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$3(arg?.buffer)) {
          warnImplicitArrayCreation$3(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$3(structure, arg);
    }
    this[TARGET_SETTER$3](arg);
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$3, set: initializer },
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [TARGET_GETTER$3]: { value: getTargetObject },
    [TARGET_SETTER$3]: { value: setTargetObject },
    [LOCATION_GETTER$3]: { value: addressGetter },
    [LOCATION_SETTER$3]: { value: addressSetter },
    [POINTER_VISITOR$3]: { value: visitPointer$3 },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [VIVIFICATOR$3]: { value: throwNullPointer$3 },
    [NORMALIZER$3]: { value: normalizePointer$3 },
    [FIXED_LOCATION$3]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$3(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$3() {
  return this[PROXY$3];
}

function copyPointer$3({ source }) {
  const target = source[SLOTS$3][0];
  if (target) {
    this[TARGET_SETTER$3](target);
  }
}

function resetPointer$3({ isActive }) {
  if (this[SLOTS$3][0] && !isActive(this)) {
    this[SLOTS$3][0] = undefined;
  }
}

function disablePointer$3() {
  const disabledProp = { get: throwInaccessiblePointer$3, set: throwInaccessiblePointer$3 };
  const disabledFunc = { value: throwInaccessiblePointer$3 };
  defineProperties$3(this[POINTER$3], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$3]: disabledFunc,
    [SETTER$3]: disabledFunc,
    [TARGET_GETTER$3]: disabledFunc,
  });
}

function visitPointer$3(fn, options = {}) {
  const {
    source,
    isActive = always$3,
    isMutable = always$3,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$3(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$7 = {
  get(pointer, name) {
    if (name === POINTER$3) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$3]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$3]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$3]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$3]();
      return name in target;
    }
  },
};

function always$3() {
  return true;
}

function never$3() {
  return false;
}

function defineStructShape$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$3(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$3.Object);
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$3](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$3(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$3, set: initializer },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$3 },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$7(structure) },
    [POINTER_VISITOR$3]: hasPointer && { value: getPointerVisitor$7(structure, always$3) },
    [NORMALIZER$3]: { value: normalizeStruct$3 },
    [PROPS$3]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$3(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$3.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$3(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$3.bind(this, options),
    length: this[PROPS$3].length,
  };
}

function getStructIterator$3(options) { 
  const entries = getStructEntries$3.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$3(options) {
  const self = this;
  const props = this[PROPS$3];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$3(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$7(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$3.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$3];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$3(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$3][slot] = constructor.call(PARENT$3, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$7(structure, visitorOptions = {}) {
  const {
    isChildActive = always$3,
    isChildMutable = always$3,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$3,
      isMutable = always$3,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$3]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$3][slot] ?? (vivificate ? this[VIVIFICATOR$3](slot) : null);
      if (child) {
        child[POINTER_VISITOR$3](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$3.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$3] = dv;
    if (hasObject) {
      this[SLOTS$3] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$3(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$3(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$3(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$3(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$7(structure) },
    [POINTER_VISITOR$3]: hasPointer && { value: getPointerVisitor$7(structure, { isChildMutable }) },
  });
  defineProperties$3(constructor, {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  });
  return constructor;
}

function defineArray$3(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$3(member, env);
  const hasStringProp = canBeString$3(member);
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$3](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$3(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$3(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$3(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$3(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$3;
  const constructor = structure.constructor = createConstructor$3(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$3(member);
  const hasObject = member.type === MemberType$3.Object;
  const instanceDescriptors = {
    $: { get: getProxy$3, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    string: hasStringProp && getStringDescriptor$3(structure),
    typedArray: typedArray && getTypedArrayDescriptor$3(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$3 },
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [Symbol.iterator]: { value: getArrayIterator$3 },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$6(structure) },
    [POINTER_VISITOR$3]: hasPointer && { value: getPointerVisitor$6() },
    [NORMALIZER$3]: { value: normalizeArray$3 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$3]: { value: getCompatibleTags$3(structure) },
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$3() {
  const proxy = new Proxy(this, proxyHandlers$6);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$3, { value: proxy }); 
  return proxy;
}

function canBeString$3(member) {
  return member.type === MemberType$3.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$3(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$3.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$3() {
  const self = this[ARRAY$3] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$3(options) {
  const self = this[ARRAY$3] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$3(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$3(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$3.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$6(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$3];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$3][index] = constructor.call(PARENT$3, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$6(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$3,
      isMutable = always$3,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$3][i];
      }
      const child = this[SLOTS$3][i] ?? (vivificate ? this[VIVIFICATOR$3](i) : null);
      if (child) {
        child[POINTER_VISITOR$3](cb, childOptions);
      }
    }
  };
}

function transformIterable$3(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$6 = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$3]) {
            array[ELEMENT_GETTER$3] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$3];
        case 'set':
          if (!array[ELEMENT_SETTER$3]) {
            array[ELEMENT_SETTER$3] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$3];
        case ARRAY$3:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$3] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$3] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$3];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$3];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$3);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$3(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$3(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$3({ ...member, type: MemberType$3.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$3(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$3];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$3] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$3(item, { [NAME$3]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$3] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$3];
    } else if (!getDataView$3(structure, arg, env)) {
      throwInvalidInitializer$3(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$3(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$3] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    typedArray: typedArray && getTypedArrayDescriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [NORMALIZER$3]: { value: normalizeEnumerationItem$3 },
  };
  const staticDescriptors = {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
    [ITEMS$3]: { value: {} },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$3(cb) {
  return cb(this.$[NAME$3]);
}

function defineErrorSet$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$3(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$3({ ...member, type: MemberType$3.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$3(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$3][arg];
    } else if (!getDataView$3(structure, arg, env)) {
      throwInvalidInitializer$3(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$3.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$3(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    typedArray: typedArray && getTypedArrayDescriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [NORMALIZER$3]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
    [ITEMS$3]: { value: {} },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$3;

function getGlobalErrorSet$3() {
  return globalErrorSet$3;
}

function defineErrorUnion$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$3(members[0], env);
  const { get: getError, set: setError } = getDescriptor$3(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$3.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$3() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$3]();
    this[POINTER_VISITOR$3]?.(resetPointer$3);
  };
  const hasObject = !!members.find(m => m.type === MemberType$3.Object);
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$3](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$3(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$3(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [RESETTER$3]: { value: getMemoryResetter$3(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$7(structure) },
    [POINTER_VISITOR$3]: hasPointer && { value: getPointerVisitor$7(structure, { isChildActive }) },
    [NORMALIZER$3]: { value: normalizeValue$3 },
  };
  const staticDescriptors = {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$3(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$3(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$3(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [NORMALIZER$3]: { value: normalizeOpaque$3 },
  };
  const staticDescriptors = {
    [COMPAT$3]: { value: getCompatibleTags$3(structure) },
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$3(cb) {
  return {};
}

function defineOptional$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$3(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$3(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$3]?.(resetPointer$3);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$3.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$3](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$3]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$3]?.(resetPointer$3);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$3.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$3]: !hasPointer && { value: getMemoryResetter$3(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$7(structure) },
    [POINTER_VISITOR$3]: hasPointer && { value: getPointerVisitor$7(structure, { isChildActive }) },
    [NORMALIZER$3]: { value: normalizeValue$3 },
  };
  const staticDescriptors = {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$3(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$3(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$3(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$3(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$3] = dv;
    this[LENGTH$3] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$3]) {
      throwArrayLengthMismatch$3(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$3]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$3](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$3(arg);
      if (!this[MEMORY$3]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$3] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$3(structure, arg, !this[MEMORY$3]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$3(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$3(structure, arg);
    }
  };
  const finalizer = createArrayProxy$3;
  const constructor = structure.constructor = createConstructor$3(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$3(member);
  const hasObject = member.type === MemberType$3.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$3, set: initializer },
    length: { get: getLength$3 },
    dataView: getDataViewDescriptor$3(structure, shapeHandlers),
    base64: getBase64Descriptor$3(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$3(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$3(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$3 },
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [Symbol.iterator]: { value: getArrayIterator$3 },
    [COPIER$3]: { value: getMemoryCopier$3(elementSize, true) },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$6(structure) },
    [POINTER_VISITOR$3]: hasPointer && { value: getPointerVisitor$6() },
    [NORMALIZER$3]: { value: normalizeArray$3 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$3]: { value: getCompatibleTags$3(structure) },
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: elementSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$3() {
  return this[LENGTH$3];
}

function getSentinel$3(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$3(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$3(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$3(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$3(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$3(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$3(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$3(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$3].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$3(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$3];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$3(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$3.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$3.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$3(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$3];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$3(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$3(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$3]?.(resetPointer$3);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$3(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$3]?.(resetPointer$3);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$3](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$3(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$3(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$3(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$3](disablePointer$3, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$3(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$3;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$3.Object);
  const instanceDescriptors = {
    $: { get: getSelf$3, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$3 },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [TAG$3]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$3]: hasObject && { value: getChildVivificator$7(structure) },
    [POINTER_VISITOR$3]: hasAnyPointer && { value: getPointerVisitor$7(structure, { isChildActive }) },
    [PROP_GETTERS$3]: { value: memberValueGetters },
    [NORMALIZER$3]: { value: normalizeUnion$3 },
    [PROPS$3]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$3];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$3(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$3.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$3(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$3.bind(this, options),
    length: this[PROPS$3].length,
  };
}

function getUnionIterator$3(options) { 
  const entries = getUnionEntries$3.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$3(options) {
  const self = this;
  const props = this[PROPS$3];
  const getters = this[PROP_GETTERS$3];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$3(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$3(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$3({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$3](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$3(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$3][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$3(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$3(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$3(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$3, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    typedArray: typedArray && getTypedArrayDescriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    entries: { value: getVectorEntries$3 },
    delete: { value: getDestructor$3(structure) },
    [Symbol.iterator]: { value: getVectorIterator$3 },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [NORMALIZER$3]: { value: normalizeVector$3 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$3]: { value: getCompatibleTags$3(structure) },
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$3(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$3.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$3() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$3() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$3() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$3.bind(this),
    length: this.length,
  };
}

const StructureType$3 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$b = Array(Object.values(StructureType$3).length);

function usePrimitive$3() {
  factories$b[StructureType$3.Primitive] = definePrimitive$3;
}

function useArray$3() {
  factories$b[StructureType$3.Array] = defineArray$3;
}

function useStruct$3() {
  factories$b[StructureType$3.Struct] = defineStructShape$3;
}

function usePackedStruct$3() {
  factories$b[StructureType$3.PackedStruct] = defineStructShape$3;
}

function useExternStruct$3() {
  factories$b[StructureType$3.ExternStruct] = defineStructShape$3;
}

function useArgStruct$3() {
  factories$b[StructureType$3.ArgStruct] = defineArgStruct$3;
}

function useExternUnion$3() {
  factories$b[StructureType$3.ExternUnion] = defineUnionShape$3;
}

function useBareUnion$3() {
  factories$b[StructureType$3.BareUnion] = defineUnionShape$3;
}

function useTaggedUnion$3() {
  factories$b[StructureType$3.TaggedUnion] = defineUnionShape$3;
}

function useErrorUnion$3() {
  factories$b[StructureType$3.ErrorUnion] = defineErrorUnion$3;
}

function useErrorSet$3() {
  factories$b[StructureType$3.ErrorSet] = defineErrorSet$3;
}

function useEnumeration$3() {
  factories$b[StructureType$3.Enumeration] = defineEnumerationShape$3;
}

function useOptional$3() {
  factories$b[StructureType$3.Optional] = defineOptional$3;
}

function usePointer$3() {
  factories$b[StructureType$3.Pointer] = definePointer$3;
}

function useSlice$3() {
  factories$b[StructureType$3.Slice] = defineSlice$3;
}

function useVector$3() {
  factories$b[StructureType$3.Vector] = defineVector$3;
}

function useOpaque$3() {
  factories$b[StructureType$3.Opaque] = defineOpaque$3;
}

function defineProperties$3(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$3 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$3, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$3]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$3(constructor.prototype, { 
    [CONST$3]: { value: false },
    [ALL_KEYS$3]: { value: Object.keys(propSetters) },
    [SETTER$3]: { value: set },
    [GETTER$3]: { value: get },
    [PROP_SETTERS$3]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$3(constructor, {
    [CONST_PROTOTYPE$3]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$3(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$3]: { value: true },
    [SETTER$3]: { value: throwReadOnly$3 },
    [VIVIFICATOR$3]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$3(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$3(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$3]) {
    const comptimeMembers = members.filter(m => isReadOnly$3(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$3();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$3(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$3] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$3]; 
      } else {
        self[MEMORY$3] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$3(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$3]);
      if (shapeDefiner) {
        setDataView$3.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$3] = dv;
      }
      if (hasSlots) {
        self[SLOTS$3] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$3](copyPointer$3, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$3][slot] = template[SLOTS$3][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$3]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$3(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$3];
    const allKeys = this[ALL_KEYS$3];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$3(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$3(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$3]) {
          this[COPIER$3](template);
        }
        this[POINTER_VISITOR$3]?.(copyPointer$3, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$3(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$3.Object:
      case MemberType$3.Comptime:
      case MemberType$3.Type:
      case MemberType$3.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$3() {
  return this;
}

function useAllStructureTypes$3() {
  usePrimitive$3();
  useArray$3();
  useStruct$3();
  useExternStruct$3();
  usePackedStruct$3();
  useArgStruct$3();
  useExternUnion$3();
  useBareUnion$3();
  useTaggedUnion$3();
  useErrorUnion$3();
  useErrorSet$3();
  useEnumeration$3();
  useOptional$3();
  usePointer$3();
  useSlice$3();
  useVector$3();
  useOpaque$3();
}

let ObjectCache$3 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$3(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$3(member, env);
  const propApplier = createPropertyApplier$3(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$3](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$3(member);
          throwInvalidInitializer$3(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$3(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$3(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$3(structure),
    base64: getBase64Descriptor$3(structure),
    typedArray: typedArray && getTypedArrayDescriptor$3(structure),
    valueOf: { value: getValueOf$3 },
    toJSON: { value: convertToJSON$3 },
    delete: { value: getDestructor$3(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$3]: { value: getMemoryCopier$3(byteSize) },
    [NORMALIZER$3]: { value: normalizeValue$3 },
  };
  const staticDescriptors = {
    [COMPAT$3]: { value: getCompatibleTags$3(structure) },
    [ALIGN$3]: { value: align },
    [SIZE$3]: { value: byteSize },
  };
  return attachDescriptors$3(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$3(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$3.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$3({ type, bitSize }) {
  if (type === MemberType$3.Int || type === MemberType$3.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$3.Float) {
    return Number;
  } else if (type === MemberType$3.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$3(member) {
  const Primitive = getPrimitiveClass$3(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$3(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$3(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$3.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$3.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$3(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$3);
  if (typedArray) {
    acceptable.push(addArticle$3(typedArray.name));
  }
  if (type === StructureType$3.Slice) {
    throw new TypeError(`Expecting ${formatList$3(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$3(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$3(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$3(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$3(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$3(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$3(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$3(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$3(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$3(type));
    }
  } else {
    acceptable.push(addArticle$3(expected));
  }
  const received = getDescription$3(arg);
  throw new TypeError(`${name} expects ${formatList$3(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$3(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$3(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$3.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$3.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$3(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$3(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$3(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$3(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$3(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$3(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$3(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$3(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$3(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$3(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$3(expected, arg) {
  const received = getDescription$3(arg);
  throw new TypeError(`Expected ${addArticle$3(expected)}, received ${received}`)
}

function throwInaccessiblePointer$3() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$3() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$3(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$3(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$3(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$3(member, value) {
  const typeName = getTypeName$3(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$3(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$3(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$3(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$3(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$3(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$3() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$3(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$3(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$3(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$3(structure, arg) {
  const created = addArticle$3(structure.typedArray.name);
  const source = addArticle$3(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$3(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$3(s);
}

function addArticle$3(noun) {
  return `${article$3(noun)} ${noun}`;
}

function article$3(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$3(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$3(access, member) {
  return cacheMethod$3(access, member, () => {
    if (isByteAligned$3(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$3({ type: MemberType$3.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$3(access, member);
    }
  });
}

function getNumericAccessor$3(access, member) {
  return cacheMethod$3(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$3(access, member);
    }
  });
}

const factories$a = {};

function useExtendedBool$3() {
  factories$a[MemberType$3.Bool] = getExtendedBoolAccessor$3;
}

function useExtendedInt$3() {
  factories$a[MemberType$3.Int] = getExtendedIntAccessor$3;
}

function useExtendedUint$3() {
  factories$a[MemberType$3.Uint] = getExtendedUintAccessor$3;
}

function useExtendedFloat$3() {
  factories$a[MemberType$3.Float] = getExtendedFloatAccessor$3;
}

function getExtendedTypeAccessor$3(access, member) {
  const f = factories$a[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$3(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$3(access, member) {
  if (isByteAligned$3(member)) {
    return getAlignedIntAccessor$3(access, member)
  } else {
    return getUnalignedIntAccessor$3(access, member);
  }
}

function getExtendedUintAccessor$3(access, member) {
  if (isByteAligned$3(member)) {
    return getAlignedUintAccessor$3(access, member)
  } else {
    return getUnalignedUintAccessor$3(access, member);
  }
}

function getExtendedFloatAccessor$3(access, member) {
  if (isByteAligned$3(member)) {
    return getAlignedFloatAccessor$3(access, member)
  } else {
    return getUnalignedFloatAccessor$3(access, member);
  }
}

function getDataView$3(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$3];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$3.Array || type === StructureType$3.Slice || type === StructureType$3.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$3(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$3.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$3(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$3(dv, structure);
  }
  return dv;
}

function checkDataView$3(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$3('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$3(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$3.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$3(structure, dv);
  }
}

function setDataView$3(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$3.Slice;
  if (!this[MEMORY$3]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$3(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$3]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$3](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$3(structure, dv, this);
    }
    const source = { [MEMORY$3]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$3](source); 
  }
}

function findElements$3(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$3(structure, arg, env) {
  const dv = getDataView$3(structure, arg, env);
  if (!dv) {
    throwBufferExpected$3(structure);
  }
  return dv;
}

function getTypedArrayClass$3(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$3.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$3.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$3.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$3.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$3(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$3(arg, constructor) {
  const tags = constructor[COMPAT$3];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$3(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$3(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$3(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$3(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$3.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$3.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$3.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$3.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$3.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$3(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$3(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$3({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$3(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$3(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$3({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$3(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$3(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$3(access, member);
}

function getUnalignedUintAccessor$3(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$3(access, member);
}

function getAlignedFloatAccessor$3(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$3(access, member) {
  return getUnalignedNumericAccessor$3(access, member);
}

function getUnalignedNumericAccessor$3(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$3('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$3(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$3('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$3(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$3 = {};

function cacheMethod$3(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$3(member);
  const suffix = isByteAligned$3(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$3.Int || type === MemberType$3.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$3[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$3(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$3[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$3() {
  useExtendedBool$3();
  useExtendedInt$3();
  useExtendedUint$3();
  useExtendedFloat$3();
}

const MemberType$3 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$3(type) {
  switch (type) {
    case MemberType$3.Type:
    case MemberType$3.Comptime:
    case MemberType$3.Literal:
      return true;
    default:
      return false;
  }
}

const factories$9 = {};

function useVoid$3() {
  factories$9[MemberType$3.Void] = getVoidDescriptor$3;
}

function useBool$3() {
  factories$9[MemberType$3.Bool] = getBoolDescriptor$3;
}

function useInt$3() {
  factories$9[MemberType$3.Int] = getIntDescriptor$3;
}

function useUint$3() {
  factories$9[MemberType$3.Uint] = getUintDescriptor$3;
}

function useFloat$3() {
  factories$9[MemberType$3.Float] = getFloatDescriptor$3;
}

function useEnumerationItem$3() {
  factories$9[MemberType$3.EnumerationItem] = getEnumerationItemDescriptor$3;
}

function useError$3() {
  factories$9[MemberType$3.Error] = getErrorDescriptor$3;
}

function useObject$3() {
  factories$9[MemberType$3.Object] = getObjectDescriptor$3;
}

function useType$3() {
  factories$9[MemberType$3.Type] = getTypeDescriptor$3;
}

function useComptime$3() {
  factories$9[MemberType$3.Comptime] = getComptimeDescriptor$3;
}

function useStatic$3() {
  factories$9[MemberType$3.Static] = getStaticDescriptor$3;
}

function useLiteral$3() {
  factories$9[MemberType$3.Literal] = getLiteralDescriptor$3;
}

function useNull$3() {
  factories$9[MemberType$3.Null] = getNullDescriptor$3;
}

function useUndefined$3() {
  factories$9[MemberType$3.Undefined] = getUndefinedDescriptor$3;
}

function isByteAligned$3({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$3(member, env) {
  const f = factories$9[member.type];
  return f(member, env);
}

function getVoidDescriptor$3(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$3(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$3(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$3(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$3(member, env) {
  return getDescriptorUsing$3(member, env, getBoolAccessor$3)
}

function getIntDescriptor$3(member, env) {
  const getDataViewAccessor = addRuntimeCheck$3(env, getNumericAccessor$3);
  return getDescriptorUsing$3(member, env, getDataViewAccessor)
}

function getUintDescriptor$3(member, env) {
  const getDataViewAccessor = addRuntimeCheck$3(env, getNumericAccessor$3);
  return getDescriptorUsing$3(member, env, getDataViewAccessor)
}

function addRuntimeCheck$3(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$3(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$3(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$3(member, env) {
  return getDescriptorUsing$3(member, env, getNumericAccessor$3)
}

function getValueDescriptor$3(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$3(valueMember, env);
}

function getEnumerationItemDescriptor$3(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$3(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$3(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$3(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$3(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$3();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$3(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$3(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$3(structure) {
  switch (structure.type) {
    case StructureType$3.Primitive:
    case StructureType$3.ErrorUnion:
    case StructureType$3.Optional:
    case StructureType$3.Enumeration:
    case StructureType$3.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$3(slot) {
  const object = this[SLOTS$3][slot] ?? this[VIVIFICATOR$3](slot);
  return object[GETTER$3]();
}

function getObject$3(slot) {
  const object = this[SLOTS$3][slot] ?? this[VIVIFICATOR$3](slot);
  return object;
}

function setValue$3(slot, value) {
  const object = this[SLOTS$3][slot] ?? this[VIVIFICATOR$3](slot);
  object[SETTER$3](value);
}

function bindSlot$3(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$3(member, env) {
  const { structure, slot } = member;
  return bindSlot$3(slot, {
    get: isValueExpected$3(structure) ? getValue$3 : getObject$3,
    set: setValue$3,
  });
}

function getType$3(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$3][slot];
  return structure?.constructor;
}

function getTypeDescriptor$3(member, env) {
  const { slot } = member;
  return bindSlot$3(slot, { get: getType$3 });
}

function getComptimeDescriptor$3(member, env) {
  const { slot, structure } = member;
  return bindSlot$3(slot, {
    get: isValueExpected$3(structure) ? getValue$3 : getObject$3,
  });
}

function getStaticDescriptor$3(member, env) {
  const { slot, structure } = member;
  return bindSlot$3(slot, {
    get: isValueExpected$3(structure) ? getValue$3 : getObject$3,
    set: setValue$3,
  });
}

function getLiteral$3(slot) {
  const object = this[SLOTS$3][slot];
  return object.string;
}

function getLiteralDescriptor$3(member, env) {
  const { slot } = member;
  return bindSlot$3(slot, { get: getLiteral$3 });
}

function getDescriptorUsing$3(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$3], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$3.call(this)) {
            return getter.call(this[MEMORY$3], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$3], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$3.call(this)) {
            return setter.call(this[MEMORY$3], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$3], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$3.call(this)) {
            return getter.call(this[MEMORY$3], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$3(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$3], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$3.call(this)) {
            return setter.call(this[MEMORY$3], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$3(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$3() {
  useVoid$3();
  useNull$3();
  useUndefined$3();
  useBool$3();
  useInt$3();
  useUint$3();
  useFloat$3();
  useEnumerationItem$3();
  useError$3();
  useObject$3();
  useType$3();
  useComptime$3();
  useStatic$3();
  useLiteral$3();
}

process.cwd();

useAllMemberTypes$3();
useAllStructureTypes$3();
useAllExtendedTypes$3();

const MEMORY$2 = Symbol('memory');
const SLOTS$2 = Symbol('slots');
const PARENT$2 = Symbol('parent');
const NAME$2 = Symbol('name');
const TAG$2 = Symbol('tag');
const ITEMS$2 = Symbol('items');
const PROPS$2 = Symbol('props');
const GETTER$2 = Symbol('getter');
const SETTER$2 = Symbol('setter');
const ELEMENT_GETTER$2 = Symbol('elementGetter');
const ELEMENT_SETTER$2 = Symbol('elementSetter');
const LOCATION_GETTER$2 = Symbol('addressGetter');
const LOCATION_SETTER$2 = Symbol('addressSetter');
const TARGET_GETTER$2 = Symbol('targetGetter');
const TARGET_SETTER$2 = Symbol('targetSetter');
const FIXED_LOCATION$2 = Symbol('fixedLocation');
const PROP_GETTERS$2 = Symbol('propGetters');
const PROP_SETTERS$2 = Symbol('propSetters');
const ALL_KEYS$2 = Symbol('allKeys');
const LENGTH$2 = Symbol('length');
const PROXY$2 = Symbol('proxy');
const COMPAT$2 = Symbol('compat');
const SIZE$2 = Symbol('size');
const ALIGN$2 = Symbol('align');
const ARRAY$2 = Symbol('array');
const POINTER$2 = Symbol('pointer');
const CONST$2 = Symbol('const');
const CONST_PROTOTYPE$2 = Symbol('constProto');
const COPIER$2 = Symbol('copier');
const RESETTER$2 = Symbol('resetter');
const NORMALIZER$2 = Symbol('normalizer');
const VIVIFICATOR$2 = Symbol('vivificator');
const POINTER_VISITOR$2 = Symbol('pointerVisitor');
const ENVIRONMENT$2 = Symbol('environment');
const MORE$2 = Symbol('more');

function getDestructor$2(env) {
  return function() {
    const dv = this[MEMORY$2];
    this[MEMORY$2] = null;
    if (this[SLOTS$2]) {
      this[SLOTS$2] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$2(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$2(size, multiple = false) {
  const copy = getCopyFunction$2(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$2.call(this);
    restoreMemory$2.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$2];
    const dest = this[MEMORY$2];
    copy(dest, src);
  };
}

function getCopyFunction$2(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$2[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$2;
  if (!(size & 0x03)) return copy4x$2;
  if (!(size & 0x01)) return copy2x$2;
  return copy1x$2;
}

const copiers$2 = {
  1: copy1$2,
  2: copy2$2,
  4: copy4$2,
  8: copy8$2,
  16: copy16$2,
  32: copy32$2,
};

function copy1x$2(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$2(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$2(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$2(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$2(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$2(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$2(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$2(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$2(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$2(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$2(offset, size) {
  const reset = getResetFunction$2(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$2.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$2];
    reset(dest, offset, size);
  };
}

function getResetFunction$2(size) {
  const resetter = resetters$2[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$2;
  if (!(size & 0x03)) return reset4x$2;
  if (!(size & 0x01)) return reset2x$2;
  return reset1x$2;
}

const resetters$2 = {
  1: reset1$2,
  2: reset2$2,
  4: reset4$2,
  8: reset8$2,
  16: reset16$2,
  32: reset32$2,
};

function reset1x$2(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$2(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$2(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$2(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$2(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$2(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$2(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$2(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$2(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$2(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$2() {
  const dv = this[MEMORY$2];
  const source = dv[MEMORY$2];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$2] = source;
  this[MEMORY$2] = newDV;
  return true;
}

const decoders$2 = {};
const encoders$2 = {};

function decodeText$2(arrays, encoding = 'utf-8') {
  let decoder = decoders$2[encoding];
  if (!decoder) {
    decoder = decoders$2[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$2(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$2[encoding];
      if (!encoder) {
        encoder = encoders$2[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$2(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$2(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$2() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$2];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$2 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$2 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$2() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$2];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$2 <= value && value <= INT_MAX$2) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$2(cb, options) {
  const value = handleError$2(() => this.$, options);
  return cb(value);
}

function handleError$2(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$2(structure, handlers = {}) {
  return markAsSpecial$2({
    get() {
      /* WASM-ONLY */
      restoreMemory$2.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$2];
    },
    set(dv) {
      checkDataView$2(dv);
      setDataView$2.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$2(structure, handlers = {}) {
  return markAsSpecial$2({
    get() {
      return encodeBase64$2(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$2('string', str);
      }
      const dv = decodeBase64$2(str);
      setDataView$2.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$2(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$2({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$2(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$2('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$2(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$2.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$2(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$2({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$2(ta, typedArray)) {
        throwTypeMismatch$2(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$2.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$2({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$2.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$2.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$2({
    type: MemberType$2.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$2({
    type: MemberType$2.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$2];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$2]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$2]);
        const target = Target.call(ENVIRONMENT$2, dv, { writable: !isConst });
        this[SLOTS$2][0] = target;
        this[FIXED_LOCATION$2] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$2][0] ?? throwNullPointer$2();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$2]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$2] = loc;
      } else {
        throwFixedMemoryTargetRequired$2();
      }
    }
    this[SLOTS$2][0] = arg;
  };
  const getTarget = isValueExpected$2(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$2]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$2][0] ?? throwNullPointer$2();
    return object[SETTER$2](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$2 || this === PARENT$2) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$2(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$2();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$5;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$2, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$2(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$2(structure, arg);
      }
      arg = arg[SLOTS$2][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$2.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$2]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$2]) {
        throwReadOnlyTarget$2(structure);       
      }
    } else if (isCompatible$2(arg, Target)) {
      // autocast to target type
      const dv = getDataView$2(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$2]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$2(arg?.buffer)) {
          warnImplicitArrayCreation$2(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$2(structure, arg);
    }
    this[TARGET_SETTER$2](arg);
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$2, set: initializer },
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [TARGET_GETTER$2]: { value: getTargetObject },
    [TARGET_SETTER$2]: { value: setTargetObject },
    [LOCATION_GETTER$2]: { value: addressGetter },
    [LOCATION_SETTER$2]: { value: addressSetter },
    [POINTER_VISITOR$2]: { value: visitPointer$2 },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [VIVIFICATOR$2]: { value: throwNullPointer$2 },
    [NORMALIZER$2]: { value: normalizePointer$2 },
    [FIXED_LOCATION$2]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$2(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$2() {
  return this[PROXY$2];
}

function copyPointer$2({ source }) {
  const target = source[SLOTS$2][0];
  if (target) {
    this[TARGET_SETTER$2](target);
  }
}

function resetPointer$2({ isActive }) {
  if (this[SLOTS$2][0] && !isActive(this)) {
    this[SLOTS$2][0] = undefined;
  }
}

function disablePointer$2() {
  const disabledProp = { get: throwInaccessiblePointer$2, set: throwInaccessiblePointer$2 };
  const disabledFunc = { value: throwInaccessiblePointer$2 };
  defineProperties$2(this[POINTER$2], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$2]: disabledFunc,
    [SETTER$2]: disabledFunc,
    [TARGET_GETTER$2]: disabledFunc,
  });
}

function visitPointer$2(fn, options = {}) {
  const {
    source,
    isActive = always$2,
    isMutable = always$2,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$2(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$5 = {
  get(pointer, name) {
    if (name === POINTER$2) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$2]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$2]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$2]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$2]();
      return name in target;
    }
  },
};

function always$2() {
  return true;
}

function never$2() {
  return false;
}

function defineStructShape$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$2(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$2.Object);
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$2](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$2(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$2, set: initializer },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$2 },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$5(structure) },
    [POINTER_VISITOR$2]: hasPointer && { value: getPointerVisitor$5(structure, always$2) },
    [NORMALIZER$2]: { value: normalizeStruct$2 },
    [PROPS$2]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$2(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$2.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$2(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$2.bind(this, options),
    length: this[PROPS$2].length,
  };
}

function getStructIterator$2(options) { 
  const entries = getStructEntries$2.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$2(options) {
  const self = this;
  const props = this[PROPS$2];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$2(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$5(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$2.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$2];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$2(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$2][slot] = constructor.call(PARENT$2, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$5(structure, visitorOptions = {}) {
  const {
    isChildActive = always$2,
    isChildMutable = always$2,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$2,
      isMutable = always$2,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$2]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$2][slot] ?? (vivificate ? this[VIVIFICATOR$2](slot) : null);
      if (child) {
        child[POINTER_VISITOR$2](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$2.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$2] = dv;
    if (hasObject) {
      this[SLOTS$2] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$2(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$2(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$2(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$2(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$5(structure) },
    [POINTER_VISITOR$2]: hasPointer && { value: getPointerVisitor$5(structure, { isChildMutable }) },
  });
  defineProperties$2(constructor, {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  });
  return constructor;
}

function defineArray$2(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$2(member, env);
  const hasStringProp = canBeString$2(member);
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$2](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$2(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$2(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$2(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$2(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$2;
  const constructor = structure.constructor = createConstructor$2(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$2(member);
  const hasObject = member.type === MemberType$2.Object;
  const instanceDescriptors = {
    $: { get: getProxy$2, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    string: hasStringProp && getStringDescriptor$2(structure),
    typedArray: typedArray && getTypedArrayDescriptor$2(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$2 },
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [Symbol.iterator]: { value: getArrayIterator$2 },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$4(structure) },
    [POINTER_VISITOR$2]: hasPointer && { value: getPointerVisitor$4() },
    [NORMALIZER$2]: { value: normalizeArray$2 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$2]: { value: getCompatibleTags$2(structure) },
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$2() {
  const proxy = new Proxy(this, proxyHandlers$4);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$2, { value: proxy }); 
  return proxy;
}

function canBeString$2(member) {
  return member.type === MemberType$2.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$2(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$2.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$2() {
  const self = this[ARRAY$2] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$2(options) {
  const self = this[ARRAY$2] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$2(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$2(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$2.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$4(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$2];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$2][index] = constructor.call(PARENT$2, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$4(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$2,
      isMutable = always$2,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$2][i];
      }
      const child = this[SLOTS$2][i] ?? (vivificate ? this[VIVIFICATOR$2](i) : null);
      if (child) {
        child[POINTER_VISITOR$2](cb, childOptions);
      }
    }
  };
}

function transformIterable$2(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$4 = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$2]) {
            array[ELEMENT_GETTER$2] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$2];
        case 'set':
          if (!array[ELEMENT_SETTER$2]) {
            array[ELEMENT_SETTER$2] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$2];
        case ARRAY$2:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$2] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$2] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$2];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$2];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$2);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$2(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$2(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$2({ ...member, type: MemberType$2.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$2(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$2];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$2] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$2(item, { [NAME$2]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$2] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$2];
    } else if (!getDataView$2(structure, arg, env)) {
      throwInvalidInitializer$2(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$2(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$2] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    typedArray: typedArray && getTypedArrayDescriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [NORMALIZER$2]: { value: normalizeEnumerationItem$2 },
  };
  const staticDescriptors = {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
    [ITEMS$2]: { value: {} },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$2(cb) {
  return cb(this.$[NAME$2]);
}

function defineErrorSet$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$2(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$2({ ...member, type: MemberType$2.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$2(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$2][arg];
    } else if (!getDataView$2(structure, arg, env)) {
      throwInvalidInitializer$2(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$2.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$2(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    typedArray: typedArray && getTypedArrayDescriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [NORMALIZER$2]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
    [ITEMS$2]: { value: {} },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$2;

function getGlobalErrorSet$2() {
  return globalErrorSet$2;
}

function defineErrorUnion$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$2(members[0], env);
  const { get: getError, set: setError } = getDescriptor$2(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$2.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$2() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$2]();
    this[POINTER_VISITOR$2]?.(resetPointer$2);
  };
  const hasObject = !!members.find(m => m.type === MemberType$2.Object);
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$2](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$2(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$2(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [RESETTER$2]: { value: getMemoryResetter$2(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$5(structure) },
    [POINTER_VISITOR$2]: hasPointer && { value: getPointerVisitor$5(structure, { isChildActive }) },
    [NORMALIZER$2]: { value: normalizeValue$2 },
  };
  const staticDescriptors = {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$2(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$2(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$2(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [NORMALIZER$2]: { value: normalizeOpaque$2 },
  };
  const staticDescriptors = {
    [COMPAT$2]: { value: getCompatibleTags$2(structure) },
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$2(cb) {
  return {};
}

function defineOptional$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$2(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$2(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$2]?.(resetPointer$2);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$2.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$2](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$2]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$2]?.(resetPointer$2);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$2.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$2]: !hasPointer && { value: getMemoryResetter$2(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$5(structure) },
    [POINTER_VISITOR$2]: hasPointer && { value: getPointerVisitor$5(structure, { isChildActive }) },
    [NORMALIZER$2]: { value: normalizeValue$2 },
  };
  const staticDescriptors = {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$2(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$2(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$2(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$2(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$2] = dv;
    this[LENGTH$2] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$2]) {
      throwArrayLengthMismatch$2(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$2]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$2](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$2(arg);
      if (!this[MEMORY$2]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$2] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$2(structure, arg, !this[MEMORY$2]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$2(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$2(structure, arg);
    }
  };
  const finalizer = createArrayProxy$2;
  const constructor = structure.constructor = createConstructor$2(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$2(member);
  const hasObject = member.type === MemberType$2.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$2, set: initializer },
    length: { get: getLength$2 },
    dataView: getDataViewDescriptor$2(structure, shapeHandlers),
    base64: getBase64Descriptor$2(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$2(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$2(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$2 },
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [Symbol.iterator]: { value: getArrayIterator$2 },
    [COPIER$2]: { value: getMemoryCopier$2(elementSize, true) },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$4(structure) },
    [POINTER_VISITOR$2]: hasPointer && { value: getPointerVisitor$4() },
    [NORMALIZER$2]: { value: normalizeArray$2 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$2]: { value: getCompatibleTags$2(structure) },
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: elementSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$2() {
  return this[LENGTH$2];
}

function getSentinel$2(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$2(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$2(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$2(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$2(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$2(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$2(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$2(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$2].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$2(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$2];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$2(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$2.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$2.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$2(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$2];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$2(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$2(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$2]?.(resetPointer$2);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$2(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$2]?.(resetPointer$2);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$2](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$2(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$2(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$2(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$2](disablePointer$2, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$2(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$2;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$2.Object);
  const instanceDescriptors = {
    $: { get: getSelf$2, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$2 },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [TAG$2]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$2]: hasObject && { value: getChildVivificator$5(structure) },
    [POINTER_VISITOR$2]: hasAnyPointer && { value: getPointerVisitor$5(structure, { isChildActive }) },
    [PROP_GETTERS$2]: { value: memberValueGetters },
    [NORMALIZER$2]: { value: normalizeUnion$2 },
    [PROPS$2]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$2];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$2(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$2.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$2(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$2.bind(this, options),
    length: this[PROPS$2].length,
  };
}

function getUnionIterator$2(options) { 
  const entries = getUnionEntries$2.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$2(options) {
  const self = this;
  const props = this[PROPS$2];
  const getters = this[PROP_GETTERS$2];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$2(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$2(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$2({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$2](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$2(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$2][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$2(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$2(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$2(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$2, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    typedArray: typedArray && getTypedArrayDescriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    entries: { value: getVectorEntries$2 },
    delete: { value: getDestructor$2(structure) },
    [Symbol.iterator]: { value: getVectorIterator$2 },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [NORMALIZER$2]: { value: normalizeVector$2 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$2]: { value: getCompatibleTags$2(structure) },
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$2(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$2.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$2() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$2() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$2() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$2.bind(this),
    length: this.length,
  };
}

const StructureType$2 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$8 = Array(Object.values(StructureType$2).length);

function usePrimitive$2() {
  factories$8[StructureType$2.Primitive] = definePrimitive$2;
}

function useArray$2() {
  factories$8[StructureType$2.Array] = defineArray$2;
}

function useStruct$2() {
  factories$8[StructureType$2.Struct] = defineStructShape$2;
}

function usePackedStruct$2() {
  factories$8[StructureType$2.PackedStruct] = defineStructShape$2;
}

function useExternStruct$2() {
  factories$8[StructureType$2.ExternStruct] = defineStructShape$2;
}

function useArgStruct$2() {
  factories$8[StructureType$2.ArgStruct] = defineArgStruct$2;
}

function useExternUnion$2() {
  factories$8[StructureType$2.ExternUnion] = defineUnionShape$2;
}

function useBareUnion$2() {
  factories$8[StructureType$2.BareUnion] = defineUnionShape$2;
}

function useTaggedUnion$2() {
  factories$8[StructureType$2.TaggedUnion] = defineUnionShape$2;
}

function useErrorUnion$2() {
  factories$8[StructureType$2.ErrorUnion] = defineErrorUnion$2;
}

function useErrorSet$2() {
  factories$8[StructureType$2.ErrorSet] = defineErrorSet$2;
}

function useEnumeration$2() {
  factories$8[StructureType$2.Enumeration] = defineEnumerationShape$2;
}

function useOptional$2() {
  factories$8[StructureType$2.Optional] = defineOptional$2;
}

function usePointer$2() {
  factories$8[StructureType$2.Pointer] = definePointer$2;
}

function useSlice$2() {
  factories$8[StructureType$2.Slice] = defineSlice$2;
}

function useVector$2() {
  factories$8[StructureType$2.Vector] = defineVector$2;
}

function useOpaque$2() {
  factories$8[StructureType$2.Opaque] = defineOpaque$2;
}

function defineProperties$2(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$2 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$2, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$2]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$2(constructor.prototype, { 
    [CONST$2]: { value: false },
    [ALL_KEYS$2]: { value: Object.keys(propSetters) },
    [SETTER$2]: { value: set },
    [GETTER$2]: { value: get },
    [PROP_SETTERS$2]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$2(constructor, {
    [CONST_PROTOTYPE$2]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$2(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$2]: { value: true },
    [SETTER$2]: { value: throwReadOnly$2 },
    [VIVIFICATOR$2]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$2(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$2(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$2]) {
    const comptimeMembers = members.filter(m => isReadOnly$2(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$2();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$2(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$2] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$2]; 
      } else {
        self[MEMORY$2] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$2(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$2]);
      if (shapeDefiner) {
        setDataView$2.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$2] = dv;
      }
      if (hasSlots) {
        self[SLOTS$2] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$2](copyPointer$2, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$2][slot] = template[SLOTS$2][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$2]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$2(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$2];
    const allKeys = this[ALL_KEYS$2];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$2(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$2(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$2]) {
          this[COPIER$2](template);
        }
        this[POINTER_VISITOR$2]?.(copyPointer$2, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$2(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$2.Object:
      case MemberType$2.Comptime:
      case MemberType$2.Type:
      case MemberType$2.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$2() {
  return this;
}

function useAllStructureTypes$2() {
  usePrimitive$2();
  useArray$2();
  useStruct$2();
  useExternStruct$2();
  usePackedStruct$2();
  useArgStruct$2();
  useExternUnion$2();
  useBareUnion$2();
  useTaggedUnion$2();
  useErrorUnion$2();
  useErrorSet$2();
  useEnumeration$2();
  useOptional$2();
  usePointer$2();
  useSlice$2();
  useVector$2();
  useOpaque$2();
}

let ObjectCache$2 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$2(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$2(member, env);
  const propApplier = createPropertyApplier$2(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$2](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$2(member);
          throwInvalidInitializer$2(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$2(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$2(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$2(structure),
    base64: getBase64Descriptor$2(structure),
    typedArray: typedArray && getTypedArrayDescriptor$2(structure),
    valueOf: { value: getValueOf$2 },
    toJSON: { value: convertToJSON$2 },
    delete: { value: getDestructor$2(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$2]: { value: getMemoryCopier$2(byteSize) },
    [NORMALIZER$2]: { value: normalizeValue$2 },
  };
  const staticDescriptors = {
    [COMPAT$2]: { value: getCompatibleTags$2(structure) },
    [ALIGN$2]: { value: align },
    [SIZE$2]: { value: byteSize },
  };
  return attachDescriptors$2(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$2(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$2.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$2({ type, bitSize }) {
  if (type === MemberType$2.Int || type === MemberType$2.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$2.Float) {
    return Number;
  } else if (type === MemberType$2.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$2(member) {
  const Primitive = getPrimitiveClass$2(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$2(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$2(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$2.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$2.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$2(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$2);
  if (typedArray) {
    acceptable.push(addArticle$2(typedArray.name));
  }
  if (type === StructureType$2.Slice) {
    throw new TypeError(`Expecting ${formatList$2(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$2(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$2(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$2(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$2(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$2(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$2(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$2(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$2(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$2(type));
    }
  } else {
    acceptable.push(addArticle$2(expected));
  }
  const received = getDescription$2(arg);
  throw new TypeError(`${name} expects ${formatList$2(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$2(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$2(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$2.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$2.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$2(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$2(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$2(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$2(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$2(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$2(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$2(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$2(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$2(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$2(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$2(expected, arg) {
  const received = getDescription$2(arg);
  throw new TypeError(`Expected ${addArticle$2(expected)}, received ${received}`)
}

function throwInaccessiblePointer$2() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$2() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$2(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$2(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$2(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$2(member, value) {
  const typeName = getTypeName$2(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$2(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$2(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$2(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$2(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$2(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$2() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$2(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$2(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$2(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$2(structure, arg) {
  const created = addArticle$2(structure.typedArray.name);
  const source = addArticle$2(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$2(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$2(s);
}

function addArticle$2(noun) {
  return `${article$2(noun)} ${noun}`;
}

function article$2(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$2(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$2(access, member) {
  return cacheMethod$2(access, member, () => {
    if (isByteAligned$2(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$2({ type: MemberType$2.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$2(access, member);
    }
  });
}

function getNumericAccessor$2(access, member) {
  return cacheMethod$2(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$2(access, member);
    }
  });
}

const factories$7 = {};

function useExtendedBool$2() {
  factories$7[MemberType$2.Bool] = getExtendedBoolAccessor$2;
}

function useExtendedInt$2() {
  factories$7[MemberType$2.Int] = getExtendedIntAccessor$2;
}

function useExtendedUint$2() {
  factories$7[MemberType$2.Uint] = getExtendedUintAccessor$2;
}

function useExtendedFloat$2() {
  factories$7[MemberType$2.Float] = getExtendedFloatAccessor$2;
}

function getExtendedTypeAccessor$2(access, member) {
  const f = factories$7[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$2(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$2(access, member) {
  if (isByteAligned$2(member)) {
    return getAlignedIntAccessor$2(access, member)
  } else {
    return getUnalignedIntAccessor$2(access, member);
  }
}

function getExtendedUintAccessor$2(access, member) {
  if (isByteAligned$2(member)) {
    return getAlignedUintAccessor$2(access, member)
  } else {
    return getUnalignedUintAccessor$2(access, member);
  }
}

function getExtendedFloatAccessor$2(access, member) {
  if (isByteAligned$2(member)) {
    return getAlignedFloatAccessor$2(access, member)
  } else {
    return getUnalignedFloatAccessor$2(access, member);
  }
}

function getDataView$2(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$2];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$2.Array || type === StructureType$2.Slice || type === StructureType$2.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$2(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$2.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$2(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$2(dv, structure);
  }
  return dv;
}

function checkDataView$2(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$2('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$2(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$2.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$2(structure, dv);
  }
}

function setDataView$2(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$2.Slice;
  if (!this[MEMORY$2]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$2(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$2]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$2](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$2(structure, dv, this);
    }
    const source = { [MEMORY$2]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$2](source); 
  }
}

function findElements$2(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$2(structure, arg, env) {
  const dv = getDataView$2(structure, arg, env);
  if (!dv) {
    throwBufferExpected$2(structure);
  }
  return dv;
}

function getTypedArrayClass$2(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$2.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$2.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$2.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$2.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$2(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$2(arg, constructor) {
  const tags = constructor[COMPAT$2];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$2(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$2(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$2(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$2(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$2.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$2.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$2.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$2.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$2.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$2(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$2(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$2({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$2(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$2(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$2({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$2(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$2(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$2(access, member);
}

function getUnalignedUintAccessor$2(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$2(access, member);
}

function getAlignedFloatAccessor$2(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$2(access, member) {
  return getUnalignedNumericAccessor$2(access, member);
}

function getUnalignedNumericAccessor$2(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$2('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$2(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$2('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$2(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$2 = {};

function cacheMethod$2(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$2(member);
  const suffix = isByteAligned$2(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$2.Int || type === MemberType$2.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$2[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$2(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$2[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$2() {
  useExtendedBool$2();
  useExtendedInt$2();
  useExtendedUint$2();
  useExtendedFloat$2();
}

const MemberType$2 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$2(type) {
  switch (type) {
    case MemberType$2.Type:
    case MemberType$2.Comptime:
    case MemberType$2.Literal:
      return true;
    default:
      return false;
  }
}

const factories$6 = {};

function useVoid$2() {
  factories$6[MemberType$2.Void] = getVoidDescriptor$2;
}

function useBool$2() {
  factories$6[MemberType$2.Bool] = getBoolDescriptor$2;
}

function useInt$2() {
  factories$6[MemberType$2.Int] = getIntDescriptor$2;
}

function useUint$2() {
  factories$6[MemberType$2.Uint] = getUintDescriptor$2;
}

function useFloat$2() {
  factories$6[MemberType$2.Float] = getFloatDescriptor$2;
}

function useEnumerationItem$2() {
  factories$6[MemberType$2.EnumerationItem] = getEnumerationItemDescriptor$2;
}

function useError$2() {
  factories$6[MemberType$2.Error] = getErrorDescriptor$2;
}

function useObject$2() {
  factories$6[MemberType$2.Object] = getObjectDescriptor$2;
}

function useType$2() {
  factories$6[MemberType$2.Type] = getTypeDescriptor$2;
}

function useComptime$2() {
  factories$6[MemberType$2.Comptime] = getComptimeDescriptor$2;
}

function useStatic$2() {
  factories$6[MemberType$2.Static] = getStaticDescriptor$2;
}

function useLiteral$2() {
  factories$6[MemberType$2.Literal] = getLiteralDescriptor$2;
}

function useNull$2() {
  factories$6[MemberType$2.Null] = getNullDescriptor$2;
}

function useUndefined$2() {
  factories$6[MemberType$2.Undefined] = getUndefinedDescriptor$2;
}

function isByteAligned$2({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$2(member, env) {
  const f = factories$6[member.type];
  return f(member, env);
}

function getVoidDescriptor$2(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$2(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$2(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$2(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$2(member, env) {
  return getDescriptorUsing$2(member, env, getBoolAccessor$2)
}

function getIntDescriptor$2(member, env) {
  const getDataViewAccessor = addRuntimeCheck$2(env, getNumericAccessor$2);
  return getDescriptorUsing$2(member, env, getDataViewAccessor)
}

function getUintDescriptor$2(member, env) {
  const getDataViewAccessor = addRuntimeCheck$2(env, getNumericAccessor$2);
  return getDescriptorUsing$2(member, env, getDataViewAccessor)
}

function addRuntimeCheck$2(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$2(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$2(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$2(member, env) {
  return getDescriptorUsing$2(member, env, getNumericAccessor$2)
}

function getValueDescriptor$2(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$2(valueMember, env);
}

function getEnumerationItemDescriptor$2(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$2(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$2(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$2(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$2(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$2();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$2(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$2(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$2(structure) {
  switch (structure.type) {
    case StructureType$2.Primitive:
    case StructureType$2.ErrorUnion:
    case StructureType$2.Optional:
    case StructureType$2.Enumeration:
    case StructureType$2.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$2(slot) {
  const object = this[SLOTS$2][slot] ?? this[VIVIFICATOR$2](slot);
  return object[GETTER$2]();
}

function getObject$2(slot) {
  const object = this[SLOTS$2][slot] ?? this[VIVIFICATOR$2](slot);
  return object;
}

function setValue$2(slot, value) {
  const object = this[SLOTS$2][slot] ?? this[VIVIFICATOR$2](slot);
  object[SETTER$2](value);
}

function bindSlot$2(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$2(member, env) {
  const { structure, slot } = member;
  return bindSlot$2(slot, {
    get: isValueExpected$2(structure) ? getValue$2 : getObject$2,
    set: setValue$2,
  });
}

function getType$2(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$2][slot];
  return structure?.constructor;
}

function getTypeDescriptor$2(member, env) {
  const { slot } = member;
  return bindSlot$2(slot, { get: getType$2 });
}

function getComptimeDescriptor$2(member, env) {
  const { slot, structure } = member;
  return bindSlot$2(slot, {
    get: isValueExpected$2(structure) ? getValue$2 : getObject$2,
  });
}

function getStaticDescriptor$2(member, env) {
  const { slot, structure } = member;
  return bindSlot$2(slot, {
    get: isValueExpected$2(structure) ? getValue$2 : getObject$2,
    set: setValue$2,
  });
}

function getLiteral$2(slot) {
  const object = this[SLOTS$2][slot];
  return object.string;
}

function getLiteralDescriptor$2(member, env) {
  const { slot } = member;
  return bindSlot$2(slot, { get: getLiteral$2 });
}

function getDescriptorUsing$2(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$2], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$2.call(this)) {
            return getter.call(this[MEMORY$2], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$2], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$2.call(this)) {
            return setter.call(this[MEMORY$2], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$2], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$2.call(this)) {
            return getter.call(this[MEMORY$2], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$2(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$2], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$2.call(this)) {
            return setter.call(this[MEMORY$2], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$2(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$2() {
  useVoid$2();
  useNull$2();
  useUndefined$2();
  useBool$2();
  useInt$2();
  useUint$2();
  useFloat$2();
  useEnumerationItem$2();
  useError$2();
  useObject$2();
  useType$2();
  useComptime$2();
  useStatic$2();
  useLiteral$2();
}

process.cwd();

useAllMemberTypes$2();
useAllStructureTypes$2();
useAllExtendedTypes$2();

const MEMORY$1 = Symbol('memory');
const SLOTS$1 = Symbol('slots');
const PARENT$1 = Symbol('parent');
const NAME$1 = Symbol('name');
const TAG$1 = Symbol('tag');
const ITEMS$1 = Symbol('items');
const PROPS$1 = Symbol('props');
const GETTER$1 = Symbol('getter');
const SETTER$1 = Symbol('setter');
const ELEMENT_GETTER$1 = Symbol('elementGetter');
const ELEMENT_SETTER$1 = Symbol('elementSetter');
const LOCATION_GETTER$1 = Symbol('addressGetter');
const LOCATION_SETTER$1 = Symbol('addressSetter');
const TARGET_GETTER$1 = Symbol('targetGetter');
const TARGET_SETTER$1 = Symbol('targetSetter');
const FIXED_LOCATION$1 = Symbol('fixedLocation');
const PROP_GETTERS$1 = Symbol('propGetters');
const PROP_SETTERS$1 = Symbol('propSetters');
const ALL_KEYS$1 = Symbol('allKeys');
const LENGTH$1 = Symbol('length');
const PROXY$1 = Symbol('proxy');
const COMPAT$1 = Symbol('compat');
const SIZE$1 = Symbol('size');
const ALIGN$1 = Symbol('align');
const ARRAY$1 = Symbol('array');
const POINTER$1 = Symbol('pointer');
const CONST$1 = Symbol('const');
const CONST_PROTOTYPE$1 = Symbol('constProto');
const COPIER$1 = Symbol('copier');
const RESETTER$1 = Symbol('resetter');
const NORMALIZER$1 = Symbol('normalizer');
const VIVIFICATOR$1 = Symbol('vivificator');
const POINTER_VISITOR$1 = Symbol('pointerVisitor');
const ENVIRONMENT$1 = Symbol('environment');
const MORE$1 = Symbol('more');

function getDestructor$1(env) {
  return function() {
    const dv = this[MEMORY$1];
    this[MEMORY$1] = null;
    if (this[SLOTS$1]) {
      this[SLOTS$1] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction$1(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier$1(size, multiple = false) {
  const copy = getCopyFunction$1(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory$1.call(this);
    restoreMemory$1.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY$1];
    const dest = this[MEMORY$1];
    copy(dest, src);
  };
}

function getCopyFunction$1(size, multiple = false) {
  if (!multiple) {
    const copier = copiers$1[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x$1;
  if (!(size & 0x03)) return copy4x$1;
  if (!(size & 0x01)) return copy2x$1;
  return copy1x$1;
}

const copiers$1 = {
  1: copy1$1,
  2: copy2$1,
  4: copy4$1,
  8: copy8$1,
  16: copy16$1,
  32: copy32$1,
};

function copy1x$1(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x$1(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x$1(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x$1(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1$1(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2$1(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4$1(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8$1(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16$1(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32$1(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter$1(offset, size) {
  const reset = getResetFunction$1(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory$1.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY$1];
    reset(dest, offset, size);
  };
}

function getResetFunction$1(size) {
  const resetter = resetters$1[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x$1;
  if (!(size & 0x03)) return reset4x$1;
  if (!(size & 0x01)) return reset2x$1;
  return reset1x$1;
}

const resetters$1 = {
  1: reset1$1,
  2: reset2$1,
  4: reset4$1,
  8: reset8$1,
  16: reset16$1,
  32: reset32$1,
};

function reset1x$1(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x$1(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x$1(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x$1(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1$1(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2$1(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4$1(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8$1(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16$1(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32$1(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory$1() {
  const dv = this[MEMORY$1];
  const source = dv[MEMORY$1];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY$1] = source;
  this[MEMORY$1] = newDV;
  return true;
}

const decoders$1 = {};
const encoders$1 = {};

function decodeText$1(arrays, encoding = 'utf-8') {
  let decoder = decoders$1[encoding];
  if (!decoder) {
    decoder = decoders$1[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText$1(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders$1[encoding];
      if (!encoder) {
        encoder = encoders$1[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64$1(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64$1(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf$1() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$1];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX$1 = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN$1 = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON$1() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER$1];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN$1 <= value && value <= INT_MAX$1) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue$1(cb, options) {
  const value = handleError$1(() => this.$, options);
  return cb(value);
}

function handleError$1(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor$1(structure, handlers = {}) {
  return markAsSpecial$1({
    get() {
      /* WASM-ONLY */
      restoreMemory$1.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY$1];
    },
    set(dv) {
      checkDataView$1(dv);
      setDataView$1.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor$1(structure, handlers = {}) {
  return markAsSpecial$1({
    get() {
      return encodeBase64$1(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$1('string', str);
      }
      const dv = decodeBase64$1(str);
      setDataView$1.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor$1(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial$1({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText$1(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch$1('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText$1(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView$1.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor$1(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial$1({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray$1(ta, typedArray)) {
        throwTypeMismatch$1(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView$1.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial$1({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType$1.Slice);
  const isTargetPointer = (targetStructure.type === StructureType$1.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor$1({
    type: MemberType$1.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor$1({
    type: MemberType$1.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION$1];
    if (prevLocation) {
      const location = this[LOCATION_GETTER$1]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE$1]);
        const target = Target.call(ENVIRONMENT$1, dv, { writable: !isConst });
        this[SLOTS$1][0] = target;
        this[FIXED_LOCATION$1] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS$1][0] ?? throwNullPointer$1();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY$1]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION$1] = loc;
      } else {
        throwFixedMemoryTargetRequired$1();
      }
    }
    this[SLOTS$1][0] = arg;
  };
  const getTarget = isValueExpected$1(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER$1]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS$1][0] ?? throwNullPointer$1();
    return object[SETTER$1](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT$1 || this === PARENT$1) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf$1(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer$1();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$3;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY$1, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf$1(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint$1(structure, arg);
      }
      arg = arg[SLOTS$1][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory$1.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST$1]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST$1]) {
        throwReadOnlyTarget$1(structure);       
      }
    } else if (isCompatible$1(arg, Target)) {
      // autocast to target type
      const dv = getDataView$1(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY$1]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer$1(arg?.buffer)) {
          warnImplicitArrayCreation$1(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget$1(structure, arg);
    }
    this[TARGET_SETTER$1](arg);
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy$1, set: initializer },
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [TARGET_GETTER$1]: { value: getTargetObject },
    [TARGET_SETTER$1]: { value: setTargetObject },
    [LOCATION_GETTER$1]: { value: addressGetter },
    [LOCATION_SETTER$1]: { value: addressSetter },
    [POINTER_VISITOR$1]: { value: visitPointer$1 },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [VIVIFICATOR$1]: { value: throwNullPointer$1 },
    [NORMALIZER$1]: { value: normalizePointer$1 },
    [FIXED_LOCATION$1]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer$1(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy$1() {
  return this[PROXY$1];
}

function copyPointer$1({ source }) {
  const target = source[SLOTS$1][0];
  if (target) {
    this[TARGET_SETTER$1](target);
  }
}

function resetPointer$1({ isActive }) {
  if (this[SLOTS$1][0] && !isActive(this)) {
    this[SLOTS$1][0] = undefined;
  }
}

function disablePointer$1() {
  const disabledProp = { get: throwInaccessiblePointer$1, set: throwInaccessiblePointer$1 };
  const disabledFunc = { value: throwInaccessiblePointer$1 };
  defineProperties$1(this[POINTER$1], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER$1]: disabledFunc,
    [SETTER$1]: disabledFunc,
    [TARGET_GETTER$1]: disabledFunc,
  });
}

function visitPointer$1(fn, options = {}) {
  const {
    source,
    isActive = always$1,
    isMutable = always$1,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf$1(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$3 = {
  get(pointer, name) {
    if (name === POINTER$1) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$1]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER$1]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER$1]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER$1]();
      return name in target;
    }
  },
};

function always$1() {
  return true;
}

function never$1() {
  return false;
}

function defineStructShape$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor$1(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType$1.Object);
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$1](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer$1(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf$1, set: initializer },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator$1 },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$3(structure) },
    [POINTER_VISITOR$1]: hasPointer && { value: getPointerVisitor$3(structure, always$1) },
    [NORMALIZER$1]: { value: normalizeStruct$1 },
    [PROPS$1]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct$1(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries$1.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries$1(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator$1.bind(this, options),
    length: this[PROPS$1].length,
  };
}

function getStructIterator$1(options) { 
  const entries = getStructEntries$1.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator$1(options) {
  const self = this;
  const props = this[PROPS$1];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError$1(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$3(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType$1.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY$1];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary$1(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS$1][slot] = constructor.call(PARENT$1, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$3(structure, visitorOptions = {}) {
  const {
    isChildActive = always$1,
    isChildMutable = always$1,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$1,
      isMutable = always$1,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS$1]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS$1][slot] ?? (vivificate ? this[VIVIFICATOR$1](slot) : null);
      if (child) {
        child[POINTER_VISITOR$1](cb, childOptions);
      }
    }
  };
}

function defineArgStruct$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType$1.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY$1] = dv;
    if (hasObject) {
      this[SLOTS$1] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch$1(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError$1(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor$1(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties$1(constructor.prototype, {
    ...memberDescriptors,
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$3(structure) },
    [POINTER_VISITOR$1]: hasPointer && { value: getPointerVisitor$3(structure, { isChildMutable }) },
  });
  defineProperties$1(constructor, {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  });
  return constructor;
}

function defineArray$1(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$1(member, env);
  const hasStringProp = canBeString$1(member);
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$1](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable$1(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch$1(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer$1(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer$1(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy$1;
  const constructor = structure.constructor = createConstructor$1(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$1(member);
  const hasObject = member.type === MemberType$1.Object;
  const instanceDescriptors = {
    $: { get: getProxy$1, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    string: hasStringProp && getStringDescriptor$1(structure),
    typedArray: typedArray && getTypedArrayDescriptor$1(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$1 },
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [Symbol.iterator]: { value: getArrayIterator$1 },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$2(structure) },
    [POINTER_VISITOR$1]: hasPointer && { value: getPointerVisitor$2() },
    [NORMALIZER$1]: { value: normalizeArray$1 },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT$1]: { value: getCompatibleTags$1(structure) },
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy$1() {
  const proxy = new Proxy(this, proxyHandlers$2);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY$1, { value: proxy }); 
  return proxy;
}

function canBeString$1(member) {
  return member.type === MemberType$1.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray$1(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries$1.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator$1() {
  const self = this[ARRAY$1] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator$1(options) {
  const self = this[ARRAY$1] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError$1(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries$1(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator$1.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator$2(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY$1];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS$1][index] = constructor.call(PARENT$1, childDV, { writable });
    return object;
  };
}

function getPointerVisitor$2(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always$1,
      isMutable = always$1,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS$1][i];
      }
      const child = this[SLOTS$1][i] ?? (vivificate ? this[VIVIFICATOR$1](i) : null);
      if (child) {
        child[POINTER_VISITOR$1](cb, childOptions);
      }
    }
  };
}

function transformIterable$1(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers$2 = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER$1]) {
            array[ELEMENT_GETTER$1] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER$1];
        case 'set':
          if (!array[ELEMENT_SETTER$1]) {
            array[ELEMENT_SETTER$1] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER$1];
        case ARRAY$1:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER$1] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER$1] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER$1];
          break;
        case 'set':
          delete array[ELEMENT_SETTER$1];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY$1);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape$1(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor$1(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$1({ ...member, type: MemberType$1.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer$1(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS$1];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE$1] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties$1(item, { [NAME$1]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG$1] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG$1];
    } else if (!getDataView$1(structure, arg, env)) {
      throwInvalidInitializer$1(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$1(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME$1] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    typedArray: typedArray && getTypedArrayDescriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [NORMALIZER$1]: { value: normalizeEnumerationItem$1 },
  };
  const staticDescriptors = {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
    [ITEMS$1]: { value: {} },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem$1(cb) {
  return cb(this.$[NAME$1]);
}

function defineErrorSet$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor$1(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor$1({ ...member, type: MemberType$1.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer$1(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS$1][arg];
    } else if (!getDataView$1(structure, arg, env)) {
      throwInvalidInitializer$1(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet$1.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass$1(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    typedArray: typedArray && getTypedArrayDescriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [NORMALIZER$1]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
    [ITEMS$1]: { value: {} },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet$1;

function getGlobalErrorSet$1() {
  return globalErrorSet$1;
}

function defineErrorUnion$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$1(members[0], env);
  const { get: getError, set: setError } = getDescriptor$1(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType$1.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet$1() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER$1]();
    this[POINTER_VISITOR$1]?.(resetPointer$1);
  };
  const hasObject = !!members.find(m => m.type === MemberType$1.Object);
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$1](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet$1(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor$1(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [RESETTER$1]: { value: getMemoryResetter$1(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$3(structure) },
    [POINTER_VISITOR$1]: hasPointer && { value: getPointerVisitor$3(structure, { isChildActive }) },
    [NORMALIZER$1]: { value: normalizeValue$1 },
  };
  const staticDescriptors = {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque$1(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque$1(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque$1(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [NORMALIZER$1]: { value: normalizeOpaque$1 },
  };
  const staticDescriptors = {
    [COMPAT$1]: { value: getCompatibleTags$1(structure) },
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque$1(cb) {
  return {};
}

function defineOptional$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor$1(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor$1(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR$1]?.(resetPointer$1);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType$1.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$1](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER$1]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR$1]?.(resetPointer$1);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType$1.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER$1]: !hasPointer && { value: getMemoryResetter$1(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$3(structure) },
    [POINTER_VISITOR$1]: hasPointer && { value: getPointerVisitor$3(structure, { isChildActive }) },
    [NORMALIZER$1]: { value: normalizeValue$1 },
  };
  const staticDescriptors = {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice$1(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor$1(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel$1(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString$1(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY$1] = dv;
    this[LENGTH$1] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH$1]) {
      throwArrayLengthMismatch$1(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY$1]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER$1](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable$1(arg);
      if (!this[MEMORY$1]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY$1] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer$1(structure, arg, !this[MEMORY$1]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$1(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$1(structure, arg);
    }
  };
  const finalizer = createArrayProxy$1;
  const constructor = structure.constructor = createConstructor$1(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$1(member);
  const hasObject = member.type === MemberType$1.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy$1, set: initializer },
    length: { get: getLength$1 },
    dataView: getDataViewDescriptor$1(structure, shapeHandlers),
    base64: getBase64Descriptor$1(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor$1(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor$1(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries$1 },
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [Symbol.iterator]: { value: getArrayIterator$1 },
    [COPIER$1]: { value: getMemoryCopier$1(elementSize, true) },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$2(structure) },
    [POINTER_VISITOR$1]: hasPointer && { value: getPointerVisitor$2() },
    [NORMALIZER$1]: { value: normalizeArray$1 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$1]: { value: getCompatibleTags$1(structure) },
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: elementSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function getLength$1() {
  return this[LENGTH$1];
}

function getSentinel$1(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor$1(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor$1(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel$1(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel$1(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel$1(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel$1(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel$1(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY$1].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel$1(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY$1];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape$1(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType$1.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType$1.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor$1(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME$1];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor$1(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty$1(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR$1]?.(resetPointer$1);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty$1(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR$1]?.(resetPointer$1);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER$1](arg);
      if (hasPointer) {
        this[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers$1(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer$1(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer$1(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR$1](disablePointer$1, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor$1(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never$1;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType$1.Object);
  const instanceDescriptors = {
    $: { get: getSelf$1, set: initializer, configurable: true },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator$1 },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [TAG$1]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR$1]: hasObject && { value: getChildVivificator$3(structure) },
    [POINTER_VISITOR$1]: hasAnyPointer && { value: getPointerVisitor$3(structure, { isChildActive }) },
    [PROP_GETTERS$1]: { value: memberValueGetters },
    [NORMALIZER$1]: { value: normalizeUnion$1 },
    [PROPS$1]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS$1];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion$1(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries$1.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries$1(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator$1.bind(this, options),
    length: this[PROPS$1].length,
  };
}

function getUnionIterator$1(options) { 
  const entries = getUnionEntries$1.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator$1(options) {
  const self = this;
  const props = this[PROPS$1];
  const getters = this[PROP_GETTERS$1];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError$1(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector$1(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor$1({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$1](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch$1(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS$1][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer$1(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer$1(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$1(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf$1, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    typedArray: typedArray && getTypedArrayDescriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    entries: { value: getVectorEntries$1 },
    delete: { value: getDestructor$1(structure) },
    [Symbol.iterator]: { value: getVectorIterator$1 },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [NORMALIZER$1]: { value: normalizeVector$1 },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT$1]: { value: getCompatibleTags$1(structure) },
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector$1(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries$1.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator$1() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator$1() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries$1() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator$1.bind(this),
    length: this.length,
  };
}

const StructureType$1 = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$5 = Array(Object.values(StructureType$1).length);

function usePrimitive$1() {
  factories$5[StructureType$1.Primitive] = definePrimitive$1;
}

function useArray$1() {
  factories$5[StructureType$1.Array] = defineArray$1;
}

function useStruct$1() {
  factories$5[StructureType$1.Struct] = defineStructShape$1;
}

function usePackedStruct$1() {
  factories$5[StructureType$1.PackedStruct] = defineStructShape$1;
}

function useExternStruct$1() {
  factories$5[StructureType$1.ExternStruct] = defineStructShape$1;
}

function useArgStruct$1() {
  factories$5[StructureType$1.ArgStruct] = defineArgStruct$1;
}

function useExternUnion$1() {
  factories$5[StructureType$1.ExternUnion] = defineUnionShape$1;
}

function useBareUnion$1() {
  factories$5[StructureType$1.BareUnion] = defineUnionShape$1;
}

function useTaggedUnion$1() {
  factories$5[StructureType$1.TaggedUnion] = defineUnionShape$1;
}

function useErrorUnion$1() {
  factories$5[StructureType$1.ErrorUnion] = defineErrorUnion$1;
}

function useErrorSet$1() {
  factories$5[StructureType$1.ErrorSet] = defineErrorSet$1;
}

function useEnumeration$1() {
  factories$5[StructureType$1.Enumeration] = defineEnumerationShape$1;
}

function useOptional$1() {
  factories$5[StructureType$1.Optional] = defineOptional$1;
}

function usePointer$1() {
  factories$5[StructureType$1.Pointer] = definePointer$1;
}

function useSlice$1() {
  factories$5[StructureType$1.Slice] = defineSlice$1;
}

function useVector$1() {
  factories$5[StructureType$1.Vector] = defineVector$1;
}

function useOpaque$1() {
  factories$5[StructureType$1.Opaque] = defineOpaque$1;
}

function defineProperties$1(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly$1 };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly$1, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR$1]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties$1(constructor.prototype, { 
    [CONST$1]: { value: false },
    [ALL_KEYS$1]: { value: Object.keys(propSetters) },
    [SETTER$1]: { value: set },
    [GETTER$1]: { value: get },
    [PROP_SETTERS$1]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties$1(constructor, {
    [CONST_PROTOTYPE$1]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties$1(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST$1]: { value: true },
    [SETTER$1]: { value: throwReadOnly$1 },
    [VIVIFICATOR$1]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor$1(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots$1(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS$1]) {
    const comptimeMembers = members.filter(m => isReadOnly$1(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache$1();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer$1(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS$1] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY$1]; 
      } else {
        self[MEMORY$1] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView$1(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE$1]);
      if (shapeDefiner) {
        setDataView$1.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY$1] = dv;
      }
      if (hasSlots) {
        self[SLOTS$1] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR$1](copyPointer$1, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS$1][slot] = template[SLOTS$1][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE$1]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier$1(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS$1];
    const allKeys = this[ALL_KEYS$1];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty$1(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers$1(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY$1]) {
          this[COPIER$1](template);
        }
        this[POINTER_VISITOR$1]?.(copyPointer$1, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots$1(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType$1.Object:
      case MemberType$1.Comptime:
      case MemberType$1.Type:
      case MemberType$1.Literal:
        return true;
    }
  }
  return false;
}

function getSelf$1() {
  return this;
}

function useAllStructureTypes$1() {
  usePrimitive$1();
  useArray$1();
  useStruct$1();
  useExternStruct$1();
  usePackedStruct$1();
  useArgStruct$1();
  useExternUnion$1();
  useBareUnion$1();
  useTaggedUnion$1();
  useErrorUnion$1();
  useErrorSet$1();
  useEnumeration$1();
  useOptional$1();
  usePointer$1();
  useSlice$1();
  useVector$1();
  useOpaque$1();
}

let ObjectCache$1 = class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
};

function definePrimitive$1(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor$1(member, env);
  const propApplier = createPropertyApplier$1(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER$1](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType$1(member);
          throwInvalidInitializer$1(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor$1(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass$1(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor$1(structure),
    base64: getBase64Descriptor$1(structure),
    typedArray: typedArray && getTypedArrayDescriptor$1(structure),
    valueOf: { value: getValueOf$1 },
    toJSON: { value: convertToJSON$1 },
    delete: { value: getDestructor$1(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER$1]: { value: getMemoryCopier$1(byteSize) },
    [NORMALIZER$1]: { value: normalizeValue$1 },
  };
  const staticDescriptors = {
    [COMPAT$1]: { value: getCompatibleTags$1(structure) },
    [ALIGN$1]: { value: align },
    [SIZE$1]: { value: byteSize },
  };
  return attachDescriptors$1(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange$1(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType$1.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass$1({ type, bitSize }) {
  if (type === MemberType$1.Int || type === MemberType$1.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType$1.Float) {
    return Number;
  } else if (type === MemberType$1.Bool) {
    return Boolean;
  }
}

function getPrimitiveType$1(member) {
  const Primitive = getPrimitiveClass$1(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer$1(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch$1(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType$1.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType$1.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected$1(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle$1);
  if (typedArray) {
    acceptable.push(addArticle$1(typedArray.name));
  }
  if (type === StructureType$1.Slice) {
    throw new TypeError(`Expecting ${formatList$1(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList$1(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected$1(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected$1(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet$1(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers$1(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty$1(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer$1(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer$1(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle$1(type));
    }
  } else {
    acceptable.push(addArticle$1(expected));
  }
  const received = getDescription$1(arg);
  throw new TypeError(`${name} expects ${formatList$1(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer$1(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType$1(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType$1.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType$1.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer$1(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch$1(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers$1(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty$1(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch$1(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError$1(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer$1(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint$1(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel$1(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel$1(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch$1(expected, arg) {
  const received = getDescription$1(arg);
  throw new TypeError(`Expected ${addArticle$1(expected)}, received ${received}`)
}

function throwInaccessiblePointer$1() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer$1() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget$1(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article$1(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired$1(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow$1(member, value) {
  const typeName = getTypeName$1(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound$1(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError$1(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound$1(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined$1(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary$1(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly$1() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget$1(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque$1(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque$1(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation$1(structure, arg) {
  const created = addArticle$1(structure.typedArray.name);
  const source = addArticle$1(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription$1(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle$1(s);
}

function addArticle$1(noun) {
  return `${article$1(noun)} ${noun}`;
}

function article$1(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList$1(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor$1(access, member) {
  return cacheMethod$1(access, member, () => {
    if (isByteAligned$1(member)) {
      const { byteSize } = member;
      const typeName = getTypeName$1({ type: MemberType$1.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor$1(access, member);
    }
  });
}

function getNumericAccessor$1(access, member) {
  return cacheMethod$1(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor$1(access, member);
    }
  });
}

const factories$4 = {};

function useExtendedBool$1() {
  factories$4[MemberType$1.Bool] = getExtendedBoolAccessor$1;
}

function useExtendedInt$1() {
  factories$4[MemberType$1.Int] = getExtendedIntAccessor$1;
}

function useExtendedUint$1() {
  factories$4[MemberType$1.Uint] = getExtendedUintAccessor$1;
}

function useExtendedFloat$1() {
  factories$4[MemberType$1.Float] = getExtendedFloatAccessor$1;
}

function getExtendedTypeAccessor$1(access, member) {
  const f = factories$4[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor$1(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor$1(access, member) {
  if (isByteAligned$1(member)) {
    return getAlignedIntAccessor$1(access, member)
  } else {
    return getUnalignedIntAccessor$1(access, member);
  }
}

function getExtendedUintAccessor$1(access, member) {
  if (isByteAligned$1(member)) {
    return getAlignedUintAccessor$1(access, member)
  } else {
    return getUnalignedUintAccessor$1(access, member);
  }
}

function getExtendedFloatAccessor$1(access, member) {
  if (isByteAligned$1(member)) {
    return getAlignedFloatAccessor$1(access, member)
  } else {
    return getUnalignedFloatAccessor$1(access, member);
  }
}

function getDataView$1(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY$1];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType$1.Array || type === StructureType$1.Slice || type === StructureType$1.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements$1(arg, Child);
        if (number !== undefined) {
          if (type === StructureType$1.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch$1(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize$1(dv, structure);
  }
  return dv;
}

function checkDataView$1(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch$1('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize$1(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType$1.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch$1(structure, dv);
  }
}

function setDataView$1(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType$1.Slice;
  if (!this[MEMORY$1]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize$1(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY$1]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER$1](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch$1(structure, dv, this);
    }
    const source = { [MEMORY$1]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER$1](source); 
  }
}

function findElements$1(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView$1(structure, arg, env) {
  const dv = getDataView$1(structure, arg, env);
  if (!dv) {
    throwBufferExpected$1(structure);
  }
  return dv;
}

function getTypedArrayClass$1(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType$1.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType$1.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType$1.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType$1.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray$1(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible$1(arg, constructor) {
  const tags = constructor[COMPAT$1];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements$1(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags$1(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer$1(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName$1(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType$1.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType$1.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType$1.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType$1.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType$1.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor$1(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor$1(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$1({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$1(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor$1(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName$1({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor$1(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor$1(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$1(access, member);
}

function getUnalignedUintAccessor$1(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor$1(access, member);
}

function getAlignedFloatAccessor$1(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor$1(access, member) {
  return getUnalignedNumericAccessor$1(access, member);
}

function getUnalignedNumericAccessor$1(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor$1('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction$1(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor$1('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction$1(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache$1 = {};

function cacheMethod$1(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName$1(member);
  const suffix = isByteAligned$1(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType$1.Int || type === MemberType$1.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache$1[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass$1(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache$1[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes$1() {
  useExtendedBool$1();
  useExtendedInt$1();
  useExtendedUint$1();
  useExtendedFloat$1();
}

const MemberType$1 = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly$1(type) {
  switch (type) {
    case MemberType$1.Type:
    case MemberType$1.Comptime:
    case MemberType$1.Literal:
      return true;
    default:
      return false;
  }
}

const factories$3 = {};

function useVoid$1() {
  factories$3[MemberType$1.Void] = getVoidDescriptor$1;
}

function useBool$1() {
  factories$3[MemberType$1.Bool] = getBoolDescriptor$1;
}

function useInt$1() {
  factories$3[MemberType$1.Int] = getIntDescriptor$1;
}

function useUint$1() {
  factories$3[MemberType$1.Uint] = getUintDescriptor$1;
}

function useFloat$1() {
  factories$3[MemberType$1.Float] = getFloatDescriptor$1;
}

function useEnumerationItem$1() {
  factories$3[MemberType$1.EnumerationItem] = getEnumerationItemDescriptor$1;
}

function useError$1() {
  factories$3[MemberType$1.Error] = getErrorDescriptor$1;
}

function useObject$1() {
  factories$3[MemberType$1.Object] = getObjectDescriptor$1;
}

function useType$1() {
  factories$3[MemberType$1.Type] = getTypeDescriptor$1;
}

function useComptime$1() {
  factories$3[MemberType$1.Comptime] = getComptimeDescriptor$1;
}

function useStatic$1() {
  factories$3[MemberType$1.Static] = getStaticDescriptor$1;
}

function useLiteral$1() {
  factories$3[MemberType$1.Literal] = getLiteralDescriptor$1;
}

function useNull$1() {
  factories$3[MemberType$1.Null] = getNullDescriptor$1;
}

function useUndefined$1() {
  factories$3[MemberType$1.Undefined] = getUndefinedDescriptor$1;
}

function isByteAligned$1({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor$1(member, env) {
  const f = factories$3[member.type];
  return f(member, env);
}

function getVoidDescriptor$1(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined$1(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor$1(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor$1(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor$1(member, env) {
  return getDescriptorUsing$1(member, env, getBoolAccessor$1)
}

function getIntDescriptor$1(member, env) {
  const getDataViewAccessor = addRuntimeCheck$1(env, getNumericAccessor$1);
  return getDescriptorUsing$1(member, env, getDataViewAccessor)
}

function getUintDescriptor$1(member, env) {
  const getDataViewAccessor = addRuntimeCheck$1(env, getNumericAccessor$1);
  return getDescriptorUsing$1(member, env, getDataViewAccessor)
}

function addRuntimeCheck$1(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange$1(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow$1(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor$1(member, env) {
  return getDescriptorUsing$1(member, env, getNumericAccessor$1)
}

function getValueDescriptor$1(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor$1(valueMember, env);
}

function getEnumerationItemDescriptor$1(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor$1(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected$1(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor$1(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor$1(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet$1();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet$1(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected$1(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected$1(structure) {
  switch (structure.type) {
    case StructureType$1.Primitive:
    case StructureType$1.ErrorUnion:
    case StructureType$1.Optional:
    case StructureType$1.Enumeration:
    case StructureType$1.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue$1(slot) {
  const object = this[SLOTS$1][slot] ?? this[VIVIFICATOR$1](slot);
  return object[GETTER$1]();
}

function getObject$1(slot) {
  const object = this[SLOTS$1][slot] ?? this[VIVIFICATOR$1](slot);
  return object;
}

function setValue$1(slot, value) {
  const object = this[SLOTS$1][slot] ?? this[VIVIFICATOR$1](slot);
  object[SETTER$1](value);
}

function bindSlot$1(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor$1(member, env) {
  const { structure, slot } = member;
  return bindSlot$1(slot, {
    get: isValueExpected$1(structure) ? getValue$1 : getObject$1,
    set: setValue$1,
  });
}

function getType$1(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS$1][slot];
  return structure?.constructor;
}

function getTypeDescriptor$1(member, env) {
  const { slot } = member;
  return bindSlot$1(slot, { get: getType$1 });
}

function getComptimeDescriptor$1(member, env) {
  const { slot, structure } = member;
  return bindSlot$1(slot, {
    get: isValueExpected$1(structure) ? getValue$1 : getObject$1,
  });
}

function getStaticDescriptor$1(member, env) {
  const { slot, structure } = member;
  return bindSlot$1(slot, {
    get: isValueExpected$1(structure) ? getValue$1 : getObject$1,
    set: setValue$1,
  });
}

function getLiteral$1(slot) {
  const object = this[SLOTS$1][slot];
  return object.string;
}

function getLiteralDescriptor$1(member, env) {
  const { slot } = member;
  return bindSlot$1(slot, { get: getLiteral$1 });
}

function getDescriptorUsing$1(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY$1], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$1.call(this)) {
            return getter.call(this[MEMORY$1], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY$1], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$1.call(this)) {
            return setter.call(this[MEMORY$1], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY$1], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory$1.call(this)) {
            return getter.call(this[MEMORY$1], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError$1(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY$1], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory$1.call(this)) {
            return setter.call(this[MEMORY$1], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError$1(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes$1() {
  useVoid$1();
  useNull$1();
  useUndefined$1();
  useBool$1();
  useInt$1();
  useUint$1();
  useFloat$1();
  useEnumerationItem$1();
  useError$1();
  useObject$1();
  useType$1();
  useComptime$1();
  useStatic$1();
  useLiteral$1();
}

process.cwd();

useAllMemberTypes$1();
useAllStructureTypes$1();
useAllExtendedTypes$1();

const MEMORY = Symbol('memory');
const SLOTS = Symbol('slots');
const PARENT = Symbol('parent');
const NAME = Symbol('name');
const TAG = Symbol('tag');
const ITEMS = Symbol('items');
const PROPS = Symbol('props');
const GETTER = Symbol('getter');
const SETTER = Symbol('setter');
const ELEMENT_GETTER = Symbol('elementGetter');
const ELEMENT_SETTER = Symbol('elementSetter');
const LOCATION_GETTER = Symbol('addressGetter');
const LOCATION_SETTER = Symbol('addressSetter');
const TARGET_GETTER = Symbol('targetGetter');
const TARGET_SETTER = Symbol('targetSetter');
const FIXED_LOCATION = Symbol('fixedLocation');
const PROP_GETTERS = Symbol('propGetters');
const PROP_SETTERS = Symbol('propSetters');
const ALL_KEYS = Symbol('allKeys');
const LENGTH = Symbol('length');
const PROXY = Symbol('proxy');
const COMPAT = Symbol('compat');
const SIZE = Symbol('size');
const ALIGN = Symbol('align');
const ARRAY = Symbol('array');
const POINTER = Symbol('pointer');
const CONST = Symbol('const');
const CONST_PROTOTYPE = Symbol('constProto');
const COPIER = Symbol('copier');
const RESETTER = Symbol('resetter');
const NORMALIZER = Symbol('normalizer');
const VIVIFICATOR = Symbol('vivificator');
const POINTER_VISITOR = Symbol('pointerVisitor');
const ENVIRONMENT = Symbol('environment');
const MORE = Symbol('more');

function getDestructor(env) {
  return function() {
    const dv = this[MEMORY];
    this[MEMORY] = null;
    if (this[SLOTS]) {
      this[SLOTS] = {};
    }
    env.releaseFixedView(dv);
  };
}

function getBitAlignFunction(bitPos, bitSize, toAligned) {
  if (bitPos + bitSize <= 8) {
    const mask = (2 ** bitSize) - 1;
    if (toAligned) {
      // from single byte
      return function(dest, src, offset) {
        const n = src.getUint8(offset);
        const b = (n >> bitPos) & mask;
        dest.setUint8(0, b);
      };
    } else {
      // to single byte
      const destMask = 0xFF ^ (mask << bitPos);
      return function(dest, src, offset) {
        const n = src.getUint8(0);
        const d = dest.getUint8(offset);
        const b = (d & destMask) | ((n & mask) << bitPos);
        dest.setUint8(offset, b);
      };
    }
  } else {
    const leadBits = 8 - bitPos;
    const leadMask = (2 ** leadBits) - 1;
    if (toAligned) {
      const trailBits = bitSize % 8;
      const trailMask = (2 ** trailBits) - 1;
      return function(dest, src, offset) {
        let i = offset, j = 0;
        let n = src.getUint8(i++), b;
        let bitBuf = (n >> bitPos) & leadMask;
        let bitCount = leadBits;
        let remaining = bitSize;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            //bitCount += 8;
          }
          b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          //bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    } else {
      const trailBits = (bitSize - leadBits) % 8;
      const trailMask = (2 ** trailBits) - 1;
      const destMask1 = 0xFF ^ (leadMask << bitPos);
      const destMask2 = 0xFF ^ trailMask;
      return function(dest, src, offset) {
        let i = 0, j = offset;
        // preserve bits ahead of bitPos
        let d = dest.getUint8(j), n, b;
        let bitBuf = d & destMask1;
        let bitCount = bitPos;
        let remaining = bitSize + bitCount;
        do {
          if (remaining > bitCount) {
            n = src.getUint8(i++);
            bitBuf = bitBuf | (n << bitCount);
            bitCount += 8;
          }
          if (remaining >= 8) {
            b = bitBuf & 0xFF;
          } else {
            // preserve bits at the destination sitting behind the trailing bits
            d = dest.getUint8(j);
            b = (d & destMask2) | (bitBuf & trailMask);
          }
          dest.setUint8(j++, b);
          bitBuf >>= 8;
          bitCount -= 8;
          remaining -= 8;
        } while (remaining > 0);
      }
    }
  }
}

function getMemoryCopier(size, multiple = false) {
  const copy = getCopyFunction(size, multiple);
  return function(target) {
    /* WASM-ONLY */
    restoreMemory.call(this);
    restoreMemory.call(target);
    /* WASM-ONLY-END */
    const src = target[MEMORY];
    const dest = this[MEMORY];
    copy(dest, src);
  };
}

function getCopyFunction(size, multiple = false) {
  if (!multiple) {
    const copier = copiers[size];
    if (copier) {
      return copier;
    }
  }
  if (!(size & 0x07)) return copy8x;
  if (!(size & 0x03)) return copy4x;
  if (!(size & 0x01)) return copy2x;
  return copy1x;
}

const copiers = {
  1: copy1,
  2: copy2,
  4: copy4,
  8: copy8,
  16: copy16,
  32: copy32,
};

function copy1x(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i++) {
    dest.setInt8(i, src.getInt8(i));
  }
}

function copy2x(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 2) {
    dest.setInt16(i, src.getInt16(i, true), true);
  }
}

function copy4x(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 4) {
    dest.setInt32(i, src.getInt32(i, true), true);
  }
}

function copy8x(dest, src) {
  for (let i = 0, len = dest.byteLength; i < len; i += 8) {
    dest.setInt32(i, src.getInt32(i, true), true);
    dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
  }
}

function copy1(dest, src) {
  dest.setInt8(0, src.getInt8(0));
}

function copy2(dest, src) {
  dest.setInt16(0, src.getInt16(0, true), true);
}

function copy4(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
}

function copy8(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
}

function copy16(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
}

function copy32(dest, src) {
  dest.setInt32(0, src.getInt32(0, true), true);
  dest.setInt32(4, src.getInt32(4, true), true);
  dest.setInt32(8, src.getInt32(8, true), true);
  dest.setInt32(12, src.getInt32(12, true), true);
  dest.setInt32(16, src.getInt32(16, true), true);
  dest.setInt32(20, src.getInt32(20, true), true);
  dest.setInt32(24, src.getInt32(24, true), true);
  dest.setInt32(28, src.getInt32(28, true), true);
}

function getMemoryResetter(offset, size) {
  const reset = getResetFunction(size);
  return function() {
    /* WASM-ONLY */
    restoreMemory.call(this);
    /* WASM-ONLY-END */
    const dest = this[MEMORY];
    reset(dest, offset, size);
  };
}

function getResetFunction(size) {
  const resetter = resetters[size];
  if (resetter) {
    return resetter;
  }
  if (!(size & 0x07)) return reset8x;
  if (!(size & 0x03)) return reset4x;
  if (!(size & 0x01)) return reset2x;
  return reset1x;
}

const resetters = {
  1: reset1,
  2: reset2,
  4: reset4,
  8: reset8,
  16: reset16,
  32: reset32,
};

function reset1x(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i++) {
    dest.setInt8(i, 0);
  }
}

function reset2x(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 2) {
    dest.setInt16(i, 0, true);
  }
}

function reset4x(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 4) {
    dest.setInt32(i, 0, true);
  }
}

function reset8x(dest, offset, size) {
  for (let i = offset, limit = offset + size; i < limit; i += 8) {
    dest.setInt32(i, 0, true);
    dest.setInt32(i + 4, 0, true);
  }
}

function reset1(dest, offset) {
  dest.setInt8(offset, 0);
}

function reset2(dest, offset) {
  dest.setInt16(offset, 0, true);
}

function reset4(dest, offset) {
  dest.setInt32(offset, 0, true);
}

function reset8(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
}

function reset16(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
}

function reset32(dest, offset) {
  dest.setInt32(offset + 0, 0, true);
  dest.setInt32(offset + 4, 0, true);
  dest.setInt32(offset + 8, 0, true);
  dest.setInt32(offset + 12, 0, true);
  dest.setInt32(offset + 16, 0, true);
  dest.setInt32(offset + 20, 0, true);
  dest.setInt32(offset + 24, 0, true);
  dest.setInt32(offset + 28, 0, true);
}

function restoreMemory() {
  const dv = this[MEMORY];
  const source = dv[MEMORY];
  if (!source || dv.buffer.byteLength !== 0) {
    return false;
  }
  const { memory, address, len } = source;
  const newDV = new DataView(memory.buffer, address, len);
  newDV[MEMORY] = source;
  this[MEMORY] = newDV;
  return true;
}

const decoders = {};
const encoders = {};

function decodeText(arrays, encoding = 'utf-8') {
  let decoder = decoders[encoding];
  if (!decoder) {
    decoder = decoders[encoding] = new TextDecoder(encoding);
  }
  let array;
  if (Array.isArray(arrays)) {
    if (arrays.length === 1) {
      array = arrays[0];
    } else {
      let len = 0;
      for (const a of arrays) {
        len += a.length;
      }
      const { constructor } = arrays[0];
      array = new constructor(len);
      let offset = 0;
      for (const a of arrays) {
        array.set(a, offset);
        offset += a.length;
      }
    }
  } else {
    array = arrays;
  }
  return decoder.decode(array);
}

function encodeText(text, encoding = 'utf-8') {
  switch (encoding) {
    case 'utf-16': {
      const { length } = text;
      const ta = new Uint16Array(length);
      for (let i = 0; i < length; i++) {
        ta[i] = text.charCodeAt(i);
      }
      return ta;
    }
    default: {
      let encoder = encoders[encoding];
      if (!encoder) {
        encoder = encoders[encoding] = new TextEncoder();
      }
      return encoder.encode(text);
    }
  }
}

function encodeBase64(dv) {
  const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
  const bstr = String.fromCharCode.apply(null, ta);
  return btoa(bstr);
}

function decodeBase64(str) {
  const bstr = atob(str);
  const ta = new Uint8Array(bstr.length);
  for (let i = 0; i < ta.byteLength; i++) {
    ta[i] = bstr.charCodeAt(i);
  }
  return new DataView(ta.buffer);  
}

function getValueOf() {
  const map = new Map();
  const options = { error: 'throw' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER];
    if (normalizer) {
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      return value;
    }
  };
  return process(this);
}

const INT_MAX = BigInt(Number.MAX_SAFE_INTEGER);
const INT_MIN = BigInt(Number.MIN_SAFE_INTEGER);

function convertToJSON() {
  const map = new Map();
  const options = { error: 'return' };
  const process = function(value) {
    const normalizer = value?.[NORMALIZER];
    if (normalizer) {
      if (value instanceof Error) {
        return { error: value.message };
      }      
      let result = map.get(value);
      if (result === undefined) {
        result = normalizer.call(value, process, options);
        map.set(value, result);
      }
      return result;
    } else {
      if (typeof(value) === 'bigint' && INT_MIN <= value && value <= INT_MAX) {
        return Number(value);
      } 
      return value;
    }
  };
  return process(this);
}

function normalizeValue(cb, options) {
  const value = handleError(() => this.$, options);
  return cb(value);
}

function handleError(cb, options = {}) {
  const { error = 'throw' } = options;
  try {
    return cb();
  } catch (err) {
    if (error === 'return') {
      return err;
    } else {
      throw err;
    }
  }
}

function getDataViewDescriptor(structure, handlers = {}) {
  return markAsSpecial({
    get() {
      /* WASM-ONLY */
      restoreMemory.call(this);
      /* WASM-ONLY-END */
      return this[MEMORY];
    },
    set(dv) {
      checkDataView(dv);
      setDataView.call(this, dv, structure, true, handlers);
    },
  });
}

function getBase64Descriptor(structure, handlers = {}) {
  return markAsSpecial({
    get() {
      return encodeBase64(this.dataView);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch('string', str);
      }
      const dv = decodeBase64(str);
      setDataView.call(this, dv, structure, false, handlers);
    }
  });
}

function getStringDescriptor(structure, handlers = {}) {
  const { sentinel, instance: { members }} = structure;
  const { byteSize: charSize } = members[0];
  return markAsSpecial({
    get() {
      const dv = this.dataView;
      const TypedArray = (charSize === 1) ? Int8Array : Int16Array;
      const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
      const s = decodeText(ta, `utf-${charSize * 8}`);
      return (sentinel?.value === undefined) ? s : s.slice(0, -1);
    },
    set(str) {
      if (typeof(str) !== 'string') {
        throwTypeMismatch('a string', str);
      }
      if (sentinel?.value !== undefined) {
        if (str.charCodeAt(str.length - 1) !== sentinel.value) {
          str = str + String.fromCharCode(sentinel.value);
        }
      }
      const ta = encodeText(str, `utf-${charSize * 8}`);
      const dv = new DataView(ta.buffer);   
      setDataView.call(this, dv, structure, false, handlers);
    },
  });
}

function getTypedArrayDescriptor(structure, handlers = {}) {
  const { typedArray } = structure;
  return markAsSpecial({
    get() {
      const dv = this.dataView;
      const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;
      return new typedArray(dv.buffer, dv.byteOffset, length);
    },
    set(ta) {
      if (!isTypedArray(ta, typedArray)) {
        throwTypeMismatch(typedArray.name, ta);
      }
      const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
      setDataView.call(this, dv, structure, true, handlers);
    },
  });
}

function markAsSpecial({ get, set }) {
  get.special = set.special = true;
  return { get, set };
}

function definePointer(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
    isConst,
  } = structure;
  const {
    runtimeSafety = true,
  } = env;
  const { structure: targetStructure } = member;
  const { sentinel } = targetStructure;
  const isTargetSlice = (targetStructure.type === StructureType.Slice);
  const isTargetPointer = (targetStructure.type === StructureType.Pointer);
  const hasLength = isTargetSlice && !sentinel;  
  const addressSize = (hasLength) ? byteSize / 2 : byteSize;
  const { get: getAddress, set: setAddress } = getDescriptor({
    type: MemberType.Uint,
    bitOffset: 0,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { byteSize: addressSize },
  }, env);
  const { get: getLength, set: setLength } = (hasLength) ? getDescriptor({
    type: MemberType.Uint,
    bitOffset: addressSize * 8,
    bitSize: addressSize * 8,
    byteSize: addressSize,
    structure: { name: 'usize', byteSize: addressSize },
  }, env) : {};
  const updateTarget = function() {
    const prevLocation = this[FIXED_LOCATION];
    if (prevLocation) {
      const location = this[LOCATION_GETTER]();
      if (location.address !== prevLocation.address || location.length !== prevLocation.length) {
        const { constructor: Target } = targetStructure;
        const dv = env.findMemory(location.address, location.length * Target[SIZE]);
        const target = Target.call(ENVIRONMENT, dv, { writable: !isConst });
        this[SLOTS][0] = target;
        this[FIXED_LOCATION] = location;
      }
    }    
  };
  const getTargetObject = function() {
    updateTarget.call(this);
    return this[SLOTS][0] ?? throwNullPointer();
  };
  const setTargetObject = function(arg) {
    if (env.inFixedMemory(this)) {
      // the pointer sits in fixed memory--apply the change immediately
      if (env.inFixedMemory(arg)) {
        const loc = {
          address: env.getViewAddress(arg[MEMORY]),
          length: (hasLength) ? arg.length : 1
        };
        addressSetter.call(this, loc);
        this[FIXED_LOCATION] = loc;
      } else {
        throwFixedMemoryTargetRequired();
      }
    }
    this[SLOTS][0] = arg;
  };
  const getTarget = isValueExpected(targetStructure)
  ? function() {
      const target = getTargetObject.call(this);
      return target[GETTER]();
    }
  : getTargetObject;
  const setTarget = function(value) {
    updateTarget.call(this);
    const object = this[SLOTS][0] ?? throwNullPointer();
    return object[SETTER](value);
  };
  const alternateCaster = function(arg, options) {
    const Target = targetStructure.constructor;
    if ((this === ENVIRONMENT || this === PARENT) || arg instanceof constructor) {
      // casting from buffer to pointer is allowed only if request comes from the runtime
      // casting from writable to read-only is also allowed
      return false;
    } else if (isPointerOf(arg, Target)) {
      // const/non-const casting
      return new constructor(Target(arg['*'], { writable: !isConst }), options);
    } else if (isTargetSlice) {
      // allow casting to slice through constructor of its pointer
      return new constructor(Target(arg), options);
    } else {
      throwNoCastingToPointer();
    }
  };
  const finalizer = function() {
    const handlers = (isTargetPointer) ? {} : proxyHandlers$1;
    const proxy = new Proxy(this, handlers);
    // hide the proxy so console wouldn't display a recursive structure
    Object.defineProperty(this, PROXY, { value: proxy });
    return proxy;
  };
  const initializer = function(arg) {
    const Target = targetStructure.constructor;
    if (isPointerOf(arg, Target)) {
      // initialize with the other pointer'structure target
      if (!isConst && arg.constructor.const) {
        throwConstantConstraint(structure, arg);
      }
      arg = arg[SLOTS][0];
    }
    if (arg instanceof Target) {
      /* wasm-only */
      restoreMemory.call(arg);
      /* wasm-only-end */
      if (isConst && !arg[CONST]) {
        // create read-only version
        arg = Target(arg, { writable: false });
      } else if (!isConst && arg[CONST]) {
        throwReadOnlyTarget(structure);       
      }
    } else if (isCompatible(arg, Target)) {
      // autocast to target type
      const dv = getDataView(targetStructure, arg, env);
      arg = Target(dv, { writable: !isConst });
    } else if (arg !== undefined && !arg[MEMORY]) {
      // autovivificate target object
      const fixed = env.inFixedMemory(this);
      const autoObj = new Target(arg, { writable: !isConst, fixed });
      if (runtimeSafety) {
        // creation of a new slice using a typed array is probably
        // not what the user wants; it's more likely that the intention
        // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
        if (targetStructure.typedArray && isBuffer(arg?.buffer)) {
          warnImplicitArrayCreation(targetStructure, arg);
        }
      }
      arg = autoObj;
    } else if (arg !== undefined) {
      throwInvalidPointerTarget(structure, arg);
    }
    this[TARGET_SETTER](arg);
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster, finalizer }, env);
  const addressSetter = function({ address, length }) {
    setAddress.call(this, address);
    setLength?.call(this, length);
  };
  const addressGetter = function() {
    const address = getAddress.call(this);
    const length = (getLength) 
    ? getLength.call(this)
    : (sentinel)
      ? (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0
      : 1;
    return { address, length };
  };
  const instanceDescriptors = {
    '*': { get: getTarget, set: setTarget },
    '$': { get: getProxy, set: initializer },
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [TARGET_GETTER]: { value: getTargetObject },
    [TARGET_SETTER]: { value: setTargetObject },
    [LOCATION_GETTER]: { value: addressGetter },
    [LOCATION_SETTER]: { value: addressSetter },
    [POINTER_VISITOR]: { value: visitPointer },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [VIVIFICATOR]: { value: throwNullPointer },
    [NORMALIZER]: { value: normalizePointer },
    [FIXED_LOCATION]: { value: undefined, writable: true },
  };
  const staticDescriptors = {
    child: { get: () => targetStructure.constructor },
    const: { value: isConst },
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function normalizePointer(cb) {
  let target;
  try {
    target = this['*'];
  } catch (err) {
    target = Symbol.for('inaccessible');
  }
  return cb(target);
}

function getProxy() {
  return this[PROXY];
}

function copyPointer({ source }) {
  const target = source[SLOTS][0];
  if (target) {
    this[TARGET_SETTER](target);
  }
}

function resetPointer({ isActive }) {
  if (this[SLOTS][0] && !isActive(this)) {
    this[SLOTS][0] = undefined;
  }
}

function disablePointer() {
  const disabledProp = { get: throwInaccessiblePointer, set: throwInaccessiblePointer };
  const disabledFunc = { value: throwInaccessiblePointer };
  defineProperties(this[POINTER], {
    '*': disabledProp,
    '$': disabledProp,
    [GETTER]: disabledFunc,
    [SETTER]: disabledFunc,
    [TARGET_GETTER]: disabledFunc,
  });
}

function visitPointer(fn, options = {}) {
  const {
    source,
    isActive = always,
    isMutable = always,
  } = options;
  fn.call(this, { source, isActive, isMutable });
}

function isPointerOf(arg, Target) {
  return (arg?.constructor?.child === Target && arg['*']);
}

const proxyHandlers$1 = {
  get(pointer, name) {
    if (name === POINTER) {
      return pointer;
    } else if (name in pointer) {
      return pointer[name];
    } else {
      const target = pointer[TARGET_GETTER]();
      return target[name];
    }
  },
  set(pointer, name, value) {
    if (name in pointer) {
      pointer[name] = value;
    } else {
      const target = pointer[TARGET_GETTER]();
      target[name] = value;
    }
    return true;
  },
  deleteProperty(pointer, name) {
    if (name in pointer) {
      delete pointer[name];
    } else {
      const target = pointer[TARGET_GETTER]();
      delete target[name];
    }
    return true;
  },
  has(pointer, name) {
    if (name in pointer) {
      return true;
    } else {
      const target = pointer[TARGET_GETTER]();
      return name in target;
    }
  },
};

function always() {
  return true;
}

function never() {
  return false;
}

function defineStructShape(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;  
  const memberDescriptors = {};
  for (const member of members) {
    const { get, set } = getDescriptor(member, env);
    memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };
    if (member.isRequired && set) {
      set.required = true;
    }
  }
  const hasObject = !!members.find(m => m.type === MemberType.Object);
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER](arg);
      if (hasPointer) {
        this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      propApplier.call(this, arg);
    } else if (arg !== undefined) {
      throwInvalidInitializer(structure, 'object', arg);
    }
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: getSelf, set: initializer },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getStructIterator },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },
    [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, always) },
    [NORMALIZER]: { value: normalizeStruct },
    [PROPS]: { value: members.map(m => m.name) },
  };
  const staticDescriptors = {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeStruct(cb, options) {
  const object = {};
  for (const [ name, value ] of getStructEntries.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getStructEntries(options) {
  return {
    [Symbol.iterator]: getStructEntriesIterator.bind(this, options),
    length: this[PROPS].length,
  };
}

function getStructIterator(options) { 
  const entries = getStructEntries.call(this, options);
  return entries[Symbol.iterator]();
}

function getStructEntriesIterator(options) {
  const self = this;
  const props = this[PROPS];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        value = [ current, handleError(() => self[current], options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}
  
function getChildVivificator$1(structure) {
  const { instance: { members } } = structure;
  const objectMembers = {};
  for (const member of members.filter(m => m.type === MemberType.Object)) {
    objectMembers[member.slot] = member;
  }
  return function vivificateChild(slot, writable = true) {
    const member = objectMembers[slot];
    const { bitOffset, byteSize, structure: { constructor } } = member;
    const dv = this[MEMORY];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + (bitOffset >> 3);
    let len = byteSize;
    if (len === undefined) {
      if (bitOffset & 7) {
        throwNotOnByteBoundary(member);
      }
      len = member.bitSize >> 3;
    }
    const childDV = new DataView(dv.buffer, offset, len);
    const object = this[SLOTS][slot] = constructor.call(PARENT, childDV, { writable });
    return object;
  }
}

function getPointerVisitor$1(structure, visitorOptions = {}) {
  const {
    isChildActive = always,
    isChildMutable = always,
  } = visitorOptions;
  const { instance: { members } } = structure;
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always,
      isMutable = always,
    } = options;
    const childOptions = {
      ...options,
      isActive: (object) => {
        // make sure parent object is active, then check whether the child is active
        return isActive(this) && isChildActive.call(this, object);
      },
      isMutable: (object) => {
        return isMutable(this) && isChildMutable.call(this, object);
      },
    };
    for (const { slot } of pointerMembers) {
      if (source) {
        // when src is a the struct's template, most slots will likely be empty,
        // since pointer fields aren't likely to have default values
        const srcChild = source[SLOTS]?.[slot];
        if (!srcChild) {
          continue;
        }
        childOptions.source = srcChild;
      }
      const child = this[SLOTS][slot] ?? (vivificate ? this[VIVIFICATOR](slot) : null);
      if (child) {
        child[POINTER_VISITOR](cb, childOptions);
      }
    }
  };
}

function defineArgStruct(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const hasObject = !!members.find(m => m.type === MemberType.Object);
  const constructor = structure.constructor = function(args) {
    const dv = env.allocateMemory(byteSize, align);
    this[MEMORY] = dv;
    if (hasObject) {
      this[SLOTS] = {};
    }
    initializer.call(this, args);
  };
  const argNames = members.slice(0, -1).map(m => m.name);
  const argCount = argNames.length;
  const initializer = function(args) {
    if (args.length !== argCount) {
      throwArgumentCountMismatch(structure, args.length);
    }
    for (const [ index, name ] of argNames.entries()) {
      try {
        this[name] = args[index];
      } catch (err) {
        rethrowArgumentError(structure, index, err);
      }
    }
  };
  const memberDescriptors = {};
  for (const member of members) {
    memberDescriptors[member.name] = getDescriptor(member, env);
  }
  const isChildMutable = function(object) {
      return (object === this.retval);
  };
  defineProperties(constructor.prototype, {
    ...memberDescriptors,
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },
    [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildMutable }) },
  });
  defineProperties(constructor, {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  });
  return constructor;
}

function defineArray(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor(member, env);
  const hasStringProp = canBeString(member);
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER](arg);
      if (hasPointer) {
        this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
      }
    } else {
      if (typeof(arg) === 'string' && hasStringProp) {
        arg = { string: arg };
      }
      if (arg?.[Symbol.iterator]) {
        arg = transformIterable(arg);
        if (arg.length !== length) {
          throwArrayLengthMismatch(structure, this, arg);
        }
        let i = 0;
        for (const value of arg) {
          set.call(this, i++, value);
        }
      } else if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidArrayInitializer(structure, arg);
        }
      } else if (arg !== undefined) {
        throwInvalidArrayInitializer(structure, arg);
      }
    }
  };
  const finalizer = createArrayProxy;
  const constructor = structure.constructor = createConstructor(structure, { initializer, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass(member);
  const hasObject = member.type === MemberType.Object;
  const instanceDescriptors = {
    $: { get: getProxy, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    string: hasStringProp && getStringDescriptor(structure),
    typedArray: typedArray && getTypedArrayDescriptor(structure),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries },
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [Symbol.iterator]: { value: getArrayIterator },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator(structure) },
    [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor() },
    [NORMALIZER]: { value: normalizeArray },
  };
  const staticDescriptors = {
    child: { get: () => member.structure.constructor },
    [COMPAT]: { value: getCompatibleTags(structure) },
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function createArrayProxy() {
  const proxy = new Proxy(this, proxyHandlers);
  // hide the proxy so console wouldn't display a recursive structure
  Object.defineProperty(this, PROXY, { value: proxy }); 
  return proxy;
}

function canBeString(member) {
  return member.type === MemberType.Uint && [ 8, 16 ].includes(member.bitSize);
}

function normalizeArray(cb, options) {
  const array = [];
  for (const [ index, value ] of getArrayEntries.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getArrayIterator() {
  const self = this[ARRAY] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self.get(current);
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntriesIterator(options) {
  const self = this[ARRAY] ?? this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < length) {
        const current = index++;
        value = [ current, handleError(() => self.get(current), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getArrayEntries(options) {
  return {
    [Symbol.iterator]: getArrayEntriesIterator.bind(this, options),
    length: this.length,
  };
}

function getChildVivificator(structure) {
  const { instance: { members: [ member ]} } = structure;
  const { byteSize, structure: elementStructure } = member;
  return function getChild(index, writable = true) {
    const { constructor } = elementStructure;
    const dv = this[MEMORY];
    const parentOffset = dv.byteOffset;
    const offset = parentOffset + byteSize * index;
    const childDV = new DataView(dv.buffer, offset, byteSize);
    const object = this[SLOTS][index] = constructor.call(PARENT, childDV, { writable });
    return object;
  };
}

function getPointerVisitor(structure) {
  return function visitPointers(cb, options = {}) {
    const {
      source,
      vivificate = false,
      isActive = always,
      isMutable = always,
    } = options;
    const childOptions = {
      ...options,
      isActive: () => isActive(this),
      isMutable: () => isMutable(this),
    };
    for (let i = 0, len = this.length; i < len; i++) {
      // no need to check for empty slots, since that isn't possible
      if (source) {
        childOptions.source = source?.[SLOTS][i];
      }
      const child = this[SLOTS][i] ?? (vivificate ? this[VIVIFICATOR](i) : null);
      if (child) {
        child[POINTER_VISITOR](cb, childOptions);
      }
    }
  };
}

function transformIterable(arg) {
  if (typeof(arg.length) === 'number') {
    // it's an array of sort
    return arg;
  }
  const iterator = arg[Symbol.iterator]();
  const first = iterator.next();
  const length = first.value?.length;
  if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
    // return generator with length attached
    return Object.assign((function*() {
      let result;
      while (!(result = iterator.next()).done) {
        yield result.value;
      }
    })(), { length });
  } else {
    const array = [];
    let result = first;
    while (!result.done) {
      array.push(result.value);
      result = iterator.next();
    }
    return array;
  }
}

const proxyHandlers = {
  get(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return array.get(index);
    } else {
      switch (name) {
        case 'get':
          if (!array[ELEMENT_GETTER]) {
            array[ELEMENT_GETTER] = array.get.bind(array);
          }
          return array[ELEMENT_GETTER];
        case 'set':
          if (!array[ELEMENT_SETTER]) {
            array[ELEMENT_SETTER] = array.set.bind(array);
          }
          return array[ELEMENT_SETTER];
        case ARRAY:
          return array;
        default:
          return array[name];
      }
    }
  },
  set(array, name, value) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      array.set(index, value);
    } else {
      switch (name) {
        case 'get':
          array[ELEMENT_GETTER] = value;
          break;
        case 'set':
          array[ELEMENT_SETTER] = value;
          break;
        default:
          array[name] = value;
      }
    }
    return true;
  },
  deleteProperty(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return false;
    } else {
      switch (name) {
        case 'get':
          delete array[ELEMENT_GETTER];
          break;
        case 'set':
          delete array[ELEMENT_SETTER];
          break;
        default:
          delete array[name];
      }
      return true;
    }
  },
  has(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      return (index >= 0 && index < array.length);
    } else {
      return array[name];
    }
  },
  ownKeys(array) {
    const keys = [];
    for (let i = 0, len = array.length; i < len; i++) {
      keys.push(`${i}`);
    }
    keys.push('length', PROXY);
    return keys;
  },
  getOwnPropertyDescriptor(array, name) {
    const index = (typeof(name) === 'symbol') ? 0 : name|0;
    if (index !== 0 || index == name) {
      if (index >= 0 && index < array.length) {
        return { value: array.get(index), enumerable: true, writable: true, configurable: true };
      }
    } else {
      return Object.getOwnPropertyDescriptor(array, name);
    }
  },
};

function defineEnumerationShape(structure, env) {
  const {
    byteSize,
    align,
    instance: {
      members: [ member ],
    },
  } = structure;
  const { get: getIndex, set: setIndex } = getDescriptor(member, env);
  // get the enum descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor({ ...member, type: MemberType.EnumerationItem, structure }, env);
  const expected = [ 'string', 'number', 'tagged union' ];
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidInitializer(structure, expected, arg);
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
      const items = constructor[ITEMS];
      let item = items[arg];
      if (!item) {
        if (constructor[MORE] && typeof(arg) !== 'string') {
          // create the item on-the-fly when enum is non-exhaustive
          item = items[arg] = new constructor(undefined);          
          setIndex.call(item, arg);
          defineProperties(item, { [NAME]: { value: `${arg}` } });
        }
      }
      return item;
    } else if (arg?.[TAG] instanceof constructor) {
      // a tagged union, return the active tag
      return arg[TAG];
    } else if (!getDataView(structure, arg, env)) {
      throwInvalidInitializer(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster }, env);
  const typedArray = structure.typedArray = getTypedArrayClass(member);
  const toPrimitive = function(hint) {
    return (hint === 'string') ? this.$[NAME] : getIndex.call(this);
  };
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    typedArray: typedArray && getTypedArrayDescriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [NORMALIZER]: { value: normalizeEnumerationItem },
  };
  const staticDescriptors = {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
    [ITEMS]: { value: {} },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeEnumerationItem(cb) {
  return cb(this.$[NAME]);
}

function defineErrorSet(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get: getIndex } = getDescriptor(member, env);
  // get the error descriptor instead of the int/uint descriptor
  const { get, set } = getDescriptor({ ...member, type: MemberType.Error, structure }, env);
  const expected = [ 'string', 'number' ];
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg && typeof(arg) === 'object') {
      try {
        if (propApplier.call(this, arg) === 0) {
          throwInvalidInitializer(structure, expected, arg);
        } 
      } catch (err) {
        const { error } = arg;
        if (typeof(error) === 'string') {
          set.call(this, error);
        } else {
          throw err;
        }
      }
    } else if (arg !== undefined) {
      set.call(this, arg);
    }
  };
  const alternateCaster = function(arg) {
    if (typeof(arg) === 'number' || typeof(arg) === 'string') {
      return constructor[ITEMS][arg];
    } else if (!getDataView(structure, arg, env)) {
      throwInvalidInitializer(structure, expected, arg);
    } else {
      return false;
    }
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster }, env);
  Object.setPrototypeOf(constructor.prototype, globalErrorSet.prototype);
  const typedArray = structure.typedArray = getTypedArrayClass(member);
  const getMessage = function() { return this.$.message; };
  const toStringTag = function() { return 'Error' };
  const toPrimitive = function(hint) {
    if (hint === 'string') {
      return Error.prototype.toString.call(this, hint);
    } else {
      return getIndex.call(this);
    }
  };
  const instanceDescriptors = {
    $: { get, set },
    message: { get: getMessage },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    typedArray: typedArray && getTypedArrayDescriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    // ensure that libraries that rely on the string tag for type detection will
    // correctly identify the object as an error
    [Symbol.toStringTag]: { get: toStringTag },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [NORMALIZER]: { value: get },
  };
  const staticDescriptors = {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
    [ITEMS]: { value: {} },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}
let globalErrorSet;

function getGlobalErrorSet() {
  return globalErrorSet;
}

function defineErrorUnion(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor(members[0], env);
  const { get: getError, set: setError } = getDescriptor(members[1], env);
  const get = function() {
    const error = getError.call(this, true);
    if (error) {
      throw error;
    } else {
      return getValue.call(this);
    }
  };
  const isValueVoid = members[0].type === MemberType.Void;
  const acceptAny = members[1].structure.name === 'anyerror';
  const TargetError = (acceptAny) ? getGlobalErrorSet() : members[1].structure.constructor;
  const isChildActive = function() {
    return !getError.call(this, true);
  };
  const clearValue = function() {
    this[RESETTER]();
    this[POINTER_VISITOR]?.(resetPointer);
  };
  const hasObject = !!members.find(m => m.type === MemberType.Object);
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER](arg);
      if (hasPointer) {
        if (isChildActive.call(this)) {
          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
        }
      }
    } else if (arg instanceof TargetError) {
      setError.call(this, arg);
      clearValue.call(this);
    } else if (arg !== undefined || isValueVoid) {
      try {
        // call setValue() first, in case it throws
        setValue.call(this, arg);
        setError.call(this, 0, true);
      } catch (err) {
        if (arg instanceof Error) {
          // we give setValue a chance to see if the error is actually an acceptable value
          // now is time to throw an error
          throwNotInErrorSet(structure);
        } else if (arg && typeof(arg) === 'object') {
          try {
            if (propApplier.call(this, arg) === 0) {
              throw err;
            }
          } catch (err) {
            const { error } = arg;
            if (typeof(error) === 'string') {
              setError.call(this, error);
              clearValue.call(this);
            } else {
              throw err;
            }   
          }                   
        } else {
          throw err;
        }
      }
    }
  };  
  const constructor = structure.constructor = createConstructor(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const instanceDescriptors = {
    '$': { get, set: initializer },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [RESETTER]: { value: getMemoryResetter(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },
    [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },
    [NORMALIZER]: { value: normalizeValue },
  };
  const staticDescriptors = {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function defineOpaque(structure, env) {
  const {
    byteSize,
    align,
  } = structure;
  const initializer = function() {
    throwCreatingOpaque(structure);
  };
  const valueAccessor = function() {
    throwAccessingOpaque(structure);
  };
  const toPrimitive = function(hint) {
    const { name } = structure;
    return `[opaque ${name}]`;
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer }, env);
  const instanceDescriptors = {
    $: { get: valueAccessor, set: valueAccessor },
    dataView: getDataViewDescriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [Symbol.toPrimitive]: { value: toPrimitive },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [NORMALIZER]: { value: normalizeOpaque },
  };
  const staticDescriptors = {
    [COMPAT]: { value: getCompatibleTags(structure) },
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}
function normalizeOpaque(cb) {
  return {};
}

function defineOptional(structure, env) {
  const {
    byteSize,
    align,
    instance: { members },
    hasPointer,
  } = structure;
  const { get: getValue, set: setValue } = getDescriptor(members[0], env);
  const { get: getPresent, set: setPresent } = getDescriptor(members[1], env);
  const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  
  const get = function() {
    const present = getPresent.call(this);
    if (present) {
      return getValue.call(this);
    } else {
      this[POINTER_VISITOR]?.(resetPointer);
      return null;
    }
  };
  const isValueVoid = members[0].type === MemberType.Void;
  const isChildActive = getPresent;
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER](arg);
      if (hasPointer) {
        // don't bother copying pointers when it's empty
        if (isChildActive.call(arg)) {
          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
        }
      }      
    } else if (arg === null) {
      setPresent.call(this, false);
      this[RESETTER]?.();
      // clear references so objects can be garbage-collected
      this[POINTER_VISITOR]?.(resetPointer);
    } else if (arg !== undefined || isValueVoid) {      
      // call setValue() first, in case it throws
      setValue.call(this, arg);
      if (hasPresentFlag || !env.inFixedMemory(this)) {
        // since setValue() wouldn't write address into memory when the pointer is in 
        // relocatable memory, we need to use setPresent() in order to write something 
        // non-zero there so that we know the field is populated
        setPresent.call(this, true);
      }
    }
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer }, env);
  const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];
  const hasObject = !!members.find(m => m.type === MemberType.Object);
  const instanceDescriptors = {
    $: { get, set: initializer },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer
    [RESETTER]: !hasPointer && { value: getMemoryResetter(valueBitOffset / 8, valueByteSize) },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },
    [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },
    [NORMALIZER]: { value: normalizeValue },
  };
  const staticDescriptors = {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function defineSlice(structure, env) {
  const {
    align,
    instance: {
      members: [ member ],
    },
    hasPointer,
  } = structure;
  const { get, set } = getDescriptor(member, env);
  const { byteSize: elementSize, structure: elementStructure } = member;
  const sentinel = getSentinel(structure, env);
  if (sentinel) {
    // zero-terminated strings aren't expected to be commonly used
    // so we're not putting this prop into the standard structure
    structure.sentinel = sentinel;
  }
  const hasStringProp = canBeString(member);
  const shapeDefiner = function(dv, length, fixed = false) {
    if (!dv) {
      dv = env.allocateMemory(length * elementSize, align, fixed);
    }
    this[MEMORY] = dv;
    this[LENGTH] = length;
  };
  const shapeChecker = function(arg, length) {
    if (length !== this[LENGTH]) {
      throwArrayLengthMismatch(structure, this, arg);
    }
  };
  // the initializer behave differently depending on whether it's called by the
  // constructor or by a member setter (i.e. after object's shape has been established)
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg, fixed = false) {
    if (arg instanceof constructor) {
      if (!this[MEMORY]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      this[COPIER](arg);
      if (hasPointer) {
        this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
      }
    } else if (typeof(arg) === 'string' && hasStringProp) {
      initializer.call(this, { string: arg }, fixed);
    } else if (arg?.[Symbol.iterator]) {
      arg = transformIterable(arg);
      if (!this[MEMORY]) {
        shapeDefiner.call(this, null, arg.length, fixed);
      } else {
        shapeChecker.call(this, arg, arg.length);
      }
      let i = 0;
      for (const value of arg) {
        sentinel?.validateValue(value, i, arg.length);
        set.call(this, i++, value);
      }
    } else if (typeof(arg) === 'number') {
      if (!this[MEMORY] && arg >= 0 && isFinite(arg)) {
        shapeDefiner.call(this, null, arg);
      } else {
        throwInvalidArrayInitializer(structure, arg, !this[MEMORY]);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer(structure, arg);
    }
  };
  const finalizer = createArrayProxy;
  const constructor = structure.constructor = createConstructor(structure, { initializer, shapeDefiner, finalizer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass(member);
  const hasObject = member.type === MemberType.Object;
  const shapeHandlers = { shapeDefiner };
  const instanceDescriptors = {
    $: { get: getProxy, set: initializer },
    length: { get: getLength },
    dataView: getDataViewDescriptor(structure, shapeHandlers),
    base64: getBase64Descriptor(structure, shapeHandlers),
    string: hasStringProp && getStringDescriptor(structure, shapeHandlers),
    typedArray: typedArray && getTypedArrayDescriptor(structure, shapeHandlers),
    get: { value: get },
    set: { value: set },
    entries: { value: getArrayEntries },
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [Symbol.iterator]: { value: getArrayIterator },
    [COPIER]: { value: getMemoryCopier(elementSize, true) },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator(structure) },
    [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor() },
    [NORMALIZER]: { value: normalizeArray },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT]: { value: getCompatibleTags(structure) },
    [ALIGN]: { value: align },
    [SIZE]: { value: elementSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function getLength() {
  return this[LENGTH];
}

function getSentinel(structure, env) {
  const {
    runtimeSafety = true,
  } = env;
  const {
    byteSize,
    instance: { members: [ member, sentinel ], template },
  } = structure;
  if (!sentinel) {
    return;
  }
  const { get: getSentinelValue } = getDescriptor(sentinel, env);
  const value = getSentinelValue.call(template, 0);
  const { get } = getDescriptor(member, env);
  const validateValue = (runtimeSafety) ? function(v, i, l) {
    if (v === value && i !== l - 1) {
      throwMisplacedSentinel(structure, v, i, l);
    } else if (v !== value && i === l - 1) {
      throwMissingSentinel(structure, value, i);
    }
  } : function(v, i, l) {
    if (v !== value && i === l - 1) {
      throwMissingSentinel(structure, value, l);
    }
  };
  const validateData = (runtimeSafety) ? function(source, len) {
    for (let i = 0; i < len; i++) {
      const v = get.call(source, i);
      if (v === value && i !== len - 1) {
        throwMisplacedSentinel(structure, value, i, len);
      } else if (v !== value && i === len - 1) {
        throwMissingSentinel(structure, value, len);
      }
    }
  } : function(source, len) {
    if (len * byteSize === source[MEMORY].byteLength) {
      const i = len - 1;
      const v = get.call(source, i);
      if (v !== value) {
        throwMissingSentinel(structure, value, len);
      }
    }
  };
  const bytes = template[MEMORY];
  return { value, bytes, validateValue, validateData };
}

function defineUnionShape(structure, env) {
  const {
    type,
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const { runtimeSafety } = env;
  const isTagged = (type === StructureType.TaggedUnion);
  const exclusion = (isTagged || (type === StructureType.BareUnion && runtimeSafety));
  const memberDescriptors = {};
  const memberInitializers = {};
  const memberValueGetters = {};
  const valueMembers = (exclusion) ? members.slice(0, -1) : members;
  const selectorMember = (exclusion) ? members[members.length - 1] : null;  
  const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor(selectorMember, env) : {};
  const getActiveField = (isTagged)
  ? function() {
      const item = getSelector.call(this);
      return item[NAME];
    }
  : function() {
      const index = getSelector.call(this);
      return valueMembers[index].name;
    };
  const setActiveField = (isTagged)
  ? function(name) {
      const { constructor } = selectorMember.structure;
      setSelector.call(this, constructor[name]);
    }
  : function(name) {
      const index = valueMembers.findIndex(m => m.name === name);
      setSelector.call(this, index);
    };
  for (const member of valueMembers) {
    const { name } = member;
    const { get: getValue, set: setValue } = getDescriptor(member, env);
    const get = (exclusion)
    ? function() {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          if (isTagged) {
            // tagged union allows inactive member to be queried
            return null;
          } else {
            // whereas bare union does not, since the condition is not detectable 
            // when runtime safety is off
            throwInactiveUnionProperty(structure, name, currentName);
          }
        }
        this[POINTER_VISITOR]?.(resetPointer);
        return getValue.call(this);
      }
    : getValue;
    const set = (exclusion && setValue) 
    ? function(value) {
        const currentName = getActiveField.call(this);
        if (name !== currentName) {
          throwInactiveUnionProperty(structure, name, currentName);
        }
        setValue.call(this, value);
      }
    : setValue;
    const init = (exclusion && setValue)
    ? function(value) {
        setActiveField.call(this, name);
        setValue.call(this, value);
        this[POINTER_VISITOR]?.(resetPointer);
      }
    : setValue;
    memberDescriptors[name] = { get, set, configurable: true, enumerable: true };
    memberInitializers[name] = init;
    memberValueGetters[name] = getValue;
  }
  const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);
  const memberKeys = Object.keys(memberDescriptors);
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      /* WASM-ONLY-END */
      this[COPIER](arg);
      if (hasPointer) {
        this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
      }
    } else if (arg && typeof(arg) === 'object') {
      let found = 0;
      for (const key of memberKeys) {
        if (key in arg) {
          found++;
        }
      }
      if (found > 1) {
        throwMultipleUnionInitializers(structure);
      }
      if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {
        throwMissingUnionInitializer(structure, arg, exclusion);
      }
    } else if (arg !== undefined) {
      throwInvalidInitializer(structure, 'object with a single property', arg);
    }
  };
  // non-tagged union as marked as not having pointers--if there're actually
  // members with pointers, we need to disable them
  const pointerMembers = members.filter(m => m.structure.hasPointer);
  const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);
  const modifier = (hasInaccessiblePointer && !env.comptime)
  ? function() {
      // make pointer access throw
      this[POINTER_VISITOR](disablePointer, { vivificate: true });
    }
  : undefined;
  const constructor = structure.constructor = createConstructor(structure, { modifier, initializer }, env);
  const fieldDescriptor = (isTagged)
  ? { 
      // for tagged union,  only the active field
      get() { return [ getActiveField.call(this) ] } 
    }
  : { 
      // for bare and extern union, all members are included 
      value: valueMembers.map(m => m.name)
    };
  const isChildActive = (isTagged)
  ? function(child) {
      const name = getActiveField.call(this);
      const active = memberValueGetters[name].call(this);
      return child === active;
    }
  : never;
  const hasAnyPointer = hasPointer || hasInaccessiblePointer;
  const hasObject = !!members.find(m => m.type === MemberType.Object);
  const instanceDescriptors = {
    $: { get: getSelf, set: initializer, configurable: true },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    ...memberDescriptors,
    [Symbol.iterator]: { value: getUnionIterator },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [TAG]: isTagged && { get: getSelector, configurable: true },
    [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },
    [POINTER_VISITOR]: hasAnyPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },
    [PROP_GETTERS]: { value: memberValueGetters },
    [NORMALIZER]: { value: normalizeUnion },
    [PROPS]: fieldDescriptor,
  };  
  const staticDescriptors = {
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
  // replace regular setters with ones that change the active field
  const setters = constructor.prototype[PROP_SETTERS];
  for (const [ name, init ] of Object.entries(memberInitializers)) {
    if (init) {
      setters[name] = init;
    }
  }
}
function normalizeUnion(cb, options) {
  const object = {};
  for (const [ name, value ] of getUnionEntries.call(this, options)) {
    object[name] = cb(value);
  }
  return object;
}

function getUnionEntries(options) {
  return {
    [Symbol.iterator]: getUnionEntriesIterator.bind(this, options),
    length: this[PROPS].length,
  };
}

function getUnionIterator(options) { 
  const entries = getUnionEntries.call(this, options);
  return entries[Symbol.iterator]();
}

function getUnionEntriesIterator(options) {
  const self = this;
  const props = this[PROPS];
  const getters = this[PROP_GETTERS];
  let index = 0;
  return {
    next() {
      let value, done;      
      if (index < props.length) {
        const current = props[index++];
        // get value of prop with no check
        value = [ current, handleError(() => getters[current].call(self), options) ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function defineVector(structure, env) {
  const {
    length,
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { bitSize: elementBitSize, structure: elementStructure } = member;
  const elementDescriptors = {};
  for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
    const { get, set } = getDescriptor({ ...member, bitOffset }, env);
    elementDescriptors[i] = { get, set, configurable: true };
  }
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER](arg);
    } else if (arg?.[Symbol.iterator]) {
      let argLen = arg.length;
      if (typeof(argLen) !== 'number') {
        arg = [ ...arg ];
        argLen = arg.length;
      }
      if (argLen !== length) {
        throwArrayLengthMismatch(structure, this, arg);
      }
      let i = 0;
      for (const value of arg) {
        this[PROP_SETTERS][i++].call(this, value);
      }
    } else if (arg && typeof(arg) === 'object') {
      if (propApplier.call(this, arg) === 0) {
        throwInvalidArrayInitializer(structure, arg);
      }
    } else if (arg !== undefined) {
      throwInvalidArrayInitializer(structure, arg);
    }
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass(member);
  const instanceDescriptors = {
    ...elementDescriptors,
    $: { get: getSelf, set: initializer },
    length: { value: length },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    typedArray: typedArray && getTypedArrayDescriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    entries: { value: getVectorEntries },
    delete: { value: getDestructor(structure) },
    [Symbol.iterator]: { value: getVectorIterator },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [NORMALIZER]: { value: normalizeVector },
  };
  const staticDescriptors = {
    child: { get: () => elementStructure.constructor },
    [COMPAT]: { value: getCompatibleTags(structure) },
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}

function normalizeVector(cb, options) {
  const array = [];
  for (const [ index, value ] of getVectorEntries.call(this, options)) {
    array.push(cb(value));
  }
  return array;
}

function getVectorIterator() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = self[current];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntriesIterator() {
  const self = this;
  const length = this.length;
  let index = 0;
  return {
    next() {
      let value, done;
      if (index < length) {
        const current = index++;
        value = [ current, self[current] ];
        done = false;
      } else {
        done = true;
      }
      return { value, done };
    },
  };
}

function getVectorEntries() {
  return {
    [Symbol.iterator]: getVectorEntriesIterator.bind(this),
    length: this.length,
  };
}

const StructureType = {
  Primitive: 0,
  Array: 1,
  Struct: 2,
  ExternStruct: 3,
  PackedStruct: 4,
  ArgStruct: 5,
  ExternUnion: 6,
  BareUnion: 7,
  TaggedUnion: 8,
  ErrorUnion: 9,
  ErrorSet: 10,
  Enumeration: 11,
  Optional: 12,
  Pointer: 13,
  Slice: 14,
  Vector: 15,
  Opaque: 16,
  Function: 17,
};

const factories$2 = Array(Object.values(StructureType).length);

function usePrimitive() {
  factories$2[StructureType.Primitive] = definePrimitive;
}

function useArray() {
  factories$2[StructureType.Array] = defineArray;
}

function useStruct() {
  factories$2[StructureType.Struct] = defineStructShape;
}

function usePackedStruct() {
  factories$2[StructureType.PackedStruct] = defineStructShape;
}

function useExternStruct() {
  factories$2[StructureType.ExternStruct] = defineStructShape;
}

function useArgStruct() {
  factories$2[StructureType.ArgStruct] = defineArgStruct;
}

function useExternUnion() {
  factories$2[StructureType.ExternUnion] = defineUnionShape;
}

function useBareUnion() {
  factories$2[StructureType.BareUnion] = defineUnionShape;
}

function useTaggedUnion() {
  factories$2[StructureType.TaggedUnion] = defineUnionShape;
}

function useErrorUnion() {
  factories$2[StructureType.ErrorUnion] = defineErrorUnion;
}

function useErrorSet() {
  factories$2[StructureType.ErrorSet] = defineErrorSet;
}

function useEnumeration() {
  factories$2[StructureType.Enumeration] = defineEnumerationShape;
}

function useOptional() {
  factories$2[StructureType.Optional] = defineOptional;
}

function usePointer() {
  factories$2[StructureType.Pointer] = definePointer;
}

function useSlice() {
  factories$2[StructureType.Slice] = defineSlice;
}

function useVector() {
  factories$2[StructureType.Vector] = defineVector;
}

function useOpaque() {
  factories$2[StructureType.Opaque] = defineOpaque;
}

function defineProperties(object, descriptors) {
  for (const [ name, descriptor ] of Object.entries(descriptors)) {
    if (descriptor) {
      const { 
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get) 
        ? { get, set, configurable, enumerable } 
        : { value, configurable, enumerable, writable }
      );
    }
  }
  for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
    const descriptor = descriptors[symbol];
    if (descriptor) {
      Object.defineProperty(object, symbol, descriptor);
    }
  }
}

function attachDescriptors(constructor, instanceDescriptors, staticDescriptors) {
  // create prototype for read-only objects
  const prototypeRO = {};
  Object.setPrototypeOf(prototypeRO, constructor.prototype);
  const instanceDescriptorsRO = {};
  const propSetters = {};
  for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {
    if (descriptor?.set) {
      instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly };
      // save the setters so we can initialize read-only objects
      if (name !== '$') {
        propSetters[name] = descriptor.set;
      }
    } else if (name === 'set') {
      instanceDescriptorsRO[name] = { value: throwReadOnly, configurable: true, writable: true };
    }
  }
  const vivificate = instanceDescriptors[VIVIFICATOR]?.value;
  const vivificateDescriptor = { 
    // vivificate child objects as read-only too
    value: function(slot) { 
      return vivificate.call(this, slot, false);
    }
  };
  const { get, set } = instanceDescriptors.$;
  defineProperties(constructor.prototype, { 
    [CONST]: { value: false },
    [ALL_KEYS]: { value: Object.keys(propSetters) },
    [SETTER]: { value: set },
    [GETTER]: { value: get },
    [PROP_SETTERS]: { value: propSetters },
    ...instanceDescriptors,
  });
  defineProperties(constructor, {
    [CONST_PROTOTYPE]: { value: prototypeRO },
    ...staticDescriptors,
  }); 
  defineProperties(prototypeRO, { 
    constructor: { value: constructor, configurable: true },
    [CONST]: { value: true },
    [SETTER]: { value: throwReadOnly },
    [VIVIFICATOR]: vivificate && vivificateDescriptor,
    ...instanceDescriptorsRO,
  });
  return constructor;
}

function createConstructor(structure, handlers, env) {
  const {
    byteSize,
    align,
    instance: { members, template },
    hasPointer,
  } = structure;
  const {
    modifier,
    initializer,
    finalizer,
    alternateCaster,
    shapeDefiner,
  } = handlers;
  const hasSlots = needSlots(members);
  // comptime fields are stored in the instance template's slots
  let comptimeFieldSlots;
  if (template?.[SLOTS]) {
    const comptimeMembers = members.filter(m => isReadOnly(m.type));
    if (comptimeMembers.length > 0) {
      comptimeFieldSlots = comptimeMembers.map(m => m.slot);
    } 
  }
  const cache = new ObjectCache();
  const constructor = function(arg, options = {}) {
    const {
      writable = true,
      fixed = false,
    } = options;
    const creating = this instanceof constructor;
    let self, dv;
    if (creating) {
      if (arguments.length === 0) {
        throwNoInitializer(structure);
      }
      self = this;
      if (hasSlots) {
        self[SLOTS] = {};
      }
      if (shapeDefiner) {
        // provided by defineSlice(); the slice is different from other structures as it does not have 
        // a fixed size; memory is allocated by the slice initializer based on the argument given
        initializer.call(self, arg, fixed);
        dv = self[MEMORY]; 
      } else {
        self[MEMORY] = dv = env.allocateMemory(byteSize, align, fixed);
      }
    } else {
      if (alternateCaster) {
        // casting from number, string, etc.
        self = alternateCaster.call(this, arg, options);
        if (self !== false) {
          return self;
        }
      }
      // look for buffer
      dv = requireDataView(structure, arg, env);
      if (self = cache.find(dv, writable)) {
        return self;
      }
      self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTOTYPE]);
      if (shapeDefiner) {
        setDataView.call(self, dv, structure, false, { shapeDefiner });
      } else {
        self[MEMORY] = dv;
      }
      if (hasSlots) {
        self[SLOTS] = {};
        if (hasPointer && arg instanceof constructor) {
          // copy pointer from other object
          self[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });
        } 
      }
    }
    if (comptimeFieldSlots) {
      for (const slot of comptimeFieldSlots) {
        self[SLOTS][slot] = template[SLOTS][slot];
      }
    }
    if (modifier) {
      modifier.call(self);
    }
    if (creating) {
      // initialize object unless it's been done already
      if (!shapeDefiner) {
        initializer.call(self, arg);
      }
      if (!writable) {
        // create object with read-only prototype
        self = Object.assign(Object.create(constructor[CONST_PROTOTYPE]), self);
      } 
    }
    if (finalizer) {
      self = finalizer.call(self);
    }
    return cache.save(dv, writable, self); 
  };
  return constructor;
}

function createPropertyApplier(structure) {
  const { instance: { template } } = structure;  
  return function(arg) {
    const argKeys = Object.keys(arg);
    const propSetters = this[PROP_SETTERS];
    const allKeys = this[ALL_KEYS];
    // don't accept unknown props
    for (const key of argKeys) {
      if (!(key in propSetters)) {
        throwNoProperty(structure, key);
      }
    }
    // checking each name so that we would see inenumerable initializers as well
    let normalCount = 0;
    let normalFound = 0;
    let normalMissing = 0;
    let specialFound = 0;
    for (const key of allKeys) {
      const set = propSetters[key];
      if (set.special) {
        if (key in arg) {
          specialFound++;
        }
      } else {
        normalCount++;
        if (key in arg) {
          normalFound++;
        } else if (set.required) {
          normalMissing++;
        }
      }
    }
    if (normalMissing !== 0 && specialFound === 0) {
      const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));
      throwMissingInitializers(structure, missing);
    }
    if (specialFound + normalFound > argKeys.length) {
      // some props aren't enumerable
      for (const key of allKeys) {
        if (key in arg) {
          if (!argKeys.includes(key)) {
            argKeys.push(key);
          }
        }
      }
    }
    // apply default values unless all properties are initialized
    if (normalFound < normalCount && specialFound === 0) {
      if (template) {
        if (template[MEMORY]) {
          this[COPIER](template);
        }
        this[POINTER_VISITOR]?.(copyPointer, { vivificate: true, source: template });
      }
    }
    for (const key of argKeys) {
      const set = propSetters[key];
      set.call(this, arg[key]);
    }
    return argKeys.length;
  };
}

function needSlots(members) {
  for (const { type } of members) {
    switch (type) {
      case MemberType.Object:
      case MemberType.Comptime:
      case MemberType.Type:
      case MemberType.Literal:
        return true;
    }
  }
  return false;
}

function getSelf() {
  return this;
}

function useAllStructureTypes() {
  usePrimitive();
  useArray();
  useStruct();
  useExternStruct();
  usePackedStruct();
  useArgStruct();
  useExternUnion();
  useBareUnion();
  useTaggedUnion();
  useErrorUnion();
  useErrorSet();
  useEnumeration();
  useOptional();
  usePointer();
  useSlice();
  useVector();
  useOpaque();
}

class ObjectCache {
  [0] = null;
  [1] = null;

  find(dv, writable) {
    const key = (writable) ? 0 : 1;
    const map = this[key];
    return map?.get(dv);
  }

  save(dv, writable, object) {
    const key = (writable) ? 0 : 1;
    let map = this[key];    
    if (!map) {
      map = this[key] = new WeakMap();
    }
    map.set(dv, object);
    return object;
  }
}

function definePrimitive(structure, env) {
  const {
    byteSize,
    align,
    instance: { members: [ member ] },
  } = structure;
  const { get, set } = getDescriptor(member, env);
  const propApplier = createPropertyApplier(structure);
  const initializer = function(arg) {
    if (arg instanceof constructor) {
      this[COPIER](arg);
    } else {
      if (arg && typeof(arg) === 'object') {
        if (propApplier.call(this, arg) === 0) {
          const type = getPrimitiveType(member);
          throwInvalidInitializer(structure, type, arg);
        }
      } else if (arg !== undefined) {
        set.call(this, arg);
      }
    }
  };
  const constructor = structure.constructor = createConstructor(structure, { initializer }, env);
  const typedArray = structure.typedArray = getTypedArrayClass(member);
  const instanceDescriptors = {
    $: { get, set },
    dataView: getDataViewDescriptor(structure),
    base64: getBase64Descriptor(structure),
    typedArray: typedArray && getTypedArrayDescriptor(structure),
    valueOf: { value: getValueOf },
    toJSON: { value: convertToJSON },
    delete: { value: getDestructor(env) },
    [Symbol.toPrimitive]: { value: get },
    [COPIER]: { value: getMemoryCopier(byteSize) },
    [NORMALIZER]: { value: normalizeValue },
  };
  const staticDescriptors = {
    [COMPAT]: { value: getCompatibleTags(structure) },
    [ALIGN]: { value: align },
    [SIZE]: { value: byteSize },
  };
  return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);
}
function getIntRange(member) {
  const { type, bitSize } = member;
  const signed = (type === MemberType.Int);
  let magBits = (signed) ? bitSize - 1 : bitSize;
  if (bitSize <= 32) {
    const max = 2 ** magBits - 1;
    const min = (signed) ? -(2 ** magBits) : 0;
    return { min, max };
  } else {
    magBits = BigInt(magBits);
    const max = 2n ** magBits - 1n;
    const min = (signed) ? -(2n ** magBits) : 0n;
    return { min, max };
  }
}

function getPrimitiveClass({ type, bitSize }) {
  if (type === MemberType.Int || type === MemberType.Uint) {
    if (bitSize <= 32) {
      return Number;
    } else {
      return BigInt;
    }
  } else if (type === MemberType.Float) {
    return Number;
  } else if (type === MemberType.Bool) {
    return Boolean;
  }
}

function getPrimitiveType(member) {
  const Primitive = getPrimitiveClass(member);
  if (Primitive) {
    return typeof(Primitive(0));
  }
}

function throwNoInitializer(structure) {
  const { name } = structure;
  throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
}

function throwBufferSizeMismatch(structure, dv, target = null) {
  const { name, type, byteSize } = structure;
  const actual = dv.byteLength;
  const s = (byteSize !== 1) ? 's' : '';
  if (type === StructureType.Slice && !target) {
    throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);
  } else {
    const total = (type === StructureType.Slice) ? target.length * byteSize : byteSize;
    throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);
  }
}

function throwBufferExpected(structure) {
  const { type, byteSize, typedArray } = structure;
  const s = (byteSize !== 1) ? 's' : '';
  const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle);
  if (typedArray) {
    acceptable.push(addArticle(typedArray.name));
  }
  if (type === StructureType.Slice) {
    throw new TypeError(`Expecting ${formatList(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);
  } else {
    throw new TypeError(`Expecting ${formatList(acceptable)} that is ${byteSize} byte${s} in length`);
  }
}

function throwEnumExpected(structure, arg) {
  const { name } = structure;
  if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);
  } else {
    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);
  }
}

function throwErrorExpected(structure, arg) {
  const { name } = structure;
  const type = typeof(arg);
  if (type === 'string' || type === 'number') {
    throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);
  } else {
    throw new TypeError(`Error of the type ${name} expected, received ${arg}`);
  }
}

function throwNotInErrorSet(structure) {
  const { name } = structure;
  throw new TypeError(`Error given is not a part of error set ${name}`);
}

function throwMultipleUnionInitializers(structure) {
  const { name } = structure;
  throw new TypeError(`Only one property of ${name} can be given a value`);
}

function throwInactiveUnionProperty(structure, name, currentName) {
  throw new TypeError(`Accessing property ${name} when ${currentName} is active`);
}

function throwMissingUnionInitializer(structure, arg, exclusion) {
  const { name, instance: { members } } = structure;
  const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
  throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
}

function throwInvalidInitializer(structure, expected, arg) {
  const { name } = structure;
  const acceptable = [];
  if (Array.isArray(expected)) {
    for (const type of expected) {
      acceptable.push(addArticle(type));
    }
  } else {
    acceptable.push(addArticle(expected));
  }
  const received = getDescription(arg);
  throw new TypeError(`${name} expects ${formatList(acceptable)} as argument, received ${received}`);
}

function throwInvalidArrayInitializer(structure, arg, shapeless = false) {
  const { instance: { members: [ member ] }, type, typedArray } = structure;
  const acceptable = [];
  const primitive = getPrimitiveType(member);
  if (primitive) {
    acceptable.push(`array of ${primitive}s`);
  } else if (member.type === MemberType.EnumerationItem) {
    acceptable.push(`array of enum items`);
  } else {
    acceptable.push(`array of objects`);
  }
  if (typedArray) {
    acceptable.push(typedArray.name);
  }
  if (type === StructureType.Slice && shapeless) {
    acceptable.push(`length`);
  }
  throwInvalidInitializer(structure, acceptable.join(' or '), arg);
}

function throwArrayLengthMismatch(structure, target, arg) {
  const { name, length, instance: { members: [ member ] } } = structure;
  const { structure: { constructor: elementConstructor} } = member;
  const { length: argLength, constructor: argConstructor } = arg;
  // get length from object whech it's a slice
  const actualLength = target?.length ?? length;
  const s = (actualLength !== 1) ? 's' : '';
  let received;
  if (argConstructor === elementConstructor) {
    received = `only a single one`;
  } else if (argConstructor.child === elementConstructor) {
    received = `a slice/array that has ${argLength}`;
  } else {
    received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
  }
  throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);
}

function throwMissingInitializers(structure, missing) {
  const { name } = structure;
  throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);
}

function throwNoProperty(structure, propName) {
  const { name, instance: { members } } = structure;
  const member = members.find(m => m.name === propName);
  if (member) {
    throw new TypeError(`Comptime value cannot be changed: ${propName}`);
  } else {
    throw new TypeError(`${name} does not have a property with that name: ${propName}`);
  }
}

function throwArgumentCountMismatch(structure, actual) {
  const { name, instance: { members } } = structure;
  const argCount = members.length - 1;
  const s = (argCount !== 1) ? 's' : '';
  throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);
}

function rethrowArgumentError(structure, index, err) {
  const { name, instance: { members } } = structure;
  // Zig currently does not provide the argument name
  const argName = `args[${index}]`;
  const argCount = members.length - 1;
  const prefix = (index !== 0) ? '..., ' : '';
  const suffix = (index !== argCount - 1) ? ', ...' : '';
  const argLabel = prefix + argName + suffix;
  const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);
  newError.stack = err.stack;
  throw newError;
}

function throwNoCastingToPointer(structure) {
  throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);
}

function throwConstantConstraint(structure, pointer) {
  const { name: target } = structure;
  const { constructor: { name } } = pointer;
  throw new TypeError(`Conversion of ${name} to ${target} requires an explicit cast`);
}

function throwMisplacedSentinel(structure, value, index, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
}

function throwMissingSentinel(structure, value, length) {
  const { name } = structure;
  throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);
}

function throwTypeMismatch(expected, arg) {
  const received = getDescription(arg);
  throw new TypeError(`Expected ${addArticle(expected)}, received ${received}`)
}

function throwInaccessiblePointer() {
  throw new TypeError(`Pointers within an untagged union are not accessible`);
}

function throwNullPointer() {
  throw new TypeError(`Null pointer`);
}

function throwInvalidPointerTarget(structure, arg) {
  const { name } = structure;
  let target;
  if (arg != null) {
    const type = typeof(arg);
    const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
    const a = article(noun);
    target = `${a} ${noun}`;
  } else {
    target = arg + '';
  }
  throw new TypeError(`${name} cannot point to ${target}`)
}

function throwFixedMemoryTargetRequired(structure, arg) {
  throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);
}


function throwOverflow(member, value) {
  const typeName = getTypeName(member);
  throw new TypeError(`${typeName} cannot represent the value given: ${value}`);
}

function throwOutOfBound(member, index) {
  const { name } = member;
  throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
}

function rethrowRangeError(member, index, err) {
  if (err instanceof RangeError) {
    throwOutOfBound(member, index);
  } else {
    throw err;
  }
}

function throwNotUndefined(member) {
  const { name } = member;
  throw new RangeError(`Property ${name} can only be undefined`);
}

function throwNotOnByteBoundary(member) {
  const { name, structure: { name: { struct }} } = member;
  throw new TypeError(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
}

function throwReadOnly() {
  throw new TypeError(`Unable to modify read-only object`);
}

function throwReadOnlyTarget(structure) {
  const { name } = structure;
  throw new TypeError(`${name} cannot point to a read-only object`);
}

function throwAccessingOpaque(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to access opaque structure ${name}`);
}

function throwCreatingOpaque(structure) {
  const { name } = structure;
  throw new TypeError(`Unable to create instance of ${name}, as it is opaque`);
}

function warnImplicitArrayCreation(structure, arg) {
  const created = addArticle(structure.typedArray.name);
  const source = addArticle(arg.constructor.name);
  console.warn(`Implicitly creating ${created} from ${source}`);
}

function getDescription(arg) {
  const type = typeof(arg);
  let s;
  if (type === 'object') {
    s = (arg) ? Object.prototype.toString.call(arg) : 'null';
  } else {
    s = type;
  }
  return addArticle(s);
}

function addArticle(noun) {
  return `${article(noun)} ${noun}`;
}

function article(noun) {
  return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
}

function formatList(list, conj = 'or') {
  const sep = ` ${conj} `;
  if (list.length > 2) {
    return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
  } else {
    return list.join(sep);
  }
}

function getBoolAccessor(access, member) {
  return cacheMethod(access, member, () => {
    if (isByteAligned(member)) {
      const { byteSize } = member;
      const typeName = getTypeName({ type: MemberType.Int, bitSize: byteSize * 8 });
      if (access === 'get') {
        const get = DataView.prototype[`get${typeName}`];
        return function(offset, littleEndian) {
          return !!get.call(this, offset, littleEndian);
        };
      } else {
        const set = DataView.prototype[`set${typeName}`];
        const T = (byteSize > 4) ? 1n : 1;
        const F = (byteSize > 4) ? 0n : 0;
        return function(offset, value, littleEndian) {
          set.call(this, offset, value ? T : F, littleEndian);
        };
      }
    } else {
      return getExtendedTypeAccessor(access, member);
    }
  });
}

function getNumericAccessor(access, member) {
  return cacheMethod(access, member, (name) => {
    if (DataView.prototype[name]) {
      return DataView.prototype[name];
    } else {
      return getExtendedTypeAccessor(access, member);
    }
  });
}

const factories$1 = {};

function useExtendedBool() {
  factories$1[MemberType.Bool] = getExtendedBoolAccessor;
}

function useExtendedInt() {
  factories$1[MemberType.Int] = getExtendedIntAccessor;
}

function useExtendedUint() {
  factories$1[MemberType.Uint] = getExtendedUintAccessor;
}

function useExtendedFloat() {
  factories$1[MemberType.Float] = getExtendedFloatAccessor;
}

function getExtendedTypeAccessor(access, member) {
  const f = factories$1[member.type];
  return f(access, member);
}

function getExtendedBoolAccessor(access, member) {
  const { bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const mask = 1 << bitPos;
  const get = DataView.prototype.getInt8;
  if (access === 'get') {
    return function(offset) {
      const n = get.call(this, offset);
      return !!(n & mask);
    };
  } else {
    const set = DataView.prototype.setInt8;
    return function(offset, value) {
      const n = get.call(this, offset);
      const b = (value) ? n | mask : n & ~mask;
      set.call(this, offset, b);
    };
  }
}

function getExtendedIntAccessor(access, member) {
  if (isByteAligned(member)) {
    return getAlignedIntAccessor(access, member)
  } else {
    return getUnalignedIntAccessor(access, member);
  }
}

function getExtendedUintAccessor(access, member) {
  if (isByteAligned(member)) {
    return getAlignedUintAccessor(access, member)
  } else {
    return getUnalignedUintAccessor(access, member);
  }
}

function getExtendedFloatAccessor(access, member) {
  if (isByteAligned(member)) {
    return getAlignedFloatAccessor(access, member)
  } else {
    return getUnalignedFloatAccessor(access, member);
  }
}

function getDataView(structure, arg, env) {
  const { type, byteSize, typedArray } = structure;
  let dv;
  // not using instanceof just in case we're getting objects created in other contexts
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView') {
    dv = arg;
  } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    dv = env.obtainView(arg, 0, arg.byteLength);
  } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {
    dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
  } else {
    const memory = arg?.[MEMORY];
    if (memory) {
      const { constructor, instance: { members: [ member ] } } = structure;
      if (arg instanceof constructor) {
        return memory;
      } else if (type === StructureType.Array || type === StructureType.Slice || type === StructureType.Vector) {
        const { byteSize: elementSize, structure: { constructor: Child } } = member;
        const number = findElements(arg, Child);
        if (number !== undefined) {
          if (type === StructureType.Slice || number * elementSize === byteSize) {
            return memory;
          } else {
            throwArrayLengthMismatch(structure, null, arg);
          }
        } 
      }
    }
  }
  if (dv && byteSize !== undefined) {
    checkDataViewSize(dv, structure);
  }
  return dv;
}

function checkDataView(dv) {
  if (dv?.[Symbol.toStringTag] !== 'DataView') {
    throwTypeMismatch('a DataView', dv);
  }
  return dv;
}

function checkDataViewSize(dv, structure) {
  const { byteSize, type } = structure;
  const multiple = type === StructureType.Slice;
  if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {
    throwBufferSizeMismatch(structure, dv);
  }
}

function setDataView(dv, structure, copy, handlers) {
  const { byteSize, type, sentinel } = structure;
  const multiple = type === StructureType.Slice;
  if (!this[MEMORY]) {
    const { shapeDefiner } = handlers;
    checkDataViewSize(dv, structure);
    const len = dv.byteLength / byteSize;
    const source = { [MEMORY]: dv };
    sentinel?.validateData(source, len);
    shapeDefiner.call(this, copy ? null : dv, len);
    if (copy) {
      this[COPIER](source);
    }  
  } else {
    const byteLength = multiple ? byteSize * this.length : byteSize;
    if (dv.byteLength !== byteLength) {
      throwBufferSizeMismatch(structure, dv, this);
    }
    const source = { [MEMORY]: dv };
    sentinel?.validateData(source, this.length);
    this[COPIER](source); 
  }
}

function findElements(arg, Child) {
  // casting to a array/slice
  const { constructor: Arg } = arg;
  if (Arg === Child) {
    // matching object
    return 1;
  } else if (Arg.child === Child) {
    // matching slice/array
    return arg.length;
  }
}

function requireDataView(structure, arg, env) {
  const dv = getDataView(structure, arg, env);
  if (!dv) {
    throwBufferExpected(structure);
  }
  return dv;
}

function getTypedArrayClass(member) {
  const { type: memberType, byteSize } = member;
  if (memberType === MemberType.Int) {
    switch (byteSize) {
      case 1: return Int8Array;
      case 2: return Int16Array;
      case 4: return Int32Array;
      case 8: return BigInt64Array;
    }
  } else if (memberType === MemberType.Uint) {
    switch (byteSize) {
      case 1: return Uint8Array;
      case 2: return Uint16Array;
      case 4: return Uint32Array;
      case 8: return BigUint64Array;
    }
  } else if (memberType === MemberType.Float) {
    switch (byteSize) {
      case 4: return Float32Array;
      case 8: return Float64Array;
    }
  } else if (memberType === MemberType.Object) {
    return member.structure.typedArray;
  }
  return null;
}

function isTypedArray(arg, TypedArray) {
  const tag = arg?.[Symbol.toStringTag];
  return (!!TypedArray && tag === TypedArray.name);
}

function isCompatible(arg, constructor) {
  const tags = constructor[COMPAT];
  if (tags) {
    const tag = arg?.[Symbol.toStringTag];
    if (tags.includes(tag)) {
      return true;
    }
  }
  if (constructor.child) {
    if (findElements(arg, constructor.child) !== undefined) {
      return true;
    }
  }
  return false;
}

function getCompatibleTags(structure) {
  const { typedArray } = structure;
  const tags = [];
  if (typedArray) {
    tags.push(typedArray.name);
    tags.push('DataView');
    if (typedArray === Uint8Array || typedArray === Int8Array) {
      tags.push('Uint8ClampedArray');
      tags.push('ArrayBuffer');
      tags.push('SharedArrayBuffer');
    }
  }
  return tags;
}

function isBuffer(arg, typedArray) {
  const tag = arg?.[Symbol.toStringTag];
  if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
    return true;
  } else if (typedArray && tag === typedArray.name) {
    return true;
  } else {
    return false;
  }
}

function getTypeName(member) {
  const { type, bitSize, byteSize } = member;
  if (type === MemberType.Int) {
    return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;
  } else if (type === MemberType.Uint) {
    return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;
  } else if (type === MemberType.Float) {
    return `Float${bitSize}`;
  } else if (type === MemberType.Bool) {
    const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;
    return `Bool${boolSize}`;
  } else if (type === MemberType.Void) {
    return `Null`;
  }
}

function getBigIntDescriptor(bitSize) {
  const getWord = DataView.prototype.getBigUint64;
  const setWord = DataView.prototype.setBigUint64;
  const wordCount = Math.ceil(bitSize / 64);
  return {
    get: function(offset, littleEndian) {
      let n = 0n;
      if (littleEndian) {
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      } else {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = getWord.call(this, j, littleEndian);
          n = (n << 64n) | w;
        }
      }
      return n;
    },
    set: function(offset, value, littleEndian) {
      let n = value;
      const mask = 0xFFFFFFFFFFFFFFFFn;
      if (littleEndian) {
        for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      } else {
        n <<= BigInt(wordCount * 64 - bitSize);
        for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
          const w = n & mask;
          setWord.call(this, j, w, littleEndian);
          n >>= 64n;
        }
      }
      return n;
    },
  };
}

function getAlignedIntAccessor(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);
    const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor(bitSize);
    const signMask = 2n ** BigInt(bitSize - 1);
    const valueMask = signMask - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return (n & valueMask) - (n & signMask);
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getAlignedUintAccessor(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize < 64) {
    // actual number of bits needed when stored aligned
    const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });
    const get = DataView.prototype[`get${typeName}`];
    const set = DataView.prototype[`set${typeName}`];
    const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  } else {
    // larger than 64 bits
    const { get, set } = getBigIntDescriptor(bitSize);
    const valueMask = (2n ** BigInt(bitSize)) - 1n;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        return n & valueMask;
      };
    } else {
      return function(offset, value, littleEndian) {
        const n = value & valueMask;
        set.call(this, offset, n, littleEndian);
      };
    }
  }
}

function getUnalignedIntAccessor(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    // sub-8-bit numbers have real use cases
    const signMask = 2 ** (bitSize - 1);
    const valueMask = signMask - 1;
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return (s & valueMask) - (s & signMask);
      };
    } else {
      const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
      return function(offset, value) {
        let b = get.call(this, offset);
        const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
        b = (b & outsideMask) | (n << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor(access, member);
}

function getUnalignedUintAccessor(access, member) {
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  if (bitPos + bitSize <= 8) {
    const set = DataView.prototype.setUint8;
    const get = DataView.prototype.getUint8;
    const valueMask = (2 ** bitSize - 1);
    if (access === 'get') {
      return function(offset) {
        const n = get.call(this, offset);
        const s = n >>> bitPos;
        return s & valueMask;
      };
    } else {
      const outsideMask = 0xFF ^ (valueMask << bitPos);
      return function(offset, value) {
        const n = get.call(this, offset);
        const b = (n & outsideMask) | ((value & valueMask) << bitPos);
        set.call(this, offset, b);
      };
    }
  }
  return getUnalignedNumericAccessor(access, member);
}

function getAlignedFloatAccessor(access, member) {
  const { bitSize, byteSize } = member;
  if (bitSize === 16) {
    const buf = new DataView(new ArrayBuffer(4));
    const set = DataView.prototype.setUint16;
    const get = DataView.prototype.getUint16;
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >>> 15;
        const exp = (n & 0x7C00) >> 10;
        const frac = n & 0x03FF;
        if (exp === 0) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x1F) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
        buf.setUint32(0, n32, littleEndian);
        return buf.getFloat32(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat32(0, value, littleEndian);
        const n = buf.getUint32(0, littleEndian);
        const sign = n >>> 31;
        const exp = (n & 0x7F800000) >> 23;
        const frac = n & 0x007FFFFF;
        const exp16 = (exp - 127 + 15);
        let n16;
        if (exp === 0) {
          n16 = sign << 15;
        } else if (exp === 0xFF) {
          n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);
        } else if (exp16 >= 31) {
          n16 = sign << 15 | 0x1F << 10;
        } else {
          n16 = sign << 15 | exp16 << 10 | (frac >> 13);
        }
        set.call(this, offset, n16, littleEndian);
      }
    }
  } else if (bitSize === 80) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      return w1 | w2 << 32n | w3 << 64n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 79n;
        const exp = (n & 0x7FFF0000000000000000n) >> 64n;
        const frac = n & 0x00007FFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n80;
        if (exp === 0n) {
          n80 = sign << 79n | (frac << 11n);
        } else if (exp === 0x07FFn) {
          n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
          //                                                 ^ bit 61                       ^ bit 63
        } else {
          n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
        }
        set.call(this, offset, n80, littleEndian);
      }
    }
  } else if (bitSize === 128) {
    const buf = new DataView(new ArrayBuffer(8));
    const get = function(offset, littleEndian) {
      const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
      const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
      const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
      const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
      return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
    };
    const set = function(offset, value, littleEndian) {
      const w1 = value & 0xFFFFFFFFn;
      const w2 = (value >> 32n) & 0xFFFFFFFFn;
      const w3 = (value >> 64n) & 0xFFFFFFFFn;
      const w4 = (value >> 96n) & 0xFFFFFFFFn;
      this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
      this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
      this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
    };
    if (access === 'get') {
      return function(offset, littleEndian) {
        const n = get.call(this, offset, littleEndian);
        const sign = n >> 127n;
        const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;
        const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;
        if (exp === 0n) {
          return (sign) ? -0 : 0;
        } else if (exp === 0x7FFFn) {
          if (!frac) {
            return (sign) ? -Infinity : Infinity;
          } else {
            return NaN;
          }
        }
        const exp64 = exp - 16383n + 1023n;
        if (exp64 >= 2047n) {
          return (sign) ? -Infinity : Infinity;
        }
        const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
        buf.setBigUint64(0, n64, littleEndian);
        return buf.getFloat64(0, littleEndian);
      }
    } else {
      return function(offset, value, littleEndian) {
        buf.setFloat64(0, value, littleEndian);
        const n = buf.getBigUint64(0, littleEndian);
        const sign = n >> 63n;
        const exp = (n & 0x7FF0000000000000n) >> 52n;
        const frac = n & 0x000FFFFFFFFFFFFFn;
        let n128;
        if (exp === 0n) {
          n128 = sign << 127n | (frac << 60n);
        } else if (exp === 0x07FFn) {
          n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);
        } else {
          n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
        }
        set.call(this, offset, n128, littleEndian);
      }
    }
  }
}

function getUnalignedFloatAccessor(access, member) {
  return getUnalignedNumericAccessor(access, member);
}

function getUnalignedNumericAccessor(access, member) {
  // pathological usage scenario--handle it anyway by copying the bitSize into a
  // temporary buffer, bit-aligning the data
  const { bitSize, bitOffset } = member;
  const bitPos = bitOffset & 0x07;
  const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
  const buf = new DataView(new ArrayBuffer(byteSize));
  if (access === 'get') {
    const getAligned = getNumericAccessor('get', { ...member, byteSize });
    const copyBits = getBitAlignFunction(bitPos, bitSize, true);
    return function(offset, littleEndian) {
      copyBits(buf, this, offset);
      return getAligned.call(buf, 0, littleEndian);
    };
  } else {
    const setAligned = getNumericAccessor('set', { ...member, byteSize });
    const applyBits = getBitAlignFunction(bitPos, bitSize, false);
    return function(offset, value, littleEndian) {
      setAligned.call(buf, 0, value, littleEndian);
      applyBits(this, buf, offset);
    };
  }
}

const methodCache = {};

function cacheMethod(access, member, cb) {
  const { type, bitOffset, bitSize, structure } = member;
  const bitPos = bitOffset & 0x07;
  const typeName = getTypeName(member);
  const suffix = isByteAligned(member) ? `` : `Bit${bitPos}`;
  const isInt = type === MemberType.Int || type === MemberType.Uint;
  let name = `${access}${typeName}${suffix}`;
  let isSize = false, originalName = name;
  if (isInt && bitSize === 64) {
    const zigTypeName = structure?.name;
    if (zigTypeName === 'usize' || zigTypeName === 'isize') {
      name += 'Size';
      isSize = true;
    }
  }
  let fn = methodCache[name];
  if (!fn) {
    if (isInt && access === 'set') {
      // add auto-conversion between number and bigint
      const Primitive = getPrimitiveClass(member);
      const set = cb(originalName);
      fn = function(offset, value, littleEndian) {
        set.call(this, offset, Primitive(value), littleEndian);
      };
    } else if (isSize && access === 'get') {
      // use number instead of bigint where possible
      const get = cb(originalName);
      const min = BigInt(Number.MIN_SAFE_INTEGER);
      const max = BigInt(Number.MAX_SAFE_INTEGER);
      fn = function(offset, littleEndian) {
        const value = get.call(this, offset, littleEndian);
        if (min <= value && value <= max) {
          return Number(value);
        } else {
          return value;
        }
      };
    } else {
      fn = cb(name);
    }
    if (fn && fn.name !== name) {
      Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });
    }
    methodCache[name] = fn;
  }
  return fn;
}

function useAllExtendedTypes() {
  useExtendedBool();
  useExtendedInt();
  useExtendedUint();
  useExtendedFloat();
}

const MemberType = {
  Void: 0,
  Bool: 1,
  Int: 2,
  Uint: 3,
  Float: 4,
  EnumerationItem: 5,
  Error: 6,
  Object: 7,
  Type: 8,
  Comptime: 9,
  Static: 10,
  Literal: 11,
  Null: 12,
  Undefined: 13,
};

function isReadOnly(type) {
  switch (type) {
    case MemberType.Type:
    case MemberType.Comptime:
    case MemberType.Literal:
      return true;
    default:
      return false;
  }
}

const factories = {};

function useVoid() {
  factories[MemberType.Void] = getVoidDescriptor;
}

function useBool() {
  factories[MemberType.Bool] = getBoolDescriptor;
}

function useInt() {
  factories[MemberType.Int] = getIntDescriptor;
}

function useUint() {
  factories[MemberType.Uint] = getUintDescriptor;
}

function useFloat() {
  factories[MemberType.Float] = getFloatDescriptor;
}

function useEnumerationItem() {
  factories[MemberType.EnumerationItem] = getEnumerationItemDescriptor;
}

function useError() {
  factories[MemberType.Error] = getErrorDescriptor;
}

function useObject() {
  factories[MemberType.Object] = getObjectDescriptor;
}

function useType() {
  factories[MemberType.Type] = getTypeDescriptor;
}

function useComptime() {
  factories[MemberType.Comptime] = getComptimeDescriptor;
}

function useStatic() {
  factories[MemberType.Static] = getStaticDescriptor;
}

function useLiteral() {
  factories[MemberType.Literal] = getLiteralDescriptor;
}

function useNull() {
  factories[MemberType.Null] = getNullDescriptor;
}

function useUndefined() {
  factories[MemberType.Undefined] = getUndefinedDescriptor;
}

function isByteAligned({ bitOffset, bitSize, byteSize }) {
  return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;
}

function getDescriptor(member, env) {
  const f = factories[member.type];
  return f(member, env);
}

function getVoidDescriptor(member, env) {
  const { runtimeSafety } = env;
  return {
    get: function() {
      return undefined;
    },
    set: (runtimeSafety)
    ? function(value) {
        if (value !== undefined) {
          throwNotUndefined(member);
        }
      }
    : function() {},
  }
}

function getNullDescriptor(member, env) {
  return {
    get: function() {
      return null;
    },
  }
}

function getUndefinedDescriptor(member, env) {
  return {
    get: function() {
      return undefined;
    },
  }
}

function getBoolDescriptor(member, env) {
  return getDescriptorUsing(member, env, getBoolAccessor)
}

function getIntDescriptor(member, env) {
  const getDataViewAccessor = addRuntimeCheck(env, getNumericAccessor);
  return getDescriptorUsing(member, env, getDataViewAccessor)
}

function getUintDescriptor(member, env) {
  const getDataViewAccessor = addRuntimeCheck(env, getNumericAccessor);
  return getDescriptorUsing(member, env, getDataViewAccessor)
}

function addRuntimeCheck(env, getDataViewAccessor) {
  return function (access, member) {
    const {
      runtimeSafety = true,
    } = env;
    const accessor = getDataViewAccessor(access, member);
    if (runtimeSafety && access === 'set') {
      const { min, max } = getIntRange(member);
      return function(offset, value, littleEndian) {
        if (value < min || value > max) {
          throwOverflow(member, value);
        }
        accessor.call(this, offset, value, littleEndian);
      };
    }
    return accessor;
  };
}

function getFloatDescriptor(member, env) {
  return getDescriptorUsing(member, env, getNumericAccessor)
}

function getValueDescriptor(member, env) {
  // enum can be int or uint--need the type from the structure
  const { type, structure } = member.structure.instance.members[0];
  // combine that with the offset/size
  const valueMember = { ...member, type, structure };
  return getDescriptor(valueMember, env);
}

function getEnumerationItemDescriptor(member, env) {
  const { structure } = member;
  const { get: getValue, set: setValue } = getValueDescriptor(member, env);
  const findEnum = function(value) {
    const { constructor } = structure;
    // the enumeration constructor returns the object for the int value
    const item = (value instanceof constructor) ? value : constructor(value);
    if (!item) {
      throwEnumExpected(structure, value);
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getEnum() {
        const value = getValue.call(this);
        return findEnum(value);
      }
    : function getEnumElement(index) {
        const value = getValue.call(this, index);
        return findEnum(value);
      },
    set: (setValue.length === 1) 
    ? function setEnum(value) {
        // call Symbol.toPrimitive directly as enum can be bigint or number
        const item = findEnum(value);
        setValue.call(this, item[Symbol.toPrimitive]());
      }
    : function setEnumElement(index, value) {
        const item = findEnum(value);
        setValue.call(this, index, item[Symbol.toPrimitive]());
      },
  };
}

function getErrorDescriptor(member, env) {
  const { structure } = member;
  const { name } = structure;
  const { get: getValue, set: setValue } = getValueDescriptor(member, env);  
  const acceptAny = name === 'anyerror';
  const globalErrorSet = getGlobalErrorSet();
  const findError = function(value, allowZero = false) {
    const { constructor } = structure;
    let item;
    if (value === 0 && allowZero) {
      return;
    } else if (value instanceof Error) {
      if (value instanceof (acceptAny ? globalErrorSet : constructor)) {
        item = value;
      } else {
        throwNotInErrorSet(structure);
      }
    } else {
      item = acceptAny ? globalErrorSet[value] : constructor(value);
      if (!item) {
        throwErrorExpected(structure, value);
      } 
    }
    return item
  };
  return {
    get: (getValue.length === 0) 
    ? function getError(allowZero) {
        const value = getValue.call(this);
        return findError(value, allowZero);
      }
    : function getErrorElement(index) {
        const value = getValue.call(this, index);
        return findError(value, false);
      },
    set: (setValue.length === 1) 
    ? function setError(value, allowZero) {
        const item = findError(value, allowZero);
        setValue.call(this, Number(item ?? 0));
      }
    : function setError(index, value) {
        const item = findError(value, false);
        setValue.call(this, index, Number(item));
      },
  };
}

function isValueExpected(structure) {
  switch (structure.type) {
    case StructureType.Primitive:
    case StructureType.ErrorUnion:
    case StructureType.Optional:
    case StructureType.Enumeration:
    case StructureType.ErrorSet:
      return true;
    default:
      return false;
  }
}

function getValue(slot) {
  const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);
  return object[GETTER]();
}

function getObject(slot) {
  const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);
  return object;
}

function setValue(slot, value) {
  const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);
  object[SETTER](value);
}

function bindSlot(slot, { get, set }) {
  if (slot !== undefined) {
    return { 
      get: function() {
        return get.call(this, slot);
      },
      set: (set) 
      ? function(arg) {
          return set.call(this, slot, arg);
        } 
      : undefined,
    };
  } else {
    // array accessors
    return { get, set };
  }
}

function getObjectDescriptor(member, env) {
  const { structure, slot } = member;
  return bindSlot(slot, {
    get: isValueExpected(structure) ? getValue : getObject,
    set: setValue,
  });
}

function getType(slot) {
  // unsupported types will have undefined structure
  const structure = this[SLOTS][slot];
  return structure?.constructor;
}

function getTypeDescriptor(member, env) {
  const { slot } = member;
  return bindSlot(slot, { get: getType });
}

function getComptimeDescriptor(member, env) {
  const { slot, structure } = member;
  return bindSlot(slot, {
    get: isValueExpected(structure) ? getValue : getObject,
  });
}

function getStaticDescriptor(member, env) {
  const { slot, structure } = member;
  return bindSlot(slot, {
    get: isValueExpected(structure) ? getValue : getObject,
    set: setValue,
  });
}

function getLiteral(slot) {
  const object = this[SLOTS][slot];
  return object.string;
}

function getLiteralDescriptor(member, env) {
  const { slot } = member;
  return bindSlot(slot, { get: getLiteral });
}

function getDescriptorUsing(member, env, getDataViewAccessor) {
  const {
    littleEndian = true,
  } = env;
  const { bitOffset, byteSize } = member;
  const getter = getDataViewAccessor('get', member);
  const setter = getDataViewAccessor('set', member);
  if (bitOffset !== undefined) {
    const offset = bitOffset >> 3;
    return {
      get: function getValue() {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
          return getter.call(this[MEMORY], offset, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory.call(this)) {
            return getter.call(this[MEMORY], offset, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      },
      set: function setValue(value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END*/
        return setter.call(this[MEMORY], offset, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory.call(this)) {
            return setter.call(this[MEMORY], offset, value, littleEndian);
          } else {
            throw err;
          }
        }
        /* WASM-ONLY-END*/
      }
    }
  } else {
    return {
      get: function getElement(index) {
        try {
          return getter.call(this[MEMORY], index * byteSize, littleEndian);
        } catch (err) {
          /* WASM-ONLY */
          if (err instanceof TypeError && restoreMemory.call(this)) {
            return getter.call(this[MEMORY], index * byteSize, littleEndian);
          } else {
          /* WASM-ONLY-END */
            rethrowRangeError(member, index, err);
          /* WASM-ONLY */
          }
          /* WASM-ONLY-END */
        }
      },
      set: function setElement(index, value) {
        /* WASM-ONLY */
        try {
        /* WASM-ONLY-END */
          return setter.call(this[MEMORY], index * byteSize, value, littleEndian);
        /* WASM-ONLY */
        } catch (err) {
          if (err instanceof TypeError && restoreMemory.call(this)) {
            return setter.call(this[MEMORY], index * byteSize, value, littleEndian);
          } else {
            rethrowRangeError(member, index, err);
          }
        }
        /* WASM-ONLY-END */
      },
    }
  }
}

function useAllMemberTypes() {
  useVoid();
  useNull();
  useUndefined();
  useBool();
  useInt();
  useUint();
  useFloat();
  useEnumerationItem();
  useError();
  useObject();
  useType();
  useComptime();
  useStatic();
  useLiteral();
}

process.cwd();

useAllMemberTypes();
useAllStructureTypes();
useAllExtendedTypes();

const MagicNumber = 0x6d736100;
const Version = 1;
const SectionType = {
  Custom: 0,
  Type: 1,
  Import: 2,
  Function: 3,
  Table: 4,
  Memory: 5,
  Global: 6,
  Export: 7,
  Start: 8,
  Element: 9,
  Code: 10,
  Data: 11,
  DataCount: 12
};
const ObjectType = {
  Function: 0,
  Table: 1,
  Memory: 2,
  Global: 3,
};

function stripUnused(binary, options = {}) {
  const {
    keepNames = false,
  } = options;
  const { sections, size } = parseBinary(binary);
  const blacklist = [
    /^getFactoryThunk$/,
    /^exporter.createRootFactory/,
  ];

  function getSection(type) {
    return sections.find(s => s.type === type);
  }

  const nameSection = sections.find(s => s.type === SectionType.Custom && s.name === 'name');
  const { moduleName, functionNames, localNames } = parseNames(nameSection);
  const functions = [];
  // allocate indices for imported functions first
  const importSection = sections.find(s => s.type === SectionType.Import);
  if (importSection) {
    for (const object of importSection.imports) {
      if (object.type === ObjectType.Function) {
        const index = functions.length;
        functions[index] = {
          type: 'imported',
          name: functionNames[index],
          descriptor: object,
          typeIndex: object.type,
          using: undefined,
          index,
          newIndex: -1,
        };
      }
    }
  }
  // allocate indices for internal functions
  const funcSection = getSection(SectionType.Function);
  const codeSection = getSection(SectionType.Code);
  if (funcSection && codeSection) {
    for (const [ i, typeIndex ] of funcSection.types.entries()) {
      const code = codeSection.functions[i];
      const index = functions.length;
      let parsed = null;
      const fn = {
        type: 'internal',
        name: functionNames[index],
        typeIndex,
        code,
        using: undefined,
        index,
        newIndex: -1,

        get instructions() {
          if (!parsed) {
            parsed = parseFunction(this.code);
          }
          return parsed.instructions;
        },
        get size() {
          return parsed.size;
        },
        get locals() {
          return parsed.locals;
        },
      };
      functions.push(fn);
    }
  }

  if (functionNames.length === 0) {
    // get the names from the export and import section if they're missing
    const exportSection = getSection(SectionType.Export);
    if (exportSection) {
      for (const object of exportSection.exports) {
        if (object.type === ObjectType.Function) {
          const fn = functions[object.index];
          fn.name = object.name;
        }
      }
    }
    const importSection = getSection(SectionType.Import);
    if (importSection) {
      for (const object of importSection.imports) {
        if (object.type === ObjectType.Function) {
          const fn = functions[object.index];
          fn.name = object.name;
        }
      }
    }
  }

  // mark blacklisted functions as unused
  for (const fn of functions) {
    if (fn.name && blacklist.some(re => re.test(fn.name))) {
      fn.using = false;
      if (fn.name === 'getFactoryThunk' && functionNames.length === 0) {
        // when compiled for ReleaseSmall, we don't get the name section
        // therefore unable to remove the factory function by name
        // we know that getFactoryThunk loads its address, however
        // and that a function pointer is just an index into table 0
        const ops = fn.instructions;
        if (ops.length === 2 && ops[0].opcode === 0x41 && ops[1].opcode === 0x0B) {
          // 0x41 is i32.const
          // 0x0B is end
          const elemIndex = ops[0].operand;
          const elemSection = getSection(SectionType.Element);
          for (const segment of elemSection.segments) {
            if (segment.indices) {
              const funcIndex = segment.indices[elemIndex - 1];
              const fn = functions[funcIndex];
              fn.using = false;
            }
          }
        }
      }
    }
  }

  function useFunction(index) {
    const fn = functions[index];
    /* c8 ignore next 3 */
    if (!fn) {
      throw new Error(`Function #${index} does not exist`);
    }
    if (fn.using === undefined) {
      fn.using = true;
      if (fn.type === 'internal') {
        // mark all functions called by this one as being in-use as well
        for (const { opcode, operand } of fn.instructions) {
          switch (opcode) {
            case 0x10:    // function call
            case 0xD2: {  // function reference
              useFunction(operand);
            } break;
          }
        }
      }
    }
  }

  // mark functions in table elements as used
  const elemSection = getSection(SectionType.Element);
  if (elemSection) {
    for (const segment of elemSection.segments) {
      if (segment.indices) {
        for (const index of segment.indices) {
          useFunction(index);
        }
      }
    }
  }

  // mark exported functions as being in-use
  const exportSection = getSection(SectionType.Export);
  if (exportSection) {
    for (const object of exportSection.exports) {
      if (object.type === ObjectType.Function) {
        useFunction(object.index);
      }
    }
  }

  // assign new indices to functions
  const newFunctions = [];
  for (const fn of functions) {
    if (fn.using) {
      fn.newIndex = newFunctions.length;
      newFunctions.push(fn);
    }
  }

  // update call instructions with new indices
  for (const fn of newFunctions) {
    if (fn.type === 'internal') {
      for (const op of fn.instructions) {
        switch (op.opcode) {
          case 0x10:    // function call
          case 0xD2: {  // function reference
            const target = functions[op.operand];
            op.operand = target.newIndex;
          } break;
        }
      }
      fn.code = repackFunction(fn);
    }
  }

  // create new code and function section
  const newCodeSection = { type: SectionType.Code, functions: [] };
  const newFuncSection = { type: SectionType.Function, types: [] };
  for (const fn of newFunctions) {
    if (fn.type === 'internal') {
      newCodeSection.functions.push(fn.code);
      newFuncSection.types.push(fn.typeIndex);
    }
  }

  // create new element section
  const newElementSection = { type: SectionType.Element, segments: [] };
  if (elemSection) {
    for (const segment of elemSection.segments) {
      if (segment.indices) {
        const indices = segment.indices.map((index) => {
          const fn = functions[index];
          return (fn.using) ? fn.newIndex : 0;
        });
        newElementSection.segments.push({ ...segment, indices });
        /* c8 ignore next 3 */
      } else {
        newElementSection.segments.push(segment);
      }
    }
  }
  // create new export section
  const newExportSection = { type: SectionType.Export, exports: [] };
  if (exportSection) {
    for (const object of exportSection.exports) {
      if (object.type === ObjectType.Function) {
        const fn = functions[object.index];
        if (fn.using) {
          const { name, type } = object;
          const index = fn.newIndex;
          newExportSection.exports.push({ name, type, index });
        }
      } else {
        newExportSection.exports.push(object);
      }
    }
  }
  // create new import section
  const newImportSection = { type: SectionType.Import, imports: [] };
  if (importSection) {
    for (const [ index, object ] of importSection.imports.entries()) {
      if (object.type === ObjectType.Function) {
        const fn = functions[index];
        if (fn.using) {
          newImportSection.imports.push(object);
        }
        /* c8 ignore next 3 */
      } else {
        newImportSection.imports.push(object);
      }
    }
  }
  // create new name section
  let newNameSection = null;
  if (nameSection && keepNames) {
    const newFunctionNames = [];
    const newLocalNames = [];
    for (const fn of newFunctions) {
      newFunctionNames.push(fn.name);
      /* c8 ignore next 3 -- can't find a file with local names */
      if (localNames.length > 0) {
        newLocalNames.push(localNames[fn.index]);
      }
    }
    const data = repackNames({
      moduleName,
      functionNames: newFunctionNames,
      localNames: newLocalNames,
      size: nameSection.data.byteLength,
    });
    newNameSection = { type: SectionType.Custom, name: 'name', data };
  }

  // create new module sections
  const newSections = [];
  for (const section of sections) {
    switch (section.type) {
      case SectionType.Code:
        newSections.push(newCodeSection);
        break;
      case SectionType.Function:
        newSections.push(newFuncSection);
        break;
      case SectionType.Element:
        newSections.push(newElementSection);
        break;
      case SectionType.Export:
        newSections.push(newExportSection);
        break;
      case SectionType.Import:
        newSections.push(newImportSection);
        break;
      case SectionType.Custom:
        if (section.name === 'name' && newNameSection) {
          newSections.push(newNameSection);
        }
        break;
      default:
        newSections.push(section);
        break;
    }
  }
  return repackBinary({ sections: newSections, size });
}

function parseBinary(binary) {
  const {
    eof,
    readBytes,
    readU8,
    readU32,
    readString,
    readArray,
    readU32Leb128,
    readExpression,
    readCustom,
  } = createReader(binary);
  const magic = readU32();
  if (magic !== MagicNumber) {
    throw new Error(`Incorrect magic number: ${magic.toString(16)}`);
  }
  const version = readU32();
  if (version !== Version) {
    throw new Error(`Incorrect version: ${version}`);
  }
  const sections = [];
  while(!eof()) {
    sections.push(readSection());
  }
  const size = binary.byteLength;
  return { sections, size };

  function readSection() {
    const type = readU8();
    const len = readU32Leb128();
    switch(type) {
      case SectionType.Custom:
        const { name, data } = readCustom(len);
        return { type, name, data };
      case SectionType.Import: {
        const imports = readArray(() => {
          const module = readString();
          const name = readString();
          const type = readU8();
          switch (type) {
            case ObjectType.Function: {
              const index = readU32Leb128();
              return { module, name, type, index };
            }
            case ObjectType.Table: {
              const reftype = readU8();
              const limits = readLimits();
              return { module, name, type, reftype, limits };
            }
            case ObjectType.Memory: {
              const limits = readLimits();
              return { module, name, type, limits };
            }
            case ObjectType.Global: {
              const valtype = readU8();
              const mut = readU8();
              return { module, name, type, valtype, mut };
            }
            /* c8 ignore next 2 */
            default:
              throw new Error(`Unknown object type: ${type}`);
          }
        });
        return { type, imports };
      }
      case SectionType.Export: {
        const exports = readArray(() => {
          const name = readString();
          const type = readU8();
          const index = readU32Leb128();
          return { name, type, index };
        });
        return { type, exports };
      }
      case SectionType.Function: {
        const types = readArray(readU32Leb128);
        return { type, types };
      }
      case SectionType.Code: {
        const functions = readArray(() => {
          const len = readU32Leb128();
          return readBytes(len);
        });
        return { type, functions };
      }
      case SectionType.Element: {
        const segments = readArray(() => {
          const type = readU32Leb128();
          switch (type) {
            case 0: {
              const expr = readExpression();
              const indices = readArray(readU32Leb128);
              return { type, expr, indices };
            }
            case 1: {
              const kind = readU8();
              const indices = readArray(readU32Leb128);
              return { type, kind, indices };
            }
            case 2: {
              const tableidx = readU32Leb128();
              const expr = readExpression();
              const kind = readU8();
              const indices = readArray(readU32Leb128);
              return { type, tableidx, expr, kind, indices };
            }
            case 3: {
              const kind = readU8();
              const indices = readArray(readU32Leb128);
              return { type, kind, indices };
            }
            case 4: {
              const expr = readExpression();
              const entries = readArray(readExpression);
              return { type, expr, entries };
            }
            case 5: {
              const reftype = readU8();
              const entries = readArray(readExpression);
              return { type, reftype, entries };
            }
            case 6: {
              const tableidx = readU32Leb128();
              const expr = readExpression();
              const reftype = readU8();
              const entries = readArray(readExpression);
              return { type, tableidx, expr, reftype, entries };
            }
            case 7: {
              const reftype = readU8();
              const entries = readArray(readExpression);
              return { type, reftype, entries };
            }
          }
        });
        return { type, segments };
      }
      default: {
        const data = readBytes(len);
        return { type, data };
      }
    }
    /* c8 ignore next -- unreachable */
  }

  function readLimits() {
    const flag = readU8();
    const min = readU32Leb128();
    switch (flag) {
      case 0:
        return { flag, min };
      case 1:
        const max = readU32Leb128();
        return { flag, min, max };
      /* c8 ignore next 4 */
      default:
        throw new Error(`Unknown limit flag: ${flag}`);
    }
  }
}

function repackBinary(module) {
  const {
    finalize,
    writeBytes,
    writeU8,
    writeU32,
    writeLength,
    writeString,
    writeArray,
    writeU32Leb128,
    writeExpression,
    writeCustom,
  } = createWriter(module.size);
  writeU32(MagicNumber);
  writeU32(Version);
  for (const section of module.sections) {
    writeSection(section);
  }
  return finalize();

  function writeSection(section) {
    writeU8(section.type);
    writeLength(() => {
      switch(section.type) {
        case SectionType.Custom: {
          writeCustom(section);
        } break;
        case SectionType.Import: {
          writeArray(section.imports, (object) => {
            writeString(object.module);
            writeString(object.name);
            writeU8(object.type);
            switch (object.type) {
              case ObjectType.Function: {
                writeU32Leb128(object.index);
              } break;
              case ObjectType.Table: {
                writeU8(object.reftype);
                writeLimits(object.limits);
              } break;
              case ObjectType.Memory: {
                writeLimits(object.limits);
              } break;
              case ObjectType.Global: {
                writeU8(object.valtype);
                writeU8(object.mut);
              } break;
            }
          });
        } break;
        case SectionType.Export: {
          writeArray(section.exports, (object) => {
            writeString(object.name);
            writeU8(object.type);
            writeU32Leb128(object.index);
          });
        } break;
        case SectionType.Function: {
          writeArray(section.types, writeU32Leb128);
        } break;
        case SectionType.Code: {
          writeArray(section.functions, (code) => {
            writeU32Leb128(code.byteLength);
            writeBytes(code);
          });
        } break;
        case SectionType.Element: {
          writeArray(section.segments, (segment) => {
            writeU32Leb128(segment.type);
            switch (segment.type) {
              case 0: {
                writeExpression(segment.expr);
                writeArray(segment.indices, writeU32Leb128);
              } break;
              case 1: {
                writeU8(segment.kind);
                writeArray(segment.indices, writeU32Leb128);
              } break;
              case 2: {
                writeU32Leb128(segment.tableidx);
                writeExpression(segment.expr);
                writeU8(segment.kind);
                writeArray(segment.indices, writeU32Leb128);
              } break;
              case 3: {
                writeU8(segment.kind);
                writeArray(segment.indices, writeU32Leb128);
              } break;
              case 4: {
                writeExpression(segment.expr);
                writeArray(segment.entries, writeExpression);
              } break;
              case 5: {
                writeU8(segment.reftype);
                writeArray(segment.entries, writeExpression);
              } break;
              case 6: {
                writeU32Leb128(segment.tableidx);
                writeExpression(segment.expr);
                writeU8(segment.reftype);
                writeArray(segment.entries, writeExpression);
              } break;
              case 7: {
                writeU8(segment.reftype);
                writeArray(segment.entries, writeExpression);
              } break;
            }
          });
        } break;
        default: {
          writeBytes(section.data);
        }
      }
    });
  }

  function writeLimits(limits) {
    writeU8(limits.flag);
    writeU32Leb128(limits.min);
    switch (limits.flag) {
      case 1: {
        writeU32Leb128(limits.max);
      } break;
    }
  }
}

function createReader(dv) {
  const decoder = new TextDecoder('utf-8', { ignoreBOM: true });
  let offset = 0;

  function eof() {
    return (offset >= dv.byteLength);
  }

  function readBytes(len) {
    const bytes = new DataView(dv.buffer, dv.byteOffset + offset, len);
    offset += len;
    return bytes;
  }

  function readU8() {
    return dv.getUint8(offset++);
  }

  function readU32() {
    const value = dv.getUint32(offset, true);
    offset += 4;
    return value;
  }

  function readF64() {
    const value = dv.getFloat64(offset, true);
    offset += 8;
    return value;
  }

  function readString() {
    const len = readU32Leb128();
    const bytes = new Uint8Array(dv.buffer, dv.byteOffset + offset, len);
    offset += len;
    return decoder.decode(bytes);
  }

  function readArray(cb) {
    const len = readU32Leb128();
    const array = [];
    for (let i = 0; i < len; i++) {
      array.push(cb());
    }
    return array;
  }

  function readU32Leb128() {
    let value = 0;
    let shift = 0;
    while (true) {
      const byte = readU8();
      value |= (byte & 0x7f) << shift;
      shift += 7;
      if ((0x80 & byte) === 0) {
        if (value < 0) {
          value += 2 ** 32;
        }
        return value;
      }
    }
  }

  function readI32Leb128() {
    let value = 0;
    let shift = 0;
    while (true) {
      const byte = dv.getUint8(offset++);
      value |= (byte & 0x7f) << shift;
      shift += 7;
      if ((0x80 & byte) === 0) {
        if (shift < 32 && (byte & 0x40) !== 0) {
          return value | (~0 << shift);
        }
        return value;
      }
    }
  }

  function readI64Leb128() {
    let value = 0n;
    let shift = 0n;
    while (true) {
      const byte = dv.getUint8(offset++);
      value |= BigInt(byte & 0x7f) << shift;
      shift += 7n;
      if ((0x80 & byte) === 0) {
        if ((byte & 0x40) !== 0) {
          return value | (~0n << shift);
        }
        return value;
      }
    }
  }

  function readExpression() {
    const start = offset;
    const { decodeNext } = createDecoder(self);
    let op;
    while (op = decodeNext()) {
      if (op.opcode === 0x0B) {
        break;
      }
    }
    const len = offset - start;
    return new DataView(dv.buffer, dv.byteOffset + start, len);
  }

  function readCustom(len) {
    const offsetBefore = offset;
    const name = readString();
    const nameLen = offset - offsetBefore;
    const data = readBytes(len - nameLen);
    return { name, data };
  }

  const self = {
    eof,
    readBytes,
    readU8,
    readU32,
    readF64,
    readString,
    readArray,
    readU32Leb128,
    readI32Leb128,
    readI64Leb128,
    readExpression,
    readCustom,
  };
  return self;
}

function createWriter(maxSize) {
  const dv = new DataView(new ArrayBuffer(maxSize));
  const encoder = new TextEncoder();
  let offset = 0, lengthChecking = false;

  function finalize() {
    return new DataView(dv.buffer, 0, offset);
  }

  function writeBytes(bytes) {
    for (let i = 0; i < bytes.byteLength; i++) {
      writeU8(bytes.getUint8(i));
    }
  }

  function writeU8(value) {
    if (!lengthChecking) {
      dv.setUint8(offset, value);
    }
    offset++;
  }

  function writeU32(value) {
    if (!lengthChecking) {
      dv.setUint32(offset, value, true);
    }
    offset += 4;
  }

  function writeF64(value) {
    if (!lengthChecking) {
      dv.setFloat64(offset, value, true);
    }
    offset += 8;
  }

  function writeString(string) {
    const bytes = encoder.encode(string);
    writeU32Leb128(bytes.length);
    for (const byte of bytes) {
      writeU8(byte);
    }
  }

  function writeArray(values, cb) {
    writeU32Leb128(values.length);
    for (const value of values) {
      cb(value);
    }
  }

  function writeU32Leb128(value) {
    while (true) {
      const byte = value & 0x7f;
      value >>>= 7;
      if (value === 0) {
        writeU8(byte);
        return;
      }
      writeU8(byte | 0x80);
    }
  }

  function writeI32Leb128(value) {
    while (true) {
      const byte = value & 0x7f;
      value >>= 7;
      if ((value === 0 && (byte & 0x40) === 0) || (value === -1 && (byte & 0x40) !== 0)) {
        writeU8(byte);
        return;
      }
      writeU8(byte | 0x80);
    }
  }

  function writeI64Leb128(value) {
    while (true) {
      const byte = Number(value & 0x7fn);
      value >>= 7n;
      if ((value === 0n && (byte & 0x40) === 0) || (value === -1n && (byte & 0x40) !== 0)) {
        writeU8(byte);
        return;
      }
      writeU8(byte | 0x80);
    }
  }

  function writeLength(cb) {
    const saved = offset;
    lengthChecking = true;
    cb();
    const length = offset - saved;
    offset = saved;
    lengthChecking = false;
    writeU32Leb128(length);
    cb();
  }

  function writeExpression(code) {
    writeBytes(code);
  }

  function writeCustom({ name, data }) {
    writeString(name);
    writeBytes(data);
  }

  return {
    finalize,
    writeBytes,
    writeU8,
    writeU32,
    writeF64,
    writeString,
    writeArray,
    writeU32Leb128,
    writeI32Leb128,
    writeI64Leb128,
    writeExpression,
    writeCustom,
    writeLength,
  };
}

function parseFunction(dv) {
  const reader = createReader(dv);
  const {
    readU8,
    readArray,
    readU32Leb128,
  } = reader;
  // read locals first
  const locals = readArray(() => {
    const number = readU32Leb128();
    const type = readU8();
    return { number, type };
  });
  // decode the expression
  const { decodeNext } = createDecoder(reader);
  const instructions = [];
  let op;
  while (op = decodeNext()) {
    instructions.push(op);
  }
  const size = dv.byteLength;
  return { locals, instructions, size };
}

function createDecoder(reader) {
  const {
    eof,
    readBytes,
    readU8,
    readArray,
    readU32Leb128,
    readI32Leb128,
    readI64Leb128,
    readU32,
    readF64,
  } = reader;
  const readOne = readU32Leb128;
  const readTwo = () => [ readOne(), readOne() ];
  const readMultiple = (count) => {
    const indices = [];
    for (let i = 0; i < count; i++) {
      indices.push(readOne());
    }
    return indices;
  };
  const operandReaders = {
    0x02: readI32Leb128,
    0x03: readI32Leb128,
    0x04: readI32Leb128,
    0x05: readI32Leb128,
    0x0C: readOne,
    0x0D: readOne,
    0x0E: () => [ readArray(readOne), readU32Leb128() ],

    0x10: readU32Leb128,
    0x11: readTwo,
    0x1C: () => readArray(readU8),

    0x20: readOne,
    0x21: readOne,
    0x22: readOne,
    0x23: readOne,
    0x24: readOne,
    0x25: readOne,
    0x26: readOne,
    0x28: readTwo,
    0x29: readTwo,
    0x2A: readTwo,
    0x2B: readTwo,
    0x2C: readTwo,
    0x2D: readTwo,
    0x2E: readTwo,
    0x2F: readTwo,

    0x30: readTwo,
    0x31: readTwo,
    0x32: readTwo,
    0x33: readTwo,
    0x34: readTwo,
    0x35: readTwo,
    0x36: readTwo,
    0x37: readTwo,
    0x38: readTwo,
    0x39: readTwo,
    0x3A: readTwo,
    0x3B: readTwo,
    0x3C: readTwo,
    0x3D: readTwo,
    0x3E: readTwo,
    0x3F: readOne,

    0x40: readOne,
    0x41: readI32Leb128,
    0x42: readI64Leb128,
    0x43: readU32,  // avoid precision loss due to float-to-double conversion
    0x44: readF64,

    0xD0: readU8,
    0xD2: readOne,

    0xFC: () => {
      const op1 = readOne();
      switch (op1) {
        case 9:
        case 11:
        case 13:
        case 15:
        case 16:
        case 17:
          return [ op1, readOne() ];
        case 8:
        case 10:
        case 12:
        case 14:
          return [ op1, readOne(), readOne() ];
        default:
          return op1;
      }
    },
    0xFD: () => {
      const op1 = readOne();
      switch (op1) {
        case 21:
        case 22:
        case 23:
        case 24:
        case 25:
        case 26:
        case 27:
        case 28:
        case 29:
        case 30:
        case 31:
        case 32:
        case 33:
        case 34:
          return [ op1, readOne() ];
        case 0:
        case 1:
        case 2:
        case 3:
        case 5:
        case 6:
        case 7:
        case 8:
        case 9:
        case 10:
        case 11:
        case 92:
        case 93:
          return [ op1, readOne(), readOne() ];
        case 84:
        case 85:
        case 86:
        case 87:
        case 88:
        case 89:
        case 90:
        case 91:
          return [ op1, readOne(), readOne(), readOne() ];
        case 12:
          return [ op1, readBytes(16) ];
        case 13:
          return [ op1, ...readMultiple(16) ];
        default:
          return op1;
      }
    },
  };

  function decodeNext() {
    if (eof()) {
      return null;
    }
    const opcode = readU8();
    const f = operandReaders[opcode];
    const operand = f?.();
    return { opcode, operand };
  }

  return { decodeNext };
}

function repackFunction({ locals, instructions, size }) {
  const writer = createWriter(size);
  const {
    finalize,
    writeU8,
    writeArray,
    writeU32Leb128,
  } = writer;
  writeArray(locals, ({ number, type }) => {
    writeU32Leb128(number);
    writeU8(type);
  });
  const { encodeNext } = createEncoder(writer);
  for (const op of instructions) {
    encodeNext(op);
  }
  return finalize();
}

function createEncoder(writer) {
  const {
    writeBytes,
    writeU8,
    writeArray,
    writeU32Leb128,
    writeI32Leb128,
    writeI64Leb128,
    writeU32,
    writeF64,
  } = writer;
  const writeOne = writeU32Leb128;
  const writeTwo = (op) => {
    writeOne(op[0]);
    writeOne(op[1]);
  };
  const writeMultiple = (indices) => {
    for (const index of indices) {
      writeOne(index);
    }
  };
  const operandWriters = {
    0x02: writeI32Leb128,
    0x03: writeI32Leb128,
    0x04: writeI32Leb128,
    0x05: writeI32Leb128,
    0x0C: writeOne,
    0x0D: writeOne,
    0x0E: (op) => [ writeArray(op[0], writeOne), writeU32Leb128(op[1]) ],

    0x10: writeU32Leb128,
    0x11: writeTwo,
    0x1C: (op) => writeArray(op, writeU8),

    0x20: writeOne,
    0x21: writeOne,
    0x22: writeOne,
    0x23: writeOne,
    0x24: writeOne,
    0x25: writeOne,
    0x26: writeOne,
    0x28: writeTwo,
    0x29: writeTwo,
    0x2A: writeTwo,
    0x2B: writeTwo,
    0x2C: writeTwo,
    0x2D: writeTwo,
    0x2E: writeTwo,
    0x2F: writeTwo,

    0x30: writeTwo,
    0x31: writeTwo,
    0x32: writeTwo,
    0x33: writeTwo,
    0x34: writeTwo,
    0x35: writeTwo,
    0x36: writeTwo,
    0x37: writeTwo,
    0x38: writeTwo,
    0x39: writeTwo,
    0x3A: writeTwo,
    0x3B: writeTwo,
    0x3C: writeTwo,
    0x3D: writeTwo,
    0x3E: writeTwo,
    0x3F: writeOne,

    0x40: writeOne,
    0x41: writeI32Leb128,
    0x42: writeI64Leb128,
    0x43: writeU32,   // avoid precision loss due to float-to-double conversion
    0x44: writeF64,

    0xD0: writeU8,
    0xD2: writeOne,

    0xFC: (op) => {
      if (op instanceof Array) {
        writeMultiple(op);
      } else {
        writeOne(op);
      }
    },
    0xFD: (op) => {
      if (op instanceof Array) {
        if (op[0] === 12) {
          writeOne(op[0]);
          writeBytes(op[1]);
        } else {
          writeMultiple(op);
        }
      } else {
        return writeOne(op);
      }
    },
  };

  function encodeNext({ opcode, operand }) {
    writeU8(opcode);
    const f = operandWriters[opcode];
    f?.(operand);
  }

  return { encodeNext };
}

function parseNames(section) {
  let moduleName = '';
  const functionNames = [];
  const localNames = [];
  if (section) {
    const {
      eof,
      readString,
      readU8,
      readU32Leb128,
      readArray,
      readBytes,
    } = createReader(section.data);
    const readMap = () => readArray(() => {
      const index = readU32Leb128();
      const name = readString();
      return { index, name };
    });
    while(!eof()) {
      const id = readU8();
      const size = readU32Leb128();
      switch (id) {
        case 0: {
          moduleName = readString();
        } break;
        case 1: {
          const map = readMap();
          for (const { index, name } of map) {
            functionNames[index] = name;
          }
        } break;
        case 2:
          const map = readArray(() => {
            const index = readU8();
            const locals = readMap();
            return { index, locals };
          });
          for (const { index, locals } of map) {
            localNames[index] = locals;
          }
          break;
        default: {
          readBytes(size);
        }
      }
    }
  }
  return { moduleName, functionNames, localNames };
}

function repackNames({ moduleName, functionNames, localNames, size }) {
  const {
    finalize,
    writeString,
    writeU8,
    writeU32Leb128,
    writeArray,
    writeLength,
  } = createWriter(size);
  const writeMap = (entries) => writeArray(entries, ({ index, name }) => {
    writeU32Leb128(index);
    writeString(name);
  });
  if (moduleName) {
    writeU8(0);
    writeLength(() => {
      writeString(moduleName);
    });
  }
  if (functionNames.length > 0) {
    writeU8(1);
    writeLength(() => {
      const map = [];
      for (const [ index, name ] of functionNames.entries()) {
        map.push({ index, name });
      }
      writeMap(map);
    });
  }
  if (localNames.length > 0) {
    writeU8(2);
    writeLength(() => {
      const imap = [];
      for (const [ index, locals ] of localNames.entries()) {
        imap.push({ index, locals });
      }
      writeArray(imap, ({ index, locals }) => {
        writeU32Leb128(index);
        writeMap(locals);
      });
    });
  }
  return finalize();
}

async function transpile(path, options) {
  const {
    embedWASM = true,
    topLevelAwait = true,
    omitExports = false,
    stripWASM = (options.optimize && options.optimize !== 'Debug'),
    keepNames = false,
    moduleResolver = (name) => name,
    wasmLoader,
    sourceFiles,
    ...compileOptions
  } = options;
  if (typeof(wasmLoader) !== 'function') {
    if (embedWASM !== true) {
      throw new Error(`wasmLoader is a required option when embedWASM is false`);
    }
  }
  Object.assign(compileOptions, { arch: 'wasm32', platform: 'wasi', isWASM: true });
  const srcPath = path.endsWith('.zig') ? path : findSourceFile(path, { 
    sourceFiles: getAbsoluteMapping(sourceFiles, process.cwd()),
  });
  const { outputPath } = await compile(srcPath, null, compileOptions);
  const content = await readFile(outputPath);
  const env = createEnvironment();
  env.loadModule(content);
  await env.initPromise;
  env.acquireStructures(compileOptions);
  const definition = env.exportStructures();
  const runtimeURL = moduleResolver('zigar-runtime');
  let binarySource;
  if (env.hasMethods()) {
    let dv = new DataView(content.buffer);
    if (stripWASM) {
      dv = stripUnused(dv, { keepNames });
    }
    if (embedWASM) {
      binarySource = embed(srcPath, dv);
    } else {
      binarySource = await wasmLoader(srcPath, dv);
    }
  }
  return generateCode(definition, {
    declareFeatures: true,
    runtimeURL,
    binarySource,
    topLevelAwait,
    omitExports,
  });
}

function embed(path, dv) {
  const base64 = Buffer.from(dv.buffer, dv.byteOffset, dv.byteLength).toString('base64');
  return `(async () => {
  // ${basename(path)}
  const binaryString = atob(${JSON.stringify(base64)});
  const bytes = new Uint8Array(binaryString.length);
  for (let i = 0; i < binaryString.length; i++) {
    bytes[i] = binaryString.charCodeAt(i);
  }
  return bytes.buffer;
})()`;
}

export { compile, compileSync, extractOptions, findConfigFile, findConfigFileSync, findSourceFile$1 as findSourceFile, generateCode, getArch, getCachePath, getModuleCachePath, getPlatform, loadConfigFile, loadConfigFileSync, normalizePath, optionsForCompile, optionsForTranspile, transpile };
