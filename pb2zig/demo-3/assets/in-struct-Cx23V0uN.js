import{_ as En}from"./index-DGtoKjJP.js";const E={Primitive:0,Array:1,Struct:2,Union:3,ErrorUnion:4,ErrorSet:5,Enum:6,Optional:7,Pointer:8,Slice:9,Vector:10,Opaque:11,ArgStruct:12,VariadicStruct:13,Function:14},G={Unknown:0,Promise:1,Generator:2,AbortSignal:3,Allocator:4,Iterator:5,File:6,Directory:7},Ye=Object.keys(E),V={HasValue:1,HasObject:2,HasPointer:4,HasSlot:8,HasProxy:16},Jt={IsSize:32},Ce={HasSentinel:32,IsString:64,IsTypedArray:128,IsClampedArray:256},Je={IsTuple:128},Tn={IsOpenEnded:32},Pt={HasSelector:32},L={HasLength:32,IsMultiple:64,IsSingle:128,IsConst:256,IsNullable:512},le={HasSentinel:32,IsString:64,IsTypedArray:128,IsClampedArray:256,IsOpaque:512},Pe={IsGlobal:32},_t={IsTypedArray:32,IsClampedArray:64},at={HasOptions:32,IsThrowing:64,IsAsync:128},F={Void:0,Bool:1,Int:2,Uint:3,Float:4,Object:5,Type:6,Literal:7,Null:8,Undefined:9,Unsupported:10},Gt=Object.keys(F),H={IsRequired:1,IsReadOnly:2,IsPartOfSet:4,IsSelector:8,IsMethod:16,IsExpectingInstance:32,IsSentinel:64,IsBackingInt:128,IsString:256,IsPlain:512,IsTypedArray:1024,IsClampedArray:2048},O={Pointer:1,Slice:2,Const:4,ReadOnly:8},P={IsInactive:1,IsImmutable:2,IgnoreUncreated:4,IgnoreInactive:8,IgnoreArguments:16,IgnoreRetval:32},B={NONE:0,EACCES:2,EAGAIN:6,EBADF:8,EDEADLK:16,EEXIST:20,EFAULT:21,EINVAL:28,EIO:29,EMFILE:34,ENOENT:44,ENOSPC:51,ENOTSUP:58,EPERM:63,ESPIPE:70,ENOTCAPABLE:76},k={fd_datasync:1,fd_read:2,fd_seek:4,fd_fdstat_set_flags:8,fd_sync:16,fd_tell:32,fd_write:64,fd_advise:128,fd_allocate:256,path_create_directory:512,path_create_file:1024,path_open:8192,fd_readdir:16384,path_filestat_get:1<<18,path_filestat_set_size:1<<19,path_filestat_set_times:1<<20,fd_filestat_get:1<<21,fd_filestat_set_size:1<<22,fd_filestat_set_times:1<<23,path_remove_directory:1<<25,path_unlink_file:1<<26},Z={stdin:0,stdout:1,stderr:2,root:-1,min:15728640,max:16777215},St=globalThis[Symbol.for("ZIGAR")]??={};function vn(t){return St[t]??=Symbol(t)}function I(t){return vn(t)}const w=I("memory"),x=I("slots"),At=I("parent"),C=I("zig"),lt=I("name"),xe=I("type"),qt=I("flags"),Ge=I("class"),zt=I("tag"),Ve=I("props"),be=I("sentinel"),K=I("target"),ye=I("entries"),_e=I("max length"),pt=I("keys"),Yt=I("address"),Ee=I("length"),$e=I("last address"),We=I("last length"),Xe=I("cache"),It=I("size"),xn=I("bit size"),se=I("align"),X=I("environment"),Mn=I("attributes"),On=I("primitive"),Ne=I("setters"),ge=I("typed array"),Xt=I("throwing"),Kt=I("promise"),Vn=I("generator"),Et=I("allocator"),mt=I("signature"),Ze=I("controller"),st=I("proxy type"),Ke=I("read only"),Fe=I("no cache"),we=I("update"),W=I("restore"),kn=I("reset"),ue=I("vivificate"),_=I("visit"),Le=I("shape"),q=I("initialize"),Cn=I("restrict"),fe=I("finalize"),it=I("proxy"),je=I("cast"),pe=I("return"),Pn=I("yield"),Ie=I("transform");function U(t,e,n){if(n){const{set:s,get:i,value:r,enumerable:o,configurable:c=!0,writable:a=!0}=n;Object.defineProperty(t,e,i||s?{get:i,set:s,configurable:c,enumerable:o}:{value:r,configurable:c,enumerable:o,writable:a})}return t}function de(t,e){for(const[n,s]of Object.entries(e))U(t,n,s);for(const n of Object.getOwnPropertySymbols(e)){const s=e[n];U(t,n,s)}return t}function b(t){return t!==void 0?{value:t}:void 0}function Tt(t){return t?.error==="return"?e=>{try{return e()}catch(n){return n}}:e=>e()}function Qt({type:t,bitSize:e}){switch(t){case F.Bool:return"boolean";case F.Int:case F.Uint:if(e>32)return"bigint";case F.Float:return"number"}}function vt(t,e="utf-8"){const n=$n[e]||=new TextDecoder(e);let s;if(Array.isArray(t))if(t.length===1)s=t[0];else{let i=0;for(const c of t)i+=c.length;const{constructor:r}=t[0];s=new r(i);let o=0;for(const c of t)s.set(c,o),o+=c.length}else s=t;return s.buffer[Symbol.toStringTag]==="SharedArrayBuffer"&&(s=new s.constructor(s)),n.decode(s)}function en(t,e="utf-8"){switch(e){case"utf-16":{const{length:n}=t,s=new Uint16Array(n);for(let i=0;i<n;i++)s[i]=t.charCodeAt(i);return s}default:return(Ln[e]||=new TextEncoder).encode(t)}}function _n(t){const e=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),n=String.fromCharCode.apply(null,e);return btoa(n)}function zn(t){const e=atob(t),n=new Uint8Array(e.length);for(let s=0;s<n.byteLength;s++)n[s]=e.charCodeAt(s);return new DataView(n.buffer)}const $n={},Ln={};function Nn(t,e){const n=t.indexOf(e);n!==-1&&t.splice(n,1)}function tn(t,e,n){let s=0,i=t.length;if(i===0)return 0;for(;s<i;){const r=Math.floor((s+i)/2);n(t[r])<=e?s=r+1:i=r}return i}function Fn(t,e){return e?!!(t&e-1):!1}function jn(t,e){return t+(e-1)&~(e-1)}const Rn=0,Qe=4294967295,Re=-1;function nn(t){return Number(t)}BigInt(Number.MAX_SAFE_INTEGER);BigInt(Number.MIN_SAFE_INTEGER);function $t(t){return t===2863311530||t===-1431655766}function Ae(t,e){return t+e}function sn(t){if(typeof t.length=="number")return t;const e=t[Symbol.iterator](),n=e.next(),s=n.value?.length;if(typeof s=="number"&&Object.keys(n.value).join()==="length")return Object.assign(function*(){let i;for(;!(i=e.next()).done;)yield i.value}(),{length:s});{const i=[];let r=n;for(;!r.done;)i.push(r.value),r=e.next();return i}}function rn(t,e){const{constructor:n}=t;if(n===e)return 1;if(n.child===e)return t.length}function on(t,e){return t===e||t?.[mt]===e[mt]&&t?.[X]!==e?.[X]}function he(t,e){return t instanceof e||on(t?.constructor,e)}function xt(t){return typeof t?.then=="function"}function Ue({get:t,set:e}){return t.special=e.special=!0,{get:t,set:e}}function ie(t,e,n=0){const s=new Uint8Array(t.buffer,t.byteOffset,t.byteLength),i=new Uint8Array(e.buffer,e.byteOffset,e.byteLength);s.set(i,n)}function cn(t,e=0,n=t.byteLength-e){new Uint8Array(t.buffer,t.byteOffset,t.byteLength).fill(0,e,e+n)}const Dn=Object.hasOwn(ArrayBuffer.prototype,"detached")?function(t){return t.detached}:function(t){return t.byteLength===0};function re(t,e){const n=t[W](),s=e[W]();ie(n,s)}function rt(){return this}function Hn(){return String(this)}function et(){}class Un{map=new WeakMap;find(e){return e[Fe]?void 0:this.map.get(e)}save(e,n){e[Fe]||this.map.set(e,n)}}const tt={name:"",mixins:[]};function A(t){return tt.mixins.includes(t)||tt.mixins.push(t),t}function Bn(){return Wn(tt.name,tt.mixins)}function Wn(t,e){const n=[],s=function(){for(const r of n)r.call(this)},{prototype:i}=s;U(s,"name",b(t));for(const r of e)for(let[o,c]of Object.entries(r))if(o==="init")n.push(c);else{if(typeof c!="function"){let a=i[o];if(a!==void 0){if(a?.constructor===Object)c=Object.assign({...a},c);else if(a!==c)throw new Error(`Duplicate property: ${o}`)}}U(i,o,b(c))}return s}function ti(){const t=Bn();return new t}A({init(){this.accessorCache=new Map},getAccessor(t,e){const{type:n,bitSize:s,bitOffset:i,byteSize:r}=e,o=[],c=r===void 0&&(s&7||i&7);c&&o.push("Unaligned");let a=Gt[n];s>32&&(n===F.Int||n===F.Uint)&&(s<=64?a=`Big${a}`:a=`Jumbo${a}`),o.push(a,`${n===F.Bool&&r?r<<3:s}`),c&&o.push(`@${i}`);const l=t+o.join("");let f=this.accessorCache.get(l);if(f)return f;if(f=DataView.prototype[l],!f){for(;o.length>0;){const u=`getAccessor${o.join("")}`;if(f=this[u]?.(t,e))break;o.pop()}if(!f)throw new Error(`No accessor available: ${l}`)}return f.name||U(f,"name",b(l)),this.accessorCache.set(l,f),f}});A({getAccessorBool(t,e){const{byteSize:n}=e,s=n*8,i=this.getAccessor(t,{type:F.Uint,bitSize:s,byteSize:n});if(t==="get")return function(r,o){return!!i.call(this,r,o)};{const r=s<=32?0:0n,o=s<=32?1:1n;return function(c,a,l){i.call(this,c,a?o:r,l)}}}});A({getAccessorUint(t,e){const{bitSize:n,byteSize:s}=e;if(s){const i=this.getAccessor(t,{...e,bitSize:s*8}),r=2**n-1;return t==="get"?function(o,c){return i.call(this,o,c)&r}:function(o,c,a){const l=c&r;i.call(this,o,l,a)}}}});class Zn extends SyntaxError{constructor(e){super(`Cannot convert ${e} to an Int`)}}class bt extends TypeError{errno=B.ENOTSUP;hide=!0;constructor(){super("Unsupported")}}class an extends TypeError{constructor(e){const{name:n}=e;super(`An initializer must be provided to the constructor of ${n}, even when the intended value is undefined`)}}class ln extends TypeError{constructor(e,n,s=null){const{name:i,type:r,byteSize:o}=e,c=n.byteLength,a=o!==1?"s":"";let l;if(r===E.Slice&&!s)l=`${i} has elements that are ${o} byte${a} in length, received ${c}`;else{const f=r===E.Slice?s.length*o:o;l=`${i} has ${f} byte${a}, received ${c}`}super(l)}}class Jn extends TypeError{constructor(e){const{type:n,byteSize:s,typedArray:i}=e,r=s!==1?"s":"",o=["ArrayBuffer","DataView"].map(ke);i&&o.push(ke(i.name));let c;n===E.Slice?c=`Expecting ${gt(o)} that can accommodate items ${s} byte${r} in length`:c=`Expecting ${gt(o)} that is ${s} byte${r} in length`,super(c)}}class Gn extends TypeError{constructor(e,n){const{name:s}=e;let i;typeof n=="number"||typeof n=="bigint"?i=`Value given does not correspond to an item of enum ${s}: ${n}`:i=`Enum item of the type ${s} expected, received ${n}`,super(i)}}class qn extends TypeError{constructor(e,n){const{name:s}=e,i=typeof n;let r;i==="string"||i==="number"||De(n)?(De(n)&&(n=`{ error: ${JSON.stringify(n.error)} }`),r=`Error ${i} does not corresponds to any error in error set ${s}: ${n}`):r=`Error of the type ${s} expected, received ${n}`,super(r)}}class fn extends TypeError{constructor(e,n){const{name:s}=e;super(`Error given is not a part of error set ${s}: ${n}`)}}class ve extends TypeError{constructor(e,n,s){const{name:i}=e,r=[];if(Array.isArray(n))for(const c of n)r.push(ke(c));else r.push(ke(n));const o=dn(s);super(`${i} expects ${gt(r)} as argument, received ${o}`)}}class Te extends ve{constructor(e,n,s=!1){const{instance:{members:[i]},type:r,constructor:o}=e,c=[],a=Qt(i);if(a){let l;switch(i.structure?.type){case E.Enum:l="enum item";break;case E.ErrorSet:l="error";break;default:l=a}c.push(`array of ${l}s`)}else c.push("array of objects");o[ge]&&c.push(o[ge].name),r===E.Slice&&s&&c.push("length"),super(e,c.join(" or "),n)}}class ot extends TypeError{constructor(e,n,s){const{name:i,length:r,instance:{members:[o]}}=e,{structure:{constructor:c}}=o,{length:a,constructor:l}=s,f=n?.length??r,u=f!==1?"s":"";let h;l===c?h="only a single one":l.child===c?h=`a slice/array that has ${a}`:h=`${a} initializer${a>1?"s":""}`,super(`${i} has ${f} element${u}, received ${h}`)}}class Lt extends TypeError{constructor(e,n){e<0?super("Length of slice cannot be negative"):super(`Length of slice can be ${n} or less, received ${e}`)}}class Yn extends TypeError{constructor(e,n){const{name:s}=e;super(`Missing initializers for ${s}: ${n.join(", ")}`)}}class Xn extends TypeError{constructor(e,n){const{name:s,instance:{members:i}}=e,r=i.find(c=>c.name===n);let o;r?o=`Comptime value cannot be changed: ${n}`:o=`${s} does not have a property with that name: ${n}`,super(o)}}class Kn extends Error{constructor(e,n,s=!1){super();const i=r=>{e-=r,n-=r;const o=e!==1?"s":"",c=s?"at least ":"";this.message=`Expecting ${c}${e} argument${o}, received ${n}`,this.stack=Mt(this.stack,"new Arg(")};i(0),U(this,we,{value:i,enumerable:!1})}}class Qn extends Error{constructor(){super("Undefined argument")}}class es extends TypeError{constructor(){super("Non-slice pointers can only be created with the help of the new operator")}}class ts extends TypeError{constructor(){super("Casting to function is not allowed")}}class ns extends TypeError{constructor(e,n){const{name:s}=e,{constructor:{name:i}}=n;super(`Conversion of ${i} to ${s} requires an explicit cast`)}}class Nt extends TypeError{constructor(e,n,s,i){const{name:r}=e;super(`${r} expects the sentinel value ${n} at ${i-1}, found at ${s}`)}}class ft extends TypeError{constructor(e,n,s){const{name:i}=e;super(`${i} expects the sentinel value ${n} at ${s-1}`)}}class ss extends TypeError{constructor(e,n){super(`Unable to simultaneously align memory to ${n}-byte and ${e}-byte boundary`)}}class oe extends TypeError{constructor(e,n){const s=dn(n);super(`Expected ${ke(e)}, received ${s}`)}}class is extends TypeError{constructor(e,n){const s=[];e&k.fd_read&&s.push("ReadableStreamDefaultReader","ReadableStreamBYOBReader","Blob","Uint8Array"),e&k.fd_write&&s.push("WritableStreamDefaultWriter","array","null"),e&k.fd_readdir&&s.push("Map");const i=s.join(", ");super(`Expected ${i}, or an object with the appropriate stream interface, received ${n}`)}}class rs extends TypeError{constructor(){super("Null pointer")}}class un extends TypeError{constructor(e){super(`Object has been freed already: ${e.constructor.name}`)}}class Ft extends TypeError{constructor(e,n){const{name:s}=e;let i;if(n!=null){const r=n instanceof Object&&n.constructor!==Object?`${n.constructor.name} object`:typeof n;i=`${yn(r)} ${r}`}else i=n+"";super(`${s} cannot point to ${i}`)}}class hn extends TypeError{constructor(){super("Pointers in Zig memory cannot point to garbage-collected object")}}class os extends RangeError{constructor(e,n){const{name:s}=e;super(`Index exceeds the size of ${s??"array"}: ${n}`)}}class jt extends TypeError{constructor(e){const{name:n}=e,s=n!==void 0?`Property ${n}`:"Element";super(`${s} can only be undefined`)}}class cs extends TypeError{constructor(e){const{name:n,structure:{name:s}}=e;super(`Unable to create ${s} as it is not situated on a byte boundary: ${n}`)}}class as extends TypeError{constructor(){super("Unable to modify read-only object")}}class ls extends TypeError{constructor(e){const{name:n}=e;super(`${n} cannot point to a read-only object`)}}class fs extends TypeError{constructor(){super("Unexpected async generator")}}class us extends Error{errno=B.EBADF;constructor(){super("Invalid file descriptor")}}class hs extends Error{errno=B.EMFILE;constructor(){super("Too many open files")}}class ds extends Error{errno=B.EDEADLK;constructor(){super("Deadlock")}}class qe extends Error{constructor(e,n=0){if(e instanceof Error)return super(e.message),e.stack=Mt(this.stack,n),e;super(e??"Error encountered in Zig code")}}class ys extends qe{constructor(e){super("Program exited"),this.code=e}}function ps(t,e){const n=s=>{e-=s,t.message=`args[${e}]: ${t.message}`,t.stack=Mt(t.stack,"new Arg(")};return n(0),U(t,we,{value:n,enumerable:!1}),t}function Mt(t,e){if(typeof t=="string"){const n=t.split(`
`),s=n.findIndex(i=>i.includes(e));s!==-1&&(n.splice(1,s),t=n.join(`
`))}return t}function ce(){throw new as}function ms(t){let e=t.replace(/_/g," ");try{e=e.replace(new RegExp("(\\p{Uppercase}+)(\\p{Lowercase}*)","gu"),(n,s,i)=>s.length===1?` ${s.toLocaleLowerCase()}${i}`:i?n:` ${s}`).trimStart()}catch{}return e.charAt(0).toLocaleUpperCase()+e.substring(1)}function bs(t=!1,e,n,s,i){const r=c=>{let a;return i?a=i(c):c.hide||console.error(c),a??c.errno??e},o=c=>s?.(c)??B.NONE;try{const c=n();if(xt(c)){if(!t)throw new ds;return c.then(o).catch(r)}else return o(c)}catch(c){return r(c)}}function De(t){return typeof t=="object"&&typeof t.error=="string"&&Object.keys(t).length===1}function dn(t){const e=typeof t;let n;return e==="object"?n=t?Object.prototype.toString.call(t):"null":n=e,ke(n)}function ke(t){return`${yn(t)} ${t}`}function yn(t){return/^\W*[aeiou]/i.test(t)?"an":"a"}function gt(t,e="or"){const n=` ${e} `;return t.length>2?t.slice(0,-1).join(", ")+n+t[t.length-1]:t.join(n)}A({defineAlloc(){return{value(t,e=1){const n=Math.clz32(e);if(e!==1<<31-n)throw new Error(`Invalid alignment: ${e}`);const s=31-n,{vtable:{alloc:i},ptr:r}=this,o=i(r,t,s,0);if(!o)throw new Error("Out of memory");o.length=t;const c=o["*"][w];return c[C].align=e,c}}},defineFree(){const t=this;return{value(e){const{dv:n,align:s}=Rt(e),i=n?.[C];if(!i)throw new oe("object containing allocated Zig memory",e);const{address:r}=i;if(r===Re)throw new un(e);const{vtable:{free:o},ptr:c}=this,a=31-Math.clz32(s);o(c,n,a,0),t.releaseZigView(n)}}},defineDupe(){return{value(t){const{dv:e,align:n,constructor:s}=Rt(t);if(!e)throw new oe("string, DataView, typed array, or Zig object",t);const i=this.alloc(e.byteLength,n);return ie(i,e),s?s(i):i}}}});function Rt(t){let e,n=1,s=null;if(t instanceof DataView){e=t;const i=e?.[C]?.align;i&&(n=i)}else if(t instanceof ArrayBuffer)e=new DataView(t);else if(t)if(t[w])t.constructor[xe]===E.Pointer&&(t=t["*"]),e=t[w],s=t.constructor,n=s[se];else{typeof t=="string"&&(t=en(t));const{buffer:i,byteOffset:r,byteLength:o,BYTES_PER_ELEMENT:c}=t;i&&r!==void 0&&o!==void 0&&(e=new DataView(i,r,o),n=c)}return{dv:e,align:n,constructor:s}}const gs=["log","mkdir","stat","utimes","open","rename","readlink","rmdir","symlink","unlink"];A({init(){this.variables=[],this.listenerMap=new Map,this.envVariables=this.envVarArrays=null},getSpecialExports(){const t=e=>{if(e===void 0)throw new Error("Not a Zig type");return e};return{init:()=>this.initPromise,abandon:()=>this.abandonModule?.(),redirect:(e,n)=>this.redirectStream(e,n),sizeOf:e=>t(e?.[It]),alignOf:e=>t(e?.[se]),typeOf:e=>ws[t(e?.[xe])],on:(e,n)=>this.addListener(e,n),set:(e,n)=>this.setObject(e,n)}},addListener(t,e){if(gs.indexOf(t)>=0){if(!this.ioRedirection)throw new Error("Redirection disabled");this.listenerMap.set(t,e)}else throw new Error(`Unknown event: ${t}`)},hasListener(t){return this.listenerMap.get(t)},setObject(t,e){if(typeof e!="object")throw new oe("object",e);if(t==="wasi")this.setCustomWASI(e);else if(t==="env")this.envVariables=e,this.libc&&this.initializeLibc();else throw new Error(`Unknown object: ${t}`)},triggerEvent(t,e){return this.listenerMap.get(t)?.(e)},recreateStructures(t,e){Object.assign(this,e);const n=(c,a)=>{for(const[l,f]of Object.entries(a))c[l]=r(f);return c},s=[],i=c=>c.length?c.buffer:new ArrayBuffer(0),r=c=>{const{memory:a,structure:l,actual:f,slots:u}=c;if(a){if(f)return f;{const{array:h,offset:y,length:p}=a,d=this.obtainView(i(h),y,p),{handle:g}=c,{constructor:S}=l,v=S.call(X,d);return u&&n(v[x],u),g!==void 0?this.variables.push({handle:g,object:v}):y===void 0&&s.push(v),c.actual=v,v}}else return l},o=new Map;for(const c of t){for(const a of[c.instance,c.static])if(a.template){const{slots:l,memory:f,handle:u}=a.template,h=a.template={};if(f){const{array:y,offset:p,length:d}=f;h[w]=this.obtainView(i(y),p,d),u!==void 0&&this.variables.push({handle:u,object:h})}if(l){const y=h[x]={};o.set(y,l)}}this.defineStructure(c)}for(const[c,a]of o)n(c,a);for(const c of t)this.finalizeStructure(c);for(const c of s)this.makeReadOnly(c)},imports:{initializeLibc:{argType:"ii"}}});const ws=Ye.map(t=>t.replace(/([a-z])([A-Z])/g,"$1 $2").toLowerCase());A({init(){this.jsFunctionThunkMap=new Map,this.jsFunctionCallerMap=new Map,this.jsFunctionControllerMap=new Map,this.jsFunctionIdMap=new WeakMap,this.jsFunctionNextId=1},getFunctionId(t){let e=this.jsFunctionIdMap.get(t);return e===void 0&&(e=this.jsFunctionNextId++,this.jsFunctionIdMap.set(t,e)),e},getFunctionThunk(t,e){const n=this.getFunctionId(t);let s=this.jsFunctionThunkMap.get(n);if(s===void 0){const i=this.getViewAddress(e[w]),r=this.createJsThunk(i,n);if(!r)throw new Error("Unable to create function thunk");s=this.obtainZigView(r,0),this.jsFunctionThunkMap.set(n,s),this.jsFunctionControllerMap.set(n,e)}return s},createInboundCaller(t,e){const n=(i,r)=>{try{const o=e(i);if(_ in o){o[_]("reset",P.IgnoreUncreated);const f=this.startContext();this.updatePointerTargets(f,o,!0),this.updateShadowTargets(f),this.endContext()}const c=[...o],a=o.hasOwnProperty(pe),l=bs(r||a,B.EFAULT,()=>t(...c),f=>{if(f?.[Symbol.asyncIterator]){if(!o.hasOwnProperty(Pn))throw new fs;this.pipeContents(f,o)}else o[pe](f)},f=>{try{if(e[Xt]&&f instanceof Error)return o[pe](f),B.NONE;throw f}catch{console.error(f)}});return a?B.NONE:l}catch(o){return console.error(o),B.EFAULT}},s=this.getFunctionId(t);return this.jsFunctionCallerMap.set(s,n),function(...i){return t(...i)}},defineArgIterator(t){const e=this,n=t.filter(({structure:s})=>s.type===E.Struct&&s.purpose===G.Allocator).length;return{value(){let s,i=0,r=0,o=0;const c=[];for(const[a,{structure:l,type:f}]of t.entries())try{let u=this[a];f===F.Object&&u?.[w]?.[C]&&(u=new u.constructor(u));let h,y;if(l.type===E.Struct)switch(l.purpose){case G.Allocator:h=n===1?"allocator":`allocator${++i}`,y=this[Et]=u;break;case G.Promise:h="callback",++r===1&&(y=e.createPromiseCallback(this,u));break;case G.Generator:h="callback",++r===1&&(y=e.createGeneratorCallback(this,u));break;case G.AbortSignal:h="signal",++o===1&&(y=e.createInboundSignal(u));break}h!==void 0?y!==void 0&&(s||={},s[h]=y):c.push(u)}catch(u){c.push(u)}return s&&c.push(s),c[Symbol.iterator]()}}},handleJscall(t,e,n,s){const i=this.obtainZigView(e,n,!1),r=this.jsFunctionCallerMap.get(t);return r?r(i,s):B.EFAULT},releaseFunction(t){const e=this.jsFunctionThunkMap.get(t),n=this.jsFunctionControllerMap.get(t);if(e&&n){const s=this.getViewAddress(n[w]),i=this.getViewAddress(e);this.destroyJsThunk(s,i),this.releaseZigView(e),t&&(this.jsFunctionThunkMap.delete(t),this.jsFunctionCallerMap.delete(t),this.jsFunctionControllerMap.delete(t))}},freeFunction(t){this.releaseFunction(this.getFunctionId(t))},exports:{handleJscall:{argType:"iiib",returnType:"i"},releaseFunction:{argType:"i"}},imports:{createJsThunk:{argType:"ii",returnType:"i"},destroyJsThunk:{argType:"ii",returnType:"i"},finalizeAsyncCall:{argType:"ii"}}});A({createOutboundCaller(t,e){const n=this,s=function(...i){if(!n.runThunk)return n.initPromise.then(()=>s(...i));const r=new e(i,this?.[Et]);try{return n.invokeThunk(t,s,r)}catch(o){if(o instanceof ys&&o.code===0)return;throw o}};return s},copyArguments(t,e,n,s,i){let r=0,o=0,c=0;const a=t[Ne];for(const{type:l,structure:f}of n){let u,h,y,p;if(f.type===E.Struct)switch(f.purpose){case G.Allocator:u=(++c===1?s?.allocator??s?.allocator1:s?.[`allocator${c}`])??this.createDefaultAllocator(t,f);break;case G.Promise:h||=this.createPromise(f,t,s?.callback),u=h;break;case G.Generator:y||=this.createGenerator(f,t,s?.callback),u=y;break;case G.AbortSignal:p||=this.createSignal(f,s?.signal),u=p;break;case G.File:u=this.createFile(e[o++]);break;case G.Directory:u=this.createDirectory(e[o++]);break}if(u===void 0&&(u=e[o++],u===void 0&&l!==F.Void))throw new Qn;try{a[r++].call(t,u,i)}catch(d){throw ps(d,r-1)}}},invokeThunk(t,e,n){const s=this.startContext(),i=n[Mn],r=this.getViewAddress(t[w]),o=this.getViewAddress(e[w]),c=fe in n,a=_ in n;a&&this.updatePointerAddresses(s,n);const l=this.getShadowAddress(s,n,null,!1),f=i?this.getShadowAddress(s,i):0;this.updateShadows(s);let u=!1;const h=()=>{this.updateShadowTargets(s),a&&this.updatePointerTargets(s,n),this.flushStreams?.(),this.endContext(),u=!0};if(c&&(n[fe]=h),!(i?this.runVariadicThunk(r,o,l,f,i.length):this.runThunk(r,o,l)))throw u||h(),new qe;u||n[we]?.(this.findShadowView(n[w]));const p=e[Ie];if(c){let d=null;if(!u)try{d=n.retval}catch(g){d=new qe(g,1)}return d!=null?(p&&(d=p(d)),n[pe](d)):p&&(n[Ie]=p),n[Kt]??n[Vn]}else{h();try{const{retval:d}=n;return p?p(d):d}catch(d){throw new qe(d,1)}}},imports:{runThunk:{argType:"iii",returnType:"b"},runVariadicThunk:{argType:"iiiii",returnType:"b"}}});A({addIntConversion(t){return function(e,n){const s=t.call(this,e,n),{flags:i,bitSize:r}=n;if(e==="set")return r>32?function(o,c,a){s.call(this,o,BigInt(c),a)}:function(o,c,a){const l=Number(c);if(!isFinite(l))throw new Zn(c);s.call(this,o,l,a)};{const{flags:o}=n.structure;if(o&Jt.IsSize&&r>32){const c=BigInt(Number.MAX_SAFE_INTEGER),a=BigInt(Number.MIN_SAFE_INTEGER);return function(l,f){const u=s.call(this,l,f);return a<=u&&u<=c?Number(u):u}}}return s}}});A({init(){this.isMemoryMapping=!0,this.memoryList=[],this.contextCount=0},startContext(){return++this.contextCount,{shadowList:[]}},endContext(){if(--this.contextCount===0){for(const{shadowDV:t}of this.memoryList)t&&this.freeShadowMemory(t);this.memoryList.splice(0)}},getShadowAddress(t,e,n,s){const i=e[w];if(n){if(n.address===void 0){const{start:r,end:o,targets:c}=n;let a=0,l;for(const M of c){const T=M[w],R=T.byteOffset,D=M.constructor[se]??T[se];(a===void 0||D>a)&&(a=D,l=R)}const f=o-r,u=this.allocateShadowMemory(f+a,1),h=this.getViewAddress(u),y=jn(Ae(h,l-r),a),p=Ae(y,r-l);for(const M of c){const T=M[w],R=T.byteOffset;if(R!==l){const D=M.constructor[se]??T[se];if(Fn(Ae(p,R-r),D))throw new ss(D,a)}}const d=u.byteOffset+Number(p-h),g=new DataView(u.buffer,d,f);g[C]={address:p,len:f,align:1,unalignedAddress:h,type:Ss.Scratch};const S=new DataView(i.buffer,Number(r),f),v=this.registerMemory(p,f,1,s,S,g);t.shadowList.push(v),n.address=p}return Ae(n.address,i.byteOffset-n.start)}else{const r=e.constructor[se]??i[se],o=i.byteLength,c=this.allocateShadowMemory(o,r),a=this.getViewAddress(c),l=this.registerMemory(a,o,1,s,i,c);return t.shadowList.push(l),a}},updateShadows(t){for(let{targetDV:e,shadowDV:n}of t.shadowList)n=this.restoreView(n),ie(n,e)},updateShadowTargets(t){for(let{targetDV:e,shadowDV:n,writable:s}of t.shadowList)s&&(n=this.restoreView(n),ie(e,n))},registerMemory(t,e,n,s,i,r){const o=ut(this.memoryList,t);let c=this.memoryList[o-1];return c?.address===t&&c.len===e?c.writable||=s:(c={address:t,len:e,align:n,writable:s,targetDV:i,shadowDV:r},this.memoryList.splice(o,0,c)),c},unregisterMemory(t,e){const n=ut(this.memoryList,t),s=this.memoryList[n-1];if(s?.address===t&&s.len===e)return this.memoryList.splice(n-1,1),s},findMemory(t,e,n,s){$t(n)&&(n=0);let i=n*(s??0);const r=ut(this.memoryList,e),o=this.memoryList[r-1];let c;if(o?.address===e&&o.len===i)c=o.targetDV;else if(o?.address<=e&&Ae(e,i)<=Ae(o.address,o.len)){const a=Number(e-o.address),l=s===void 0,{targetDV:f}=o;l&&(i=f.byteLength-a),c=this.obtainView(f.buffer,f.byteOffset+a,i),l&&(c[se]=o.align)}if(!c)c=this.obtainZigView(e,i);else{let{targetDV:a,shadowDV:l}=o;l&&t&&!t.shadowList.includes(o)&&(l=this.restoreView(l),ie(a,l))}return c},findShadowView(t){for(const{shadowDV:e,targetDV:n}of this.memoryList)if(n===t)return e},releaseZigView(t){const e=t[C],n=e?.address;n&&n!==Re&&(e.address=Re)},getViewAddress(t){const e=t[C];if(e)return e.address;{const n=this.getBufferAddress(t.buffer);return Ae(n,t.byteOffset)}},imports:{allocateScratchMemory:{argType:"ii",returnType:"i"},freeScratchMemory:{argType:"iii"}},exports:{getViewAddress:{argType:"v",returnType:"i"}},usizeMaxBuffer:new ArrayBuffer(0),allocateShadowMemory(t,e){const n=t?this.allocateScratchMemory(t,e):0;if(!n&&t)throw new Error("Out of memory");const s=this.obtainZigView(n,t),i=s?.[C];return i&&(i.align=e),s},freeShadowMemory(t){const{address:e,unalignedAddress:n,len:s,align:i}=t[C];s&&this.freeScratchMemory(n??e,s,i),this.releaseZigView(t)},obtainZigView(t,e,n=!0){if($t(t)&&(t=e>0?0:Qe),!t&&e)return null;let{buffer:s}=this.memory;return t===Qe&&(s=this.usizeMaxBuffer,t=Rn,e=0),this.obtainView(s,t,e,n)},getTargetAddress(t,e,n,s){const i=e[w];return i[C]?this.getViewAddress(i):i.byteLength===0?0:this.getShadowAddress(t,e,n,s)},getBufferAddress(t){return 0}});function ut(t,e){return tn(t,e,n=>n.address)}const Ss={Scratch:1},ze=WebAssembly;A({init(){this.abandoned=!1,this.destructors=[],this.nextValueIndex=1,this.valueMap=new Map,this.valueIndices=new Map,this.options=null,this.executable=null,this.instance=null,this.memory=null,this.table=null,this.initialTableLength=0,this.exportedFunctions=null,this.customWASI=null},abandonModule(){if(!this.abandoned){for(const t of this.destructors.reverse())t();this.abandoned=!0}},imports:{initialize:{argType:""}},exports:{displayPanic:{argType:"ii"}},getObjectIndex(t){if(t!=null){let e=this.valueIndices.get(t);return e===void 0&&(e=this.nextValueIndex++,this.valueIndices.set(t,e),this.valueMap.set(e,t)),e}else return 0},fromWebAssembly(t,e){switch(t){case"v":case"s":return this.valueMap.get(e);case"i":return e;case"b":return!!e}},toWebAssembly(t,e){switch(t){case"v":case"s":return this.getObjectIndex(e);case"i":return e;case"b":return e?1:0}},exportFunction(t,e="",n="",s){return t?(...i)=>{i=i.map((c,a)=>this.fromWebAssembly(e.charAt(a),c));const r=t.apply(this,i);return this.toWebAssembly(n,r)}:()=>{}},importFunction(t,e="",n=""){return(...s)=>{s=s.map((r,o)=>this.toWebAssembly(e.charAt(o),r));const i=t.apply(this,s);return this.fromWebAssembly(n,i)}},exportFunctions(){const t={};for(const[e,{argType:n,returnType:s,alias:i}]of Object.entries(this.exports)){const r=this[i??e];r&&(t[`_${e}`]=this.exportFunction(r,n,s,e))}return t},importFunctions(t){this.memory||(this.memory=t.memory);for(const[e,{argType:n,returnType:s}]of Object.entries(this.imports)){const i=t[e];i&&(U(this,e,b(this.importFunction(i,n,s))),this.destructors.push(()=>this[e]=As))}},async instantiateWebAssembly(t,e){const{memoryInitial:n,memoryMax:s,tableInitial:i,multithreaded:r}=this.options=e,o=await t,c=o[Symbol.toStringTag]==="Response"?"Streaming":"",a=ze["compile"+c],l=this.executable=await a(o),f=this.exportFunctions(),u={},h={},y={},p=this.exportedModules={env:u,wasi:h,wasi_snapshot_preview1:y};for(const{module:d,name:g,kind:S}of ze.Module.imports(l))S==="function"&&(d==="env"?u[g]=f[g]??et:d==="wasi_snapshot_preview1"?(y[g]=this.getWASIHandler(g),g==="fd_write"&&(y[`${g}_stderr`]=this.getWASIHandler(`${g}_stderr`))):d==="wasi"&&(h[g]=this.getThreadHandler?.(g)??et));return n&&(this.memory=u.memory=new ze.Memory({initial:n,maximum:s,shared:r})),i&&(this.table=u.__indirect_function_table=new ze.Table({initial:i,element:"anyfunc",shared:r})),this.initialTableLength=i,ze.instantiate(l,p)},loadModule(t,e){return this.initPromise=(async()=>{const n=this.instance=await this.instantiateWebAssembly(t,e);this.importFunctions(n.exports),this.initializeCustomWASI(),this.initialize()})()},getWASIHandler(t){const e=t.replace(/_./g,i=>i.charAt(1).toUpperCase()),n=this[e]?.bind?.(this),s=this[e+"Event"];return(...i)=>{const r=n?.(...i)??B.ENOTSUP,o=c=>{if(c===B.ENOTSUP||c===B.ENOTCAPABLE){if(c===B.ENOTSUP){const a=this.customWASI?.wasiImport?.[t];if(a)return a(...i)}return s&&console.error(`WASI method '${t}' requires the handling of the '${s}' event`),B.ENOTSUP}return c};return xt(r)?r.then(o):o(r)}},setCustomWASI(t){this.customWASI=t,this.instance&&this.initializeCustomWASI()},initializeCustomWASI(){const t=this.customWASI;if(t){const e={...this.instance.exports,memory:this.memory},n=new Proxy(this.instance,{get(s,i){return i==="exports"?e:s[i]}});t.initialize?.(n)}},displayPanic(t,e){const n=new Uint8Array(this.memory.buffer,t,e),s=vt(n);console.error(`Zig panic: ${s}`)}});const As=()=>{throw new Error("Module was abandoned")};A({linkVariables(t){if(!this.memory){this.initPromise=this.initPromise.then(()=>this.linkVariables(t));return}for(const{object:e,handle:n}of this.variables){const s=e[w],i=n;let r=e[w]=this.obtainZigView(i,s.byteLength);t&&ie(r,s),e.constructor[Xe]?.save?.(r,e),this.destructors.push(()=>{r=this.restoreView(e[w]);const c=e[w]=this.allocateMemory(r.byteLength);ie(c,r)});const o=c=>{const a=c[x];if(a){const l=r.byteOffset;for(const f of Object.values(a))if(f){const u=f[w];if(u.buffer===s.buffer){const h=l+u.byteOffset-s.byteOffset;f[w]=this.obtainView(r.buffer,h,u.byteLength),f.constructor[Xe]?.save?.(r,f),o(f)}}}};o(e),e[_]?.(function(){this[we]()},P.IgnoreInactive)}this.createDeferredThunks?.()},imports:{recreateAddress:{argType:"i",returnType:"i"}}});A({updatePointerAddresses(t,e){const n=new Map,s=new Map,i=[],r=function(l){if(n.get(this)===void 0){const f=this[x][0];if(f){const u=!this.constructor.const,h={target:f,writable:u},y=f[w];if(y[C])n.set(this,null);else{n.set(this,f);const p=s.get(y.buffer);if(p){const d=Array.isArray(p)?p:[p],g=tn(d,y.byteOffset,S=>S.target[w].byteOffset);d.splice(g,0,h),Array.isArray(p)||(s.set(y.buffer,d),i.push(d))}else s.set(y.buffer,h);f[_]?.(r,0)}}}},o=P.IgnoreRetval|P.IgnoreInactive;e[_](r,o);const c=this.findTargetClusters(i),a=new Map;for(const l of c)for(const f of l.targets)a.set(f,l);for(const[l,f]of n)if(f){const u=a.get(f),h=u?.writable??!l.constructor.const;l[Yt]=this.getTargetAddress(t,f,u,h),Ee in l&&(l[Ee]=f.length)}},updatePointerTargets(t,e,n=!1){const s=new Map,i=function(o){if(!s.get(this)){s.set(this,!0);const c=this[x][0],a=!c||!(o&P.IsImmutable)?this[we](t,!0,!(o&P.IsInactive)):c,l=this.constructor.const?P.IsImmutable:0;l&P.IsImmutable||c&&!c[w][C]&&c[_]?.(i,l),a!==c&&a&&!a[w][C]&&a?.[_]?.(i,l)}},r=n?P.IgnoreRetval:0;e[_](i,r)},findTargetClusters(t){const e=[];for(const n of t){let s=null,i=0,r=0,o=null;for(const{target:c,writable:a}of n){const l=c[w],{byteOffset:f,byteLength:u}=l,h=f+u;let y=!0;s&&(r>f?(o?o.writable||=a:(o={targets:[s],start:i,end:r,address:void 0,misaligned:void 0,writable:a},e.push(o)),o.targets.push(c),h>r?o.end=h:y=!1):o=null),y&&(s=c,i=f,r=h)}}return e}});const Is=[k.fd_read,0],ht=[k.fd_write,0],Dt=k.fd_seek|k.fd_fdstat_set_flags|k.fd_tell|k.path_create_directory|k.path_create_file|k.path_open|k.fd_readdir|k.path_filestat_get|k.path_filestat_set_size|k.path_filestat_set_times|k.fd_filestat_get|k.fd_filestat_set_times|k.path_remove_directory|k.path_unlink_file,Ht=k.fd_datasync|k.fd_read|k.fd_seek|k.fd_sync|k.fd_tell|k.fd_write|k.fd_advise|k.fd_allocate|k.fd_filestat_get|k.fd_filestat_set_times|k.fd_filestat_set_size;A({init(){const t={cookie:0n,readdir(){const e=Number(this.cookie);let n=null;switch(e){case 0:case 1:n={name:".".repeat(e+1),type:"directory"}}return n},seek(e){return this.cookie=e},tell(){return this.cookie},valueOf(){return null}};this.streamMap=new Map([[Z.root,[t,this.getDefaultRights("dir"),0]],[Z.stdout,[this.createLogWriter("stdout"),ht,0]],[Z.stderr,[this.createLogWriter("stderr"),ht,0]]]),this.flushRequestMap=new Map,this.nextStreamHandle=Z.min},getStream(t){t===3&&(t=Z.root);const e=this.streamMap.get(t);if(!e)throw 2<t&&t<Z.min?new bt:new us;return e},createStreamHandle(t,e,n=0){if(!this.ioRedirection)throw new bt;let s=this.nextStreamHandle++;if(s>Z.max){for(s=Z.min;this.streamMap.get(s);)if(s++,s>Z.max)throw new hs;this.nextStreamHandle=s+1}return this.streamMap.set(s,[t,e,n]),t.onClose=()=>this.destroyStreamHandle(s),s},destroyStreamHandle(t){const e=this.streamMap.get(t);if(e){const[n]=e;n?.destroy?.(),this.streamMap.delete(t)}},redirectStream(t,e){const n=this.streamMap,s=Z[t],i=n.get(s);if(e!==void 0){let r,o;if(s===Z.stdin)r=this.convertReader(e),o=Is;else if(s===Z.stdout||s===Z.stderr)r=this.convertWriter(e),o=ht;else if(s===Z.root)r=this.convertDirectory(e),o=this.getDefaultRights("dir");else throw new Error(`Expecting 'stdin', 'stdout', 'stderr', or 'root', received ${t}`);if(!r)throw new is(o[0],e);n.set(s,[r,o,0])}else n.delete(s);return i?.[0]},createLogWriter(t){const e=this;return{pending:[],write(n){const s=n.lastIndexOf(10);if(s===-1)this.pending.push(n);else{const i=n.subarray(0,s),r=n.subarray(s+1);this.dispatch([...this.pending,i]),this.pending.splice(0),r.length>0&&this.pending.push(r)}e.scheduleFlush(this,this.pending.length>0,250)},dispatch(n){const s=vt(n);e.triggerEvent("log",{source:t,message:s})==null&&console.log(s)},flush(){this.pending.length>0&&(this.dispatch(this.pending),this.pending.splice(0))}}},scheduleFlush(t,e,n){const s=this.flushRequestMap,i=s.get(t);i&&(clearTimeout(i),s.delete(t)),e&&s.set(t,setTimeout(()=>{t.flush(),s.delete(t)},n))},flushStreams(){const t=this.flushRequestMap;if(t.size>0){for(const[e,n]of t)e.flush(),clearTimeout(n);t.clear()}},getDefaultRights(t){return t==="dir"?[Dt,Dt|Ht]:[Ht,0]}});A({exports:{allocateJsThunk:{argType:"ii",returnType:"i"},freeJsThunk:{argType:"ii",returnType:"i"},findJsThunk:{argType:"ii",returnType:"i"}},imports:{identifyJsThunk:{argType:"ii",returnType:"i"}},init(){this.thunkSources=[],this.thunkMap=new Map},addJsThunkSource(){const{memoryInitial:t,memoryMax:e,tableInitial:n,multithreaded:s}=this.options,i=WebAssembly,r={},o={},c={},a={env:r,wasi:o,wasi_snapshot_preview1:c};for(const{module:d,name:g,kind:S}of i.Module.imports(this.executable))S==="function"&&(d==="env"?r[g]=et:d==="wasi_snapshot_preview1"&&(c[g]=et));r.memory=new i.Memory({initial:t,maximum:e,shared:s});const l=r.__indirect_function_table=new i.Table({initial:n,element:"anyfunc"}),{exports:f}=new i.Instance(this.executable,a),{createJsThunk:u,destroyJsThunk:h,identifyJsThunk:y}=f,p={thunkCount:0,createJsThunk:u,destroyJsThunk:h,identifyJsThunk:y,table:l};return this.thunkSources.unshift(p),p},allocateJsThunk(t,e){let n,s=0;for(n of this.thunkSources){s=n.createJsThunk(t,e);break}s||(n=this.addJsThunkSource(),s=n.createJsThunk(t,e));const i=n.table.get(s);let r=0;for(let o=this.table.length-1;o>=this.initialTableLength;o--)if(!this.table.get(o)){r=o;break}return r||(r=this.table.length,this.table.grow(8)),this.table.set(r,i),n.thunkCount++,this.thunkMap.set(i,{source:n,sourceAddress:s}),r},freeJsThunk(t,e){let n=0;const s=this.table.get(e);this.table.set(e,null);const i=this.thunkMap.get(s);if(i){const{source:r,sourceAddress:o}=i;if(n=r.destroyJsThunk(t,o),--r.thunkCount===0){const c=this.thunkSources.indexOf(r);c!==-1&&this.thunkSources.splice(c,1)}this.thunkMap.delete(s)}return n},findJsThunk(t,e){let n=0;const s=this.table.get(e);this.table.set(e,null);const i=this.thunkMap.get(s);if(i){const{source:r,sourceAddress:o}=i;n=r.identifyJsThunk(t,o)}return n}});A({init(){this.viewMap=new WeakMap},extractView(t,e,n=Ts){const{type:s,byteSize:i,constructor:r}=t;let o;const c=e?.[Symbol.toStringTag];if(c&&(c==="DataView"?o=this.registerView(e):c==="ArrayBuffer"?o=this.obtainView(e,0,e.byteLength):(c&&c===r[ge]?.name||c==="Uint8ClampedArray"&&r[ge]===Uint8Array)&&(o=this.obtainView(e.buffer,e.byteOffset,e.byteLength))),!o){const a=e?.[w];if(a){const{constructor:l,instance:{members:[f]}}=t;if(he(e,l))return a;if(Es(s)){const{byteSize:u,structure:{constructor:h}}=f,y=rn(e,h);if(y!==void 0){if(s===E.Slice||y*u===i)return a;throw new ot(t,null,e)}}}}return o?i!==void 0&&Ut(o,t):n?.(t,e),o},assignView(t,e,n,s,i){const{byteSize:r,type:o}=n,c=r??1,a={[w]:e,[W](){return this[w]}};if(t[w]){const l=o===E.Slice?c*t.length:c;if(e.byteLength!==l)throw new ln(n,e,t);t.constructor[be]?.validateData?.(a,t.length),re(t,a)}else{r!==void 0&&Ut(e,n);const l=e.byteLength/c;t.constructor[be]?.validateData?.(a,l),i&&(s=!0),t[Le](s?null:e,l,i),s&&re(t,a)}},findViewAt(t,e,n){let s=this.viewMap.get(t),i;if(s)if(s instanceof DataView)if(s.byteOffset===e&&s.byteLength===n)i=s,s=null;else{const r=s,o=`${r.byteOffset}:${r.byteLength}`;s=new Map([[o,r]]),this.viewMap.set(t,s)}else i=s.get(`${e}:${n}`);return i?.[C]?.address===Re&&(i=null),{existing:i,entry:s}},obtainView(t,e,n,s=!0){let i;if(s){const{existing:r,entry:o}=this.findViewAt(t,e,n);if(r)return r;i=new DataView(t,e,n),o?o.set(`${e}:${n}`,i):this.viewMap.set(t,i)}else i=new DataView(t,e,n),i[Fe]=!0;return(t===this.memory?.buffer||t===this.usizeMaxBuffer)&&(i[C]={address:e,len:n}),i},registerView(t){if(!t[C]){const{buffer:e,byteOffset:n,byteLength:s}=t,{existing:i,entry:r}=this.findViewAt(e,n,s);if(i)return i;r?r.set(`${n}:${s}`,t):this.viewMap.set(e,t)}return t},allocateMemory(t,e=0,n=null){return n?.alloc?.(t,e)??this.allocateJSMemory(t,e)},allocateJSMemory(t,e){return this.obtainView(new ArrayBuffer(t),0,t)},restoreView(t){const e=t?.[C];return e&&Dn(t.buffer)&&(t=this.obtainZigView(e.address,e.len),e.align&&(t[C].align=e.align)),t},defineRestorer(){const t=this;return{value(){const e=this[w],n=t.restoreView(e);return e!==n&&(this[w]=n,this.constructor[Xe]?.save?.(n,this)),n}}},moveExternBytes(t,e,n){const{memory:s}=this,i=t.byteLength;if(i===0)return;const r=new DataView(s.buffer,e,i);t instanceof DataView||(t=new DataView(t.buffer,t.byteOffset,t.byteLength)),ie(n?r:t,n?t:r)}});function Ut(t,e){const{byteSize:n,type:s}=e;if(!(s===E.Slice?t.byteLength%n===0:t.byteLength===n))throw new ln(e,t)}function Es(t){return t===E.Array||t===E.Vector||t===E.Slice}function Ts(t){throw new Jn(t)}A({init(){this.nextThreadId=1,this.workers=[]},getThreadHandler(t){switch(t){case"thread-spawn":return typeof window=="object"&&!window.crossOriginIsolated&&console.warn(`%cHTML document is not cross-origin isolated %c

WebAssembly multithreading in the browser is only possibly when %cwindow.crossOriginIsolated%c = true. Visit https://developer.mozilla.org/en-US/docs/Web/API/Window/crossOriginIsolated for information on how to enable it.`,"color: red;font-size: 200%;font-weight:bold","","background-color: lightgrey;font-weight:bold",""),this.spawnThread.bind(this);case"thread-cancel":return this.cancelThread.bind(this);case"thread-address":return this.getThreadAddress.bind(this)}},spawnThread(t){const e=this.nextThreadId++;return this.nextThreadId===1073741824&&(this.nextThreadId=1),this.createWorker().run(e,t),e},cancelThread(t,e){const n=this.workers.find(s=>s.tid===t);n&&(e?(n.end(!0),this.createWorker().clean(e)):n.canceled=!0)},getThreadAddress(t){return this.workers.find(n=>n.tid===t).taddr},createWorker(){const t=r=>{switch(r.type){case"call":{const{module:o,name:c,args:a,futex:l}=r;if(e.canceled)e.canceled=!1,e.signal(l,2);else{const f=this.exportedModules[o]?.[c],u=f?.(...a,!0),h=y=>e.signal(l,1,y);xt(u)?u.then(h):h(u)}}break;case"done":e.end();break}};let e;if(typeof Worker=="function"){const r=xs();e=new Worker(r,{name:"zig"}),e.addEventListener("message",o=>t(o.data))}const{executable:n,memory:s,options:i}=this;return e.postMessage({type:"start",executable:n,memory:s,options:i}),e.signal=(r,o,c)=>{Atomics.load(r,0)===0&&(Atomics.store(r,0,o),Atomics.store(r,1,c|0),Atomics.notify(r,0,1))},e.run=(r,o)=>{e.tid=r,e.taddr=o,e.canceled=!1,e.postMessage({type:"run",tid:r,taddr:o})},e.clean=r=>{e.postMessage({type:"clean",raddr:r})},e.end=(r=!1)=>{r?e.terminate():e.postMessage({type:"end"}),Nn(this.workers,e)},this.workers.push(e),e}});function vs(){const t=Ms.toString(),e=t.indexOf("{")+1,n=t.lastIndexOf("}");return t.slice(e,n)}let dt;function xs(){if(!dt){const t=vs();dt=URL.createObjectURL(new Blob([t],{type:"text/javascript"}))}return dt}function Ms(){const t=WebAssembly;let e,n;typeof self=="object"?(self.onmessage=i=>s(i.data),e=self):En(()=>import("./__vite-browser-external-BIHI7g3E.js"),[]).then(i=>{e=i.parentPort,e.on("message",s)});function s(i){switch(i.type){case"start":{const{executable:r,memory:o,options:c}=i,a={env:{memory:o},wasi:{},wasi_snapshot_preview1:{}},l=()=>{throw new Error("Exit")},f=(h,y)=>Atomics.wait(h,0,0,y)!=="timed-out"?(Atomics.load(h,0)===2&&(n.exports.wasi_thread_clean(0),l()),Atomics.load(h,1)):0,u=()=>new Int32Array(new SharedArrayBuffer(8));for(const{module:h,name:y,kind:p}of t.Module.imports(r)){const d=a[h];if(p==="function"&&d&&(d[y]=y==="proc_exit"?l:function(...g){const S=u();return e.postMessage({type:"call",module:h,name:y,args:g,futex:S}),f(S)},y==="fd_write")){const g=d[y];d[y]=function(S,v,M,T){if(S===2){const R=new DataView(o.buffer);let D=0;const N=[];for(let Se=0,Y=0;Se<M;Se++,Y+=8){const m=R.getUint32(v+Y,!0),$=R.getUint32(v+Y+4,!0);N.push({ptr:m,len:$}),D+=$}const ae=new Uint8Array(D);let Q=0;for(const{ptr:Se,len:Y}of N){const m=new Uint8Array(R.buffer,Se,Y);ae.set(m,Q),Q+=Y}const ee=u();return e.postMessage({type:"call",module:h,name:`${y}_stderr`,args:[ae],futex:ee},[ae.buffer]),R.setUint32(T,D,!0),f(ee,5e4)}else return g(S,v,M,T)}}}c.tableInitial&&(a.env.__indirect_function_table=new t.Table({initial:c.tableInitial,element:"anyfunc"})),n=new t.Instance(r,a)}break;case"run":{try{n.exports.wasi_thread_start(i.tid,i.taddr)}catch{}e.postMessage({type:"done"})}break;case"clean":{try{n.exports.wasi_thread_clean(i.raddr)}catch{}e.postMessage({type:"done"})}break;case"end":e.close();break}}}const Os=St.proxyMaps??=[0,O.Const,O.ReadOnly,O.Const|O.ReadOnly].reduce((t,e)=>(t[e]=new WeakMap,t),{}),pn=St.proxyTargetMap??=new WeakMap;function me(t,e){const n=t,s=Os[e&(O.Const|O.ReadOnly)];let i=s.get(n);return i||(i=new Proxy(t,Ps[e]),s.set(n,i),pn.set(i,{target:t,type:e})),i}function Bt(t,e=!1){const{type:n,flags:s}=t;let i=e&&n!==E.Function?O.ReadOnly:0;return s&V.HasProxy&&(n===E.Pointer?(i|=O.Pointer,s&L.IsConst&&(i|=O.Const)):i|=O.Slice),i}function ct(t){if((typeof t=="object"||typeof t=="function")&&t)return pn.get(t)}function Oe(t){const e=ct(t);return e?[e.target,e.type]:[t,0]}function mn(t){const e=ct(t);let n;if(e){if(e.type&O.ReadOnly)return t;n=e.type|O.ReadOnly,t=e.target}else{if(!t?.[w]||typeof t!="object"||t[Ke])return t;n=t.constructor[st]??O.ReadOnly}return me(t,n)}const Ot={get(t,e){return e in t?t[e]:t[K][e]},set(t,e,n){if(e in t)t[e]=n;else{const s=t[K];s[e]=n}return!0},deleteProperty(t,e){if(e in t)delete t[e];else{const n=t[K];delete n[e]}return!0},has(t,e){if(e in t)return!0;{const n=t[K];return e in n}},apply(t,e,n){return t["*"].apply(e,n)}},bn={...Ot,set(t,e,n){if(e in t)ce();else{const s=t[K];s[e]=n}return!0}},nt={get(t,e){const n=t[e];return typeof e=="string"?mn(n):n},set(t,e,n){ce()}},Vs={...Ot,get(t,e){return e in t?nt.get(t,e):nt.get(t[K],e)},set(t,e,n){return e in t?t[e]=n:ce(),!0}},ks={...bn,set:nt.set},gn={get(t,e){const n=typeof e=="symbol"?0:e|0;return n!==0||n==e?t.get(n):t[e]},set(t,e,n){const s=typeof e=="symbol"?0:e|0;return s!==0||s==e?t.set(s,n):t[e]=n,!0},deleteProperty(t,e){const n=typeof e=="symbol"?0:e|0;return n!==0||n==e?!1:(delete t[e],!0)},has(t,e){const n=typeof e=="symbol"?0:e|0;return n!==0||n==e?n>=0&&n<t.length:t[e]},ownKeys(t){const e=[];for(let n=0,s=t.length;n<s;n++)e.push(`${n}`);return e.push("length"),e},getOwnPropertyDescriptor(t,e){const n=typeof e=="symbol"?0:e|0;if(n!==0||n==e){if(n>=0&&n<t.length)return{value:t.get(n),enumerable:!0,writable:!0,configurable:!0}}else return Object.getOwnPropertyDescriptor(t,e)}},Cs={...gn,get(t,e){const n=typeof e=="symbol"?0:e|0;return n!==0||n==e?mn(t.get(n)):e==="set"?ce:t[e]},set:ce},Ps={[O.Pointer]:Ot,[O.Pointer|O.Const]:Vs,[O.Pointer|O.ReadOnly]:bn,[O.Pointer|O.ReadOnly|O.Const]:ks,[O.Slice]:gn,[O.Slice|O.ReadOnly]:Cs,[O.ReadOnly]:nt};A({makeReadOnly(t){Vt(t)}});function Vt(t){const[e]=Oe(t);if(e?.[w]&&!e[Ke]){e[Ke]=!0;const n=e.constructor[xe];n===E.Pointer?yt(e,["length"]):n===E.Array||n===E.Slice?(yt(e),_s(e)):yt(e)}return t}function yt(t,e=[]){const n=Object.getOwnPropertyDescriptors(t.constructor.prototype);for(const[s,i]of Object.entries(n))if(!e.includes(s)){const{get:r,set:o}=i;i.get=r?function(){return Vt(r.call(this))}:void 0,i.set=o?ce:void 0,U(t,s,i)}}function _s(t){const{get:e}=t;de(t,{get:b(function(n){return Vt(e.call(this,n))}),set:b(ce)})}A({defineArrayEntries(){return b(Ls)},defineArrayIterator(){return b(zs)}});function wn(t){const e=ct(t);if(e){const{target:n}=e;return e.type&O.Pointer?n["*"]:n}return t}function zs(){const t=wn(this),e=t.length;let n=0;return{next(){let s,i;if(n<e){const r=n++;s=t.get(r),i=!1}else i=!0;return{value:s,done:i}}}}function $s(t){const e=Tt(t),n=wn(this),s=n.length;let i=0;return{next(){let r,o;if(i<s){const c=i++;r=[c,e(()=>n.get(c))],o=!1}else o=!0;return{value:r,done:o}}}}function Ls(t){return{[Symbol.iterator]:$s.bind(this,t),length:this.length}}A({defineStructEntries(){return b(Sn)},defineStructIterator(){return b(Ns)}});function Sn(t){return{[Symbol.iterator]:Fs.bind(this,t),length:this[Ve].length}}function Ns(t){return Sn.call(this,t)[Symbol.iterator]()}function Fs(t){const e=Tt(t),n=this,s=this[Ve];let i=0;return{next(){let r,o;if(i<s.length){const c=s[i++];r=[c,e(()=>n[c])],o=!1}else o=!0;return{value:r,done:o}}}}A({defineVectorEntries(){return b(Ds)},defineVectorIterator(){return b(js)}});function js(){const t=this,e=this.length;let n=0;return{next(){let s,i;if(n<e){const r=n++;s=t[r],i=!1}else i=!0;return{value:s,done:i}}}}function Rs(){const t=this,e=this.length;let n=0;return{next(){let s,i;if(n<e){const r=n++;s=[r,t[r]],i=!1}else i=!0;return{value:s,done:i}}}}function Ds(){return{[Symbol.iterator]:Rs.bind(this),length:this.length}}A({defineMember(t,e=!0){if(!t)return{};const{type:n,structure:s}=t,i=`defineMember${Gt[n]}`,o=this[i].call(this,t);if(e&&s){const{type:c}=s,a=`transformDescriptor${Ye[c]}`,l=this[a];if(l)return l.call(this,o,t)}return o}});function An(t,{get:e,set:n}){return t!==void 0?{get:function(){return e.call(this,t)},set:n?function(s,i){return n.call(this,t,s,i)}:void 0}:{get:e,set:n}}A({defineBase64(t){const e=this;return Ue({get(){return _n(this.dataView)},set(n,s){if(typeof n!="string")throw new oe("string",n);const i=zn(n);e.assignView(this,i,t,!1,s)}})}});A({defineMemberBool(t){return this.defineMemberUsing(t,this.getAccessor)}});A({defineClampedArray(t){const e=this,n=Uint8ClampedArray;return Ue({get(){const s=this.typedArray;return new n(s.buffer,s.byteOffset,s.length)},set(s,i){if(s?.[Symbol.toStringTag]!==n.name)throw new oe(n.name,s);const r=new DataView(s.buffer,s.byteOffset,s.byteLength);e.assignView(this,r,t,!0,i)}})}});A({defineDataView(t){const e=this;return Ue({get(){return this[W]()},set(n,s){if(n?.[Symbol.toStringTag]!=="DataView")throw new oe("DataView",n);e.assignView(this,n,t,!0,s)}})}});A({defineMemberFloat(t){return this.defineMemberUsing(t,this.getAccessor)}});A({defineMemberInt(t){let e=this.getAccessor;return this.runtimeSafety&&(e=this.addRuntimeCheck(e)),e=this.addIntConversion(e),this.defineMemberUsing(t,e)}});A({defineMemberObject(t){const{flags:e,structure:n,slot:s}=t;let i,r;return e&H.IsString?i=Hs:e&H.IsTypedArray?i=Us:e&H.IsClampedArray?i=Bs:e&H.IsPlain?i=Ws:n.flags&(V.HasValue|V.HasProxy)?i=Be:i=kt,e&H.IsReadOnly?r=ce:r=Zs,An(s,{get:i,set:r})}});function Be(t){return kt.call(this,t).$}function Hs(t){return Be.call(this,t)?.string??null}function Us(t){return Be.call(this,t)?.typedArray??null}function Bs(t){return Be.call(this,t)?.clampedArray??null}function Ws(t){return Be.call(this,t)?.valueOf?.()??null}function kt(t){return this[x][t]??this[ue](t)}function Zs(t,e,n){kt.call(this,t)[q](e,n)}A({defineMemberUsing(t,e){const{littleEndian:n}=this,{bitOffset:s,byteSize:i}=t,r=e.call(this,"get",t),o=e.call(this,"set",t);if(s!==void 0){const c=s>>3;return{get:function(){const l=this[W]();return r.call(l,c,n)},set:function(l){const f=this[W]();return o.call(f,c,l,n)}}}else return{get:function(a){const l=this[W]();return r.call(l,a*i,n)},set:function(a,l){const f=this[W]();return o.call(f,a*i,l,n)}}}});A({defineRetvalCopier({byteSize:t,bitOffset:e}){if(t>0){const n=this,s=e>>3;return{value(i){const r=this[w],{address:o}=i[C],c=new DataView(n.memory.buffer,o+s,t),a=new DataView(r.buffer,r.byteOffset+s,t);ie(a,c)}}}}});A({defineSentinel(t){const{byteSize:e,instance:{members:[n,s],template:i}}=t,{get:r}=this.defineMember(s),{get:o}=this.defineMember(n),c=r.call({[w]:i[w],[W](){return this[w]}},0),a=!!(s.flags&H.IsRequired),{runtimeSafety:l}=this;return b({value:c,bytes:i[w],validateValue(f,u,h){if(a){if(l&&f===c&&u!==h-1)throw new Nt(t,f,u,h);if(f!==c&&u===h-1)throw new ft(t,c,h)}},validateData(f,u){if(a){if(l)for(let h=0;h<u;h++){const y=o.call(f,h);if(y===c&&h!==u-1)throw new Nt(t,c,h,u);if(y!==c&&h===u-1)throw new ft(t,c,u)}else if(u>0&&u*e===f[w].byteLength&&o.call(f,u-1)!==c)throw new ft(t,c,u)}},isRequired:a})},findSentinel(t,e){const{memory:n}=this,s=e.byteLength,i=n.buffer.byteLength-s+1;for(let r=t;r<i;r+=s){const o=new DataView(n.buffer,r,s);let c=!0;for(let a=0;a<s;a++){const l=o.getUint8(a),f=e.getUint8(a);if(l!==f){c=!1;break}}if(c)return(r-t)/s}}});A({defineString(t){const e=this,{byteSize:n}=t.instance.members[0],s=`utf-${n*8}`;return Ue({get(){let i=vt(this.typedArray,s);const r=this.constructor[be]?.value;return r!==void 0&&i.charCodeAt(i.length-1)===r&&(i=i.slice(0,-1)),i},set(i,r){if(typeof i!="string")throw new oe("string",i);const o=this.constructor[be]?.value;o!==void 0&&i.charCodeAt(i.length-1)!==o&&(i+=String.fromCharCode(o));const c=en(i,s),a=new DataView(c.buffer);e.assignView(this,a,t,!1,r)}})}});A({defineValueOf(){return{value(){return In(this,!1)}}}});const Js=BigInt(Number.MAX_SAFE_INTEGER),Gs=BigInt(Number.MIN_SAFE_INTEGER);function In(t,e){const n={error:e?"return":"throw"},s=Tt(n),i=new Map,r=function(o){const c=typeof o=="function"?E.Struct:o?.constructor?.[xe];if(c===void 0){if(e){if(typeof o=="bigint"&&Gs<=o&&o<=Js)return Number(o);if(o instanceof Error)return{error:o.message}}return o}let a=i.get(o);if(a===void 0){let l;switch(c){case E.Struct:l=o[ye](n),a=o.constructor[qt]&Je.IsTuple?[]:{};break;case E.Union:l=o[ye](n),a={};break;case E.Array:case E.Vector:case E.Slice:l=o[ye](),a=[];break;case E.Pointer:try{a=o["*"]}catch{a=Symbol.for("inaccessible")}break;case E.Enum:a=s(()=>String(o));break;case E.Opaque:a={};break;default:a=s(()=>o.$)}if(a=r(a),i.set(o,a),l)for(const[f,u]of l)a[f]=r(u)}return a};return r(t)}A({defineToJSON(){return{value(){return In(this,!0)}}}});A({defineMemberType(t,e){const{slot:n}=t;return An(n,{get(s){return this[x][s]?.constructor},set:ce})}});A({defineTypedArray(t){const e=this,n=this.getTypedArray(t);return Ue({get(){const s=this.dataView,i=s.byteLength/n.BYTES_PER_ELEMENT;return new n(s.buffer,s.byteOffset,i)},set(s,i){if(s?.[Symbol.toStringTag]!==n.name)throw new oe(n.name,s);const r=new DataView(s.buffer,s.byteOffset,s.byteLength);e.assignView(this,r,t,!0,i)}})}});A({defineMemberUint(t){let e=this.getAccessor;return this.runtimeSafety&&(e=this.addRuntimeCheck(e)),e=this.addIntConversion(e),this.defineMemberUsing(t,e)}});A({defineMemberVoid(t,e){const{bitOffset:n}=t;return{get(){},set:n!==void 0?function(s){if(s!==void 0)throw new jt(t)}:function(s,i){if(i!==void 0)throw new jt(t);if(s<0||s>=this.length)throw new os(t,s)}}}});A({createSignal(t,e){const{constructor:{child:n}}=t.instance.members[0].structure,s=new Int32Array([e?.aborted?1:0]),i=n(s);return e&&e.addEventListener("abort",()=>{{const r=this.findShadowView(i[w]);if(r){const o=new Int32Array(r.buffer,r.byteOffset,1);Atomics.store(o,0,1)}}},{once:!0}),{ptr:i}},createInboundSignal(t){const e=new AbortController;if(t.ptr["*"])e.abort();else{const n=setInterval(()=>{t.ptr["*"]&&(e.abort(),clearInterval(n))},50)}return e.signal}});A({defineStructure(t){const{type:e,byteSize:n}=t,s=`define${Ye[e]}`,i=this[s],r=[],o={},c={dataView:this.defineDataView(t),base64:this.defineBase64(t),toJSON:this.defineToJSON(),valueOf:this.defineValueOf(),[Ne]:b(o),[pt]:b(r),[W]:this.defineRestorer()},a=t.constructor=i.call(this,t,c);for(const[l,f]of Object.entries(c)){const u=f?.set;u&&!o[l]&&l!=="$"&&(o[l]=u,r.push(l))}return de(a.prototype,c),a},finalizeStructure(t){const{name:e,type:n,constructor:s,align:i,byteSize:r,flags:o,signature:c,static:{members:a,template:l}}=t,f=[],u={name:b(e),toJSON:this.defineToJSON(),valueOf:this.defineValueOf(),[mt]:b(c),[X]:b(this),[se]:b(i),[It]:b(r),[xe]:b(n),[qt]:b(o),[Ve]:b(f),[ge]:b(this.getTypedArray(t)),[Symbol.iterator]:this.defineStructIterator(),[ye]:this.defineStructEntries(),[Ve]:b(f)},h={[Symbol.toStringTag]:b(e)};if(a)for(const d of a){const{name:g,slot:S,flags:v}=d;if(d.structure.type===E.Function){let M=l[x][S];v&H.IsString?M[Ie]=N=>N.string:v&H.IsClampedArray?M[Ie]=N=>N.clampedArray:v&H.IsTypedArray?M[Ie]=N=>N.typedArray:v&H.IsPlain&&(M[Ie]=N=>N.valueOf()),u[g]=b(M),M.name||U(M,"name",b(g));const[T,R]=/^(get|set)\s+([\s\S]+)/.exec(g)?.slice(1)??[],D=T==="get"?0:1;if(T&&M.length===D){u[R]||={};const N=u[R];N[T]=M}if(v&H.IsMethod){const N=function(...ae){try{let[Q,ee]=Oe(this);return v&H.IsExpectingInstance&&ee===O.Pointer&&(Q=Q["*"]),M(Q,...ae)}catch(Q){throw Q[we]?.(1),Q}};if(de(N,{name:b(g),length:b(M.length-1)}),h[g]=b(N),T&&N.length===D){const ae=h[R]||={};ae[T]=N}}}else u[g]=this.defineMember(d),f.push(g)}u[x]=f.length>0&&b(l[x]);const y=`finalize${Ye[n]}`;this[y]?.call(this,t,u,h)!==!1&&(de(s.prototype,h),de(s,u))},createConstructor(t,e={}){const{type:n,byteSize:s,align:i,flags:r,instance:{members:o,template:c}}=t,{onCastError:a}=e;let l;if(c?.[x]){const y=o.filter(p=>p.flags&H.IsReadOnly);y.length>0&&(l=y.map(p=>p.slot))}const f=new Un,u=this,h=function(y,p={}){const{allocator:d}=p,g=this instanceof h;let S,v,M=!1;if(g){if(arguments.length===0)throw new an(t);if(S=this,r&V.HasSlot&&(S[x]={}),Le in S)S[q](y,d),v=S[w];else{const T=n!==E.Pointer?d:null;S[w]=v=u.allocateMemory(s,i,T)}}else{if(je in h&&(S=h[je].call(this,y,p),S!==!1))return S;v=u.extractView(t,y,a),(S=f.find(v))?M=!0:(S=Object.create(h.prototype),Le in S?u.assignView(S,v,t,!1,!1):S[w]=v,r&V.HasSlot&&(S[x]={}))}if(!M){if(l)for(const T of l)S[x][T]=c[x][T];S[Cn]?.(),g&&(Le in S||S[q](y,d)),fe in S&&(S=S[fe]()),f.save(v,S)}return r&V.HasProxy&&(g||!this)?S[it]():S};return U(h,Xe,b(f)),c?.[w]&&U(c,W,this.defineRestorer()),h},createInitializer(t){return function(e,n){const[s,i]=Oe(e),[r]=Oe(this);return t.call(r,s,n,i)}},createApplier(t){const{instance:{template:e}}=t;return function(n,s){const[i]=Oe(n),[r]=Oe(this),o=Object.keys(i);if(i instanceof Error)throw i;const c=r[pt],a=r[Ne];for(const y of o)if(!(y in a))throw new Xn(t,y);let l=0,f=0,u=0,h=0;for(const y of c){const p=a[y];p.special?y in i&&h++:(l++,y in i?f++:p.required&&u++)}if(u!==0&&h===0){const y=c.filter(p=>a[p].required&&!(p in i));throw new Yn(t,y)}if(h+f>o.length)for(const y of c)y in i&&(o.includes(y)||o.push(y));f<l&&h===0&&e&&e[w]&&re(r,e);for(const y of o)a[y].call(r,i[y],s);return o.length}},getTypedArray(t){const{type:e,instance:n}=t;if(e!==void 0&&n)switch(e){case E.Enum:case E.ErrorSet:case E.Primitive:{const{byteSize:s,type:i}=n.members[0],r=i===F.Float?"Float":i===F.Int?"Int":"Uint",c=(s>4&&i!==F.Float?"Big":"")+r+s*8+"Array";return globalThis[c]}case E.Array:case E.Slice:case E.Vector:return this.getTypedArray(n.members[0].structure)}}});A({init(){this.defaultAllocator=null,this.allocatorVtable=null,this.allocatorContextMap=new Map,this.nextAllocatorContextId=nn(4096)},createDefaultAllocator(t,e){let n=this.defaultAllocator;return n||(n=this.defaultAllocator=this.createJsAllocator(t,e,!1)),n},createJsAllocator(t,e,n){const{constructor:s}=e;let i=this.allocatorVtable;if(!i){const{noResize:c,noRemap:a}=s;i=this.allocatorVtable={alloc:this.allocateHostMemory.bind(this),free:this.freeHostMemory.bind(this),resize:c},a&&(i.remap=a),this.destructors.push(()=>this.freeFunction(i.alloc)),this.destructors.push(()=>this.freeFunction(i.free))}let r=Qe;if(n){const c=[];r=this.nextAllocatorContextId++,this.allocatorContextMap.set(r,c),t[kn]=a=>{for(const{address:l,len:f}of c){const u=this.unregisterMemory(l,f);u&&this.freeShadowMemory(u.shadowDV),a&&this.allocatorContextMap.delete(r)}c.splice(0)}}const o=this.obtainZigView(r,0);return new s({ptr:o,vtable:i})},allocateHostMemory(t,e,n){const s=this.getViewAddress(t["*"][w]),i=s!=Qe?this.allocatorContextMap.get(s):null,r=1<<n,o=this.allocateJSMemory(e,r);try{const c=this.allocateShadowMemory(e,r),a=this.getViewAddress(c);return this.registerMemory(a,e,r,!0,o,c),i?.push({address:a,len:e}),c}catch{return null}},freeHostMemory(t,e,n){const s=e["*"][w],i=this.getViewAddress(s),r=s.byteLength,o=this.unregisterMemory(i,r);o&&this.freeShadowMemory(o.shadowDV)}});A({defineArgStruct(t,e){const{flags:n,byteSize:s,align:i,length:r,instance:{members:o}}=t,c=this,a=o.slice(1),l=function(u,h){const y=this instanceof l;let p,d;if(y?(p=this,d=c.allocateMemory(s,i)):(p=Object.create(l.prototype),d=u),p[w]=d,n&V.HasSlot&&(p[x]={}),y){let g;if(n&at.HasOptions&&u.length===r+1&&(g=u.pop()),u.length!==r)throw new Kn(r,u.length);n&at.IsAsync&&(p[fe]=null),c.copyArguments(p,u,a,g,h)}else return p};for(const u of o)e[u.name]=this.defineMember(u);const f=e.retval.set;return e.length=b(a.length),e[ue]=n&V.HasObject&&this.defineVivificatorStruct(t),e[_]=n&V.HasPointer&&this.defineVisitorArgStruct(o),e[pe]=b(function(u){f.call(this,u,this[Et])}),e[Symbol.iterator]=this.defineArgIterator?.(a),e[we]=this.defineRetvalCopier(o[0]),l},finalizeArgStruct(t,e){const{flags:n}=t;e[Xt]=b(!!(n&at.IsThrowing))}});A({defineArray(t,e){const{length:n,instance:{members:[s]},flags:i}=t,r=this.createApplier(t),o=this.defineMember(s),{set:c}=o,a=this.createConstructor(t),l=this.createInitializer(function(f,u){if(he(f,a))re(this,f),i&V.HasPointer&&this[_]("copy",P.Vivificate,f);else if(typeof f=="string"&&i&Ce.IsString&&(f={string:f}),f?.[Symbol.iterator]){if(f=sn(f),f.length!==n)throw new ot(t,this,f);let h=0;for(const y of f)c.call(this,h++,y,u)}else if(f&&typeof f=="object"){if(r.call(this,f)===0)throw new Te(t,f)}else if(f!==void 0)throw new Te(t,f)});return e.$={get:function(){return me(this,O.Slice)},set:l},e.length=b(n),e.entries=e[ye]=this.defineArrayEntries(),i&Ce.IsTypedArray&&(e.typedArray=this.defineTypedArray(t),i&Ce.IsString&&(e.string=this.defineString(t)),i&Ce.IsClampedArray&&(e.clampedArray=this.defineClampedArray(t))),e[Symbol.iterator]=this.defineArrayIterator(),e[q]=b(l),e[fe]=this.defineFinalizerArray(o),e[ue]=i&V.HasObject&&this.defineVivificatorArray(t),e[_]=i&V.HasPointer&&this.defineVisitorArray(),e[it]={value(){return me(this,O.Slice)}},e[st]=b(O.Slice),a},finalizeArray(t,e){const{flags:n,instance:{members:[s]}}=t;e.child=b(s.structure.constructor),e[be]=n&Ce.HasSentinel&&this.defineSentinel(t)}});A({defineFinalizerArray({get:t,set:e}){return{value(){return de(this,{get:{value:t.bind(this)},set:e&&{value:e.bind(this)}}),this}}},defineVivificatorArray(t){const{instance:{members:[e]}}=t,{byteSize:n,structure:s}=e,i=this;return{value:function(c){const{constructor:a}=s,l=this[W](),u=l.byteOffset+n*c,h=i.obtainView(l.buffer,u,n,!l[Fe]);return this[x][c]=a.call(At,h)}}}});A({defineEnum(t,e){const{instance:{members:[n]}}=t,s=this.defineMember(n),{get:i,set:r}=s,{get:o}=this.defineMember(n,!1),c=this.createApplier(t),a=["string","number","tagged union"],l=function(u){if(u&&typeof u=="object"){if(c.call(this,u)===0)throw new ve(t,a,u)}else u!==void 0&&r.call(this,u)},f=this.createConstructor(t,{onCastError(u,h){throw new ve(u,a,h)}});return e.$=s,e.toString=b(Hn),e[Symbol.toPrimitive]={value(u){switch(u){case"string":case"default":return this.$[lt];default:return o.call(this)}}},e[q]=b(l),f},finalizeEnum(t,e){const{flags:n,constructor:s,instance:{members:[i]},static:{members:r,template:o}}=t,c=o[x],{get:a,set:l}=this.defineMember(i,!1),f={};for(const{name:u,flags:h,slot:y}of r)if(h&H.IsPartOfSet){const p=c[y];U(p,lt,b(u));const d=a.call(p);e[u]={value:p,writable:!1},f[d]=p}e[je]={value(u){if(typeof u=="string")return s[u];if(typeof u=="number"||typeof u=="bigint"){let h=f[u];if(!h&&n&Tn.IsOpenEnded){h=new s(void 0),l.call(h,u);const y=`${u}`;U(h,lt,b(y)),U(s,y,b(h)),f[u]=h}return h}else return u instanceof s?u:u?.[zt]instanceof s?u[zt]:!1}},e[ge]=b(this.getTypedArray(t))},transformDescriptorEnum(t,e){const{type:n,structure:s}=e;if(n===F.Object)return t;const i=function(c){const{constructor:a}=s,l=a(c);if(!l)throw new Gn(s,c);return l},{get:r,set:o}=t;return{get:r.length===0?function(){const a=r.call(this);return i(a)}:function(a){const l=r.call(this,a);return i(l)},set:o.length===1?function(a){a=i(a)[Symbol.toPrimitive](),o.call(this,a)}:function(a,l){const f=i(l);o.call(this,a,f[Symbol.toPrimitive]())}}}});A({init(){this.ZigError=null,this.globalItemsByIndex={},this.globalErrorSet=null},defineErrorSet(t,e){const{instance:{members:[n]},byteSize:s,flags:i}=t;if(!this.ZigError){this.ZigError=class extends qs{};const u={type:E.ErrorSet,flags:Pe.IsGlobal,byteSize:s,name:"anyerror",instance:{members:[n]},static:{members:[],template:{SLOTS:{}}}},h=this.defineStructure(u);this.finalizeStructure(u),this.globalErrorSet=h}if(this.globalErrorSet&&i&Pe.IsGlobal)return this.globalErrorSet;const r=this.defineMember(n),{set:o}=r,c=["string","number"],a=this.createApplier(t),l=function(u){if(u instanceof f[Ge])o.call(this,u);else if(u&&typeof u=="object"&&!De(u)){if(a.call(this,u)===0)throw new ve(t,c,u)}else u!==void 0&&o.call(this,u)},f=this.createConstructor(t,{onCastError(u,h){throw new ve(u,c,h)}});return e.$=r,e[q]=b(l),f},finalizeErrorSet(t,e){const{constructor:n,flags:s,instance:{members:[i]},static:{members:r,template:o}}=t;if(this.globalErrorSet&&s&Pe.IsGlobal)return!1;const c=o?.[x]??{},a=s&Pe.IsGlobal?this.globalItemsByIndex:{},{get:l}=this.defineMember(i,!1);for(const{name:f,slot:u}of r){const h=c[u],y=l.call(h);let p=this.globalItemsByIndex[y];const d=!!p;p||(p=new this.ZigError(f,y));const g=b(p);e[f]=g;const S=`${p}`;e[S]=g,a[y]=p,d||(de(this.globalErrorSet,{[f]:g,[S]:g}),this.globalErrorSet[Ve].push(f),this.globalItemsByIndex[y]=p)}e[je]={value(f){return typeof f=="number"?a[f]:typeof f=="string"?n[f]:f instanceof n[Ge]?a[Number(f)]:De(f)?n[`Error: ${f.error}`]:f instanceof Error?n[`${f}`]:!1}},e[Ge]=b(this.ZigError)},transformDescriptorErrorSet(t,e){const{type:n,structure:s}=e;if(n===F.Object)return t;const i=c=>{const{constructor:a,flags:l}=s,f=a(c);if(!f){if(l&Pe.IsGlobal&&typeof c=="number"){const u=new this.ZigError(`Unknown error: ${c}`,c);return this.globalItemsByIndex[c]=u,U(this.globalErrorSet,`${u}`,b(u)),u}throw c instanceof Error?new fn(s,c):new qn(s,c)}return f},{get:r,set:o}=t;return{get:r.length===0?function(){const a=r.call(this);return i(a)}:function(a){const l=r.call(this,a);return i(l)},set:o.length===1?function(a){const l=i(a);a=Number(l),o.call(this,a)}:function(a,l){const f=i(l);l=Number(f),o.call(this,a,l)}}}});class qs extends Error{constructor(e,n){super(ms(e)),this.number=n,this.stack=void 0}[Symbol.toPrimitive](e){switch(e){case"string":case"default":return Error.prototype.toString.call(this,e);default:return this.number}}toJSON(){return{error:this.message}}}A({defineErrorUnion(t,e){const{instance:{members:[n,s]},flags:i}=t,{get:r,set:o}=this.defineMember(n),{get:c,set:a}=this.defineMember(s),{get:l,set:f}=this.defineMember(s,!1),u=function(){if(l.call(this))throw c.call(this);return r.call(this)},h=n.type===F.Void,y=s.structure.constructor,{bitOffset:p,byteSize:d}=n,g=function(){cn(this[w],p>>3,d),this[_]?.("clear",P.IgnoreUncreated)},S=this.createApplier(t),v=this.createInitializer(function(T,R){if(he(T,M))re(this,T),i&V.HasPointer&&(l.call(this)||this[_]("copy",0,T));else if(T instanceof y[Ge]&&y(T))a.call(this,T),g.call(this);else if(T!==void 0||h)try{o.call(this,T,R),f.call(this,0);return}catch(D){if(T instanceof Error){const N=y(T)??y.Unexpected;if(N)a.call(this,N),g.call(this);else throw new fn(s.structure,T)}else if(De(T))a.call(this,T),g.call(this);else if(T&&typeof T=="object"){if(S.call(this,T)===0)throw D}else throw D}}),M=this.createConstructor(t);return e.$={get:u,set:v},e[q]=b(v),e[ue]=i&V.HasObject&&this.defineVivificatorStruct(t),e[_]=i&V.HasPointer&&this.defineVisitorErrorUnion(n,l),M}});A({defineFunction(t,e){const{instance:{members:[n],template:s}}=t,{structure:{constructor:i}}=n,r=this,o=function(c){const a=this instanceof o;let l;if(a){if(arguments.length===0)throw new an(t);if(typeof c!="function")throw new oe("function",c);if(i[xe]===E.VariadicStruct||!o[Ze])throw new bt;r.instance&&(l=r.getFunctionThunk(c,o[Ze]))}else{if(this!==X)throw new ts;l=c}const f=i.prototype.length,u=a?r.createInboundCaller(c,i):r.createOutboundCaller(s,i);return de(u,{length:b(f),name:b(a?c.name:"")}),Object.setPrototypeOf(u,o.prototype),l?u[w]=l:(r.deferredThunks??=[],r.deferredThunks.push({target:u,fn:c})),u};return Object.setPrototypeOf(o.prototype,Function.prototype),e.valueOf=e.toJSON=b(rt),o},finalizeFunction(t,e,n){const{static:{template:s}}=t;e[Ze]=b(s),n[Symbol.toStringTag]=void 0},createDeferredThunks(){const t=this.deferredThunks;if(t)for(const{target:e,fn:n}of t){const{constructor:s}=e,i=this.getFunctionThunk(n,s[Ze]);e[w]=i}}});A({defineOptional(t,e){const{instance:{members:[n,s]},flags:i}=t,{get:r,set:o}=this.defineMember(n),{get:c,set:a}=this.defineMember(s),l=function(){return c.call(this)?r.call(this):(this[_]?.("clear",P.IgnoreUncreated),null)},f=n.type===F.Void,{bitOffset:u,byteSize:h}=n,y=this.createInitializer(function(d,g){he(d,p)?(re(this,d),i&V.HasPointer&&c.call(this)&&this[_]("copy",P.Vivificate,d)):d===null?(a.call(this,0),i&Pt.HasSelector&&cn(this[w],u>>3,h),this[_]?.("clear",P.IgnoreUncreated)):(d!==void 0||f)&&(o.call(this,d,g),i&Pt.HasSelector?a.call(this,1):i&V.HasPointer&&(c.call(this)||a.call(this,13)))}),p=t.constructor=this.createConstructor(t);return e.$={get:l,set:y},e[q]=b(y),e[ue]=i&V.HasObject&&this.defineVivificatorStruct(t),e[_]=i&V.HasPointer&&this.defineVisitorOptional(n,c),p}});A({definePointer(t,e){const{flags:n,byteSize:s,instance:{members:[i]}}=t,{structure:r}=i,{type:o,flags:c,byteSize:a=1}=r,l=n&L.HasLength?s/2:s,{get:f,set:u}=this.defineMember({type:F.Uint,bitOffset:0,bitSize:l*8,byteSize:l,structure:{byteSize:l}}),{get:h,set:y}=n&L.HasLength?this.defineMember({type:F.Uint,bitOffset:l*8,bitSize:l*8,byteSize:l,structure:{flags:Jt.IsSize,byteSize:l}}):{},p=function(m,$=!0,j=!0){if($||this[w][C])if(j){const z=Y.child,te=f.call(this),J=n&L.HasLength?h.call(this):o===E.Slice&&c&le.HasSentinel?ee.findSentinel(te,z[be].bytes)+1:1;if(te!==this[$e]||J!==this[We]){const ne=ee.findMemory(m,te,J,z[It]),Me=ne?z.call(X,ne):null;return this[x][0]=Me,this[$e]=te,this[We]=J,n&L.HasLength&&(this[_e]=null),Me}}else return this[x][0]=void 0;return this[x][0]},d=function(m){u.call(this,m),this[$e]=m},g=c&le.HasSentinel?1:0,S=n&L.HasLength||c&le.HasSentinel?function(m){y?.call?.(this,m-g),this[We]=m}:null,v=Bt(t),M=Bt(r,n&L.IsConst),T=function(m=!0){const $=!this[x][0],j=p.call(this,null,$);if(!j){if(n&L.IsNullable)return null;throw new rs}return M&&m?me(j,M):j},R=function(m){if(m!==void 0){if(m){const $=m[w][C];if($){const{address:j,js:z}=$;d.call(this,j),S?.call?.(this,m.length),z&&(m[w][C]=void 0)}else if(this[w][C])throw new hn}else this[w][C]&&(d.call(this,0),S?.call?.(this,0));this[x][0]=m??null,n&L.HasLength&&(this[_e]=null)}},D=c&V.HasValue?function(){return T.call(this).$}:T,N=n&L.IsConst?ce:function(m){const $=T.call(this);return $.$=m},ae=function(){const m=T.call(this,!1);return m?m.length:0},Q=function(m){m=m|0;const $=T.call(this,!1);if($){if($.length===m)return}else{if(m!==0)throw new Lt(m,0);return}const j=$[W](),z=j[C];let te;if(z||(n&L.HasLength?(this[_e]||=$.length,te=this[_e]):te=(j.buffer.byteLength-j.byteOffset)/a|0),m<0||m>te)throw new Lt(m,te);const J=m*a,ne=z?ee.obtainZigView(z.address,J):ee.obtainView(j.buffer,j.byteOffset,J),Me=r.constructor;this[x][0]=Me.call(X,ne),S?.call?.(this,m)},ee=this,Se=this.createInitializer(function(m,$,j){const z=r.constructor;if(wt(m,z)){if(!(n&L.IsConst)&&m.constructor.const)throw new ns(t,m);m=m[x][0]}else if(n&L.IsMultiple)Wt(m,z,n)&&(m=z.call(X,m[x][0][w]));else if(o===E.Slice&&c&le.IsOpaque&&m){if(m.constructor[xe]===E.Pointer)m=m[K]?.[w];else if(m[w])m=m[w];else if(m?.buffer instanceof ArrayBuffer&&!(m instanceof Uint8Array||m instanceof DataView)){const{byteOffset:J,byteLength:ne}=m;J!==void 0&&ne!==void 0&&(m=new DataView(m.buffer,J,ne))}}if(m instanceof z){if(m[W](),(j===O.ReadOnly||m[Ke])&&!(n&L.IsConst))throw new ls(t)}else if(he(m,z))m=z.call(X,m[w]);else if(n&L.IsSingle&&n&L.IsMultiple&&m instanceof z.child)m=z.call(X,m[w]);else if(Ys(m,z)){const J=ee.extractView(r,m);m=z.call(X,J)}else if(m!=null&&!m[w]){if(n&L.IsSingle&&n&L.IsMultiple&&typeof m=="object"&&!m[Symbol.iterator]){let ne=!0;const Me=z.prototype[Ne];for(const Ct of Object.keys(m))if(Me[Ct]?.special){ne=!1;break}ne&&(m=[m])}if(ge in z&&m?.buffer&&m[Symbol.iterator])throw new Ft(t,m);const J=m=new z(m,{allocator:$});c&V.HasProxy&&(m=ct(J).target)}else if(m!==void 0&&(!(n&L.IsNullable)||m!==null))throw new Ft(t,m);if(m?.[w]?.[C]?.address===Re)throw new un(m);this[K]=m}),Y=this.createConstructor(t);return e["*"]={get:D,set:N},e.$={get:o===E.Pointer?rt:function(){return me(this,v)},set:Se},e.length={get:ae,set:Q},e.slice=o===E.Slice&&{value(m,$){const j=this[K].slice(m,$);return new Y(j)}},e.subarray=o===E.Slice&&{value(m,$,j){const z=this[K].subarray(m,$,j);return new Y(z)}},e[Symbol.toPrimitive]=o===E.Primitive&&{value(m){return this[K][Symbol.toPrimitive](m)}},e[q]=b(Se),e[fe]=o===E.Function&&{value(){const m=function(...$){return m["*"].call(this,...$)};return m[w]=this[w],m[x]=this[x],Object.setPrototypeOf(m,Y.prototype),m}},e[it]=v&&{value(){return me(this,v)}},e[st]=b(v),e[K]={get:T,set:R},e[we]=b(p),e[Yt]={set:d},e[Ee]={set:S},e[_]=this.defineVisitor(),e[$e]=b(0),e[We]=b(0),e[_e]=n&L.HasLength&&b(null),e.dataView=e.base64=void 0,Y},finalizePointer(t,e){const{flags:n,constructor:s,instance:{members:[i]}}=t,{structure:r}=i,{type:o,constructor:c}=r;e.child=c!==Object?b(c):{get(){return r.constructor}},e.const=b(!!(n&L.IsConst)),e[je]={value(a,l){if(this===X||this===At||a instanceof s)return!1;if(wt(a,c))return new s(c(a["*"]),l);if(Wt(a,c,n))return new s(a);if(o===E.Slice)return new s(c(a),l);throw new es(t)}}}});function wt(t,e){return on(t?.constructor?.child,e)&&t["*"]}function Wt(t,e,n){if(n&L.IsMultiple){if(t?.constructor?.child?.child===e.child&&t["*"])return!0;if(n&L.IsSingle&&wt(t,e.child))return!0}return!1}function Ys(t,e){const n=t?.[Symbol.toStringTag];if(n){const s=e[ge];if(s)switch(n){case s.name:case"DataView":return!0;case"ArrayBuffer":return s===Uint8Array||s===Int8Array;case"Uint8ClampedArray":return s===Uint8Array}if(e.child&&rn(t,e.child)!==void 0)return!0}return!1}A({definePrimitive(t,e){const{instance:{members:[n]}}=t,s=this.createApplier(t),{get:i,set:r}=this.defineMember(n),o=function(a){if(he(a,c))re(this,a);else if(a&&typeof a=="object"){if(s.call(this,a)===0){const l=Qt(n);throw new ve(t,l,a)}}else a!==void 0&&r.call(this,a)},c=this.createConstructor(t);return e.$={get:i,set:o},e[q]=b(o),e[Symbol.toPrimitive]=b(i),c},finalizePrimitive(t,e){const{instance:{members:[n]}}=t;e[xn]=b(n.bitSize),e[On]=b(n.type)}});A({init(){this.promiseCallbackMap=new Map,this.promiseContextMap=new Map,this.nextPromiseContextId=nn(4096)},createPromise(t,e,n){const{constructor:s}=t;if(n){if(typeof n!="function")throw new oe("function",n)}else e[Kt]=new Promise((c,a)=>{n=l=>{if(l?.[w]?.[C]&&(l=new l.constructor(l)),l instanceof Error)a(l);else{if(l){const f=e[Ie];f&&(l=f(l))}c(l)}}});const i=this.nextPromiseContextId++,r=this.obtainZigView(i,0,!1);this.promiseContextMap.set(i,{func:n,args:e});let o=this.promiseCallbackMap.get(s);return o||(o=(c,a)=>{const l=c instanceof DataView?c:c["*"][w],f=this.getViewAddress(l),u=this.promiseContextMap.get(f);if(u){const{func:h,args:y}=u;if(h.length===2){const p=a instanceof Error;h(p?a:null,p?null:a)}else h(a);y[fe](),this.promiseContextMap.delete(f)}},this.promiseCallbackMap.set(s,o),this.destructors.push(()=>this.freeFunction(o))),e[pe]=c=>o(r,c),{ptr:r,callback:o}},createPromiseCallback(t,e){const{ptr:n,callback:s}=e,i=s["*"];return t[pe]=r=>i.call(t,n,r),(...r)=>{const o=r.length===2?r[0]??r[1]:r[0];return t[pe](o)}}});A({defineSlice(t,e){const{align:n,flags:s,instance:{members:[i]}}=t,{byteSize:r}=i,o=this,c=function(d,g,S){d||(d=o.allocateMemory(g*r,n,S)),this[w]=d,this[Ee]=g},a=function(d,g){if(g!==this[Ee])throw new ot(t,this,d)},l=this.defineMember(i),{set:f}=l,u=this.createApplier(t),h=this.createInitializer(function(d,g){if(he(d,p))this[w]?a.call(this,d,d.length):c.call(this,null,d.length,g),re(this,d),s&V.HasPointer&&this[_]("copy",P.Vivificate,d);else if(typeof d=="string"&&s&le.IsString)h.call(this,{string:d},g);else if(d?.[Symbol.iterator]){d=sn(d),this[w]?a.call(this,d,d.length):c.call(this,null,d.length,g);let S=0;for(const v of d)p[be]?.validateValue(v,S,d.length),f.call(this,S++,v,g)}else if(typeof d=="number")if(!this[w]&&d>=0&&isFinite(d))c.call(this,null,d,g);else throw new Te(t,d,!this[w]);else if(d&&typeof d=="object"){if(u.call(this,d,g)===0)throw new Te(t,d)}else if(d!==void 0)throw new Te(t,d)}),y=function(d,g){const S=this[Ee],v=this[w];d=d===void 0?0:Zt(d,S),g=g===void 0?S:Zt(g,S);const M=d*r,T=g*r-M;return o.obtainView(v.buffer,v.byteOffset+M,T)},p=this.createConstructor(t);return e.$={get:function(){return me(this,O.Slice)},set:h},e.length={get:Xs},s&le.IsTypedArray&&(e.typedArray=this.defineTypedArray(t),s&le.IsString&&(e.string=this.defineString(t)),s&le.IsClampedArray&&(e.clampedArray=this.defineClampedArray(t))),e.entries=e[ye]=this.defineArrayEntries(),e.subarray={value(d,g){const S=y.call(this,d,g);return p(S)}},e.slice={value(d,g,S={}){const{zig:v=!1}=S,M=y.call(this,d,g),T=o.allocateMemory(M.byteLength,n,v),R=p(T);return ie(T,M),R}},e[Symbol.iterator]=this.defineArrayIterator(),e[Le]=b(c),e[q]=b(h),e[fe]=this.defineFinalizerArray(l),e[ue]=s&V.HasObject&&this.defineVivificatorArray(t),e[_]=s&V.HasPointer&&this.defineVisitorArray(),e[it]={value(){return me(this,O.Slice)}},e[st]=b(O.Slice),p},finalizeSlice(t,e){const{flags:n,instance:{members:[s]}}=t;e.child=b(s.structure.constructor),e[be]=n&le.HasSentinel&&this.defineSentinel(t)}});function Xs(){return this[Ee]}function Zt(t,e){return t=t|0,t<0?(t=e+t,t<0&&(t=0)):t>e&&(t=e),t}A({defineStruct(t,e){const{purpose:n,flags:s,length:i,instance:{members:r}}=t,o=r.find(p=>p.flags&H.IsBackingInt),c=o&&this.defineMember(o),a=this.createApplier(t),l=this.createInitializer(function(p,d){if(he(p,f))re(this,p),s&V.HasPointer&&this[_]("copy",0,p);else if(p&&typeof p=="object")a.call(this,p,d);else if((typeof p=="number"||typeof p=="bigint")&&c)c.set.call(this,p);else if(p!==void 0)throw new ve(t,"object",p)}),f=this.createConstructor(t),u=e[Ne].value,h=e[pt].value,y=[];for(const p of r.filter(d=>!!d.name)){const{name:d,flags:g}=p,{set:S}=e[d]=this.defineMember(p);S&&(g&H.IsRequired&&(S.required=!0),u[d]=S,h.push(d)),y.push(d)}return e.$={get:rt,set:l},e.length=b(i),e.entries=s&Je.IsTuple&&this.defineVectorEntries(),e[Symbol.toPrimitive]=c&&{value(p){return p==="string"?Object.prototype.toString.call(this):c.get.call(this)}},e[Symbol.iterator]=n===G.Iterator?this.defineZigIterator():s&Je.IsTuple?this.defineVectorIterator():this.defineStructIterator(),e[q]=b(l),e[ue]=s&V.HasObject&&this.defineVivificatorStruct(t),e[_]=s&V.HasPointer&&this.defineVisitorStruct(r),e[ye]=s&Je.IsTuple?this.defineVectorEntries():this.defineStructEntries(),e[Ve]=b(y),n===G.Allocator&&(e.alloc=this.defineAlloc(),e.free=this.defineFree(),e.dupe=this.defineDupe()),f}});A({defineVivificatorStruct(t){const{instance:{members:e}}=t,n={};for(const i of e.filter(r=>r.type===F.Object))n[i.slot]=i;const s=this;return{value(i){const r=n[i],{bitOffset:o,byteSize:c,structure:{constructor:a}}=r,l=this[W](),u=l.byteOffset+(o>>3);let h=c;if(h===void 0){if(o&7)throw new cs(r);h=r.bitSize>>3}const y=s.obtainView(l.buffer,u,h,!l[Fe]);return this[x][i]=a.call(At,y)}}}});A({defineVector(t,e){const{flags:n,length:s,instance:{members:[i]}}=t,r=this.createApplier(t),o=this.createInitializer(function(l){if(he(l,c))re(this,l),n&V.HasPointer&&this[_]("copy",P.Vivificate,l);else if(l?.[Symbol.iterator]){let f=l.length;if(typeof f!="number"&&(l=[...l],f=l.length),f!==s)throw new ot(t,this,l);let u=0;for(const h of l)this[u++]=h}else if(l&&typeof l=="object"){if(r.call(this,l)===0)throw new Te(t,l)}else if(l!==void 0)throw new Te(t,l)}),c=this.createConstructor(t),{bitSize:a}=i;for(let l=0,f=0;l<s;l++,f+=a)n&V.HasPointer?e[l]=this.defineMember({...i,slot:l}):e[l]=this.defineMember({...i,bitOffset:f});return e.$={get:rt,set:o},e.length=b(s),n&_t.IsTypedArray&&(e.typedArray=this.defineTypedArray(t),n&_t.IsClampedArray&&(e.clampedArray=this.defineClampedArray(t))),e.entries=e[ye]=this.defineVectorEntries(),e[Symbol.iterator]=this.defineVectorIterator(),e[q]=b(o),e[ue]=n&V.HasObject&&this.defineVivificatorArray(t),e[_]=n&V.HasPointer&&this.defineVisitorArray(),c},finalizeVector(t,e){const{instance:{members:[n]}}=t;e.child=b(n.structure.constructor)}});A({defineVisitor(){return{value(t,e,n){let s;typeof t=="string"?s=Ks[t]:s=t,s.call(this,e,n)}}}});function He(t,e,n,s){let i=this[x][t];if(!i)if(!(n&P.IgnoreUncreated))i=this[ue](t);else return;let r;s&&(r=s[x][t],!r)||i[_](e,n,r)}const Ks={copy(t,e){const n=e[x][0];if(this[w][C]&&n&&!n[w][C])throw new hn;this[x][0]=n},clear(t){t&P.IsInactive&&(this[x][0]=void 0)},reset(){this[x][0]=void 0,this[$e]=void 0}};A({defineVisitorArgStruct(t){const e=[];let n;for(const[s,{slot:i,structure:r}]of t.entries())r.flags&V.HasPointer&&(s===0?n=i:e.push(i));return{value(s,i,r){if(!(i&P.IgnoreArguments)&&e.length>0)for(const o of e)He.call(this,o,s,i|P.IsImmutable,r);!(i&P.IgnoreRetval)&&n!==void 0&&He.call(this,n,s,i,r)}}}});A({defineVisitorErrorUnion(t,e){const{slot:n}=t;return{value(s,i,r){e.call(this)&&(i|=P.IsInactive),(!(i&P.IsInactive)||!(i&P.IgnoreInactive))&&He.call(this,n,s,i,r)}}}});A({defineVisitorOptional(t,e){const{slot:n}=t;return{value(s,i,r){e.call(this)||(i|=P.IsInactive),(!(i&P.IsInactive)||!(i&P.IgnoreInactive))&&He.call(this,n,s,i,r)}}}});A({defineVisitorStruct(t){const e=t.filter(n=>n.structure?.flags&V.HasPointer).map(n=>n.slot);return{value(n,s,i){for(const r of e)He.call(this,r,n,s,i)}}}});export{ti as c};
