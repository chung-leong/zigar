R"=====(
((function (exports) {
  'use strict';

  const StructureType = {
    Primitive: 0,
    Array: 1,
    Struct: 2,
    Union: 3,
    ErrorUnion: 4,
    ErrorSet: 5,
    Enum: 6,
    Optional: 7,
    Pointer: 8,
    Slice: 9,
    Vector: 10,
    Opaque: 11,
    ArgStruct: 12,
    VariadicStruct: 13,
    Function: 14,
  };
  const StructureFlag = {
    HasValue:         0x0000_0001,
    HasObject:        0x0000_0002,
    HasPointer:       0x0000_0004,
    HasSlot:          0x0000_0008,
    HasLength:        0x0000_0010,
    HasSelector:      0x0000_0020,
    HasTag:           0x0000_0040,
    HasSentinel:      0x0000_0080,

    IsConst:          0x0000_0100,
    IsMultiple:       0x0000_0200,
    IsSingle:         0x0000_0400,
    IsExtern:         0x0000_0800,
    IsString:         0x0000_1000,
    IsPacked:         0x0000_2000,
    IsIterator:       0x0000_4000,
    IsTuple:          0x0000_8000,

    HasInaccessible:  0x0001_0000,

    IsNullable:       0x0100_0000,
    IsOpenEnded:      0x0200_0000,
    IsVariandic:      0x0400_0000,
  };
  const structureNames = Object.keys(StructureType);

  const MemberType = {
    Void: 0,
    Bool: 1,
    Int: 2,
    Uint: 3,
    Float: 4,
    Object: 5,
    Type: 6,
    Literal: 7,
    Null: 8,
    Undefined: 9,
    Unsupported: 10,
  };
  const memberNames = Object.keys(MemberType);
  const MemberFlag = {
    IsRequired:       0x0000_0001,
    IsReadOnly:       0x0000_0002,
    IsSize:           0x0000_0004,
    IsPartOfSet:      0x0000_0008,
    IsSelector:       0x0000_0010,
    IsSentinel:       0x0000_0020,
    IsBackingInt:     0x0000_0040,
  };

  const MEMORY = Symbol('memory');
  const SLOTS = Symbol('slots');
  const PARENT = Symbol('parent');
  const FIXED = Symbol('fixed');
  const NAME = Symbol('name');
  const TYPE = Symbol('type');
  const FLAGS = Symbol('flags');
  const CLASS = Symbol('class');
  const TAG = Symbol('tag');
  const PROPS = Symbol('props');
  const POINTER = Symbol('pointer');
  const SENTINEL = Symbol('sentinel');
  const ARRAY = Symbol('array');
  const TARGET = Symbol('target');
  const ENTRIES = Symbol('entries');
  const MAX_LENGTH = Symbol('maxLength');
  const KEYS = Symbol('keys');
  const ADDRESS = Symbol('address');
  const LENGTH = Symbol('length');
  const LAST_ADDRESS = Symbol('lastAddress');
  const LAST_LENGTH = Symbol('lastLength');
  const PROXY = Symbol('proxy');
  const CACHE = Symbol('cache');
  const SIZE = Symbol('size');
  const BIT_SIZE = Symbol('bitSize');
  const ALIGN = Symbol('align');
  const CONST_TARGET = Symbol('constTarget');
  const CONST_PROXY = Symbol('constProxy');
  const ENVIRONMENT = Symbol('environment');
  const ATTRIBUTES = Symbol('attributes');
  const PRIMITIVE = Symbol('primitive');
  const VARIANTS = Symbol('variants');
  const GETTERS = Symbol('getters');
  const SETTERS = Symbol('setters');
  const TYPED_ARRAY = Symbol('typedArray');

  const UPDATE = Symbol('update');
  const RESET = Symbol('resetter');
  const VIVIFICATE = Symbol('vivificate');
  const VISIT = Symbol('visit');
  const COPY = Symbol('copy');
  const SHAPE = Symbol('shape');
  const MODIFY = Symbol('modify');
  const INITIALIZE = Symbol('initialize');
  const FINALIZE = Symbol('finalize');
  const CAST = Symbol('cast');

  function defineProperty(object, name, descriptor) {
    if (descriptor) {
      const {
        set,
        get,
        value,
        enumerable,
        configurable = true,
        writable = true,
      } = descriptor;
      Object.defineProperty(object, name, (get || set)
        ? { get, set, configurable, enumerable }
        : { value, configurable, enumerable, writable }
      );
    }
    return object;
  }

  function defineProperties(object, descriptors) {
    for (const [ name, descriptor ] of Object.entries(descriptors)) {
      defineProperty(object, name, descriptor);
    }
    for (const symbol of Object.getOwnPropertySymbols(descriptors)) {
      const descriptor = descriptors[symbol];
      defineProperty(object, symbol, descriptor);
    }
    return object;
  }

  function defineValue(value) {
    return (value !== undefined) ? { value } : undefined;
  }

  function getTypeName(member) {
    const { type, bitSize, byteSize } = member;
    const suffix = (type === MemberType.Bool && byteSize) ? byteSize * 8 : bitSize;
    let name = memberNames[type] + suffix;
    if (bitSize > 32 && (type === MemberType.Int || type === MemberType.Uint)) {
      if (bitSize <= 64) {
        name = `Big${name}`;
      } else {
        name = `Jumbo${name}`;
      }
    }
    if (byteSize === undefined) {
      name += 'Unaligned';
    }
    return name;
  }

  function getPrimitiveName({ type, bitSize }) {
    switch (type) {
      case MemberType.Bool: return 'boolean';
      case MemberType.Int:
      case MemberType.Uint:
        if (bitSize > 32) {
          return 'bigint';
        }
      case MemberType.Float: return 'number';
    }
  }

  function decodeText(arrays, encoding = 'utf-8') {
    const decoder = decoders[encoding] ??= new TextDecoder(encoding);
    let array;
    if (Array.isArray(arrays)) {
      if (arrays.length === 1) {
        array = arrays[0];
      } else {
        let len = 0;
        for (const a of arrays) {
          len += a.length;
        }
        const { constructor } = arrays[0];
        array = new constructor(len);
        let offset = 0;
        for (const a of arrays) {
          array.set(a, offset);
          offset += a.length;
        }
      }
    } else {
      array = arrays;
    }
    return decoder.decode(array);
  }

  function encodeText(text, encoding = 'utf-8') {
    switch (encoding) {
      case 'utf-16': {
        const { length } = text;
        const ta = new Uint16Array(length);
        for (let i = 0; i < length; i++) {
          ta[i] = text.charCodeAt(i);
        }
        return ta;
      }
      default: {
        const encoder = encoders[encoding] ??= new TextEncoder();
        return encoder.encode(text);
      }
    }
  }

  function encodeBase64(dv) {
    {
      if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {
        return Buffer.from(dv.buffer, dv.byteOffset, dv.byteLength).toString('base64');
      }
    }
    const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);
    const bstr = String.fromCharCode.apply(null, ta);
    return btoa(bstr);
  }

  function decodeBase64(str) {
    {
      if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {
        const b = Buffer.from(str, 'base64');
        return new DataView(b.buffer, b.byteOffset, b.byteLength);
      }
    }
    const bstr = atob(str);
    const ta = new Uint8Array(bstr.length);
    for (let i = 0; i < ta.byteLength; i++) {
      ta[i] = bstr.charCodeAt(i);
    }
    return new DataView(ta.buffer);
  }

  const decoders = {};
  const encoders = {};

  function findSortedIndex(array, value, cb) {
    let low = 0;
    let high = array.length;
    if (high === 0) {
      return 0;
    }
    while (low < high) {
      const mid = Math.floor((low + high) / 2);
      const value2 = cb(array[mid]);
      if (value2 <= value) {
        low = mid + 1;
      } else {
        high = mid;
      }
    }
    return high;
  }

  const isMisaligned = function(address, align) {
      return (align !== undefined) ? !!(address & BigInt(align - 1)) : false;
    }
  ;

  const alignForward = function(address, align) {
      return (address + BigInt(align - 1)) & ~BigInt(align - 1);
    }
  ;

  const isInvalidAddress = function(address) {
      return address === 0xaaaaaaaaaaaaaaaan;
    }
  ;

  const adjustAddress = function(address, addend) {
      return address + BigInt(addend);
    }
  ;

  function transformIterable(arg) {
    if (typeof(arg.length) === 'number') {
      // it's an array of sort
      return arg;
    }
    const iterator = arg[Symbol.iterator]();
    const first = iterator.next();
    const length = first.value?.length;
    if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {
      // return generator with length attached
      return Object.assign((function*() {
        let result;
        while (!(result = iterator.next()).done) {
          yield result.value;
        }
      })(), { length });
    } else {
      const array = [];
      let result = first;
      while (!result.done) {
        array.push(result.value);
        result = iterator.next();
      }
      return array;
    }
  }

  function findElements(arg, Child) {
    // casting to a array/slice
    const { constructor: Arg } = arg;
    if (Arg === Child) {
      // matching object
      return 1;
    } else if (Arg.child === Child) {
      // matching slice/array
      return arg.length;
    }
  }

  function getSelf() {
    return this;
  }

  function getProxy() {
    return this[PROXY];
  }

  function toString() {
    return String(this);
  }

  function always() {
    return true;
  }

  function never() {
    return false;
  }

  class ObjectCache {
    map = new WeakMap();

    find(dv) {
      return this.map.get(dv);
    }

    save(dv, object) {
      this.map.set(dv, object);
      return object;
    }
  }

  const cls = {
    name: '',
    mixins: [],
    constructor: null,
  };

  function mixin(object) {
    if (!cls.constructor) {
      cls.mixins.push(object);
    }
    return object;
  }

  function defineEnvironment() {
    if (!cls.constructor) {
      cls.constructor = defineClass(cls.name, cls.mixins);
      cls.name = '';
      cls.mixins = [];
    }
    return cls.constructor;
  }

  function defineClass(name, mixins) {
    const props = {};
    const constructor = function() {
      for (const [ name, object ] of Object.entries(props)) {
        this[name] = structuredClone(object);
      }
    };
    const { prototype } = constructor;
    defineProperty(constructor, 'name', defineValue(name));
    for (const mixin of mixins) {
      for (let [ name, object ] of Object.entries(mixin)) {
        if (typeof(object) === 'function') {
          defineProperty(prototype, name, defineValue(object));
        } else {
          let current = props[name];
          if (current !== undefined) {
            if (current?.constructor === Object) {
              object = Object.assign({ ...current }, object);
            } else if (current !== object) {
              throw new Error(`Duplicate property: ${name}`);
            }
          }
          props[name] = object;
        }
      }
    }
    return constructor;
  }

  // handle retrieval of accessors

  mixin({
    getAccessor(access, member) {
      const { bitOffset, byteSize } = member;
      const typeName = getTypeName(member);
      const accessorName = access + typeName + ((byteSize === undefined) ? `${bitOffset}` : '');
      // see if it's a built-in method of DataView
      let accessor = DataView.prototype[accessorName];
      if (accessor) {
        return accessor;
      }
      // check cache
      accessor = cache.get(accessorName);
      if (accessor) {
        return accessor;
      }
      accessor = this[`getAccessor${typeName}`]?.(access, member)
              ?? this[`getAccessor${typeName.replace(/\d+/, '') || '*'}`]?.(access, member)
              ?? this[`getAccessor${typeName.replace(/^\D+\d+/, '') || '*'}`]?.(access, member);
      /* c8 ignore start */
      if (!accessor) {
        throw new Error(`No accessor available: ${typeName}`);
      }
      /* c8 ignore end */
      defineProperty(accessor, 'name', defineValue(accessorName));
      cache.set(accessorName, accessor);
      return accessor;
    },
  });

  const cache = new Map();

  mixin({
    getAccessorBigInt(access, member) {
      const { bitSize } = member;
      const signMask = 2n ** BigInt(bitSize - 1);
      const valueMask = signMask - 1n;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = this.getBigUint64(offset, littleEndian);
          return (n & valueMask) - (n & signMask);
        };
      } else {
        return function(offset, value, littleEndian) {
          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
          this.setBigUint64(offset, n, littleEndian);
        };
      }
    },
  });

  mixin({
    getAccessorBigUint(access, member) {
      const { bitSize } = member;
      const valueMask = (2n ** BigInt(bitSize)) - 1n;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = this.getBigInt64(offset, littleEndian);
          return n & valueMask;
        };
      } else {
        return function(offset, value, littleEndian) {
          const n = value & valueMask;
          this.setBigUint64(offset, n, littleEndian);
        };
      }
    },
  });

  // handles bools, including implicit ones in optional pointers, where an address
  // of zero would be treated as boolean false

  mixin({
    getAccessorBool(access, member) {
      const { byteSize } = member;
      const bitSize = byteSize * 8;
      const f = this.getAccessor(access, { type: MemberType.Uint, bitSize, byteSize });
      if (access === 'get') {
        return function(offset, littleEndian) {
          return !!f.call(this, offset, littleEndian);
        }
      } else {
        const zero = (bitSize <= 32) ? 0 : 0n;
        const one = (bitSize <= 32) ? 1 : 1n;
        return function(offset, value, littleEndian) {
          f.call(this, offset, value ? one : zero, littleEndian);
        }
      }
    }
  });

  // handle bools in packed structs

  mixin({
    getAccessorBool1Unaligned(access, member) {
      const { bitOffset } = member;
      const bitPos = bitOffset & 0x07;
      const mask = 1 << bitPos;
      if (access === 'get') {
        return function(offset) {
          const n = this.getInt8(offset);
          return !!(n & mask);
        };
      } else {
        return function(offset, value) {
          const n = this.getInt8(offset);
          const b = (value) ? n | mask : n & ~mask;
          this.setInt8(offset, b);
        };
      }
    },
  });

  // handles f128

  mixin({
    getAccessorFloat128(access, member) {
      const { byteSize } = member;
      const buf = new DataView(new ArrayBuffer(8));
      const get = function(offset, littleEndian) {
        const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
        const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
        const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
        const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));
        return w1 | w2 << 32n | w3 << 64n | w4 << 96n;
      };
      const set = function(offset, value, littleEndian) {
        const w1 = value & 0xffff_ffffn;
        const w2 = (value >> 32n) & 0xffff_ffffn;
        const w3 = (value >> 64n) & 0xffff_ffffn;
        const w4 = (value >> 96n) & 0xffff_ffffn;
        this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
        this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
        this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
        this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);
      };
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = get.call(this, offset, littleEndian);
          const sign = n >> 127n;
          const exp = (n & 0x7fff_0000_0000_0000_0000_0000_0000_0000n) >> 112n;
          const frac = n & 0x0000_ffff_ffff_ffff_ffff_ffff_ffff_ffffn;
          if (exp === 0n) {
            return (sign) ? -0 : 0;
          } else if (exp === 0x7fffn) {
            if (!frac) {
              return (sign) ? -Infinity : Infinity;
            } else {
              return NaN;
            }
          }
          const exp64 = exp - 16383n + 1023n;
          if (exp64 >= 2047n) {
            return (sign) ? -Infinity : Infinity;
          }
          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);
          buf.setBigUint64(0, n64, littleEndian);
          return buf.getFloat64(0, littleEndian);
        }
      } else {
        return function(offset, value, littleEndian) {
          buf.setFloat64(0, value, littleEndian);
          const n = buf.getBigUint64(0, littleEndian);
          const sign = n >> 63n;
          const exp = (n & 0x7ff0_0000_0000_0000n) >> 52n;
          const frac = n & 0x000f_ffff_ffff_ffffn;
          let n128;
          if (exp === 0n) {
            n128 = sign << 127n | (frac << 60n);
          } else if (exp === 0x07ffn) {
            n128 = sign << 127n | 0x7fffn << 112n | (frac ? 1n : 0n);
          } else {
            n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);
          }
          set.call(this, offset, n128, littleEndian);
        }
      }
    }
  });

  // handles f16

  mixin({
    getAccessorFloat16(access, member) {
      const buf = new DataView(new ArrayBuffer(4));
      const set = DataView.prototype.setUint16;
      const get = DataView.prototype.getUint16;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = get.call(this, offset, littleEndian);
          const sign = n >>> 15;
          const exp = (n & 0x7c00) >> 10;
          const frac = n & 0x03ff;
          if (exp === 0) {
            return (sign) ? -0 : 0;
          } else if (exp === 0x1f) {
            if (!frac) {
              return (sign) ? -Infinity : Infinity;
            } else {
              return NaN;
            }
          }
          const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);
          buf.setUint32(0, n32, littleEndian);
          return buf.getFloat32(0, littleEndian);
        }
      } else {
        return function(offset, value, littleEndian) {
          buf.setFloat32(0, value, littleEndian);
          const n = buf.getUint32(0, littleEndian);
          const sign = n >>> 31;
          const exp = (n & 0x7f80_0000) >> 23;
          const frac = n & 0x007f_ffff;
          const exp16 = (exp - 127 + 15);
          let n16;
          if (exp === 0) {
            n16 = sign << 15;
          } else if (exp === 0xff) {
            n16 = sign << 15 | 0x1f << 10 | (frac ? 1 : 0);
          } else if (exp16 >= 31) {
            n16 = sign << 15 | 0x1f << 10;
          } else {
            n16 = sign << 15 | exp16 << 10 | (frac >> 13);
          }
          set.call(this, offset, n16, littleEndian);
        }
      }
    }
  });

  // handles f80

  mixin({
    getAccessorFloat80(access, member) {
      const { byteSize } = member;
      const buf = new DataView(new ArrayBuffer(8));
      const get = function(offset, littleEndian) {
        const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));
        const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));
        const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));
        return w1 | w2 << 32n | w3 << 64n;
      };
      const set = function(offset, value, littleEndian) {
        const w1 = value & 0xffff_ffffn;
        const w2 = (value >> 32n) & 0xffff_ffffn;
        const w3 = (value >> 64n) & 0xffff_ffffn;
        this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);
        this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);
        this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);
      };
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = get.call(this, offset, littleEndian);
          const sign = n >> 79n;
          const exp = (n & 0x7fff_0000_0000_0000_0000n) >> 64n;
          const frac = n & 0x0000_7fff_ffff_ffff_ffffn;
          if (exp === 0n) {
            return (sign) ? -0 : 0;
          } else if (exp === 0x7fffn) {
            if (!frac) {
              return (sign) ? -Infinity : Infinity;
            } else {
              return NaN;
            }
          }
          const exp64 = exp - 16383n + 1023n;
          if (exp64 >= 2047n) {
            return (sign) ? -Infinity : Infinity;
          }
          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);
          buf.setBigUint64(0, n64, littleEndian);
          return buf.getFloat64(0, littleEndian);
        }
      } else {
        return function(offset, value, littleEndian) {
          buf.setFloat64(0, value, littleEndian);
          const n = buf.getBigUint64(0, littleEndian);
          const sign = n >> 63n;
          const exp = (n & 0x7ff0_0000_0000_0000n) >> 52n;
          const frac = n & 0x000f_ffff_ffff_ffffn;
          let n80;
          if (exp === 0n) {
            n80 = sign << 79n | (frac << 11n);
          } else if (exp === 0x07ffn) {
            n80 = sign << 79n | 0x7fffn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;
            //                                                 ^ bit 61                       ^ bit 63
          } else {
            n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;
          }
          set.call(this, offset, n80, littleEndian);
        }
      }
    }
  });

  // handle ints 7-bit or smaller in packed structs that are stored in a single byte
  // other unaligned ints are handled by the mixin "unaligned"

  mixin({
    getAccessorIntUnaligned(access, member) {
      const { bitSize, bitOffset } = member;
      const bitPos = bitOffset & 0x07;
      if (bitPos + bitSize <= 8) {
        const signMask = 2 ** (bitSize - 1);
        const valueMask = signMask - 1;
        if (access === 'get') {
          return function(offset) {
            const n = this.getUint8(offset);
            const s = n >>> bitPos;
            return (s & valueMask) - (s & signMask);
          };
        } else {
          const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);
          return function(offset, value) {
            let b = this.getUint8(offset);
            const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
            b = (b & outsideMask) | (n << bitPos);
            this.setUint8(offset, b);
          };
        }
      }
    }
  });

  // handle non-standard ints 32-bit or smaller

  mixin({
    getAccessorInt(access, member) {
      const { bitSize, byteSize } = member;
      const f = this.getAccessor(access, { type: MemberType.Uint, bitSize: byteSize * 8, byteSize });
      const signMask = 2 ** (bitSize - 1);
      const valueMask = signMask - 1;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = f.call(this, offset, littleEndian);
          return (n & valueMask) - (n & signMask);
        };
      } else {
        return function(offset, value, littleEndian) {
          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
          f.call(this, offset, n, littleEndian);
        };
      }
    }
  });

  mixin({
    getAccessorJumboInt(access, member) {
      const { bitSize } = member;
      const f = this.getJumboAccessor(access, bitSize);
      const signMask = 2n ** BigInt(bitSize - 1);
      const valueMask = signMask - 1n;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = f.call(this, offset, littleEndian);
          return (n & valueMask) - (n & signMask);
        };
      } else {
        return function(offset, value, littleEndian) {
          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;
          f.call(this, offset, n, littleEndian);
        };
      }
    },
  });

  mixin({
    getAccessorJumboUint(access, member) {
      const { bitSize } = member;
      const f = this.getJumboAccessor(access, bitSize);
      const valueMask = (2n ** BigInt(bitSize)) - 1n;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = f.call(this, offset, littleEndian);
          return n & valueMask;
        };
      } else {
        return function(offset, value, littleEndian) {
          const n = value & valueMask;
          f.call(this, offset, n, littleEndian);
        };
      }
    },
  });

  mixin({
    getJumboAccessor(access, bitSize) {
      const wordCount = (bitSize + 63) >> 6;
      if (access === 'get') {
        return function(offset, littleEndian) {
          let n = 0n;
          if (littleEndian) {
            for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
              const w = this.getBigUint64(j, littleEndian);
              n = (n << 64n) | w;
            }
          } else {
            for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
              const w = this.getBigUint64(j, littleEndian);
              n = (n << 64n) | w;
            }
          }
          return n;
        };
      } else {
        return function(offset, value, littleEndian) {
          let n = value;
          const mask = 0xffff_ffff_ffff_ffffn;
          if (littleEndian) {
            for (let i = 0, j = offset; i < wordCount; i++, j += 8) {
              const w = n & mask;
              this.setBigUint64(j, w, littleEndian);
              n >>= 64n;
            }
          } else {
            n <<= BigInt(wordCount * 64 - bitSize);
            for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {
              const w = n & mask;
              this.setBigUint64(j, w, littleEndian);
              n >>= 64n;
            }
          }
        };
      }
    }
  });

  // handle uints 7-bit or smaller in packed structs that are stored in a single byte
  // other unaligned ints are handled by the mixin "unaligned"

  mixin({
    getAccessorUintUnaligned(access, member) {
      const { bitSize, bitOffset } = member;
      const bitPos = bitOffset & 0x07;
      if (bitPos + bitSize <= 8) {
        const valueMask = (2 ** bitSize - 1);
        if (access === 'get') {
          return function(offset) {
            const n = this.getUint8(offset);
            const s = n >>> bitPos;
            return s & valueMask;
          };
        } else {
          const outsideMask = 0xFF ^ (valueMask << bitPos);
          return function(offset, value) {
            const n = this.getUint8(offset);
            const b = (n & outsideMask) | ((value & valueMask) << bitPos);
            this.setUint8(offset, b);
          };
        }
      }
    },
  });

  // handle non-standard uints 32-bit or smaller

  mixin({
    getAccessorUint(access, member) {
      const { bitSize, byteSize } = member;
      const f = this.getAccessor(access, { ...member, bitSize: byteSize * 8 });
      const valueMask = (2 ** bitSize) - 1;
      if (access === 'get') {
        return function(offset, littleEndian) {
          const n = f.call(this, offset, littleEndian);
          return n & valueMask;
        };
      } else {
        return function(offset, value, littleEndian) {
          const n = value & valueMask;
          f.call(this, offset, n, littleEndian);
        };
      }
    }
  });

  // handle unaligned ints and floats by copying the bits into a
  // temporary buffer, aligning them

  mixin({
    getAccessorUnaligned(access, member) {
      const { bitSize, bitOffset } = member;
      const bitPos = bitOffset & 0x07;
      const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;
      const buf = new DataView(new ArrayBuffer(byteSize));
      if (access === 'get') {
        const getAligned = this.getAccessor('get', { ...member, byteSize });
        const copyBits = getBitAlignFunction(bitPos, bitSize, true);
        return function(offset, littleEndian) {
          copyBits(buf, this, offset);
          return getAligned.call(buf, 0, littleEndian);
        };
      } else {
        const setAligned = this.getAccessor('set', { ...member, byteSize });
        const applyBits = getBitAlignFunction(bitPos, bitSize, false);
        return function(offset, value, littleEndian) {
          setAligned.call(buf, 0, value, littleEndian);
          applyBits(this, buf, offset);
        };
      }
    }
  });


  function getBitAlignFunction(bitPos, bitSize, toAligned) {
    if (bitPos + bitSize <= 8) {
      const mask = (2 ** bitSize) - 1;
      if (toAligned) {
        // from single byte
        return function(dest, src, offset) {
          const n = src.getUint8(offset);
          const b = (n >> bitPos) & mask;
          dest.setUint8(0, b);
        };
      } else {
        // to single byte
        const destMask = 0xFF ^ (mask << bitPos);
        return function(dest, src, offset) {
          const n = src.getUint8(0);
          const d = dest.getUint8(offset);
          const b = (d & destMask) | ((n & mask) << bitPos);
          dest.setUint8(offset, b);
        };
      }
    } else {
      const leadBits = 8 - bitPos;
      const leadMask = (2 ** leadBits) - 1;
      if (toAligned) {
        const trailBits = bitSize % 8;
        const trailMask = (2 ** trailBits) - 1;
        return function(dest, src, offset) {
          let i = offset, j = 0;
          let n = src.getUint8(i++), b;
          let bitBuf = (n >> bitPos) & leadMask;
          let bitCount = leadBits;
          let remaining = bitSize;
          do {
            if (remaining > bitCount) {
              n = src.getUint8(i++);
              bitBuf = bitBuf | (n << bitCount);
              //bitCount += 8;
            }
            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;
            dest.setUint8(j++, b);
            bitBuf >>= 8;
            //bitCount -= 8;
            remaining -= 8;
          } while (remaining > 0);
        }
      } else {
        const trailBits = (bitSize - leadBits) % 8;
        const trailMask = (2 ** trailBits) - 1;
        const destMask1 = 0xFF ^ (leadMask << bitPos);
        const destMask2 = 0xFF ^ trailMask;
        return function(dest, src, offset) {
          let i = 0, j = offset;
          // preserve bits ahead of bitPos
          let d = dest.getUint8(j), n, b;
          let bitBuf = d & destMask1;
          let bitCount = bitPos;
          let remaining = bitSize + bitCount;
          do {
            if (remaining > bitCount) {
              n = src.getUint8(i++);
              bitBuf = bitBuf | (n << bitCount);
              bitCount += 8;
            }
            if (remaining >= 8) {
              b = bitBuf & 0xFF;
            } else {
              // preserve bits at the destination sitting behind the trailing bits
              d = dest.getUint8(j);
              b = (d & destMask2) | (bitBuf & trailMask);
            }
            dest.setUint8(j++, b);
            bitBuf >>= 8;
            bitCount -= 8;
            remaining -= 8;
          } while (remaining > 0);
        }
      }
    }
  }

  mixin({
    littleEndian: true,
    variables: [],

    getSpecialExports() {
      const check = (v) => {
        if (v === undefined) throw new Error('Not a Zig type');
        return v;
      };
      return {
        init: (...args) => this.initialize?.(...args),
        abandon: () => this.abandonModule?.(),
        released: () => this.released,
        connect: (console) => this.consoleObject = console,
        multithread: (enable) => this.setMultithread?.(enable),
        sizeOf: (T) => check(T[SIZE]),
        alignOf: (T) => check(T[ALIGN]),
        typeOf: (T) => structureNames[check(T[TYPE])]?.toLowerCase(),
      };
    },
    recreateStructures(structures, options) {
      Object.assign(this, options);
      const insertObjects = (dest, placeholders) => {
        for (const [ slot, placeholder ] of Object.entries(placeholders)) {
          dest[slot] = createObject(placeholder);
        }
        return dest;
      };
      const createObject = (placeholder) => {
        const { memory, structure, actual } = placeholder;
        if (memory) {
          if (actual) {
            return actual;
          } else {
            const { array, offset, length } = memory;
            const dv = this.obtainView(array.buffer, offset, length);
            const { reloc, const: isConst } = placeholder;
            const constructor = structure?.constructor;
            const object = placeholder.actual = (constructor)
            ? constructor.call(ENVIRONMENT, dv)
            : { [MEMORY]: dv };
            if (placeholder.slots) {
              insertObjects(object[SLOTS], placeholder.slots);
            }
            if (reloc !== undefined) {
              // need to replace dataview with one pointing to fixed memory later,
              // when the VM is up and running
              this.variables.push({ reloc, object });
            }
            return object;
          }
        } else {
          return structure;
        }
      };
      this.resetGlobalErrorSet?.();
      const objectPlaceholders = new Map();
      for (const structure of structures) {
        // recreate the actual template using the provided placeholder
        for (const scope of [ structure.instance, structure.static ]) {
          if (scope.template) {
            const { slots, memory, reloc } = scope.template;
            const object = scope.template = {};
            if (memory) {
              const { array, offset, length } = memory;
              object[MEMORY] = this.obtainView(array.buffer, offset, length);
              if (reloc) {
                this.variables.push({ reloc, object });
              }
            }
            if (slots) {
              // defer creation of objects until shapes of structures are finalized
              const realSlots = object[SLOTS] = {};
              objectPlaceholders.set(realSlots, slots);
            }
          }
        }
        this.defineStructure(structure);
      }
      // insert objects into template slots
      for (const [ slots, placeholders ] of objectPlaceholders) {
        insertObjects(slots, placeholders);
      }
      // add static members, methods, etc.
      for (const structure of structures) {
        this.finalizeStructure(structure);
      }
    },
  });

  mixin({
    jsFunctionMap: null,
    jsFunctionIdMap: null,
    jsFunctionNextId: 1,

    getFunctionId(fn) {
      if (!this.jsFunctionIdMap) {
        this.jsFunctionIdMap = new WeakMap();
      }
      let id = this.jsFunctionIdMap.get(fn);
      if (id === undefined) {
        id = this.jsFunctionNextId++;
        this.jsFunctionIdMap.set(fn, id);
      }
      return id;
    },
    getFunctionThunk(constructorAddr, funcId) {
      if (!this.jsFunctionThunkMap) {
        this.jsFunctionThunkMap = new Map();
      }
      let dv = this.jsFunctionThunkMap.get(funcId);
      if (dv === undefined) {
        dv = this.runJsThunkConstructor(constructorAddr, funcId);
        if (typeof(dv) === 'string') {
          throw new ZigError(dv);
        }
        this.jsFunctionThunkMap.set(funcId, dv);
      }
      return dv;
    },
    setFunctionCaller(id, caller) {
      if (!this.jsFunctionCallerMap) {
        this.jsFunctionCallerMap = new Map();
      }
      this.jsFunctionCallerMap.set(id, caller);
    },
    runFunction(id, dv, futexHandle) {
      const caller = this.jsFunctionCallerMap.get(id);
      return caller?.(dv, futexHandle) ?? CallResult.Failure;
    },
    ...({
      imports: {
        runJsThunkConstructor: null,
      },
      export: {
        runFunction: null,
      },
    } ),
  });

  class InvalidDeallocation extends ReferenceError {
    constructor(address) {
      super(`Invalid memory deallocation: @${address.toString(16)}`);
    }
  }

  class Unsupported extends TypeError {
    constructor() {
      super(`Unsupported`);
    }
  }

  let NoInitializer$1 = class NoInitializer extends TypeError {
    constructor(structure) {
      const { name } = structure;
      super(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);
    }
  };

  class BufferSizeMismatch extends TypeError {
    constructor(structure, dv, target = null) {
      const { name, type, byteSize } = structure;
      const actual = dv.byteLength;
      const s = (byteSize !== 1) ? 's' : '';
      let msg;
      if (type === StructureType.Slice && !target) {
        msg = `${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`;
      } else {
        const total = (type === StructureType.Slice) ? target.length * byteSize : byteSize;
        msg = `${name} has ${total} byte${s}, received ${actual}`;
      }
      super(msg);
    }
  }

  class BufferExpected extends TypeError {
    constructor(structure) {
      const { type, byteSize, typedArray } = structure;
      const s = (byteSize !== 1) ? 's' : '';
      const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle);
      if (typedArray) {
        acceptable.push(addArticle(typedArray.name));
      }
      let msg;
      if (type === StructureType.Slice) {
        msg = `Expecting ${formatList(acceptable)} that can accommodate items ${byteSize} byte${s} in length`;
      } else {
        msg = `Expecting ${formatList(acceptable)} that is ${byteSize} byte${s} in length`;
      }
      super(msg);
    }
  }

  class EnumExpected extends TypeError {
    constructor(structure, arg) {
      const { name } = structure;
      let msg;
      if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {
        msg = `Value given does not correspond to an item of enum ${name}: ${arg}`;
      } else {
        msg = `Enum item of the type ${name} expected, received ${arg}`;
      }
      super(msg);
    }
  }

  class ErrorExpected extends TypeError {
    constructor(structure, arg) {
      const { name } = structure;
      const type = typeof(arg);
      let msg;
      if (type === 'string' || type === 'number' || isErrorJSON(arg)) {
        if (isErrorJSON(arg)) {
          arg = `{ error: ${JSON.stringify(arg.error)} }`;
        }
        msg = `Error ${type} does not corresponds to any error in error set ${name}: ${arg}`;
      } else {
        msg = `Error of the type ${name} expected, received ${arg}`;
      }
      super(msg);
    }
  }

  class NotInErrorSet extends TypeError {
    constructor(structure) {
      const { name } = structure;
      super(`Error given is not a part of error set ${name}`);
    }
  }

  class MultipleUnionInitializers extends TypeError {
    constructor(structure) {
      const { name } = structure;
      super(`Only one property of ${name} can be given a value`);
    }
  }

  class InactiveUnionProperty extends TypeError {
    constructor(structure, name, currentName) {
      super(`Accessing property ${name} when ${currentName} is active`);
    }
  }

  class MissingUnionInitializer extends TypeError {
    constructor(structure, arg, exclusion) {
      const { name, instance: { members } } = structure;
      const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);
      super(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);
    }
  }

  class InvalidInitializer extends TypeError {
    constructor(structure, expected, arg) {
      const { name } = structure;
      const acceptable = [];
      if (Array.isArray(expected)) {
        for (const type of expected) {
          acceptable.push(addArticle(type));
        }
      } else {
        acceptable.push(addArticle(expected));
      }
      const received = getDescription(arg);
      super(`${name} expects ${formatList(acceptable)} as argument, received ${received}`);
    }
  }

  class InvalidArrayInitializer extends InvalidInitializer {
    constructor(structure, arg, shapeless = false) {
      const { instance: { members: [ member ] }, type, constructor } = structure;
      const acceptable = [];
      const primitive = getPrimitiveName(member);
      if (primitive) {
        let object;
        switch (member.structure?.type) {
          case StructureType.Enum: object = 'enum item'; break;
          case StructureType.ErrorSet: object = 'error'; break;
          default: object = primitive;
        }
        acceptable.push(`array of ${object}s`);
      } else {
        acceptable.push(`array of objects`);
      }
      if (constructor[TYPED_ARRAY]) {
        acceptable.push(constructor[TYPED_ARRAY].name);
      }
      if (type === StructureType.Slice && shapeless) {
        acceptable.push(`length`);
      }
      super(structure, acceptable.join(' or '), arg);
    }
  }

  class ArrayLengthMismatch extends TypeError {
    constructor(structure, target, arg) {
      const { name, length, instance: { members: [ member ] } } = structure;
      const { structure: { constructor: elementConstructor} } = member;
      const { length: argLength, constructor: argConstructor } = arg;
      // get length from object whech it's a slice
      const actualLength = target?.length ?? length;
      const s = (actualLength !== 1) ? 's' : '';
      let received;
      if (argConstructor === elementConstructor) {
        received = `only a single one`;
      } else if (argConstructor.child === elementConstructor) {
        received = `a slice/array that has ${argLength}`;
      } else {
        received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;
      }
      super(`${name} has ${actualLength} element${s}, received ${received}`);
    }
  }

  class InvalidSliceLength extends TypeError {
    constructor(length, max) {
      if (length < 0) {
        super(`Length of slice cannot be negative`);
      } else {
        super(`Length of slice can be ${max} or less, received ${length}`);
      }
    }
  }

  class MissingInitializers extends TypeError {
    constructor(structure, missing) {
      const { name } = structure;
      super(`Missing initializers for ${name}: ${missing.join(', ')}`);
    }
  }

  class NoProperty extends TypeError {
    constructor(structure, propName) {
      const { name, instance: { members } } = structure;
      const member = members.find(m => m.name === propName);
      let msg;
      if (member) {
        msg = `Comptime value cannot be changed: ${propName}`;
      } else {
        msg = `${name} does not have a property with that name: ${propName}`;
      }
      super(msg);
    }
  }

  class ArgumentCountMismatch extends Error {
    constructor(name, expected, actual) {
      const s = (expected !== 1) ? 's' : '';
      super(`${name}() expects ${expected} argument${s}, received ${actual}`);
    }
  }

  class NoCastingToPointer extends TypeError {
    constructor(structure) {
      super(`Non-slice pointers can only be created with the help of the new operator`);
    }
  }

  class ConstantConstraint extends TypeError {
    constructor(structure, pointer) {
      const { name: target } = structure;
      const { constructor: { name } } = pointer;
      super(`Conversion of ${name} to ${target} requires an explicit cast`);
    }
  }

  class MisplacedSentinel extends TypeError {
    constructor(structure, value, index, length) {
      const { name } = structure;
      super(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);
    }
  }

  class MissingSentinel extends TypeError {
    constructor(structure, value, length) {
      const { name } = structure;
      super(`${name} expects the sentinel value ${value} at ${length - 1}`);
    }
  }

  class AlignmentConflict extends TypeError {
    constructor(align1, align2) {
      super(`Unable to simultaneously align memory to ${align2}-byte and ${align1}-byte boundary`);
    }
  }

  class TypeMismatch extends TypeError {
    constructor(expected, arg) {
      const received = getDescription(arg);
      super(`Expected ${addArticle(expected)}, received ${received}`);
    }
  }

  class InaccessiblePointer extends TypeError {
    constructor() {
      super(`Pointers within an untagged union are not accessible`);
    }
  }

  class NullPointer extends TypeError {
    constructor() {
      super(`Null pointer`);
    }
  }

  class InvalidPointerTarget extends TypeError {
    constructor(structure, arg) {
      const { name } = structure;
      let target;
      if (arg != null) {
        const type = typeof(arg);
        const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;
        const a = article(noun);
        target = `${a} ${noun}`;
      } else {
        target = arg + '';
      }
      super(`${name} cannot point to ${target}`);
    }
  }

  class FixedMemoryTargetRequired extends TypeError {
    constructor(structure, arg) {
      super(`Pointers in fixed memory cannot point to garbage-collected object`);
    }
  }

  class Overflow extends TypeError {
    constructor(member, value) {
      const typeName = getTypeName(member);
      super(`${typeName} cannot represent the value given: ${value}`);
    }
  }

  class OutOfBound extends RangeError {
    constructor(member, index) {
      const { name } = member;
      super(`Index exceeds the size of ${name ?? 'array'}: ${index}`);
    }
  }

  class NotUndefined extends TypeError {
    constructor(member) {
      const { name } = member;
      const rvalue = (name !== undefined) ? `Property ${name}` : `Element`;
      super(`${rvalue} can only be undefined`);
    }
  }

  class NotOnByteBoundary extends TypeError {
    constructor(member) {
      const { name, structure: { name: { struct }} } = member;
      super(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);
    }
  }

  class ReadOnly extends TypeError {
    constructor() {
      super(`Unable to modify read-only object`);
    }
  }

  class ReadOnlyTarget extends TypeError {
    constructor(structure) {
      const { name } = structure;
      super(`${name} cannot point to a read-only object`);
    }
  }

  class AccessingOpaque extends TypeError {
    constructor(structure) {
      const { name } = structure;
      super(`Unable to access opaque structure ${name}`);
    }
  }

  class CreatingOpaque extends TypeError {
    constructor(structure) {
      const { name } = structure;
      super(`Unable to create instance of ${name}, as it is opaque`);
    }
  }

  class InvalidVariadicArgument extends TypeError {
    constructor() {
      super(`Arguments passed to variadic function must be casted to a Zig type`);
    }
  }

  let ZigError$1 = class ZigError extends Error {
    constructor() {
      super(`Error encountered in Zig code`);
    }
  };

  function adjustArgumentError(name, index, argCount, err) {
    // Zig currently does not provide the argument name
    const argName = `args[${index}]`;
    const prefix = (index !== 0) ? '..., ' : '';
    const suffix = (index !== argCount - 1) ? ', ...' : '';
    const argLabel = prefix + argName + suffix;
    const newError = Object.create(err.constructor.prototype);
    newError.message = `${name}(${argLabel}): ${err.message}`;
    newError.stack = err.stack;
    return newError;
  }

  function adjustRangeError(member, index, err) {
    if (err instanceof RangeError && !(err instanceof OutOfBound)) {
      err = new OutOfBound(member, index);
    }
    return err;
  }

  function throwReadOnly() {
    throw new ReadOnly();
  }

  function warnImplicitArrayCreation(structure, arg) {
    const created = addArticle(structure.constructor[TYPED_ARRAY].name);
    const source = addArticle(arg.constructor.name);
    console.warn(`Implicitly creating ${created} from ${source}`);
  }

  function deanimalizeErrorName(name) {
    // deal with snake_case first
    let s = name.replace(/_/g, ' ');
    // then camelCase, using a try block in case Unicode regex fails
    try {
      s = s.replace(/(\p{Uppercase}+)(\p{Lowercase}*)/gu, (m0, m1, m2) => {
        if (m1.length === 1) {
          return ` ${m1.toLocaleLowerCase()}${m2}`;
        } else {
          if (m2) {
            return m0;
          } else {
            return ` ${m1}`;
          }
        }
      }).trimStart();
      /* c8 ignore next 2 */
    } catch (err) {
    }
    return s.charAt(0).toLocaleUpperCase() + s.substring(1);
  }

  function isErrorJSON(arg) {
    return typeof(arg) === 'object' && typeof(arg.error) === 'string' && Object.keys(arg).length === 1  ;
  }

  function getDescription(arg) {
    const type = typeof(arg);
    let s;
    if (type === 'object') {
      s = (arg) ? Object.prototype.toString.call(arg) : 'null';
    } else {
      s = type;
    }
    return addArticle(s);
  }

  function addArticle(noun) {
    return `${article(noun)} ${noun}`;
  }

  function article(noun) {
    return /^\W*[aeiou]/i.test(noun) ? 'an' : 'a';
  }

  function formatList(list, conj = 'or') {
    const sep = ` ${conj} `;
    if (list.length > 2) {
      return list.slice(0, -1).join(', ') + sep + list[list.length - 1];
    } else {
      return list.join(sep);
    }
  }

  mixin({
    context: undefined,
    contextStack: [],

    startContext() {
      if (this.context) {
        this.contextStack.push(this.context);
      }
      this.context = new CallContext();
    },
    endContext() {
      this.context = this.contextStack.pop();
    },
    ...({
      imports: {
        runThunk: null,
        runVariadicThunk: null,
      },

      invokeThunk(thunkAddress, fnAddress, args) {
        // create an object where information concerning pointers can be stored
        this.startContext();
        const hasPointers = args[VISIT];
        const attrs = args[ATTRIBUTES];
        if (hasPointers) {
          // copy addresses of garbage-collectible objects into memory
          this.updatePointerAddresses(args);
          this.updateShadows();
        }
        const success = (attrs)
        ? this.runVariadicThunk(thunkAddress, fnAddress, args[MEMORY], attrs[MEMORY])
        : this.runThunk(thunkAddress, fnAddress, args[MEMORY]);
        if (hasPointers) {
          // create objects that pointers point to
          this.updateShadowTargets();
          this.updatePointerTargets(args);
          this.releaseShadows();
        }
        // restore the previous context if there's one
        this.endContext();
        if (!this.context) {
          this.flushConsole();
        }
        // errors returned by exported Zig functions are normally written into the
        // argument object and get thrown when we access its retval property (a zig error union)
        // if the thunk returns false, it indicates a problem in the thunking process
        // (i.e. bugs in export.zig)
        if (!success) {
          throw new ZigError$1();
        }
      },
    } ),
  });

  class CallContext {
    pointerProcessed = new Map();
    memoryList = [];
    shadowMap = null;
    call = 0;
  }

  mixin({
    defineCopier(size, multiple) {
      const copy = getCopyFunction(size, multiple);
      return {
        value(target) {
          const src = target[MEMORY];
          const dest = this[MEMORY];
          copy(dest, src);
        },
      };
    },
    defineResetter(offset, size) {
      const reset = getResetFunction(size);
      return {
        value() {
          const dest = this[MEMORY];
          reset(dest, offset, size);
        }
      };
    },
    getCopyFunction,
  });

  function getCopyFunction(size, multiple = false) {
    if (size !== undefined) {
      if (!multiple) {
        const copier = copiers[size];
        if (copier) {
          return copier;
        }
      }
      if (!(size & 0x07)) return copy8x;
      if (!(size & 0x03)) return copy4x;
      if (!(size & 0x01)) return copy2x;
      return copy1x;
    } else {
      return copyAny;
    }
  }

  function copyAny(dest, src) {
    const copy = getCopyFunction(dest.byteLength);
    copy(dest, src);
  }

  const copiers = {
    1: copy1,
    2: copy2,
    4: copy4,
    8: copy8,
    16: copy16,
    32: copy32,
  };

  function copy1x(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i++) {
      dest.setInt8(i, src.getInt8(i));
    }
  }

  function copy2x(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i += 2) {
      dest.setInt16(i, src.getInt16(i, true), true);
    }
  }

  function copy4x(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i += 4) {
      dest.setInt32(i, src.getInt32(i, true), true);
    }
  }

  function copy8x(dest, src) {
    for (let i = 0, len = dest.byteLength; i < len; i += 8) {
      dest.setInt32(i, src.getInt32(i, true), true);
      dest.setInt32(i + 4, src.getInt32(i + 4, true), true);
    }
  }

  function copy1(dest, src) {
    dest.setInt8(0, src.getInt8(0));
  }

  function copy2(dest, src) {
    dest.setInt16(0, src.getInt16(0, true), true);
  }

  function copy4(dest, src) {
    dest.setInt32(0, src.getInt32(0, true), true);
  }

  function copy8(dest, src) {
    dest.setInt32(0, src.getInt32(0, true), true);
    dest.setInt32(4, src.getInt32(4, true), true);
  }

  function copy16(dest, src) {
    dest.setInt32(0, src.getInt32(0, true), true);
    dest.setInt32(4, src.getInt32(4, true), true);
    dest.setInt32(8, src.getInt32(8, true), true);
    dest.setInt32(12, src.getInt32(12, true), true);
  }

  function copy32(dest, src) {
    dest.setInt32(0, src.getInt32(0, true), true);
    dest.setInt32(4, src.getInt32(4, true), true);
    dest.setInt32(8, src.getInt32(8, true), true);
    dest.setInt32(12, src.getInt32(12, true), true);
    dest.setInt32(16, src.getInt32(16, true), true);
    dest.setInt32(20, src.getInt32(20, true), true);
    dest.setInt32(24, src.getInt32(24, true), true);
    dest.setInt32(28, src.getInt32(28, true), true);
  }

  function getResetFunction(size) {
    const resetter = resetters[size];
    if (resetter) {
      return resetter;
    }
    if (!(size & 0x07)) return reset8x;
    if (!(size & 0x03)) return reset4x;
    if (!(size & 0x01)) return reset2x;
    return reset1x;
  }

  const resetters = {
    1: reset1,
    2: reset2,
    4: reset4,
    8: reset8,
    16: reset16,
    32: reset32,
  };

  function reset1x(dest, offset, size) {
    for (let i = offset, limit = offset + size; i < limit; i++) {
      dest.setInt8(i, 0);
    }
  }

  function reset2x(dest, offset, size) {
    for (let i = offset, limit = offset + size; i < limit; i += 2) {
      dest.setInt16(i, 0, true);
    }
  }

  function reset4x(dest, offset, size) {
    for (let i = offset, limit = offset + size; i < limit; i += 4) {
      dest.setInt32(i, 0, true);
    }
  }

  function reset8x(dest, offset, size) {
    for (let i = offset, limit = offset + size; i < limit; i += 8) {
      dest.setInt32(i, 0, true);
      dest.setInt32(i + 4, 0, true);
    }
  }

  function reset1(dest, offset) {
    dest.setInt8(offset, 0);
  }

  function reset2(dest, offset) {
    dest.setInt16(offset, 0, true);
  }

  function reset4(dest, offset) {
    dest.setInt32(offset, 0, true);
  }

  function reset8(dest, offset) {
    dest.setInt32(offset + 0, 0, true);
    dest.setInt32(offset + 4, 0, true);
  }

  function reset16(dest, offset) {
    dest.setInt32(offset + 0, 0, true);
    dest.setInt32(offset + 4, 0, true);
    dest.setInt32(offset + 8, 0, true);
    dest.setInt32(offset + 12, 0, true);
  }

  function reset32(dest, offset) {
    dest.setInt32(offset + 0, 0, true);
    dest.setInt32(offset + 4, 0, true);
    dest.setInt32(offset + 8, 0, true);
    dest.setInt32(offset + 12, 0, true);
    dest.setInt32(offset + 16, 0, true);
    dest.setInt32(offset + 20, 0, true);
    dest.setInt32(offset + 24, 0, true);
    dest.setInt32(offset + 28, 0, true);
  }

  mixin({
    addIntConversion(getAccessor) {
      return function (access, member) {
        const accessor = getAccessor.call(this, access, member);
        if (access === 'set') {
          const Type = (member.bitSize > 32) ? BigInt : Number;
          return function(offset, value, littleEndian) {
            accessor.call(this, offset, Type(value), littleEndian);
          };
        } else {
          if (member.flags & MemberFlag.IsSize) {
            return function(offset, littleEndian) {
              return Number(accessor.call(this, offset, littleEndian));
            };
          }
        }
        return accessor;
      };
    },
  });

  mixin({
    emptyBuffer: new ArrayBuffer(0),

    getShadowAddress(target, cluster) {
      if (cluster) {
        const dv = target[MEMORY];
        if (cluster.address === undefined) {
          const shadow = this.createClusterShadow(cluster);
          cluster.address = this.getViewAddress(shadow[MEMORY]);
        }
        return adjustAddress(cluster.address, dv.byteOffset - cluster.start);
      } else {
        const shadow = this.createShadow(target);
        return this.getViewAddress(shadow[MEMORY]);
      }
    },
    createShadow(object) {
      const dv = object[MEMORY];
      // use the alignment of the structure; in the case of an opaque pointer's target,
      // try to the alignment specified when the memory was allocated
      const align = object.constructor[ALIGN] ?? dv[ALIGN];
      const shadow = Object.create(object.constructor.prototype);
      shadow[MEMORY] = this.allocateShadowMemory(dv.byteLength, align);
      return this.addShadow(shadow, object, align);
    },
    addShadow(shadow, object, align) {
      const shadowMap = this.context.shadowMap ??= new Map();
      shadowMap.set(shadow, object);
      this.registerMemory(shadow[MEMORY], object[MEMORY], align);
      return shadow;
    },
    removeShadow(dv) {
      const { shadowMap } = this.context;
      if (shadowMap) {
        for (const [ shadow ] of shadowMap) {
          if (shadow[MEMORY] === dv) {
            shadowMap.delete(shadow);
            break;
          }
        }
      }
    },
    createClusterShadow(cluster) {
      const { start, end, targets } = cluster;
      // look for largest align
      let maxAlign = 0, maxAlignOffset;
      for (const target of targets) {
        const dv = target[MEMORY];
        const offset = dv.byteOffset;
        const align = target.constructor[ALIGN] ?? dv[ALIGN];
        if (maxAlign === undefined || align > maxAlign) {
          maxAlign = align;
          maxAlignOffset = offset;
        }
      }
      // ensure the shadow buffer is large enough to accommodate necessary adjustments
      const len = end - start;
      const unalignedShadowDV = this.allocateShadowMemory(len + maxAlign, 1);
      const unalignedAddress = this.getViewAddress(unalignedShadowDV);
      const maxAlignAddress = alignForward(adjustAddress(unalignedAddress, maxAlignOffset - start), maxAlign);
      const shadowAddress = adjustAddress(maxAlignAddress, start - maxAlignOffset);
      const shadowOffset = unalignedShadowDV.byteOffset + Number(shadowAddress - unalignedAddress);
      const shadowDV = new DataView(unalignedShadowDV.buffer, shadowOffset, len);
      // make sure that other pointers are correctly aligned also
      for (const target of targets) {
        const dv = target[MEMORY];
        const offset = dv.byteOffset;
        if (offset !== maxAlignOffset) {
          const align = target.constructor[ALIGN] ?? dv[ALIGN];
          if (isMisaligned(adjustAddress(shadowAddress, offset - start), align)) {
            throw new AlignmentConflict(align, maxAlign);
          }
        }
      }
      // placeholder object type
      const prototype = defineProperty({}, COPY, this.defineCopier(len, false));
      const source = Object.create(prototype);
      const shadow = Object.create(prototype);
      source[MEMORY] = new DataView(targets[0][MEMORY].buffer, Number(start), len);
      shadow[MEMORY] = shadowDV;
      return this.addShadow(shadow, source, 1);
    },
    updateShadows() {
      const { shadowMap } = this.context;
      if (!shadowMap) {
        return;
      }
      for (const [ shadow, object ] of shadowMap) {
        shadow[COPY](object);
      }
    },
    updateShadowTargets() {
      const { shadowMap } = this.context;
      if (!shadowMap) {
        return;
      }
      for (const [ shadow, object ] of shadowMap) {
        object[COPY](shadow);
      }
    },
    releaseShadows() {
      const { shadowMap } = this.context;
      if (!shadowMap) {
        return;
      }
      for (const [ shadow ] of shadowMap) {
        this.freeShadowMemory(shadow[MEMORY]);
      }
    },
    registerMemory(dv, targetDV = null, targetAlign = undefined) {
      const { memoryList } = this.context;
      const address = this.getViewAddress(dv);
      const index = findMemoryIndex(memoryList, address);
      memoryList.splice(index, 0, { address, dv, len: dv.byteLength, targetDV, targetAlign });
      return address;
    },
    unregisterMemory(address) {
      const { memoryList } = this.context;
      const index = findMemoryIndex(memoryList, address);
      const entry = memoryList[index - 1];
      if (entry?.address === address) {
        memoryList.splice(index - 1, 1);
        return entry.dv;
      }
    },
    findMemory(address, count, size) {
      if (isInvalidAddress(address)) {
        if (!count) {
          address = 0;
        } else {
          return null;
        }
      } else if (!address && count) {
        return null;
      }
      let len = count * (size ?? 0);
      // check for null address (=== can't be used since address can be both number and bigint)
      if (this.context) {
        const { memoryList } = this.context;
        const index = findMemoryIndex(memoryList, address);
        const entry = memoryList[index - 1];
        if (entry?.address === address && entry.len === len) {
          return entry.targetDV ?? entry.dv;
        } else if (entry?.address <= address && address < adjustAddress(entry.address, entry.len)) {
          const offset = Number(address - entry.address);
          const targetDV = entry.targetDV ?? entry.dv;
          const isOpaque = size === undefined;
          if (isOpaque) {
            len = targetDV.byteLength - offset;
          }
          const dv = this.obtainView(targetDV.buffer, targetDV.byteOffset + offset, len);
          if (isOpaque) {
            // opaque structure--need to save the alignment
            dv[ALIGN] = entry.targetAlign;
          }
          return dv;
        }
      }
      // not found in any of the buffers we've seen--assume it's fixed memory
      return this.obtainFixedView(address, len);
    },
    allocateFixedMemory(len, align, type = MemoryType.Normal) {
      const address = (len) ? this.allocateExternMemory(type, len, align) : 0;
      const dv = this.obtainFixedView(address, len);
      dv[FIXED].align = align;
      dv[FIXED].type = type;
      return dv;
    },
    freeFixedMemory(dv) {
      const { address, unalignedAddress, len, align, type } = dv[FIXED];
      if (len) {
        this.freeExternMemory(type, unalignedAddress ?? address, len, align);
      }
    },
    obtainFixedView(address, len) {
      let dv;
      if (address && len) {
        dv = this.obtainExternView(address, len);
      } else {
        // pointer to nothing
        let entry = this.viewMap.get(this.emptyBuffer);
        if (!entry) {
          this.viewMap.set(this.emptyBuffer, entry = {});
        }
        const key = `${address}:0`;
        dv = entry[key];
        if (!dv) {
          dv = entry[key] = new DataView(this.emptyBuffer);
          dv[FIXED] = { address, len: 0 };
        }
      }
      return dv;
    },
    releaseFixedView(dv) {
      // only allocated memory would have type attached
      if (dv[FIXED]?.type !== undefined) {
        this.freeFixedMemory(dv);
        dv[FIXED] = null;
      }
    },
    getViewAddress(dv) {
      const fixed = dv[FIXED];
      if (fixed) {
        return fixed.address;
      } else {
        const address = this.getBufferAddress(dv.buffer);
        return adjustAddress(address, dv.byteOffset);
      }
    },
    ...({
      imports: {
        allocateExternMemory: null,
        freeExternMemory: null,
        getBufferAddress: null,
        copyExternBytes: null,
      },
      exports: {
        allocateHostMemory: null,
        freeHostMemory: null,
        getViewAddress: null,
      },

      allocateHostMemory(len, align) {
        const dv = this.allocateRelocMemory(len, align);
        this.registerMemory(dv);
        return dv;
      },
      freeHostMemory(address, len, align) {
        // no freeing actually occurs--memory will await garbage collection
        const dv = this.unregisterMemory(address);
        if (!dv) {
          throw new InvalidDeallocation(address);
        }
      },
      allocateShadowMemory(len, align) {
        // Node can read into JavaScript memory space so we can keep shadows there
        return this.allocateRelocMemory(len, align);
      },
      freeShadowMemory(dv) {
        // nothing needs to happen
      },
      obtainExternView(address, len) {
        const buffer = this.obtainExternBuffer(address, len);
        buffer[FIXED] = { address, len };
        return this.obtainView(buffer, 0, len);
      },
      getTargetAddress(target, cluster) {
        const dv = target[MEMORY];
        if (cluster) {
          // pointer is pointing to buffer with overlapping views
          if (cluster.misaligned === undefined) {
            const address = this.getBufferAddress(dv.buffer);
            // ensure that all pointers are properly aligned
            for (const target of cluster.targets) {
              const offset = target[MEMORY].byteOffset;
              const align = target.constructor[ALIGN];
              const viewAddress = adjustAddress(address, offset);
              if (isMisaligned(viewAddress, align)) {
                cluster.misaligned = true;
                break;
              }
            }
            if (cluster.misaligned === undefined)  {
              cluster.misaligned = false;
              cluster.address = address;
            }
          }
          if (!cluster.misaligned) {
            return adjustAddress(cluster.address, dv.byteOffset);
          }
        } else {
          const align = target.constructor[ALIGN];
          const address = this.getViewAddress(dv);
          if (!isMisaligned(address, align)) {
            this.registerMemory(dv);
            return address;
          }
        }
        // need shadowing
      },
    } ),
  });

  function findMemoryIndex(array, address) {
    return findSortedIndex(array, address, m => m.address);
  }

  const MemoryType = {
    Normal: 0,
    Scratch: 1,
  };

  mixin({
    exports: {},
    imports: {},
    released: false,
    abandoned: false,

    releaseFunctions() {
      const throwError = () => { throw new Error(`Module was abandoned`) };
      for (const name of Object.keys(this.imports)) {
        if (this[name]) {
          this[name] = throwError;
        }
      }
    },
    isReleased() {
      return this.released;
    },
    abandonModule() {
      if (!this.abandoned) {
        this.setMultithread?.(false);
        this.releaseFunctions();
        this.unlinkVariables?.();
        this.abandoned = true;
      }
    },
    ...({
      exportFunctions() {
        const imports = {};
        for (const [ name, alias ] of Object.entries(this.exports)) {
          const fn = this[alias ?? name];
          imports[name] = fn.bind(this);
        }
        return imports;
      },
      importFunctions(exports) {
        for (const [ name, alias ] of Object.entries(this.imports)) {
          const fn = exports[alias ?? name];
          this[name] = fn;
        }
      },
    } )
  });

  mixin({
    linkVariables(writeBack) {
      const pointers = [];
      for (const { object, reloc } of this.variables) {
        this.linkObject(object, reloc, writeBack);
        if (TARGET in object && object[SLOTS][0]) {
          pointers.push(object);
        }
      }
      // save locations of pointer targets
      for (const pointer of pointers) {
        const target = pointer[TARGET];
        const address = this.getViewAddress(target[MEMORY]);
        pointer[ADDRESS] = address;
        if (LENGTH in pointer) {
          pointer[LENGTH] = target.length;
        }
      }
    },
    linkObject(object, reloc, writeBack) {
      if (object[MEMORY][FIXED]) {
        return;
      }
      const dv = object[MEMORY];
      const address = this.recreateAddress(reloc);
      const fixedDV = this.obtainFixedView(address, dv.byteLength);
      if (writeBack) {
        const dest = Object.create(object.constructor.prototype);
        dest[MEMORY] = fixedDV;
        dest[COPY](object);
      }
      object[MEMORY] = fixedDV;
      const linkChildren = (object) => {
        if (object[SLOTS]) {
          for (const child of Object.values(object[SLOTS])) {
            if (child) {
              const childDV = child[MEMORY];
              if (childDV.buffer === dv.buffer) {
                const offset = childDV.byteOffset - dv.byteOffset;
                child[MEMORY] = this.obtainView(fixedDV.buffer, offset, childDV.byteLength);
                linkChildren(child);
              }
            }
          }
        }
      };
      linkChildren(object);
    },
    unlinkVariables() {
      for (const { object } of this.variables) {
        this.unlinkObject(object);
      }
    },
    unlinkObject(object) {
      if (!object[MEMORY][FIXED]) {
        return;
      }
      const dv = object[MEMORY];
      const relocDV = this.allocateMemory(dv.byteLength);
      if (object[COPY]) {
        const dest = Object.create(object.constructor.prototype);
        dest[MEMORY] = relocDV;
        dest[COPY](object);
      }
      object[MEMORY] = relocDV;
    },
    ...({
      imports: {
        recreateAddress: null,
      },
    } ),
  });

  mixin({
    updatePointerAddresses(args) {
      // first, collect all the pointers
      const pointerMap = new Map();
      const bufferMap = new Map();
      const potentialClusters = [];
      const callback = function({ isActive }) {
        if (isActive(this)) {
          // bypass proxy
          const pointer = this[POINTER];
          if (!pointerMap.get(pointer)) {
            const target = pointer[SLOTS][0];
            if (target) {
              pointerMap.set(pointer, target);
              // only relocatable targets need updating
              const dv = target[MEMORY];
              if (!dv[FIXED]) {
                // see if the buffer is shared with other objects
                const other = bufferMap.get(dv.buffer);
                if (other) {
                  const array = Array.isArray(other) ? other : [ other ];
                  const index = findSortedIndex(array, dv.byteOffset, t => t[MEMORY].byteOffset);
                  array.splice(index, 0, target);
                  if (!Array.isArray(other)) {
                    bufferMap.set(dv.buffer, array);
                    potentialClusters.push(array);
                  }
                } else {
                  bufferMap.set(dv.buffer, target);
                }
                // scan pointers in target
                target[VISIT]?.(callback);
              }
            }
          }
        }
      };
      args[VISIT](callback);
      // find targets that overlap each other
      const clusters = this.findTargetClusters(potentialClusters);
      const clusterMap = new Map();
      for (const cluster of clusters) {
        for (const target of cluster.targets) {
          clusterMap.set(target, cluster);
        }
      }
      // process the pointers
      for (const [ pointer, target ] of pointerMap) {
        const cluster = clusterMap.get(target);
        const address = this.getTargetAddress(target, cluster) ?? this.getShadowAddress(target, cluster);
        // update the pointer
        pointer[ADDRESS] = address;
        if (LENGTH in pointer) {
          pointer[LENGTH] = target.length;
        }
      }
    },
    updatePointerTargets(args) {
      const pointerMap = new Map();
      const callback = function({ isActive, isMutable }) {
        // bypass proxy
        const pointer = this[POINTER] ?? this;
        if (!pointerMap.get(pointer)) {
          pointerMap.set(pointer, true);
          const writable = !pointer.constructor.const;
          const currentTarget = pointer[SLOTS][0];
          const newTarget = (!currentTarget || isMutable(this))
          ? pointer[UPDATE](true, isActive(this))
          : currentTarget;
          // update targets of pointers in original target (which could have been altered)
          currentTarget?.[VISIT]?.(callback, { vivificate: true, isMutable: () => writable });
          if (newTarget !== currentTarget) {
            // acquire targets of pointers in new target
            newTarget?.[VISIT]?.(callback, { vivificate: true, isMutable: () => writable });
          }
        }
      };
      args[VISIT](callback, { vivificate: true });
    },
    findTargetClusters(potentialClusters) {
      const clusters = [];
      for (const targets of potentialClusters) {
        let prevTarget = null, prevStart = 0, prevEnd = 0;
        let currentCluster = null;
        for (const target of targets) {
          const dv = target[MEMORY];
          const { byteOffset: start, byteLength } = dv;
          const end = start + byteLength;
          let forward = true;
          if (prevTarget) {
            if (prevEnd > start) {
              // the previous target overlaps this one
              if (!currentCluster) {
                currentCluster = {
                  targets: [ prevTarget ],
                  start: prevStart,
                  end: prevEnd,
                  address: undefined,
                  misaligned: undefined,
                };
                clusters.push(currentCluster);
              }
              currentCluster.targets.push(target);
              if (end > prevEnd) {
                // set cluster end offset to include this one
                currentCluster.end = end;
              } else {
                // the previous target contains this one
                forward = false;
              }
            } else {
              currentCluster = null;
            }
          }
          if (forward) {
            prevTarget = target;
            prevStart = start;
            prevEnd = end;
          }
        }
      }
      return clusters;
    },
  });

  mixin({
    imports: {
      isRuntimeSafetyActive: { argType: '', returnType: 'b' },
    },

    addRuntimeCheck(getAccessor) {
      return function (access, member) {
        const accessor = getAccessor.call(this, access, member);
        if (access === 'set') {
          const { min, max } = getIntRange(member);
          return function(offset, value, littleEndian) {
            if (value < min || value > max) {
              throw new Overflow(member, value);
            }
            accessor.call(this, offset, value, littleEndian);
          };
        }
        return accessor;
      };
    },
  });

  function getIntRange(member) {
    const { type, bitSize } = member;
    const signed = (type === MemberType.Int);
    let magBits = (signed) ? bitSize - 1 : bitSize;
    if (bitSize <= 32) {
      const max = 2 ** magBits - 1;
      const min = (signed) ? -(2 ** magBits) : 0;
      return { min, max };
    } else {
      magBits = BigInt(magBits);
      const max = 2n ** magBits - 1n;
      const min = (signed) ? -(2n ** magBits) : 0n;
      return { min, max };
    }
  }

  mixin({
    consoleObject: null,
    consolePending: [],
    consoleTimeout: 0,

    writeToConsole(dv) {
      try {
        // make copy of array, in case incoming buffer is pointing to stack memory
        const array = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength).slice();
        // send text up to the last newline character
        const index = array.lastIndexOf(0x0a);
        if (index === -1) {
          this.consolePending.push(array);
        } else {
          const beginning = array.subarray(0, index);
          const remaining = array.subarray(index + 1);
          this.writeToConsoleNow([ ...this.consolePending, beginning ]);
          this.consolePending.splice(0);
          if (remaining.length > 0) {
            this.consolePending.push(remaining);
          }
        }
        clearTimeout(this.consoleTimeout);
        this.consoleTimeout = 0;
        if (this.consolePending.length > 0) {
          this.consoleTimeout = setTimeout(() => {
            this.writeToConsoleNow(this.consolePending);
            this.consolePending.splice(0);
          }, 250);
        }
        /* c8 ignore next 3 */
      } catch (err) {
        console.error(err);
      }
    },
    writeToConsoleNow(array) {
      const c = this.consoleObject ?? globalThis.console;
      c.log?.call?.(c, decodeText(array));
    },
    flushConsole() {
      if (this.consolePending.length > 0) {
        this.writeToConsoleNow(this.consolePending);
        this.consolePending.splice(0);
        clearTimeout(this.consoleTimeout);
      }
    },
    ...({
      imports: {
        flushStdout: null,
      },
    } ),
  });

  mixin({
    comptime: false,
    slots: {},
    structures: [],

    readSlot(target, slot) {
      const slots = target ? target[SLOTS] : this.slots;
      return slots?.[slot];
    },
    writeSlot(target, slot, value) {
      const slots = target ? target[SLOTS] : this.slots;
      if (slots) {
        slots[slot] = value;
      }
    },
    createTemplate(dv) {
      return {
        [MEMORY]: dv,
        [SLOTS]: {}
      };
    },
    beginStructure(def) {
      const {
        type,
        name,
        length,
        byteSize,
        align,
        flags,
      } = def;
      return {
        constructor: null,
        type,
        name,
        length,
        byteSize,
        align,
        flags,
        instance: {
          members: [],
          template: null,
        },
        static: {
          members: [],
          template: null,
        },
      };
    },
    attachMember(structure, member, isStatic = false) {
      const target = (isStatic) ? structure.static : structure.instance;
      target.members.push(member);
    },
    attachTemplate(structure, template, isStatic = false) {
      const target = (isStatic) ? structure.static : structure.instance;
      target.template = template;
    },
    endStructure(structure) {
      this.structures.push(structure);
      this.finalizeStructure(structure);
    },
    captureView(address, len, copy) {
      if (copy) {
        // copy content into reloctable memory
        const dv = this.allocateRelocMemory(len, 0);
        if (len > 0) {
          this.copyBytes(dv, address, len);
        }
        return dv;
      } else {
        // link into fixed memory
        return this.obtainFixedView(address, len);
      }
    },
    castView(address, len, copy, structure) {
      const { constructor, flags } = structure;
      const dv = this.captureView(address, len, copy);
      const object = constructor.call(ENVIRONMENT, dv);
      if (flags & StructureFlag.HasPointer) {
        // acquire targets of pointers
        this.updatePointerTargets(object);
      }
      return object;
    },
    acquireDefaultPointers() {
      for (const structure of this.structures) {
        const { constructor, flags, instance: { template } } = structure;
        if (flags & StructureFlag.HasPointer && template && template[MEMORY]) {
          // create a placeholder for retrieving default pointers
          const placeholder = Object.create(constructor.prototype);
          placeholder[MEMORY] = template[MEMORY];
          placeholder[SLOTS] = template[SLOTS];
          this.updatePointerTargets(placeholder);
        }
      }
    },
    defineFactoryArgStruct() {
      const options = this.beginStructure({
        type: StructureType.Struct,
        flags: 0,
        name: 'Options',
        byteSize: 2,
      });
      this.attachMember(options, {
        type: MemberType.Bool,
        name: 'omitFunctions',
        bitOffset: 0,
        bitSize: 1,
        byteSize: 1,
        structure: {},
      });
      this.attachMember(options, {
        type: MemberType.Bool,
        name: 'omitVariables',
        bitOffset: 8,
        bitSize: 1,
        byteSize: 1,
        structure: {},
      });
      this.defineStructure(options);
      const structure = this.beginStructure({
        type: StructureType.ArgStruct,
        flags: StructureFlag.HasObject | StructureFlag.HasSlot,
        name: 'ArgFactory',
        byteSize: 2,
      });
      this.attachMember(structure, {
        type: MemberType.Void,
        name: 'retval',
        bitOffset: 0,
        bitSize: 0,
        byteSize: 0,
        structure: {},
      });
      this.attachMember(structure, {
        type: MemberType.Object,
        name: '0',
        bitOffset: 0,
        bitSize: 16,
        byteSize: 2,
        slot: 0,
        structure: options,
      });
      return this.defineStructure(structure);
    },
    acquireStructures(options) {
      const {
        omitFunctions = false,
        omitVariables = isElectron(),
      } = options;
      this.resetGlobalErrorSet?.();
      const thunkAddress = this.getFactoryThunk();
      const ArgStruct = this.defineFactoryArgStruct();
      const args = new ArgStruct([ { omitFunctions, omitVariables } ]);
      this.comptime = true;
      this.invokeThunk(thunkAddress, thunkAddress, args);
      this.comptime = false;
    },
    getRootModule() {
      const root = this.structures[this.structures.length - 1];
      return root.constructor;
    },
    hasMethods() {
      return !!this.structures.find(s => s.type === StructureType.Function);
    },
    exportStructures() {
      this.acquireDefaultPointers();
      this.prepareObjectsForExport();
      const { structures, runtimeSafety, littleEndian } = this;
      return {
        structures,
        options: { runtimeSafety, littleEndian },
        keys: { MEMORY, SLOTS, CONST_TARGET },
      };
    },
    prepareObjectsForExport() {
      const objects = findAllObjects(this.structures, SLOTS);
      const list = [];
      for (const object of objects) {
        if (object[MEMORY]?.[FIXED]) {
          // replace fixed memory
          const dv = object[MEMORY];
          const address = this.getViewAddress(dv);
          const offset = this.getMemoryOffset(address);
          const len = dv.byteLength;
          const relocDV = this.captureView(address, len, true);
          relocDV.reloc = offset;
          object[MEMORY] = relocDV;
          list.push({ offset, len, owner: object, replaced: false });
        }
      }
      // larger memory blocks come first
      list.sort((a, b) => b.len - a.len);
      for (const a of list) {
        if (!a.replaced) {
          for (const b of list) {
            if (a !== b && !b.replaced) {
              if (a.offset <= b.offset && b.offset < a.offset + a.len) {
                // B is inside A--replace it with a view of A's buffer
                const dv = a.owner[MEMORY];
                const pos = b.offset - a.offset + dv.byteOffset;
                const newDV = this.obtainView(dv.buffer, pos, b.len);
                newDV.reloc = b.offset;
                b.owner[MEMORY] = newDV;
                b.replaced = true;
              }
            }
          }
        }
      }
    },
    useStructures() {
      const module = this.getRootModule();
      // add fixed memory object to list so they can be unlinked
      const objects = findAllObjects(this.structures, SLOTS);
      for (const object of objects) {
        if (object[MEMORY]?.[FIXED]) {
          this.variables.push({ object });
        }
      }
      // clear comptime-only variables
      this.slots = {};
      this.structures = [];
      module.__zigar = this.getSpecialExports();
      return module;
    },
    ...({
      imports: {
        getFactoryThunk: null,
      },
    } ),
  });

  function findAllObjects(structures, SLOTS) {
    const list = [];
    const found = new Map();
    const find = (object) => {
      if (!object || found.get(object)) {
        return;
      }
      found.set(object, true);
      list.push(object);
      if (object[SLOTS]) {
        for (const child of Object.values(object[SLOTS])) {
          find(child);
        }
      }
    };
    for (const structure of structures) {
      find(structure.instance.template);
      find(structure.static.template);
    }
    return list;
  }

  function isElectron() {
    return typeof(process) === 'object'
        && typeof(process?.versions) === 'object'
        && !!process.versions?.electron;
  }

  mixin({
    viewMap: new Map(),

    extractView(structure, arg, onError = throwError) {
      const { type, byteSize, constructor } = structure;
      let dv;
      // not using instanceof just in case we're getting objects created in other contexts
      const tag = arg?.[Symbol.toStringTag];
      if (tag) {
        if (tag === 'DataView') {
          // capture relationship between the view and its buffer
          dv = this.registerView(arg);
        } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
          dv = this.obtainView(arg, 0, arg.byteLength);
        } else if ((tag && tag === constructor[TYPED_ARRAY]?.name) || (tag === 'Uint8ClampedArray' && constructor[TYPED_ARRAY] === Uint8Array)) {
          dv = this.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
        } else if (tag === 'Uint8Array' && arg instanceof Buffer) {
          dv = this.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);
        }
      }
      if (!dv) {
        const memory = arg?.[MEMORY];
        if (memory) {
          // arg a Zig data object
          const { constructor, instance: { members: [ member ] } } = structure;
          if (arg instanceof constructor) {
            // same type, no problem
            return memory;
          } else {
            if (isArrayLike(type)) {
              // make sure the arg has the same type of elements
              const { byteSize: elementSize, structure: { constructor: Child } } = member;
              const number = findElements(arg, Child);
              if (number !== undefined) {
                if (type === StructureType.Slice || number * elementSize === byteSize) {
                  return memory;
                } else {
                  throw new ArrayLengthMismatch(structure, null, arg);
                }
              }
            }
          }
        }
      }
      if (dv) {
        if (byteSize !== undefined) {
          checkDataViewSize(dv, structure);
        }
      } else {
        onError?.(structure, arg);
      }
      return dv;
    },
    assignView(target, dv, structure, copy, fixed) {
      const { byteSize, type } = structure;
      const elementSize = byteSize ?? 1;
      if (!target[MEMORY]) {
        if (byteSize !== undefined) {
          checkDataViewSize(dv, structure);
        }
        const len = dv.byteLength / elementSize;
        const source = { [MEMORY]: dv };
        target.constructor[SENTINEL]?.validateData?.(source, len);
        if (fixed) {
          // need to copy when target object is in fixed memory
          copy = true;
        }
        target[SHAPE](copy ? null : dv, len, fixed);
        if (copy) {
          target[COPY](source);
        }
      } else {
        const byteLength = (type === StructureType.Slice) ? elementSize * target.length : elementSize;
        if (dv.byteLength !== byteLength) {
          throw new BufferSizeMismatch(structure, dv, target);
        }
        const source = { [MEMORY]: dv };
        target.constructor[SENTINEL]?.validateData?.(source, target.length);
        target[COPY](source);
      }
    },
    findViewAt(buffer, offset, len) {
      let entry = this.viewMap.get(buffer);
      let existing;
      if (entry) {
        if (entry instanceof DataView) {
          // only one view created thus far--see if that's the matching one
          if (entry.byteOffset === offset && entry.byteLength === len) {
            existing = entry;
          } else {
            // no, need to replace the entry with a hash keyed by `offset:len`
            const prev = entry;
            const prevKey = `${prev.byteOffset}:${prev.byteLength}`;
            entry = { [prevKey]: prev };
            this.viewMap.set(buffer, entry);
          }
        } else {
          existing = entry[`${offset}:${len}`];
        }
      }
      return { existing, entry };
    },
    obtainView(buffer, offset, len) {
      const { existing, entry } = this.findViewAt(buffer, offset, len);
      let dv;
      if (existing) {
        return existing;
      } else if (entry) {
        dv = entry[`${offset}:${len}`] = new DataView(buffer, offset, len);
      } else {
        // just one view of this buffer for now
        this.viewMap.set(buffer, dv = new DataView(buffer, offset, len));
      }
      const fixed = buffer[FIXED];
      if (fixed) {
        // attach address to view of fixed buffer
        dv[FIXED] = { address: adjustAddress(fixed.address, offset), len };
      }
      return dv;
    },
    registerView(dv) {
      if (!dv[FIXED]) {
        const { buffer, byteOffset, byteLength } = dv;
        const { existing, entry } = this.findViewAt(buffer, byteOffset, byteLength);
        if (existing) {
          // return existing view instead of this one
          return existing;
        } else if (entry) {
          entry[`${byteOffset}:${byteLength}`] = dv;
        } else {
          this.viewMap.set(buffer, dv);
        }
      }
      return dv;
    },
    allocateMemory(len, align = 0, fixed = false) {
      if (fixed) {
        return this.allocateFixedMemory(len, align);
      } else {
        return this.allocateRelocMemory(len, align);
      }
    },
    ...({
      allocateRelocMemory(len, align) {
        // allocate extra memory for alignment purpose when align is larger than the default
        const extra = (align > defaultAlign && this.getBufferAddress) ? align : 0;
        const buffer = new ArrayBuffer(len + extra);
        let offset = 0;
        if (extra) {
          const address = this.getBufferAddress(buffer);
          const aligned = alignForward(address, align);
          offset = aligned - address;
        }
        return this.obtainView(buffer, Number(offset), len);
      },
    } ),
  });

  function checkDataViewSize(dv, structure) {
    const { byteSize, type } = structure;
    const isSizeMatching = type === StructureType.Slice
    ? dv.byteLength % byteSize === 0
    : dv.byteLength === byteSize;
    if (!isSizeMatching) {
      throw new BufferSizeMismatch(structure, dv);
    }
  }

  function isArrayLike(type) {
    return type === StructureType.Array || type === StructureType.Vector || type === StructureType.Slice;
  }

  function throwError(structure) {
    throw new BufferExpected(structure);
  }

  const defaultAlign = [ 'arm64', 'ppc64', 'x64', 's390x' ].includes(process.arch) ? 16 : /* c8 ignore next */ 8;

  mixin({
    ...(undefined),
  });

  mixin({
    defineMember(member, applyTransform = true) {
      if (!member) {
        return {};
      }
      const { type, structure } = member;
      const handleName = `defineMember${memberNames[type]}`;
      const f = this[handleName];
      /* c8 ignore end */
      const descriptor = f.call(this, member);
      if (applyTransform) {
        // we use int/uint getters to access underlying values of enums and error sets;
        // the transform functions put wrapper functions around the accessors that
        // perform item lookup
        const { type } = structure;
        const handleName = `transformDescriptor${structureNames[type]}`;
        const f = this[handleName];
        if (f) {
          return f(descriptor, member);
        }
      }
      return descriptor;
    },
  });

  function bindSlot(slot, { get, set }) {
    if (slot !== undefined) {
      return {
        get: function() {
          return get.call(this, slot);
        },
        set: (set)
        ? function(arg) {
            return set.call(this, slot, arg);
          }
        : undefined,
      };
    } else {
      // array accessors
      return { get, set };
    }
  }

  mixin({
    defineMemberBool(member) {
      return this.defineMemberUsing(member, this.getAccessor);
    },
  });

  mixin({
    defineMemberFloat(member) {
      return this.defineMemberUsing(member, this.getAccessor);
    },
  });

  mixin({
    defineMemberInt(member) {
      let getAccessor = this.getAccessor;
      if (this.runtimeSafety) {
        getAccessor = this.addRuntimeCheck(getAccessor);
      }
      getAccessor = this.addIntConversion(getAccessor);
      return this.defineMemberUsing(member, getAccessor);
    },
  });

  mixin({
    defineMemberLiteral(member) {
      const { slot } = member;
      return bindSlot(slot, { get: getLiteral });
    },
  });

  function getLiteral(slot) {
    const object = this[SLOTS][slot];
    return object.string;
  }

  mixin({
    defineMemberNull(member) {
      return {
        get: function() {
          return null;
        },
      };
    },
  });

  mixin({
    defineMemberObject(member) {
      return bindSlot(member.slot, {
        get: (member.structure.flags & StructureFlag.HasValue) ? getValue : getObject,
        set: (member.flags & MemberFlag.IsReadOnly) ? undefined : setValue,
      });
    }
  });

  function getValue(slot) {
    const object = this[SLOTS][slot] ?? this[VIVIFICATE](slot);
    return object.$;
  }

  function getObject(slot) {
    const object = this[SLOTS][slot] ?? this[VIVIFICATE](slot);
    return object;
  }

  function setValue(slot, value) {
    const object = this[SLOTS][slot] ?? this[VIVIFICATE](slot);
    object.$ = value;
  }

  mixin({
    defineVisitorArray(structure) {
      const value = function visitPointers(cb, options = {}) {
        const {
          source,
          vivificate = false,
          isActive = always,
          isMutable = always,
        } = options;
        const childOptions = {
          ...options,
          isActive: () => isActive(this),
          isMutable: () => isMutable(this),
        };
        for (let i = 0, len = this.length; i < len; i++) {
          // no need to check for empty slots, since that isn't possible
          if (source) {
            childOptions.source = source?.[SLOTS][i];
          }
          const child = this[SLOTS][i] ?? (vivificate ? this[VIVIFICATE](i) : null);
          if (child) {
            child[VISIT](cb, childOptions);
          }
        }
      };
      return { value };
    },
  });

  mixin({
    defineVisitorStruct(structure, visitorOptions = {}) {
      const {
        isChildActive = always,
        isChildMutable = always,
      } = visitorOptions;
      const { instance: { members } } = structure;
      const pointerMembers = members.filter(m => m.structure?.flags & StructureFlag.HasPointer);
      const value = function visitPointers(cb, options = {}) {
        const {
          source,
          vivificate = false,
          isActive = always,
          isMutable = always,
        } = options;
        const childOptions = {
          ...options,
          isActive: (object) => {
            // make sure parent object is active, then check whether the child is active
            return isActive(this) && isChildActive.call(this, object);
          },
          isMutable: (object) => {
            return isMutable(this) && isChildMutable.call(this, object);
          },
        };
        for (const { slot } of pointerMembers) {
          if (source) {
            // when src is a the struct's template, most slots will likely be empty,
            // since pointer fields aren't likely to have default values
            const srcChild = source[SLOTS]?.[slot];
            if (!srcChild) {
              continue;
            }
            childOptions.source = srcChild;
          }
          const child = this[SLOTS][slot] ?? (vivificate ? this[VIVIFICATE](slot) : null);
          if (child) {
            child[VISIT](cb, childOptions);
          }
        }
      };
      return { value };
    }
  });

  mixin({
    ...({
      defineMemberUsing(member, getAccessor) {
        const { littleEndian } = this;
        const { bitOffset, byteSize } = member;
        const getter = getAccessor.call(this, 'get', member);
        const setter = getAccessor.call(this, 'set', member);
        /* c8 ignore end */
        if (bitOffset !== undefined) {
          const offset = bitOffset >> 3;
          return {
            get: function getValue() {
              return getter.call(this[MEMORY], offset, littleEndian);
            },
            set: function setValue(value) {
              return setter.call(this[MEMORY], offset, value, littleEndian);
            }
          }
        } else {
          return {
            get: function getElement(index) {
              try {
                return getter.call(this[MEMORY], index * byteSize, littleEndian);
              } catch (err) {
                throw adjustRangeError(member, index, err);
              }
            },
            set: function setElement(index, value) {
              return setter.call(this[MEMORY], index * byteSize, value, littleEndian);
            },
          }
        }
      },
    }),
  });

  mixin({
    defineSentinel(structure) {
      const {
        byteSize,
        instance: { members: [ member, sentinel ], template },
      } = structure;
      /* c8 ignore end */
      const { get: getSentinelValue } = this.defineMember(sentinel);
      const { get } = this.defineMember(member);
      const value = getSentinelValue.call(template, 0);
      const isRequired = !!(sentinel.flags & MemberFlag.IsRequired);
      const { runtimeSafety } = this;
      return defineValue({
        value,
        bytes: template[MEMORY],
        validateValue(v, i, l) {
          if (isRequired) {
            if (runtimeSafety && v === value && i !== l - 1) {
              throw new MisplacedSentinel(structure, v, i, l);
            }
            if (v !== value && i === l - 1) {
              throw new MissingSentinel(structure, value, l);
            }
          }
        },
        validateData(source, len) {
          if (isRequired) {
            if (runtimeSafety) {
              for (let i = 0; i < len; i++) {
                const v = get.call(source, i);
                if (v === value && i !== len - 1) {
                  throw new MisplacedSentinel(structure, value, i, len);
                } else if (v !== value && i === len - 1) {
                  throw new MissingSentinel(structure, value, len);
                }
              }
            } else {
              // if the length doesn't match, let the operation fail elsewhere
              if (len > 0 && len * byteSize === source[MEMORY].byteLength) {
                const v = get.call(source, len - 1);
                if (v !== value) {
                  throw new MissingSentinel(structure, value, len);
                }
              }
            }
          }
        },
        isRequired,
      });
    },
    ...({
      imports: {
        findSentinel: null,
      },
    } ),
  });

  mixin({
    defineSpecialMethods() {
      return {
        toJSON: defineValue(convertToJSON),
        valueOf: defineValue(convertToJS),
      };
    },
  });

  function convertToJS() {
    return normalizeObject(this, false);
  }

  function convertToJSON() {
    return normalizeObject(this, true);
  }

  const INT_MAX = BigInt(Number.MAX_SAFE_INTEGER);
  const INT_MIN = BigInt(Number.MIN_SAFE_INTEGER);

  function normalizeObject(object, forJSON) {
    const handleError = (forJSON)
    ? (cb) => {
        try {
          return cb();
        } catch (err) {
          return err;
        }
      }
    : (cb) => cb();
    const resultMap = new Map();
    const process = function(value) {
      // handle type (i.e. constructor) like a struct
      const type = (typeof(value) === 'function') ? StructureType.Struct : value?.constructor?.[TYPE];
      if (type === undefined) {
        if (forJSON) {
          if (typeof(value) === 'bigint' && INT_MIN <= value && value <= INT_MAX) {
            return Number(value);
          } else if (value instanceof Error) {
            return { error: value.message };
          }
        }
        return value;
      }
      let result = resultMap.get(value);
      if (result === undefined) {
        let entries;
        switch (type) {
          case StructureType.Struct:
          case StructureType.Union:
            entries = value[ENTRIES];
            result = (value.constructor[FLAGS] & StructureFlag.IsTuple) ? [] : {};
            break;
          case StructureType.Array:
          case StructureType.Vector:
          case StructureType.Slice:
            entries = value[ENTRIES];
            result = [];
            break;
          case StructureType.Pointer:
            try {
              result = value['*'];
            } catch (err) {
              result = Symbol.for('inaccessible');
            }
            break;
          case StructureType.Enum:
            result = handleError(() => String(value));
            break;
          case StructureType.Opaque:
            result = {};
            break;
          default:
            result = handleError(() => value.$);
        }
        result = process(result);
        resultMap.set(value, result);
        if (entries) {
          for (const [ key, child ] of entries) {
            result[key] = process(child);
          }
        }
      }
      return result;
    };
    return process(object);
  }

  mixin({
    defineSpecialProperties(structure) {
      const descriptors = {};
      const thisEnv = this;
      descriptors.dataView = markAsSpecial({
        get() {
          return this[MEMORY];
        },
        set(dv, fixed) {
          checkDataView(dv);
          thisEnv.assignView(this, dv, structure, true, fixed);
        },
      });
      descriptors.base64 = markAsSpecial({
        get() {
          return encodeBase64(this.dataView);
        },
        set(str, fixed) {
          if (typeof(str) !== 'string') {
            throw new TypeMismatch('string', str);
          }
          const dv = decodeBase64(str);
          thisEnv.assignView(this, dv, structure, false, fixed);
        }
      });
      const TypedArray = this.getTypedArray(structure); // (from mixin "structures/all")
      if (TypedArray) {
        descriptors.typedArray = markAsSpecial({
          get() {
            const dv = this.dataView;
            const length = dv.byteLength / TypedArray.BYTES_PER_ELEMENT;
            return new TypedArray(dv.buffer, dv.byteOffset, length);
          },
          set(ta, fixed) {
            if (!isTypedArray(ta, TypedArray)) {
              throw new TypeMismatch(TypedArray.name, ta);
            }
            const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);
            thisEnv.assignView(this, dv, structure, true, fixed);
          },
        });
        if (structure.flags & StructureFlag.IsString) {
          const { byteSize } = structure.instance.members[0];
          const encoding = `utf-${byteSize * 8}`;
          descriptors.string = markAsSpecial({
            get() {
              const dv = this.dataView;
              const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);
              let str = decodeText(ta, encoding);
              const sentinelValue = this.constructor[SENTINEL]?.value;
              if (sentinelValue !== undefined && str.charCodeAt(str.length - 1) === sentinelValue) {
                str = str.slice(0, -1);
              }
              return str;
            },
            set(str, fixed) {
              if (typeof(str) !== 'string') {
                throw new TypeMismatch('a string', str);
              }
              const sentinelValue = this.constructor[SENTINEL]?.value;
              if (sentinelValue !== undefined && str.charCodeAt(str.length - 1) !== sentinelValue) {
                str += String.fromCharCode(sentinelValue);
              }
              const ta = encodeText(str, encoding);
              const dv = new DataView(ta.buffer);
              thisEnv.assignView(this, dv, structure, false, fixed);
            },
          });
        }
      }
      return descriptors;
    },
  });

  function isTypedArray(arg, TypedArray) {
    const tag = arg?.[Symbol.toStringTag];
    return (!!TypedArray && tag === TypedArray.name);
  }

  function checkDataView(dv) {
    if (dv?.[Symbol.toStringTag] !== 'DataView') {
      throw new TypeMismatch('a DataView', dv);
    }
    return dv;
  }

  function markAsSpecial({ get, set }) {
    get.special = set.special = true;
    return { get, set };
  }

  mixin({
    defineMemberType(member, env) {
      const { slot } = member;
      return bindSlot(slot, { get: getType });
    }
  });

  function getType(slot) {
    // unsupported types will have undefined structure
    const structure = this[SLOTS][slot];
    return structure?.constructor;
  }

  mixin({
    defineMemberUint(member) {
      let getAccessor = this.getAccessor;
      if (this.runtimeSafety) {
        getAccessor = this.addRuntimeCheck(getAccessor);
      }
      getAccessor = this.addIntConversion(getAccessor);
      return this.defineMemberUsing(member, getAccessor);
    },
  });

  mixin({
    defineMemberUndefined(member) {
      return {
        get: function() {
          return undefined;
        },
      };
    },
  });

  mixin({
    defineMemberUnsupported(member) {
      const throwUnsupported = function() {
        throw new Unsupported();
      };
      return { get: throwUnsupported, set: throwUnsupported };
    },
  });

  mixin({
    defineMemberVoid(member, env) {
      const { bitOffset } = member;
      return {
        get() {
          return undefined;
        },
        set: (bitOffset !== undefined)
        ? function(value) {
          if (value !== undefined) {
            throw new NotUndefined(member);
          }
        }
        : function(index, value) {
          if (value !== undefined) {
            throw new NotUndefined(member);
          }
          if (index < 0 || index >= this.length) {
            throw new OutOfBound(member, index);
          }
        },
      };
    }
  });

  function getZigIterator() {
    const self = this;
    return {
      next() {
        const value = self.next();
        const done = value === null;
        return { value, done };
      },
    };
  }

  function getStructEntries(options) {
    return {
      [Symbol.iterator]: getStructEntriesIterator.bind(this, options),
      length: this[PROPS].length,
    };
  }

  function getStructIterator(options) {
    const entries = getStructEntries.call(this, options);
    return entries[Symbol.iterator]();
  }

  function getStructEntriesIterator(options) {
    const handleError = getErrorHandler(options);
    const self = this;
    const props = this[PROPS];
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < props.length) {
          const current = props[index++];
          value = [ current, handleError(() => self[current]) ];
          done = false;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function getArrayIterator() {
    const self = this[ARRAY] ?? this;
    const length = this.length;
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < length) {
          const current = index++;
          value = self.get(current);
          done = false;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function getArrayEntriesIterator(options) {
    const handleError = getErrorHandler(options);
    const self = this[ARRAY] ?? this;
    const length = this.length;
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < length) {
          const current = index++;
          value = [ current, handleError(() => self.get(current)) ];
          done = false;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function getArrayEntries(options) {
    return {
      [Symbol.iterator]: getArrayEntriesIterator.bind(this, options),
      length: this.length,
    };
  }

  function getVectorIterator() {
    const self = this;
    const length = this.length;
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < length) {
          const current = index++;
          value = self[current];
          done = false;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function getVectorEntriesIterator() {
    const self = this;
    const length = this.length;
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < length) {
          const current = index++;
          value = [ current, self[current] ];
          done = false;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function getVectorEntries() {
    return {
      [Symbol.iterator]: getVectorEntriesIterator.bind(this),
      length: this.length,
    };
  }

  function getUnionEntries(options) {
    return {
      [Symbol.iterator]: getUnionEntriesIterator.bind(this, options),
      length: this[PROPS].length,
    };
  }

  function getUnionIterator(options) {
    const entries = getUnionEntries.call(this, options);
    return entries[Symbol.iterator]();
  }

  function getUnionEntriesIterator(options) {
    const handleError = getErrorHandler(options);
    const self = this;
    const props = this[PROPS];
    const getters = this[GETTERS];
    let index = 0;
    return {
      next() {
        let value, done;
        if (index < props.length) {
          const current = props[index++];
          // get value of prop with no check
          value = [ current, handleError(() => getters[current].call(self)) ];
          done = false;
        } else {
          done = true;
        }
        return { value, done };
      },
    };
  }

  function getErrorHandler(options) {
    return (options?.error === 'return')
    ? (cb) => {
        try {
          return cb();
        } catch (err) {
          return err;
        }
      }
    : (cb) => cb();
  }

  mixin({
    defineStructure(structure) {
      const {
        type,
        name,
        byteSize,
      } = structure;
      const handlerName = `define${structureNames[type]}`;
      const f = this[handlerName];
      // default discriptors
      const keys = [];
      const setters = {};
      const descriptors = {
        delete: this.defineDestructor(),
        [Symbol.toStringTag]: defineValue(name),
        [CONST_TARGET]: { value: null },
        [SETTERS]: defineValue(setters),
        [KEYS]: defineValue(keys),
        // add memory copier (from mixin "memory/copying")
        [COPY]: this.defineCopier(byteSize),
        // add special methods like toJSON() (from mixin "members/special-method")
        ...this.defineSpecialMethods?.(),
        // add special properties like dataView (from mixin "members/special-props")
        ...this.defineSpecialProperties?.(structure),
        ...("node" === 'wasm'),
      };
      for (const [ name, descriptor ] of Object.entries(descriptors)) {
        let s;
        if (s = descriptor?.set) {
          setters[name] = s;
          keys.push(name);
        }
      }
      const constructor = f.call(this, structure, descriptors);
      defineProperties(constructor.prototype, descriptors);
      structure.constructor = constructor;
      return constructor;
    },
    finalizeStructure(structure) {
      const {
        name,
        type,
        constructor,
        align,
        byteSize,
        flags,
        static: { members, template },
      } = structure;
      const props = [];
      const staticDescriptors = {
        name: defineValue(name),
        [ALIGN]: defineValue(align),
        [SIZE]: defineValue(byteSize),
        [TYPE]: defineValue(type),
        [FLAGS]: defineValue(flags),
        [PROPS]: defineValue(props),
        [TYPED_ARRAY]: defineValue(this.getTypedArray(structure)),
        [Symbol.iterator]: defineValue(getStructIterator),
        [ENTRIES]: { get: getStructEntries },
        [PROPS]: defineValue(props),
        ...this.defineSpecialMethods?.(),
      };
      const descriptors = {};
      for (const member of members) {
        const { name, slot } = member;
        if (member.structure.type === StructureType.Function) {
          const fn = template[SLOTS][slot];
          staticDescriptors[name] = defineValue(fn);
          // provide a name if one isn't assigned yet
          if (!fn.name) {
            defineProperty(fn, 'name', { value: name });
          }
          // see if it's a getter or setter
          const [ accessorType, propName ] = /^(get|set)\s+([\s\S]+)/.exec(name)?.slice(1) ?? [];
          const argRequired = (accessorType === 'get') ? 0 : 1;
          if (accessorType && fn.length  === argRequired) {
            const descriptor = staticDescriptors[propName] ??= {};
            descriptor[accessorType] = fn;
          }
          // see if it's a method
          if (startsWithSelf(member, structure)) {
            const { method } = fn[VARIANTS];
            descriptors[name] = defineValue(method);
            if (accessorType && method.length  === argRequired) {
              const descriptor = descriptors[propName] ??= {};
              descriptor[accessorType] = method;
            }
          }
        } else {
          staticDescriptors[name] = this.defineMember(member);
          props.push(name);
        }
      }
      // static variable/constants are stored in slots
      staticDescriptors[SLOTS] = (props.length > 0) && defineValue(template[SLOTS]);
      const handlerName = `finalize${structureNames[type]}`;
      const f = this[handlerName];
      if (f?.call(this, structure, staticDescriptors) !== false) {
        defineProperties(constructor.prototype, descriptors);
        defineProperties(constructor, staticDescriptors);
      }
    },
    createConstructor(structure, handlers = {}) {
      const {
        byteSize,
        align,
        flags,
        instance: { members, template },
      } = structure;
      const { onCastError } = handlers;
      // comptime fields are stored in the instance template's slots
      let comptimeFieldSlots;
      if (template?.[SLOTS]) {
        const comptimeMembers = members.filter(m => m.flags & MemberFlag.IsReadOnly);
        if (comptimeMembers.length > 0) {
          comptimeFieldSlots = comptimeMembers.map(m => m.slot);
        }
      }
      const cache = new ObjectCache();
      const thisEnv = this;
      const constructor = function(arg, options = {}) {
        const {
          fixed = false,
        } = options;
        const creating = this instanceof constructor;
        let self, dv;
        if (creating) {
          if (arguments.length === 0) {
            throw new NoInitializer$1(structure);
          }
          self = this;
          if (flags & StructureFlag.HasSlot) {
            self[SLOTS] = {};
          }
          if (SHAPE in self) {
            // provided by defineStructureSlice(); the slice is different from other structures
            // as it does not have a fixed size; memory is allocated by the slice initializer
            // based on the argument given
            self[INITIALIZE](arg, fixed);
            dv = self[MEMORY];
          } else {
            self[MEMORY] = dv = thisEnv.allocateMemory(byteSize, align, fixed);
          }
        } else {
          if (CAST in constructor) {
            // casting from number, string, etc.
            self = constructor[CAST].call(this, arg, options);
            if (self !== false) {
              return self;
            }
          }
          // look for buffer
          dv = thisEnv.extractView(structure, arg, onCastError);
          if (self = cache.find(dv)) {
            return self;
          }
          self = Object.create(constructor.prototype);
          if (SHAPE in self) {
            thisEnv.assignView(self, dv, structure, false, false);
          } else {
            self[MEMORY] = dv;
          }
          if (flags & StructureFlag.HasSlot) {
            self[SLOTS] = {};
          }
        }
        if (comptimeFieldSlots) {
          for (const slot of comptimeFieldSlots) {
            self[SLOTS][slot] = template[SLOTS][slot];
          }
        }
        if (MODIFY in self) {
          self[MODIFY]();
        }
        if (creating) {
          // initialize object unless that's done already
          if (!(SHAPE in self)) {
            self[INITIALIZE](arg);
          }
        }
        if (FINALIZE in self) {
          self = self[FINALIZE]();
        }
        return cache.save(dv, self);
      };
      defineProperty(constructor, CACHE, defineValue(cache));
      return constructor;
    },
    defineDestructor() {
      const thisEnv = this;
      return {
        value() {
          const dv = this[MEMORY];
          this[MEMORY] = null;
          if (this[SLOTS]) {
            this[SLOTS] = {};
          }
          thisEnv.releaseFixedView(dv);
        }
      };
    },
    createApplier(structure) {
      const { instance: { template } } = structure;
      return function(arg, fixed) {
        const argKeys = Object.keys(arg);
        const keys = this[KEYS];
        const setters = this[SETTERS];
        // don't accept unknown props
        for (const key of argKeys) {
          if (!(key in setters)) {
            throw new NoProperty(structure, key);
          }
        }
        // checking each name so that we would see inenumerable initializers as well
        let normalCount = 0;
        let normalFound = 0;
        let normalMissing = 0;
        let specialFound = 0;
        for (const key of keys) {
          const set = setters[key];
          if (set.special) {
            if (key in arg) {
              specialFound++;
            }
          } else {
            normalCount++;
            if (key in arg) {
              normalFound++;
            } else if (set.required) {
              normalMissing++;
            }
          }
        }
        if (normalMissing !== 0 && specialFound === 0) {
          const missing = keys.filter(k => setters[k].required && !(k in arg));
          throw new MissingInitializers(structure, missing);
        }
        if (specialFound + normalFound > argKeys.length) {
          // some props aren't enumerable
          for (const key of keys) {
            if (key in arg) {
              if (!argKeys.includes(key)) {
                argKeys.push(key);
              }
            }
          }
        }
        // apply default values unless all properties are initialized
        if (normalFound < normalCount && specialFound === 0) {
          if (template) {
            if (template[MEMORY]) {
              this[COPY](template);
            }
            this[VISIT]?.('copy', { vivificate: true, source: template });
          }
        }
        for (const key of argKeys) {
          const set = setters[key];
          set.call(this, arg[key], fixed);
        }
        return argKeys.length;
      };
    },
    getTypedArray(structure) {
      const { type, instance } = structure;
      if (type !== undefined && instance) {
        const [ member ] = instance.members;
        switch (type) {
          case StructureType.Enum:
          case StructureType.ErrorSet:
          case StructureType.Primitive: {
            const { byteSize, type } = member;
            const intType = (type === MemberType.Float)
                          ? 'Float'
                          : (type === MemberType.Int) ? 'Int' : 'Uint';
            const prefix = (byteSize > 4 && type !== MemberType.Float) ? 'Big' : '';
            const arrayName = prefix + intType + (byteSize * 8) + 'Array';
            return globalThis[arrayName];
          }        case StructureType.Array:
          case StructureType.Slice:
          case StructureType.Vector:
            return this.getTypedArray(member.structure);
        }
      }
    },
    ...({
      exports: {
        defineStructure: null,
      },
    } ),
  });

  function startsWithSelf(fnMember, structure) {
    const argStructure = fnMember.structure.instance.members[0].structure;
    // get structure of first argument (members[0] is retval)
    const arg0Structure = argStructure.instance.members[1]?.structure;
    if (arg0Structure) {
      if (arg0Structure === structure) {
        return true;
      } else if (arg0Structure.type === StructureType.Pointer) {
        const targetStructure = arg0Structure.instance.members[0].structure;
        if (targetStructure === structure) {
          return true;
        }
      }

    }
    return false;
  }

  mixin({
    defineArgStruct(structure, descriptors) {
      const {
        flags,
        byteSize,
        align,
        instance: { members },
      } = structure;
      const thisEnv = this;
      const hasObject = !!members.find(m => m.type === MemberType.Object);
      const argKeys = members.slice(1).map(m => m.name);
      const argCount = argKeys.length;
      const constructor = function(args, name, offset) {
        const creating = this instanceof constructor;
        let self, dv;
        if (creating) {
          self = this;
          dv = thisEnv.allocateMemory(byteSize, align);
        } else {
          self = Object.create(constructor.prototype);
          dv = args;
        }
        self[MEMORY] = dv;
        if (hasObject) {
          self[SLOTS] = {};
        }
        if (creating) {
          if (args.length !== argCount) {
            throw new ArgumentCountMismatch(name, argCount - offset, args.length - offset);
          }
          for (const [ index, key ] of argKeys.entries()) {
            try {
              this[key] = args[index];
            } catch (err) {
              throw adjustArgumentError(name, index - offset, argCount - offset, err);
            }
          }
        } else {
          return self;
        }
      };
      for (const member of members) {
        descriptors[member.name] = this.defineMember(member);
      }
      const { slot: retvalSlot, type: retvalType } = members[0];
      const isChildMutable = (retvalType === MemberType.Object)
      ? function(object) {
          const child = this[VIVIFICATE](retvalSlot);
          return object === child;
        }
      : never;
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, { isChildMutable });
      return constructor;
    },
  });

  mixin({
    defineFinalizerArray({ get, set }) {
      return {
        value() {
          const value = new Proxy(this, proxyHandlers$1);
          defineProperties(this, {
            [PROXY]: { value },
            get: { value: get.bind(this) },
            set: { value: set.bind(this) },
          });
          return value;
        },
      };
    },
    defineVivificatorArray(structure) {
      const { instance: { members: [ member ]} } = structure;
      const { byteSize, structure: elementStructure } = member;
      const thisEnv = this;
      const value = function getChild(index) {
        const { constructor } = elementStructure;
        const dv = this[MEMORY];
        const parentOffset = dv.byteOffset;
        const offset = parentOffset + byteSize * index;
        const childDV = thisEnv.obtainView(dv.buffer, offset, byteSize);
        const object = this[SLOTS][index] = constructor.call(PARENT, childDV);
        return object;
      };
      return { value };
    },
  });

  const proxyHandlers$1 = {
    get(array, name) {
      const index = (typeof(name) === 'symbol') ? 0 : name|0;
      if (index !== 0 || index == name) {
        return array.get(index);
      } else if (name === ARRAY) {
        return array;
      } else {
        return array[name];
      }
    },
    set(array, name, value) {
      const index = (typeof(name) === 'symbol') ? 0 : name|0;
      if (index !== 0 || index == name) {
        array.set(index, value);
      } else {
        array[name] = value;
      }
      return true;
    },
    deleteProperty(array, name) {
      const index = (typeof(name) === 'symbol') ? 0 : name|0;
      if (index !== 0 || index == name) {
        return false;
      } else {
        delete array[name];
        return true;
      }
    },
    has(array, name) {
      const index = (typeof(name) === 'symbol') ? 0 : name|0;
      if (index !== 0 || index == name) {
        return (index >= 0 && index < array.length);
      } else {
        return array[name];
      }
    },
    ownKeys(array) {
      const keys = [];
      for (let i = 0, len = array.length; i < len; i++) {
        keys.push(`${i}`);
      }
      keys.push('length', PROXY);
      return keys;
    },
    getOwnPropertyDescriptor(array, name) {
      const index = (typeof(name) === 'symbol') ? 0 : name|0;
      if (index !== 0 || index == name) {
        if (index >= 0 && index < array.length) {
          return { value: array.get(index), enumerable: true, writable: true, configurable: true };
        }
      } else {
        return Object.getOwnPropertyDescriptor(array, name);
      }
    },
  };

  mixin({
    defineArray(structure, descriptors) {
      const {
        length,
        instance: { members: [ member ] },
        flags,
      } = structure;
      const propApplier = this.createApplier(structure);
      const descriptor = this.defineMember(member);
      const { set } = descriptor;
      const constructor = this.createConstructor(structure);
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
          if (flags & StructureFlag.HasPointer) {
            this[VISIT]('copy', { vivificate: true, source: arg });
          }
        } else {
          if (typeof(arg) === 'string' && flags & StructureFlag.IsString) {
            arg = { string: arg };
          }
          if (arg?.[Symbol.iterator]) {
            arg = transformIterable(arg);
            if (arg.length !== length) {
              throw new ArrayLengthMismatch(structure, this, arg);
            }
            let i = 0;
            for (const value of arg) {
              set.call(this, i++, value);
            }
          } else if (arg && typeof(arg) === 'object') {
            if (propApplier.call(this, arg) === 0) {
              throw new InvalidArrayInitializer(structure, arg);
            }
          } else if (arg !== undefined) {
            throw new InvalidArrayInitializer(structure, arg);
          }
        }
      };
      descriptors.$ = { get: getProxy, set: initializer };
      descriptors.length = defineValue(length);
      descriptors.entries = defineValue(getArrayEntries);
      descriptors[Symbol.iterator] = defineValue(getArrayIterator);
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[FINALIZE] = this.defineFinalizerArray(descriptor);
      descriptors[ENTRIES] = { get: getArrayEntries };
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorArray(structure);
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorArray(structure);
      return constructor;
    },
    finalizeArray(structure, staticDescriptors) {
      const {
        instance: { members: [ member ] },
      } = structure;
      staticDescriptors.child = defineValue(member.structure.constructor);
    },
  });

  mixin({
    defineEnum(structure, descriptors) {
      const {
        instance: {
          members: [ member ],
        },
      } = structure;
      const descriptor = this.defineMember(member);
      const { get, set } = descriptor;
      const { get: getNumber } = this.defineMember(member, false);
      const propApplier = this.createApplier(structure);
      const expected = [ 'string', 'number', 'tagged union' ];
      const initializer = function(arg) {
        if (arg && typeof(arg) === 'object') {
          if (propApplier.call(this, arg) === 0) {
            throw new InvalidInitializer(structure, expected, arg);
          }
        } else if (arg !== undefined) {
          set.call(this, arg);
        }
      };
      const constructor = this.createConstructor(structure, {
        onCastError(structure, arg) {
          throw new InvalidInitializer(structure, expected, arg);
        }
      });
      descriptors.$ = descriptor;
      descriptors.toString = defineValue(toString);
      descriptors[Symbol.toPrimitive] = {
        value(hint)  {
          switch (hint) {
            case 'string':
            case 'default':
              return this.$[NAME];
            default:
              return getNumber.call(this);
          }
        },
      };
      descriptors[INITIALIZE] = defineValue(initializer);
      return constructor;
    },
    finalizeEnum(structure, staticDescriptors) {
      const {
        flags,
        constructor,
        instance: { members: [ member ] },
        static: { members, template },
      } = structure;
      const items = template[SLOTS];
      // obtain getter/setter for accessing int values directly
      const { get, set } = this.defineMember(member, false);
      for (const { name, flags, slot } of members) {
        if (flags & MemberFlag.IsPartOfSet) {
          const item = items[slot];
          // attach name to item so tagged union code can quickly find it
          defineProperty(item, NAME, defineValue(name));
          const index = get.call(item);
          // make item available by name and by index
          staticDescriptors[name] = staticDescriptors[index] = { value: item, writable: false };
        }
      }
      // add cast handler allowing strings, numbers, and tagged union to be casted into enums
      staticDescriptors[CAST] = {
        value(arg) {
          if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {
            let item = constructor[arg];
            if (!item) {
              if (flags & StructureFlag.IsOpenEnded && typeof(arg) !== 'string') {
                // create the item on-the-fly when enum is non-exhaustive
                item = new constructor(undefined);
                // write the value into memory
                set.call(item, arg);
                // attach the new item to the enum set
                defineProperty(item, NAME, defineValue(arg));
                defineProperty(constructor, arg, defineValue(item));
              }
            }
            return item;
          } else if (arg instanceof constructor) {
            return arg;
          } else if (arg?.[TAG] instanceof constructor) {
            // a tagged union, return the active tag
            return arg[TAG];
          } else {
            return false;
          }
        }
      };
      staticDescriptors[TYPED_ARRAY] = defineValue(this.getTypedArray(structure));
    },
    transformDescriptorEnum(descriptor, member) {
      const { type, structure } = member;
      if (type === MemberType.Object) {
        return descriptor;
      }
      const findEnum = function(value) {
        const { constructor } = structure;
        // the enumeration constructor returns the object for the int value
        const item = constructor(value);
        if (!item) {
          throw new EnumExpected(structure, value);
        }
        return item
      };
      const { get, set } = descriptor;
      return {
        get: (get.length === 0)
        ? function getEnum() {
            const value = get.call(this);
            return findEnum(value);
          }
        : function getEnumElement(index) {
            const value = get.call(this, index);
            return findEnum(value);
          },
        set: (set.length === 1)
        ? function setEnum(value) {
            const item = findEnum(value);
            // call Symbol.toPrimitive directly as enum can be bigint or number
            value = item[Symbol.toPrimitive]();
            set.call(this, value);
          }
        : function setEnumElement(index, value) {
            const item = findEnum(value);
            set.call(this, index, item[Symbol.toPrimitive]());
          },
      };
    },
  });

  mixin({
    currentGlobalSet: undefined,
    currentErrorClass: undefined,

    defineErrorSet(structure, descriptors) {
      const {
        name,
        instance: { members: [ member ] },
      } = structure;
      if (!this.currentErrorClass) {
        // create anyerror set
        this.currentErrorClass = class ZigError extends ZigErrorBase {};
        const ae = {
          type: StructureType.ErrorSet,
          name: 'anyerror',
          instance: { members: [ member ] },
          static: { members: [], template: { SLOTS: {} } },
        };
        this.defineStructure(ae);
        this.finalizeStructure(ae);
        this.currentGlobalSet = ae.constructor;
      }
      if (this.currentGlobalSet && name === 'anyerror') {
        return this.currentGlobalSet;
      }
      const descriptor = this.defineMember(member);
      const { set } = descriptor;
      const expected = [ 'string', 'number' ];
      const propApplier = this.createApplier(structure);
      const initializer = function(arg) {
        if (arg instanceof constructor[CLASS]) {
          set.call(this, arg);
        } else if (arg && typeof(arg) === 'object' && !isErrorJSON(arg)) {
          if (propApplier.call(this, arg) === 0) {
            throw new InvalidInitializer(structure, expected, arg);
          }
        } else if (arg !== undefined) {
          set.call(this, arg);
        }
      };
      const constructor = this.createConstructor(structure, {
        onCastError(structure, arg) {
          throw new InvalidInitializer(structure, expected, arg);
        }
      });
      descriptors.$ = descriptor;
      descriptors[INITIALIZE] = defineValue(initializer);
      return constructor;
    },
    finalizeErrorSet(structure, staticDescriptors) {
      const {
        constructor,
        name,
        instance: { members: [ member ] },
        static: { members, template },
      } = structure;
      if (this.currentGlobalSet && name === 'anyerror') {
        // already finalized
        return false;
      }
      const items = template?.[SLOTS] ?? {};
      // obtain getter/setter for accessing int values directly
      const { get } = this.defineMember(member, false);
      for (const { name, slot } of members) {
        const item = items[slot];
        // unlike enums, error objects in an error-set aren't instances of the error-set class
        // they're instance of a superclass of JavaScript's Error; here we need to extract the
        // error number from the error-set instance and create the error object, if hasn't been
        // created already for an earlier set
        const number = get.call(item);
        let error = this.currentGlobalSet[number], inGlobalSet = true;
        if (!error) {
          error = new this.currentErrorClass(name, number);
          inGlobalSet = false;
        }
        // make the error object available by errno, by name, and by error message
        const descriptor = defineValue(error);
        const string = String(error);
        staticDescriptors[name] =
        staticDescriptors[string] =
        staticDescriptors[number] = descriptor;
        if (!inGlobalSet) {
          // add to global error set as well
          defineProperties(this.currentGlobalSet, {
            [number]: descriptor,
            [string]: descriptor,
            [name]: descriptor,
          });
          this.currentGlobalSet[PROPS].push(name);
        }
      }
      // add cast handler allowing strings, numbers, and JSON object to be casted into error set
      staticDescriptors[CAST] = {
        value(arg) {
          if (typeof(arg) === 'number' || typeof(arg) === 'string') {
            return constructor[arg];
          } else if (arg instanceof constructor[CLASS]) {
            return constructor[Number(arg)];
          } else if (isErrorJSON(arg)) {
            return constructor[`Error: ${arg.error}`];
          } else {
            return false;
          }
        }
      };
      staticDescriptors[CLASS] = defineValue(this.currentErrorClass);
    },
    transformDescriptorErrorSet(descriptor, member) {
      const { type, structure } = member;
      if (type === MemberType.Object) {
        return descriptor;
      }
      const findError = function(value) {
        const { constructor } = structure;
        const item = constructor(value);
        if (!item) {
          if (value instanceof Error) {
            throw new NotInErrorSet(structure);
          } else {
            throw new ErrorExpected(structure, value);
          }
        }
        return item
      };
      const { get, set } = descriptor;
      return {
        get: (get.length === 0)
        ? function getError() {
            const value = get.call(this);
            return findError(value);
          }
        : function getErrorElement(index) {
            const value = get.call(this, index);
            return findError(value);
          },
        set: (set.length === 1)
        ? function setError(value) {
            const item = findError(value);
            value = Number(item);
            set.call(this, value);
          }
        : function setError(index, value) {
            const item = findError(value);
            value = Number(item);
            set.call(this, index, value);
          },
      };
    },
    resetGlobalErrorSet() {
      this.currentErrorClass = this.currentGlobalSet = undefined;
    },
  });

  class ZigErrorBase extends Error {
    constructor(name, number) {
      super(deanimalizeErrorName(name));
      this.number = number;
      this.stack = undefined;
    }

    [Symbol.toPrimitive](hint) {
      switch (hint) {
        case 'string':
        case 'default':
          return Error.prototype.toString.call(this, hint);
        default:
          return this.number;
      }
    }

    toJSON() {
      return { error: this.message };
    }
  }

  mixin({
    defineErrorUnion(structure, descriptors) {
      const {
        instance: { members },
        flags,
      } = structure;
      const { get: getValue, set: setValue } = this.defineMember(members[0]);
      const { get: getError, set: setError } = this.defineMember(members[1]);
      const { get: getErrorNumber, set: setErrorNumber } = this.defineMember(members[1], false);
      const get = function() {
        const errNum = getErrorNumber.call(this);
        if (errNum) {
          throw getError.call(this);
        } else {
          return getValue.call(this);
        }
      };
      const isValueVoid = members[0].type === MemberType.Void;
      const errorSet = members[1].structure.constructor;
      const isChildActive = function() {
        return !getErrorNumber.call(this);
      };
      const clearValue = function() {
        this[RESET]();
        this[VISIT]?.('reset');
      };
      const propApplier = this.createApplier(structure);
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
          if (flags & StructureFlag.HasPointer) {
            if (isChildActive.call(this)) {
              this[VISIT]('copy', { vivificate: true, source: arg });
            }
          }
        } else if (arg instanceof errorSet[CLASS] && errorSet(arg)) {
          setError.call(this, arg);
          clearValue.call(this);
        } else if (arg !== undefined || isValueVoid) {
          try {
            // call setValue() first, in case it throws
            setValue.call(this, arg);
            setErrorNumber.call(this, 0);
          } catch (err) {
            if (arg instanceof Error) {
              // we gave setValue a chance to see if the error is actually an acceptable value
              // now is time to throw an error
              throw new NotInErrorSet(structure);
            } else if (isErrorJSON(arg)) {
              // setValue() failed because the argument actually is an error as JSON
              setError.call(this, arg);
              clearValue.call(this);
            } else if (arg && typeof(arg) === 'object') {
              // maybe the argument contains a special property like `dataView` or `base64`
              if (propApplier.call(this, arg) === 0) {
                // propApplier() found zero prop, so it's time to throw
                throw err;
              }
            } else {
              throw err;
            }
          }
        }
      };
      const { bitOffset, byteSize } = members[0];
      const constructor = this.createConstructor(structure);
      descriptors.$ = { get, set: initializer };
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);
      // for clear value after error union is set to an an error (from mixin "features/data-copying")
      descriptors[RESET] = this.defineResetter(bitOffset / 8, byteSize);
      // for operating on pointers contained in the error union
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, { isChildActive });
      return constructor;
    },
  });

  mixin({
    defineFunction(structure) {
      const {
        name,
        instance: { members: [ member ], template: thunk },
        static: { template: jsThunkConstructor },
      } = structure;
      const thisEnv = this;
      const cache = new ObjectCache();
      const { structure: { constructor: Arg, instance: { members: argMembers } } } = member;
      const argCount = argMembers.length - 1;
      const constructor = structure.constructor = function(arg) {
        const creating = this instanceof constructor;
        let self, method, binary;
        let dv, funcId;
        if (creating) {
          if (arguments.length === 0) {
            throw new NoInitializer(structure);
          }
          if (typeof(arg) !== 'function') {
            throw new TypeMismatch('function', arg);
          }
          const constuctorAddr = thisEnv.getViewAddress(jsThunkConstructor[MEMORY]);
          funcId = thisEnv.getFunctionId(arg);
          dv = thisEnv.getFunctionThunk(constuctorAddr, funcId);
        } else {
          dv = arg;
        }
        if (self = cache.find(dv)) {
          return self;
        }
        if (creating) {
          const fn = arg;
          self = anonymous(function(...args) {
            return fn(...args);
          });
          method = function(...args) {
            return fn([ this, ...args]);
          };
          binary = function(dv, asyncCallHandle) {
            let result = CallResult$1.OK;
            let awaiting = false;
            try {
              const argStruct = Arg(dv);
              const args = [];
              for (let i = 0; i < argCount; i++) {
                args.push(argStruct[i]);
              }
              const retval = fn(...args);
              if (retval?.[Symbol.toStringTag] === 'Promise') {
                if (asyncCallHandle) {
                  retval.then((value) => {
                    argStruct.retval = value;
                  }).catch((err) => {
                    console.error(err);
                    result = CallResult$1.Failure;
                  }).then(() => {
                    thisEnv.finalizeAsyncCall(asyncCallHandle, result);
                  });
                  awaiting = true;
                } else {
                  result = CallResult$1.Deadlock;
                }
              } else {
                argStruct.retval = retval;
              }
            } catch (err) {
              console.error(err);
              result = CallResult$1.Failure;
            }
            if (!awaiting && asyncCallHandle) {
              thisEnv.finalizeAsyncCall(asyncCallHandle, result);
            }
            return result;
          };
          thisEnv.setFunctionCaller(funcId, binary);
        } else {
          const invoke = function(argStruct) {
            const thunkAddr = thisEnv.getViewAddress(thunk[MEMORY]);
            const funcAddr = thisEnv.getViewAddress(self[MEMORY]);
            thisEnv.invokeThunk(thunkAddr, funcAddr, argStruct);
          };
          self = anonymous(function (...args) {
            const argStruct = new Arg(args, self.name, 0);
            invoke(argStruct);
            return argStruct.retval;
          });
          method = function(...args) {
            const argStruct = new Arg([ this, ...args ], self.name, 1);
            invoke(argStruct);
            return argStruct.retval;
          };
          binary = function(dv) {
            invoke(Arg(dv));
          };
        }
        Object.setPrototypeOf(self, constructor.prototype);
        self[MEMORY] = dv;
        defineProperties(self, {
          length: { value: argCount, writable: false },
          [VARIANTS]: { value: { method, binary } },
        });
        defineProperties(method, {
          length: { value: argCount - 1, writable: false },
          name: { get: () => self.name },
        });
        cache.save(dv, self);
        return self;
      };
      constructor.prototype = Object.create(Function.prototype);
      defineProperties(constructor.prototype, {
        constructor: { value: constructor },
      });
      defineProperties(constructor, {
        [ALIGN]: { value: 1 },
      });
    },
  });

  const CallResult$1 = {
    OK: 0,
    Failure: 1,
    Deadlock: 2,
    Disabled: 3,
  };

  function anonymous(f) {
    return f
  }

  mixin({
    defineOpaque(structure, descriptors) {
      const {
        flags,
      } = structure;
      const initializer = () => { throw new CreatingOpaque(structure) };
      const valueAccessor = () => { throw new AccessingOpaque(structure) };
      const constructor = this.createConstructor(structure);
      descriptors.$ = { get: valueAccessor, set: valueAccessor };
      descriptors[Symbol.iterator] = (flags & StructureFlag.IsIterator) && {
        value: getZigIterator
      };
      descriptors[Symbol.toPrimitive] = {
        value(hint) {
          const { name } = structure;
          return `[opaque ${name}]`;
        },
      };
      descriptors[INITIALIZE] = defineValue(initializer);
      return constructor;
    },
  });

  mixin({
    defineOptional(structure, descriptors) {
      const {
        instance: { members },
        flags,
      } = structure;
      const { get: getValue, set: setValue } = this.defineMember(members[0]);
      const { get: getPresent, set: setPresent } = this.defineMember(members[1]);
      const get = function() {
        const present = getPresent.call(this);
        if (present) {
          return getValue.call(this);
        } else {
          this[VISIT]?.('reset');
          return null;
        }
      };
      const isValueVoid = members[0].type === MemberType.Void;
      const isChildActive = function () {

        return !!getPresent.call(this);
      };
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
          if (flags & StructureFlag.HasPointer) {
            // don't bother copying pointers when it's empty
            if (isChildActive.call(arg)) {
              this[VISIT]('copy', { vivificate: true, source: arg });
            }
          }
        } else if (arg === null) {
          setPresent.call(this, 0);
          this[RESET]?.();
          // clear references so objects can be garbage-collected
          this[VISIT]?.('reset');
        } else if (arg !== undefined || isValueVoid) {
          // call setValue() first, in case it throws
          setValue.call(this, arg);
          if (flags & StructureFlag.HasSelector || !this[MEMORY][FIXED]) {
            // since setValue() wouldn't write address into memory when the pointer is in
            // relocatable memory, we need to use setPresent() in order to write something
            // non-zero there so that we know the field is populated
            setPresent.call(this, 1);
          }
        }
      };
      const constructor = structure.constructor = this.createConstructor(structure);
      const { bitOffset, byteSize } = members[0];
      descriptors.$ = { get, set: initializer };
      // we need to clear the value portion when there's a separate bool indicating whether a value
      // is present; for optional pointers, the bool overlaps the usize holding the address; setting
      // it to false automatically clears the address
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[RESET] = (flags & StructureFlag.HasSelector) && this.defineResetter(bitOffset / 8, byteSize);
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, { isChildActive });
      return constructor;
    },
  });

  mixin({
    definePointer(structure, descriptors) {
      const {
        name,
        flags,
        byteSize,
        instance: { members: [ member ] },
      } = structure;
      const { structure: targetStructure } = member;
      const {
        type: targetType,
        flags: targetFlags,
        byteSize: targetSuze = 1
      } = targetStructure;
      // length for slice can be zero or undefined
      const addressSize = (flags & StructureFlag.HasLength) ? byteSize / 2 : byteSize;
      const { get: readAddress, set: writeAddress } = this.defineMember({
        type: MemberType.Uint,
        bitOffset: 0,
        bitSize: addressSize * 8,
        byteSize: addressSize,
        structure: { byteSize: addressSize },
      });
      const { get: readLength, set: writeLength } = (flags & StructureFlag.HasLength) ? this.defineMember({
        type: MemberType.Uint,
        flags: MemberFlag.IsSize,
        bitOffset: addressSize * 8,
        bitSize: addressSize * 8,
        byteSize: addressSize,
        structure: { byteSize: addressSize },
      }) : {};
      const updateTarget = function(all = true, active = true) {
        if (all || this[MEMORY][FIXED]) {
          if (active) {
            const Target = constructor.child;
            const address = readAddress.call(this);
            const length = (flags & StructureFlag.HasLength)
            ? readLength.call(this)
            : (flags & StructureFlag.HasSentinel)
              ? thisEnv.findSentinel(address, Target[SENTINEL].bytes) + 1
              : 1;
            if (address !== this[LAST_ADDRESS] || length !== this[LAST_LENGTH]) {
              const dv = thisEnv.findMemory(address, length, Target[SIZE]);
              const newTarget = (dv) ? Target.call(ENVIRONMENT, dv) : null;
              this[SLOTS][0] = newTarget;
              this[LAST_ADDRESS] = address;
              this[LAST_LENGTH] = length;
              if (flags & StructureFlag.HasLength) {
                this[MAX_LENGTH] = undefined;
              }
              return newTarget;
            }
          } else {
            return this[SLOTS][0] = undefined;
          }
        }
        return this[SLOTS][0];
      };
      const setAddress = function(address) {
        writeAddress.call(this, address);
        this[LAST_ADDRESS] = address;
      };
      const setLength = (flags & StructureFlag.HasLength || flags & StructureFlag.HasSentinel)
      ? function(length) {
          writeLength?.call?.(this, length);
          this[LAST_LENGTH] = length;
        }
      : null;
      const getTargetObject = function() {
        const pointer = this[POINTER] ?? this;
        const target = updateTarget.call(pointer, false);
        if (!target) {
          if (flags & StructureFlag.IsNullable) {
            return null;
          }
          throw new NullPointer();
        }
        return (flags & StructureFlag.IsConst) ? getConstProxy(target) : target;
      };
      const setTargetObject = function(arg) {
        if (arg === undefined) {
          return;
        }
        const pointer = this[POINTER] ?? this;
        // the target sits in fixed memory--apply the change immediately
        if (arg) {
          if (arg[MEMORY][FIXED]) {
            const address = thisEnv.getViewAddress(arg[MEMORY]);
            setAddress.call(this, address);
            setLength?.call?.(this, arg.length);
          } else {
            if (pointer[MEMORY][FIXED]) {
              throw new FixedMemoryTargetRequired(structure, arg);
            }
          }
        } else if (pointer[MEMORY][FIXED]) {
          setAddress.call(this, 0);
          setLength?.call?.(this, 0);
        }
        pointer[SLOTS][0] = arg ?? null;
        if (flags & StructureFlag.HasLength) {
          pointer[MAX_LENGTH] = undefined;
        }
      };
      const getTarget = (targetFlags & StructureFlag.HasValue)
      ? function() {
          const target = getTargetObject.call(this);
          return target.$;
        }
      : getTargetObject;
      const setTarget = (flags & StructureFlag.IsConst)
      ? throwReadOnly
      : function(value) {
          const target = getTargetObject.call(this);
          return target.$ = value;
        };
      const getTargetLength = function() {
        const target = getTargetObject.call(this);
        return (target) ? target.length : 0;
      };
      const setTargetLength = function(len) {
        len = len | 0;
        const target = getTargetObject.call(this);
        if (!target) {
          if (len !== 0) {
            throw new InvalidSliceLength(len, 0);
          }
          return;
        }
        const dv = target[MEMORY];
        const fixed = dv[FIXED];
        const bytesAvailable = dv.buffer.byteLength - dv.byteOffset;
        // determine the maximum length
        let max;
        if (!fixed) {
          if (flags & StructureFlag.HasLength) {
            max = this[MAX_LENGTH] ??= target.length;
          } else {
            max = (bytesAvailable / targetSuze) | 0;
          }
        }
        if (len < 0 || len > max) {
          throw new InvalidSliceLength(len, max);
        }
        const byteLength = len * targetSuze;
        const newDV = (byteLength <= bytesAvailable)
        // can use the same buffer
        ? thisEnv.obtainView(dv.buffer, dv.byteOffset, byteLength)
        // need to ask V8 for a larger external buffer
        : thisEnv.obtainFixedView(fixed.address, byteLength);
        const Target = targetStructure.constructor;
        this[SLOTS][0] = Target.call(ENVIRONMENT, newDV);
        setLength?.call?.(this, len);
      };
      const thisEnv = this;
      const initializer = function(arg) {
        const Target = targetStructure.constructor;
        if (isPointerOf(arg, Target)) {
          // initialize with the other pointer'structure target
          if (!(flags & StructureFlag.IsConst) && arg.constructor.const) {
            throw new ConstantConstraint(structure, arg);
          }
          arg = arg[SLOTS][0];
        } else if (flags & StructureFlag.IsMultiple) {
          if (isCompatiblePointer(arg, Target, flags)) {
            arg = Target(arg[SLOTS][0][MEMORY]);
          }
        } else if (name === '*anyopaque' && arg) {
          if (arg.constructor[TYPE] === StructureType.Pointer) {
            arg = arg['*']?.[MEMORY];
          } else if (arg[MEMORY]) {
            arg = arg[MEMORY];
          } else if (arg?.buffer instanceof ArrayBuffer) {
            if (!(arg instanceof Uint8Array || arg instanceof DataView)) {
              const { byteOffset, byteLength } = arg;
              if (byteOffset !== undefined && byteLength !== undefined) {
                arg = new DataView(arg.buffer, byteOffset, byteLength);
              }
            }
          }
        }
        if (arg instanceof Target) {
          const constTarget = arg[CONST_TARGET];
          if (constTarget) {
            if (flags & StructureFlag.IsConst) {
              arg = constTarget;
            } else {
              throw new ReadOnlyTarget(structure);
            }
          }      } else if (flags & StructureFlag.IsSingle && flags & StructureFlag.IsMultiple && arg instanceof Target.child) {
          // C pointer
          arg = Target(arg[MEMORY]);
        } else if (isCompatibleBuffer(arg, Target)) {
          // autocast to target type
          const dv = thisEnv.extractView(targetStructure, arg);
          arg = Target(dv);
        } else if (arg != undefined && !arg[MEMORY]) {
          if (flags & StructureFlag.IsSingle && flags & StructureFlag.IsMultiple) {
            // C pointer
            if (typeof(arg) === 'object' && !arg[Symbol.iterator]) {
              let single = true;
              // make sure the object doesn't contain special props for the slice
              const propSetters = Target.prototype[SETTERS];
              for (const key of Object.keys(arg)) {
                const set = propSetters[key];
                if (set?.special) {
                  single = false;
                  break;
                }
              }
              if (single) {
                arg = [ arg ];
              }
            }
          }
          // autovivificate target object
          const autoObj = new Target(arg, { fixed: !!this[MEMORY][FIXED] });
          if (thisEnv.runtimeSafety) {
            // creation of a new slice using a typed array is probably
            // not what the user wants; it's more likely that the intention
            // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)
            if (TYPED_ARRAY in Target) {
              const tag = arg?.buffer?.[Symbol.toStringTag];
              if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {
                warnImplicitArrayCreation(targetStructure, arg);
              }
            }
          }
          arg = autoObj;
        } else if (arg !== undefined) {
          if (!(flags & StructureFlag.IsNullable) || arg !== null) {
            throw new InvalidPointerTarget(structure, arg);
          }
        }
        this[TARGET] = arg;
      };
      const destructor = descriptors.delete.value;
      const constructor = this.createConstructor(structure);
      descriptors['*'] = { get: getTarget, set: setTarget };
      descriptors.$ = { get: getProxy, set: initializer };
      descriptors.length = { get: getTargetLength, set: setTargetLength };
      descriptors.slice = (targetType === StructureType.Slice) && {
        value(begin, end) {
          const newTarget = this[TARGET].slice(begin, end);
          return new constructor(newTarget);
        }
      };
      descriptors.subarray = (targetType === StructureType.Slice) && {
        value(begin, end, options) {
          const newTarget = this[TARGET].subarray(begin, end, options);
          return new constructor(newTarget);
        }
      };
      descriptors.delete = {
        value() {
          this[TARGET]?.delete();
          destructor.call(this);
        }
      },
      descriptors[Symbol.toPrimitive] = (targetType === StructureType.Primitive) && {
        value(hint) {
          return this[TARGET][Symbol.toPrimitive](hint);
        }
      };
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[FINALIZE] = {
        value() {
          const handlers = (targetType === StructureType.Pointer) ? {} : proxyHandlers;
          const proxy = new Proxy(this, handlers);
          // hide the proxy so console wouldn't display a recursive structure
          Object.defineProperty(this, PROXY, { value: proxy });
          return proxy;
        }
      };
      descriptors[TARGET] = { get: getTargetObject, set: setTargetObject };
      descriptors[UPDATE] = defineValue(updateTarget);
      descriptors[ADDRESS] = { set: setAddress };
      descriptors[LENGTH] = { set: setLength };
      descriptors[VISIT] = defineValue(visitPointer);
      descriptors[LAST_ADDRESS] = defineValue(0);
      descriptors[LAST_LENGTH] = defineValue(0);
      // disable these so the target's properties are returned instead through auto-dereferencing
      descriptors.dataView = descriptors.base64 = undefined;
      return constructor;
    },
    finalizePointer(structure, staticDescriptors) {
      const {
        flags,
        constructor,
        instance: { members: [ member ] },
      } = structure;
      const { structure: targetStructure } = member;
      const { type: targetType, constructor: Target } = targetStructure;
      staticDescriptors.child = (Target) ? defineValue(Target) : {
        // deal with self-referencing pointer
        get() { return targetStructure.constructor }
      };
      staticDescriptors.const = defineValue(!!(flags & StructureFlag.IsConst));
      staticDescriptors[CAST] = {
        value(arg, options) {
          if (this === ENVIRONMENT || this === PARENT || arg instanceof constructor) {
            // casting from buffer to pointer is allowed only if request comes from the runtime
            // casting from writable to read-only is also allowed
            return false;
          } else if (isPointerOf(arg, Target)) {
            // const/non-const casting
            return new constructor(Target(arg['*']), options);
          } else if (isCompatiblePointer(arg, Target, flags)) {
            // casting between C/multi/slice pointers
            return new constructor(arg);
          } else if (targetType === StructureType.Slice) {
            // allow casting to slice through constructor of its pointer
            return new constructor(Target(arg), options);
          } else {
            throw new NoCastingToPointer(structure);
          }
        }
      };
    }
  });

  function throwInaccessible() {
    throw new InaccessiblePointer();
  }
  const builtinVisitors = {
    copy({ source }) {
      const target = source[SLOTS][0];
      if (target) {
        this[TARGET] = target;
      }
    },
    reset({ isActive }) {
      if (this[SLOTS][0] && !isActive(this)) {
        this[SLOTS][0] = undefined;
      }
    },
    disable() {
      const disabledProp = { get: throwInaccessible, set: throwInaccessible };
      defineProperties(this[POINTER], {
        '*': disabledProp,
        '$': disabledProp,
        [POINTER]: disabledProp,
        [TARGET]: disabledProp,
      });
    },
  };

  function visitPointer(visitor, options = {}) {
    const {
      source,
      isActive = always,
      isMutable = always,
    } = options;
    let fn;
    if (typeof(visitor) === 'string') {
      fn = builtinVisitors[visitor];
    } else {
      fn = visitor;
    }
    fn.call(this, { source, isActive, isMutable });
  }

  function isPointerOf(arg, Target) {
    return (arg?.constructor?.child === Target && arg['*']);
  }

  function isCompatiblePointer(arg, Target, flags) {
    if (flags & StructureFlag.IsMultiple) {
      if (arg?.constructor?.child?.child === Target.child && arg['*']) {
        return true;
      } else if (flags & StructureFlag.IsSingle && isPointerOf(arg, Target.child)) {
        // C pointer
        return true;
      }
    }
    return false;
  }

  function getConstProxy(target) {
    let proxy = target[CONST_PROXY];
    if (!proxy) {
      Object.defineProperty(target, CONST_PROXY, { value: undefined, configurable: true });
      proxy = new Proxy(target, constTargetHandlers);
      Object.defineProperty(target, CONST_PROXY, { value: proxy });
    }
    return proxy;
  }

  const proxyHandlers = {
    get(pointer, name) {
      if (name === POINTER) {
        return pointer;
      } else if (name in pointer) {
        return pointer[name];
      } else {
        const target = pointer[TARGET];
        return target[name];
      }
    },
    set(pointer, name, value) {
      if (name in pointer) {
        pointer[name] = value;
      } else {
        const target = pointer[TARGET];
        target[name] = value;
      }
      return true;
    },
    deleteProperty(pointer, name) {
      if (name in pointer) {
        delete pointer[name];
      } else {
        const target = pointer[TARGET];
        delete target[name];
      }
      return true;
    },
    has(pointer, name) {
      if (name in pointer) {
        return true;
      } else {
        const target = pointer[TARGET];
        return name in target;
      }
    },
  };

  const constTargetHandlers = {
    get(target, name) {
      if (name === CONST_TARGET) {
        return target;
      } else {
        const value = target[name];
        if (value?.[CONST_TARGET] === null) {
          return getConstProxy(value);
        }
        return value;
      }
    },
    set(target, name, value) {
      const ptr = target[POINTER];
      if (ptr && !(name in ptr)) {
        target[name] = value;
      } else {
        throwReadOnly();
      }
      return true;
    }
  };

  function isCompatibleBuffer(arg, constructor) {
    // TODO: merge this with extractView in mixin "view-management"
    const tag = arg?.[Symbol.toStringTag];
    if (tag) {
      const typedArray = constructor[TYPED_ARRAY];
      if (typedArray) {
        switch (tag) {
          case typedArray.name:
          case 'DataView':
            return true;
          case 'ArrayBuffer':
          case 'SharedArrayBuffer':
            return typedArray === Uint8Array || typedArray === Int8Array;
          case 'Uint8ClampedArray':
            return typedArray === Uint8Array;
        }
      }
      if (constructor.child) {
        if (findElements(arg, constructor.child) !== undefined) {
          return true;
        }
      }
    }
    return false;
  }

  mixin({
    definePrimitive(structure, descriptors) {
      const {
        instance: { members: [ member ] },
      } = structure;
      const propApplier = this.createApplier(structure);
      const { get, set } = this.defineMember(member);
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
        } else {
          if (arg && typeof(arg) === 'object') {
            if (propApplier.call(this, arg) === 0) {
              const type = getPrimitiveName(member);
              throw new InvalidInitializer(structure, type, arg);
            }
          } else if (arg !== undefined) {
            set.call(this, arg);
          }
        }
      };
      const constructor = this.createConstructor(structure);
      descriptors.$ = { get, set: initializer };
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[Symbol.toPrimitive] = defineValue(get);
      return constructor;
    },
    finalizePrimitive(structure, staticDescriptors) {
      const {
        instance: { members: [ member ] },
      } = structure;
      staticDescriptors[BIT_SIZE] = defineValue(member.bitSize);
      staticDescriptors[PRIMITIVE] = defineValue(member.type);
    },
  });

  mixin({
    defineSlice(structure, descriptors) {
      const {
        align,
        flags,
        byteSize,
        instance: {
          members: [ member ],
        },
      } = structure;
      /* c8 ignore end */
      const { byteSize: elementSize, structure: elementStructure } = member;
      const thisEnv = this;
      const shapeDefiner = function(dv, length, fixed = false) {
        if (!dv) {
          dv = thisEnv.allocateMemory(length * elementSize, align, fixed);
        }
        this[MEMORY] = dv;
        this[LENGTH] = length;
      };
      const shapeChecker = function(arg, length) {
        if (length !== this[LENGTH]) {
          throw new ArrayLengthMismatch(structure, this, arg);
        }
      };
      const descriptor = this.defineMember(member);
      const { set } = descriptor;
      // the initializer behave differently depending on whether it's called by the
      // constructor or by a member setter (i.e. after object's shape has been established)
      const propApplier = this.createApplier(structure);
      const initializer = function(arg, fixed = false) {
        if (arg instanceof constructor) {
          if (!this[MEMORY]) {
            shapeDefiner.call(this, null, arg.length, fixed);
          } else {
            shapeChecker.call(this, arg, arg.length);
          }
          this[COPY](arg);
          if (flags & StructureFlag.HasPointer) {
            this[VISIT]('copy', { vivificate: true, source: arg });
          }
        } else if (typeof(arg) === 'string' && flags & StructureFlag.IsString) {
          initializer.call(this, { string: arg }, fixed);
        } else if (arg?.[Symbol.iterator]) {
          arg = transformIterable(arg);
          if (!this[MEMORY]) {
            shapeDefiner.call(this, null, arg.length, fixed);
          } else {
            shapeChecker.call(this, arg, arg.length);
          }
          let i = 0;
          for (const value of arg) {
            constructor[SENTINEL]?.validateValue(value, i, arg.length);
            set.call(this, i++, value);
          }
        } else if (typeof(arg) === 'number') {
          if (!this[MEMORY] && arg >= 0 && isFinite(arg)) {
            shapeDefiner.call(this, null, arg, fixed);
          } else {
            throw new InvalidArrayInitializer(structure, arg, !this[MEMORY]);
          }
        } else if (arg && typeof(arg) === 'object') {
          if (propApplier.call(this, arg, fixed) === 0) {
            throw new InvalidArrayInitializer(structure, arg);
          }
        } else if (arg !== undefined) {
          throw new InvalidArrayInitializer(structure, arg);
        }
      };
      const getSubArrayView = function(begin, end) {
        const length = this[LENGTH];
        const dv = this[MEMORY];
        begin = (begin === undefined) ? 0 : adjustIndex(begin, length);
        end = (end === undefined) ? length : adjustIndex(end, length);
        const offset = begin * elementSize;
        const len = (end * elementSize) - offset;
        return thisEnv.obtainView(dv.buffer, dv.byteOffset + offset, len);
      };
      const constructor = this.createConstructor(structure);
      descriptors.$ = { get: getProxy, set: initializer };
      descriptors.length = { get: getLength };
      descriptors.entries = defineValue(getArrayEntries);
      descriptors.subarray = {
        value(begin, end) {
          const dv = getSubArrayView.call(this, begin, end);
          return constructor(dv);
        },
      };
      descriptors.slice = {
        value(begin, end, options = {}) {
          const {
            fixed = false
          } = options;
          const dv1 = getSubArrayView.call(this, begin, end);
          const dv2 = thisEnv.allocateMemory(dv1.byteLength, align, fixed);
          const slice = constructor(dv2);
          slice[COPY]({ [MEMORY]: dv1 });
          return slice;
        },
      };
      descriptors[Symbol.iterator] = defineValue(getArrayIterator);
      descriptors[SHAPE] = defineValue(shapeDefiner);
      descriptors[COPY] = this.defineCopier(byteSize, true);
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[FINALIZE] = this.defineFinalizerArray(descriptor);
      descriptors[ENTRIES] = { get: getArrayEntries };
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorArray(structure);
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorArray(structure);
      return constructor;
    },
    finalizeSlice(structure, staticDescriptors) {
      const {
        flags,
        instance: { members: [ member ] },
      } = structure;
      staticDescriptors.child = defineValue(member.structure.constructor);
      staticDescriptors[SENTINEL] = (flags & StructureFlag.HasSentinel) && this.defineSentinel(structure);
    },
  });

  function getLength() {
    return this[LENGTH];
  }

  function adjustIndex(index, len) {
    index = index | 0;
    if (index < 0) {
      index = len + index;
      if (index < 0) {
        index = 0;
      }
    } else {
      if (index > len) {
        index = len;
      }
    }
    return index;
  }

  mixin({
    defineVivificatorStruct(structure) {
      const { instance: { members } } = structure;
      const objectMembers = {};
      for (const member of members.filter(m => m.type === MemberType.Object)) {
        objectMembers[member.slot] = member;
      }
      const thisEnv = this;
      return {
        value(slot) {
          const member = objectMembers[slot];
          const { bitOffset, byteSize, structure: { constructor } } = member;
          const dv = this[MEMORY];
          const parentOffset = dv.byteOffset;
          const offset = parentOffset + (bitOffset >> 3);
          let len = byteSize;
          if (len === undefined) {
            if (bitOffset & 7) {
              throw new NotOnByteBoundary(member);
            }
            len = member.bitSize >> 3;
          }
          const childDV = thisEnv.obtainView(dv.buffer, offset, len);
          const object = this[SLOTS][slot] = constructor.call(PARENT, childDV);
          return object;
        }
      };
    },
  });

  mixin({
    defineStruct(structure, descriptors) {
      const {
        instance: { members },
        flags,
      } = structure;
      const backingIntMember = members.find(m => m.flags & MemberFlag.IsBackingInt);
      const backingInt = backingIntMember && this.defineMember(backingIntMember);
      const propApplier = this.createApplier(structure);
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
          if (flags & StructureFlag.HasPointer) {
            this[VISIT]('copy', { vivificate: true, source: arg });
          }
        } else if (arg && typeof(arg) === 'object') {
          propApplier.call(this, arg);
        } else if ((typeof(arg) === 'number' || typeof(arg) === 'bigint') && backingInt) {
          backingInt.set.call(this, arg);
        } else if (arg !== undefined) {
          throw new InvalidInitializer(structure, 'object', arg);
        }
      };
      const constructor = this.createConstructor(structure);
      // add descriptors of struct field
      const setters = descriptors[SETTERS].value;
      const keys = descriptors[KEYS].value;
      const props = [];
      for (const member of members.filter(m => !!m.name)) {
        const { name, flags } = member;
        const { set } = descriptors[name] = this.defineMember(member);
        if (set) {
          if (flags & MemberFlag.IsRequired) {
            set.required = true;
          }
          setters[name] = set;
          keys.push(name);
        }
        props.push(name);
      }
      descriptors.$ = { get() { return this }, set: initializer };
      // add length and entries if struct is a tuple
      descriptors.length = (flags & StructureFlag.IsTuple) && {
        value: (members.length > 0) ? parseInt(members[members.length - 1].name) + 1 : 0,
      };
      descriptors.entries = (flags & StructureFlag.IsTuple) && {
        value: getVectorEntries,
      };
      // allow conversion of packed struct to number when there's a backing int
      descriptors[Symbol.toPrimitive] = backingInt && {
        value(hint) {
          return (hint === 'string')
            ? Object.prototype.toString.call(this)
            : backingInt.get.call(this);
        }
      };
      // add iterator
      descriptors[Symbol.iterator] = defineValue(
        (flags & StructureFlag.IsIterator)
        ? getZigIterator
        : (flags & StructureFlag.IsTuple)
          ? getVectorIterator
          : getStructIterator
      );
      descriptors[INITIALIZE] = defineValue(initializer);
      // for creating complex fields on access
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);
      // for operating on pointers contained in the struct
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure);
      descriptors[ENTRIES] = { get: (flags & StructureFlag.IsTuple) ? getVectorEntries : getStructEntries };
      descriptors[PROPS] = defineValue(props);
      return constructor;
    }
  });

  mixin({
    defineUnion(structure, descriptors) {
      const {
        flags,
        instance: { members },
      } = structure;
      const exclusion = !!(flags & StructureFlag.HasSelector);
      const valueMembers = (exclusion) ? members.slice(0, -1) : members;
      const selectorMember = (exclusion) ? members[members.length - 1] : null;
      const { get: getSelector, set: setSelector } = this.defineMember(selectorMember);
      const { get: getSelectorNumber } = this.defineMember(selectorMember, false);
      const getActiveField = (flags & StructureFlag.HasTag)
      ? function() {
          const item = getSelector.call(this);
          return item[NAME];
        }
      : function() {
          const index = getSelector.call(this);
          return valueMembers[index].name;
        };
      const setActiveField = (flags & StructureFlag.HasTag)
      ? function(name) {
          const { constructor } = selectorMember.structure;
          setSelector.call(this, constructor[name]);
        }
      : function(name) {
          const index = valueMembers.findIndex(m => m.name === name);
          setSelector.call(this, index);
        };
      const propApplier = this.createApplier(structure);
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
          if (flags & StructureFlag.HasPointer) {
            this[VISIT]('copy', { vivificate: true, source: arg });
          }
        } else if (arg && typeof(arg) === 'object') {
          let found = 0;
          for (const key of props) {
            if (key in arg) {
              found++;
            }
          }
          if (found > 1) {
            throw new MultipleUnionInitializers(structure);
          }
          if (propApplier.call(this, arg) === 0) {
            throw new MissingUnionInitializer(structure, arg, exclusion);
          }
        } else if (arg !== undefined) {
          throw new InvalidInitializer(structure, 'object with a single property', arg);
        }
      };
      const constructor = this.createConstructor(structure);
      const getters = {};
      const setters = descriptors[SETTERS].value;
      const keys = descriptors[KEYS].value;
      const props = [];
      for (const member of valueMembers) {
        const { name } = member;
        const { get: getValue, set: setValue } = this.defineMember(member);
        const get = (exclusion)
        ? function() {
            const currentName = getActiveField.call(this);
            if (name !== currentName) {
              if (flags & StructureFlag.HasTag) {
                // tagged union allows inactive member to be queried
                return null;
              } else {
                // whereas bare union does not, since the condition is not detectable
                // when runtime safety is off
                throw new InactiveUnionProperty(structure, name, currentName);
              }
            }
            this[VISIT]?.('reset');
            return getValue.call(this);
          }
        : getValue;
        const set = (exclusion && setValue)
        ? function(value) {
            const currentName = getActiveField.call(this);
            if (name !== currentName) {
              throw new InactiveUnionProperty(structure, name, currentName);
            }
            setValue.call(this, value);
          }
        : setValue;
        const init = (exclusion && setValue)
        ? function(value) {
            setActiveField.call(this, name);
            setValue.call(this, value);
            this[VISIT]?.('reset');
          }
        : setValue;
        descriptors[name] = { get, set };
        setters[name] = init;
        getters[name] = getValue;
        keys.push(name);
        props.push(name);
      }
      descriptors.$ = { get: function() { return this }, set: initializer };
      descriptors[Symbol.iterator] = {
        value: (flags & StructureFlag.IsIterator) ? getZigIterator : getUnionIterator,
      };
      descriptors[Symbol.toPrimitive] = (flags & StructureFlag.HasTag) && {
        value(hint) {
          switch (hint) {
            case 'string':
            case 'default':
              return getActiveField.call(this);
            default:
              return getSelectorNumber.call(this);
          }
        }
      };
      descriptors[MODIFY] = (flags & StructureFlag.HasInaccessible && !this.comptime) && {
        value() {
          // pointers in non-tagged union are not accessible--we need to disable them
          this[VISIT]('disable', { vivificate: true });
        }
      };
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[TAG] = (flags & StructureFlag.HasTag) && { get: getSelector, set : setSelector };
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);
      descriptors[VISIT] =  (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, {
        isChildActive: (flags & StructureFlag.HasTag)
        ? function(child) {
            const name = getActiveField.call(this);
            const active = getters[name].call(this);
            return child === active;
          }
        : () => false,
      });
      descriptors[ENTRIES] = { get: getUnionEntries };
      descriptors[PROPS] = (flags & StructureFlag.HasTag) ? {
        get() {
          return [ getActiveField.call(this) ];
        }
      } : defineValue(props);
      descriptors[GETTERS] = defineValue(getters);
      return constructor;
    },
    finalizeUnion(structure, staticDescriptors) {
      const {
        flags,
        instance: { members },
      } = structure;
      if (flags & StructureFlag.HasTag) {
        staticDescriptors.tag = defineValue(members[members.length - 1].structure.constructor);
      }
    }
  });

  mixin({
    defineVariadicStruct(structure, descriptors) {
      const {
        byteSize,
        align,
        flags,
        instance: { members },
      } = structure;
      const argMembers = members.slice(1);
      const argCount = argMembers.length;
      const argKeys = argMembers.map(m => m.name);
      const maxSlot = members.map(m => m.slot).sort().pop();
      const thisEnv = this;
      const constructor = function(args, name, offset) {
        if (args.length < argCount) {
          throw new ArgumentCountMismatch(name, `at least ${argCount - offset}`, args.length - offset);
        }
        // calculate the actual size of the struct based on arguments given
        let totalByteSize = byteSize;
        let maxAlign = align;
        const varArgs = args.slice(argCount);
        const offsets = {};
        for (const [ index, arg ] of varArgs.entries()) {
          const dv = arg[MEMORY];
          let argAlign = arg.constructor[ALIGN];
          if (!dv || !argAlign) {
            const err = new InvalidVariadicArgument();
            throw adjustArgumentError(name, argCount + index - offset, args.length - offset, err);
          }
          if (argAlign > maxAlign) {
            maxAlign = argAlign;
          }
          // can't use alignForward here, since that uses bigint when platform is 64-bit
          const byteOffset = offsets[index] = (totalByteSize + (argAlign - 1)) & ~(argAlign - 1);
          totalByteSize = byteOffset + dv.byteLength;
        }
        const attrs = new ArgAttributes(args.length);
        const dv = thisEnv.allocateMemory(totalByteSize, maxAlign);
        // attach the alignment so we can correctly shadow the struct
        dv[ALIGN] = maxAlign;
        this[MEMORY] = dv;
        this[SLOTS] = {};
        for (const [ index, key ] of argKeys.entries()) {
          try {
            this[key] = args[index];
          } catch (err) {
            throw adjustArgumentError(name, index - offset, argCount - offset, err);
          }
        }
        // set attributes of retval and fixed args
        for (const [ index, { bitOffset, bitSize, type, structure: { align } } ] of argMembers.entries()) {
          attrs.set(index, bitOffset / 8, bitSize, align, type);
        }
        // create additional child objects and copy arguments into them
        for (const [ index, arg ] of varArgs.entries()) {
          const slot = maxSlot + index + 1;
          const { byteLength } = arg[MEMORY];
          const offset = offsets[index];
          const childDV = thisEnv.obtainView(dv.buffer, offset, byteLength);
          const child = this[SLOTS][slot] = arg.constructor.call(PARENT, childDV);
          const bitSize = arg.constructor[BIT_SIZE] ?? byteLength * 8;
          const align = arg.constructor[ALIGN];
          const type = arg.constructor[PRIMITIVE];
          child.$ = arg;
          // set attributes
          attrs.set(argCount + index, offset, bitSize, align, type);
        }
        this[ATTRIBUTES] = attrs;
      };
      for (const member of members) {
        descriptors[member.name] = this.defineMember(member);
      }
      const { slot: retvalSlot, type: retvalType } = members[0];
      const isChildMutable = (retvalType === MemberType.Object)
      ? function(object) {
          const child = this[VIVIFICATE](retvalSlot);
          return object === child;
        }
      : function() { return false };
      const ArgAttributes = function(length) {
        this[MEMORY] = thisEnv.allocateMemory(length * 8, 4);
        this.length = length;
        this.littleEndian = thisEnv.littleEndian;
      };
      const setAttributes = function(index, offset, bitSize, align, type) {
        const dv = this[MEMORY];
        const le = thisEnv.littleEndian;
        dv.setUint16(index * 8, offset, le);
        dv.setUint16(index * 8 + 2, bitSize, le);
        dv.setUint16(index * 8 + 4, align, le);
        dv.setUint8(index * 8 + 6, type == MemberType.Float);
        dv.setUint8(index * 8 + 7, type == MemberType.Int || type == MemberType.Float);
      };
      defineProperties(ArgAttributes, {
        [ALIGN]: { value: 4 },
      });
      defineProperties(ArgAttributes.prototype, {
        set: defineValue(setAttributes),
        [COPY]: this.defineCopier(4, true),
        ...(undefined),
      });
      descriptors[COPY] = this.defineCopier(undefined, true);
      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);
      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && {
        value(cb, options = {}) {
          const {
            vivificate = false,
            isActive = always,
            isMutable = always,
          } = options;
          const childOptions = {
            ...options,
            isActive,
            isMutable: (object) => isMutable(this) && isChildMutable.call(this, object),
          };
          if (vivificate && retvalType === MemberType.Object) {
            this[VIVIFICATE](retvalSlot);
          }
          for (const child of Object.values(this[SLOTS])) {
            child?.[VISIT]?.(cb, childOptions);
          }
        },
      };
      return constructor;
    }
  });

  mixin({
    defineVector(structure, descriptors) {
      const {
        length,
        instance: { members: [ member ] },
      } = structure;
      const propApplier = this.createApplier(structure);
      const initializer = function(arg) {
        if (arg instanceof constructor) {
          this[COPY](arg);
        } else if (arg?.[Symbol.iterator]) {
          let argLen = arg.length;
          if (typeof(argLen) !== 'number') {
            arg = [ ...arg ];
            argLen = arg.length;
          }
          if (argLen !== length) {
            throw new ArrayLengthMismatch(structure, this, arg);
          }
          let i = 0;
          for (const value of arg) {
            this[i++] = value;
          }
        } else if (arg && typeof(arg) === 'object') {
          if (propApplier.call(this, arg) === 0) {
            throw new InvalidArrayInitializer(structure, arg);
          }
        } else if (arg !== undefined) {
          throw new InvalidArrayInitializer(structure, arg);
        }
      };
      const constructor = this.createConstructor(structure, { initializer });
      const { bitSize: elementBitSize } = member;
      for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {
        descriptors[i] = this.defineMember({ ...member, bitOffset });
      }
      descriptors.$ = { get: getSelf, set: initializer };
      descriptors.length = defineValue(length);
      descriptors.entries = defineValue(getVectorEntries);
      descriptors[Symbol.iterator] = defineValue(getVectorIterator);
      descriptors[INITIALIZE] = defineValue(initializer);
      descriptors[ENTRIES] = { get: getVectorEntries };
      return constructor;
    },
    finalizeVector(structure, staticDescriptors) {
      const {
        instance: { members: [ member ] },
      } = structure;
      staticDescriptors.child = defineValue(member.structure.constructor);
    },
  });

  const Environment = defineEnvironment();

  exports.Environment = Environment;

  return exports;

})({}))
)====="
