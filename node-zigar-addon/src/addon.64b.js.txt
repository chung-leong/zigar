"(function(t) {\n"
"    \"use strict\";\n"
"    const e = {\n"
"        Primitive: 0,\n"
"        Array: 1,\n"
"        Struct: 2,\n"
"        Union: 3,\n"
"        ErrorUnion: 4,\n"
"        ErrorSet: 5,\n"
"        Enum: 6,\n"
"        Optional: 7,\n"
"        Pointer: 8,\n"
"        Slice: 9,\n"
"        Vector: 10,\n"
"        Opaque: 11,\n"
"        ArgStruct: 12,\n"
"        VariadicStruct: 13,\n"
"        Function: 14\n"
"    }, n = Object.keys(e), r = 1, i = 2, s = 4, o = 8, c = 16, a = 16, l = 32, u = 64, f = 128, h = 64, d = 128, g = 256, y = 512, b = 1024, p = 2048, m = 16, w = 32, v = 64, S = 512, A = 16, I = 16, V = 16, E = 32, M = 64, x = 128, O = 256, $ = 16, T = 32, U = 64, z = 128, C = 256, F = 16, B = 16, j = 16, N = 32, k = 16, P = 32, L = 64, D = {\n"
"        Void: 0,\n"
"        Bool: 1,\n"
"        Int: 2,\n"
"        Uint: 3,\n"
"        Float: 4,\n"
"        Object: 5,\n"
"        Type: 6,\n"
"        Literal: 7,\n"
"        Null: 8,\n"
"        Undefined: 9,\n"
"        Unsupported: 10\n"
"    }, R = Object.keys(D), Z = 1, q = 2, J = 4, G = 16, _ = 64, W = 0, H = 1, X = 2, Y = 1, K = 2, Q = 4, tt = {\n"
"        IsInactive: 1,\n"
"        IsImmutable: 2,\n"
"        IgnoreUncreated: 4,\n"
"        IgnoreInactive: 8,\n"
"        IgnoreArguments: 16,\n"
"        IgnoreRetval: 32\n"
"    }, et = globalThis[Symbol.for(\"ZIGAR\")] ||= {};\n"
"    function nt(t) {\n"
"        return et[t] ||= Symbol(t);\n"
"    }\n"
"    function rt(t) {\n"
"        return nt(t);\n"
"    }\n"
"    const it = rt(\"memory\"), st = rt(\"slots\"), ot = rt(\"parent\"), ct = rt(\"zig\"), at = rt(\"name\"), lt = rt(\"type\"), ut = rt(\"flags\"), ft = rt(\"class\"), ht = rt(\"tag\"), dt = rt(\"props\"), gt = rt(\"pointer\"), yt = rt(\"sentinel\"), bt = rt(\"array\"), pt = rt(\"target\"), mt = rt(\"entries\"), wt = rt(\"max length\"), vt = rt(\"keys\"), St = rt(\"address\"), At = rt(\"length\"), It = rt(\"last address\"), Vt = rt(\"last length\"), Et = rt(\"proxy\"), Mt = rt(\"cache\"), xt = rt(\"size\"), Ot = rt(\"bit size\"), $t = rt(\"align\"), Tt = rt(\"const target\"), Ut = rt(\"environment\"), zt = rt(\"attributes\"), Ct = rt(\"primitive\"), Ft = rt(\"getters\"), Bt = rt(\"setters\"), jt = rt(\"typed array\"), Nt = rt(\"throwing\"), kt = rt(\"promise\"), Pt = rt(\"generator\"), Lt = rt(\"allocator\"), Dt = rt(\"fallback\"), Rt = rt(\"signature\"), Zt = rt(\"update\"), qt = rt(\"reset\"), Jt = rt(\"vivificate\"), Gt = rt(\"visit\"), _t = rt(\"copy\"), Wt = rt(\"shape\"), Ht = rt(\"initialize\"), Xt = rt(\"restrict\"), Yt = rt(\"finalize\"), Kt = rt(\"cast\"), Qt = rt(\"return\"), te = rt(\"yield\");\n"
"    function ee(t, e, n) {\n"
"        if (n) {\n"
"            const {set: r, get: i, value: s, enumerable: o, configurable: c = !0, writable: a = !0} = n;\n"
"            Object.defineProperty(t, e, i || r ? {\n"
"                get: i,\n"
"                set: r,\n"
"                configurable: c,\n"
"                enumerable: o\n"
"            } : {\n"
"                value: s,\n"
"                configurable: c,\n"
"                enumerable: o,\n"
"                writable: a\n"
"            });\n"
"        }\n"
"        return t;\n"
"    }\n"
"    function ne(t, e) {\n"
"        for (const [n, r] of Object.entries(e)) ee(t, n, r);\n"
"        for (const n of Object.getOwnPropertySymbols(e)) {\n"
"            ee(t, n, e[n]);\n"
"        }\n"
"        return t;\n"
"    }\n"
"    function re(t) {\n"
"        return void 0 !== t ? {\n"
"            value: t\n"
"        } : void 0;\n"
"    }\n"
"    function ie(t) {\n"
"        return \"return\" === t?.error ? t => {\n"
"            try {\n"
"                return t();\n"
"            } catch (t) {\n"
"                return t;\n"
"            }\n"
"        } : t => t();\n"
"    }\n"
"    function se({type: t, bitSize: e}) {\n"
"        switch (t) {\n"
"          case D.Bool:\n"
"            return \"boolean\";\n"
"\n"
"          case D.Int:\n"
"          case D.Uint:\n"
"            if (e > 32) return \"bigint\";\n"
"\n"
"          case D.Float:\n"
"            return \"number\";\n"
"        }\n"
"    }\n"
"    function oe(t, e = \"utf-8\") {\n"
"        const n = ae[e] ||= new TextDecoder(e);\n"
"        let r;\n"
"        if (Array.isArray(t)) if (1 === t.length) r = t[0]; else {\n"
"            let e = 0;\n"
"            for (const n of t) e += n.length;\n"
"            const {constructor: n} = t[0];\n"
"            r = new n(e);\n"
"            let i = 0;\n"
"            for (const e of t) r.set(e, i), i += e.length;\n"
"        } else r = t;\n"
"        return \"SharedArrayBuffer\" === r.buffer[Symbol.toStringTag] && (r = new r.constructor(r)), \n"
"        n.decode(r);\n"
"    }\n"
"    function ce(t, e = \"utf-8\") {\n"
"        if (\"utf-16\" === e) {\n"
"            const {length: e} = t, n = new Uint16Array(e);\n"
"            for (let r = 0; r < e; r++) n[r] = t.charCodeAt(r);\n"
"            return n;\n"
"        }\n"
"        return (le[e] ||= new TextEncoder).encode(t);\n"
"    }\n"
"    const ae = {}, le = {};\n"
"    function ue(t, e, n) {\n"
"        let r = 0, i = t.length;\n"
"        if (0 === i) return 0;\n"
"        for (;r < i; ) {\n"
"            const s = Math.floor((r + i) / 2);\n"
"            n(t[s]) <= e ? r = s + 1 : i = s;\n"
"        }\n"
"        return i;\n"
"    }\n"
"    const fe = function(t, e) {\n"
"        return !!e && !!(t & BigInt(e - 1));\n"
"    }, he = function(t, e) {\n"
"        return t + BigInt(e - 1) & ~BigInt(e - 1);\n"
"    }, de = 0xFFFFFFFFFFFFFFFFn, ge = -1n, ye = function(t, e) {\n"
"        return t + BigInt(e);\n"
"    };\n"
"    function be(t) {\n"
"        if (\"number\" == typeof t.length) return t;\n"
"        const e = t[Symbol.iterator](), n = e.next(), r = n.value?.length;\n"
"        if (\"number\" == typeof r && \"length\" === Object.keys(n.value).join()) return Object.assign(function*() {\n"
"            let t;\n"
"            for (;!(t = e.next()).done; ) yield t.value;\n"
"        }(), {\n"
"            length: r\n"
"        });\n"
"        {\n"
"            const t = [];\n"
"            let r = n;\n"
"            for (;!r.done; ) t.push(r.value), r = e.next();\n"
"            return t;\n"
"        }\n"
"    }\n"
"    function pe(t, e) {\n"
"        const {constructor: n} = t;\n"
"        return n === e ? 1 : n.child === e ? t.length : void 0;\n"
"    }\n"
"    function me(t, e) {\n"
"        const n = [], r = new Map, i = t => {\n"
"            if (t && !r.get(t) && (r.set(t, !0), n.push(t), t[e])) for (const n of Object.values(t[e])) i(n);\n"
"        };\n"
"        for (const e of t) i(e.instance.template), i(e.static.template);\n"
"        return n;\n"
"    }\n"
"    function we(t, e) {\n"
"        return t === e || t?.[Rt] === e[Rt] && t?.[Ut] !== e?.[Ut];\n"
"    }\n"
"    function ve(t, e) {\n"
"        return t instanceof e || we(t?.constructor, e);\n"
"    }\n"
"    function Se({get: t, set: e}) {\n"
"        return t.special = e.special = !0, {\n"
"            get: t,\n"
"            set: e\n"
"        };\n"
"    }\n"
"    function Ae() {\n"
"        return this;\n"
"    }\n"
"    function Ie() {\n"
"        return this[Et];\n"
"    }\n"
"    function Ve() {\n"
"        return String(this);\n"
"    }\n"
"    function Ee() {}\n"
"    class ObjectCache {\n"
"        map=new WeakMap;\n"
"        find(t) {\n"
"            return this.map.get(t);\n"
"        }\n"
"        save(t, e) {\n"
"            return this.map.set(t, e), e;\n"
"        }\n"
"    }\n"
"    const Me = {\n"
"        name: \"\",\n"
"        mixins: [],\n"
"        constructor: null\n"
"    };\n"
"    function xe(t) {\n"
"        return Me.constructor || Me.mixins.push(t), t;\n"
"    }\n"
"    function Oe() {\n"
"        return Me.constructor || (Me.constructor = function(t, e) {\n"
"            const n = [], r = function() {\n"
"                for (const t of n) t.call(this);\n"
"            }, {prototype: i} = r;\n"
"            ee(r, \"name\", re(t));\n"
"            for (const t of e) for (let [e, r] of Object.entries(t)) if (\"init\" === e) n.push(r); else {\n"
"                if (\"function\" == typeof r) ; else {\n"
"                    let t = i[e];\n"
"                    if (void 0 !== t) if (t?.constructor === Object) r = Object.assign({\n"
"                        ...t\n"
"                    }, r); else if (t !== r) throw new Error(`Duplicate property: ${e}`);\n"
"                }\n"
"                ee(i, e, re(r));\n"
"            }\n"
"            return r;\n"
"        }(Me.name, Me.mixins), Me.name = \"\", Me.mixins = []), Me.constructor;\n"
"    }\n"
"    function $e(t, e, n) {\n"
"        if (t + e <= 8) {\n"
"            const r = 2 ** e - 1;\n"
"            if (n) return function(e, n, i) {\n"
"                const s = n.getUint8(i) >> t & r;\n"
"                e.setUint8(0, s);\n"
"            };\n"
"            {\n"
"                const e = 255 ^ r << t;\n"
"                return function(n, i, s) {\n"
"                    const o = i.getUint8(0), c = n.getUint8(s) & e | (o & r) << t;\n"
"                    n.setUint8(s, c);\n"
"                };\n"
"            }\n"
"        }\n"
"        {\n"
"            const r = 8 - t, i = 2 ** r - 1;\n"
"            if (n) {\n"
"                const n = 2 ** (e % 8) - 1;\n"
"                return function(s, o, c) {\n"
"                    let a, l = c, u = 0, f = o.getUint8(l++), h = f >> t & i, d = r, g = e;\n"
"                    do {\n"
"                        g > d && (f = o.getUint8(l++), h |= f << d), a = g >= 8 ? 255 & h : h & n, s.setUint8(u++, a), \n"
"                        h >>= 8, g -= 8;\n"
"                    } while (g > 0);\n"
"                };\n"
"            }\n"
"            {\n"
"                const n = 2 ** ((e - r) % 8) - 1, s = 255 ^ i << t, o = 255 ^ n;\n"
"                return function(r, i, c) {\n"
"                    let a, l, u = 0, f = c, h = r.getUint8(f), d = h & s, g = t, y = e + g;\n"
"                    do {\n"
"                        y > g && (a = i.getUint8(u++), d |= a << g, g += 8), y >= 8 ? l = 255 & d : (h = r.getUint8(f), \n"
"                        l = h & o | d & n), r.setUint8(f++, l), d >>= 8, g -= 8, y -= 8;\n"
"                    } while (y > 0);\n"
"                };\n"
"            }\n"
"        }\n"
"    }\n"
"    xe({\n"
"        init() {\n"
"            this.accessorCache = new Map;\n"
"        },\n"
"        getAccessor(t, e) {\n"
"            const {type: n, bitSize: r, bitOffset: i, byteSize: s} = e, o = [], c = void 0 === s && (7 & r || 7 & i);\n"
"            c && o.push(\"Unaligned\");\n"
"            let a = R[n];\n"
"            r > 32 && (n === D.Int || n === D.Uint) && (a = r <= 64 ? `Big${a}` : `Jumbo${a}`), \n"
"            o.push(a, `${n === D.Bool && s ? 8 * s : r}`), c && o.push(`@${i}`);\n"
"            const l = t + o.join(\"\");\n"
"            let u = DataView.prototype[l];\n"
"            if (u && this.usingBufferFallback()) {\n"
"                const e = this, i = u, s = function(t) {\n"
"                    const {buffer: e, byteOffset: n, byteLength: i} = this, s = e[Dt];\n"
"                    if (s) {\n"
"                        if (t < 0 || t + r / 8 > i) throw new RangeError(\"Offset is outside the bounds of the DataView\");\n"
"                        return s + BigInt(n + t);\n"
"                    }\n"
"                };\n"
"                u = \"get\" === t ? function(t, o) {\n"
"                    const c = s.call(this, t);\n"
"                    return void 0 !== c ? e.getNumericValue(n, r, c) : i.call(this, t, o);\n"
"                } : function(t, o, c) {\n"
"                    const a = s.call(this, t);\n"
"                    return void 0 !== a ? e.setNumericValue(n, r, a, o) : i.call(this, t, o, c);\n"
"                };\n"
"            }\n"
"            if (u) return u;\n"
"            if (u = this.accessorCache.get(l), u) return u;\n"
"            for (;o.length > 0; ) {\n"
"                const n = `getAccessor${o.join(\"\")}`;\n"
"                if (u = this[n]?.(t, e)) break;\n"
"                o.pop();\n"
"            }\n"
"            if (!u) throw new Error(`No accessor available: ${l}`);\n"
"            return ee(u, \"name\", re(l)), this.accessorCache.set(l, u), u;\n"
"        },\n"
"        imports: {\n"
"            getNumericValue: null,\n"
"            setNumericValue: null\n"
"        }\n"
"    }), xe({\n"
"        getAccessorBigInt(t, e) {\n"
"            const {bitSize: n} = e, r = 2n ** BigInt(n - 1), i = r - 1n;\n"
"            return \"get\" === t ? function(t, e) {\n"
"                const n = this.getBigUint64(t, e);\n"
"                return (n & i) - (n & r);\n"
"            } : function(t, e, n) {\n"
"                const s = e < 0 ? r | e & i : e & i;\n"
"                this.setBigUint64(t, s, n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorBigUint(t, e) {\n"
"            const {bitSize: n} = e, r = 2n ** BigInt(n) - 1n;\n"
"            return \"get\" === t ? function(t, e) {\n"
"                return this.getBigInt64(t, e) & r;\n"
"            } : function(t, e, n) {\n"
"                const i = e & r;\n"
"                this.setBigUint64(t, i, n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorBool(t, e) {\n"
"            const {byteSize: n} = e, r = 8 * n, i = this.getAccessor(t, {\n"
"                type: D.Uint,\n"
"                bitSize: r,\n"
"                byteSize: n\n"
"            });\n"
"            if (\"get\" === t) return function(t, e) {\n"
"                return !!i.call(this, t, e);\n"
"            };\n"
"            {\n"
"                const t = r <= 32 ? 0 : 0n, e = r <= 32 ? 1 : 1n;\n"
"                return function(n, r, s) {\n"
"                    i.call(this, n, r ? e : t, s);\n"
"                };\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        getAccessorFloat128(t, e) {\n"
"            const {byteSize: n} = e, r = new DataView(new ArrayBuffer(8)), i = function(t, e) {\n"
"                return BigInt(this.getUint32(t + (e ? 0 : n - 4), e)) | BigInt(this.getUint32(t + (e ? 4 : n - 8), e)) << 32n | BigInt(this.getUint32(t + (e ? 8 : n - 12), e)) << 64n | BigInt(this.getUint32(t + (e ? 12 : n - 16), e)) << 96n;\n"
"            }, s = function(t, e, r) {\n"
"                const i = 0xffffffffn & e, s = e >> 32n & 0xffffffffn, o = e >> 64n & 0xffffffffn, c = e >> 96n & 0xffffffffn;\n"
"                this.setUint32(t + (r ? 0 : n - 4), Number(i), r), this.setUint32(t + (r ? 4 : n - 8), Number(s), r), \n"
"                this.setUint32(t + (r ? 8 : n - 12), Number(o), r), this.setUint32(t + (r ? 12 : n - 16), Number(c), r);\n"
"            };\n"
"            return \"get\" === t ? function(t, e) {\n"
"                const n = i.call(this, t, e), s = n >> 127n, o = (0x7fff0000000000000000000000000000n & n) >> 112n, c = 0x0000ffffffffffffffffffffffffffffn & n;\n"
"                if (0n === o) {\n"
"                    const t = c ? Number.MIN_VALUE : 0;\n"
"                    return s ? -t : t;\n"
"                }\n"
"                if (0x7fffn === o) return c ? NaN : s ? -1 / 0 : 1 / 0;\n"
"                const a = o - 16383n + 1023n;\n"
"                if (a >= 2047n) {\n"
"                    const t = 1 / 0;\n"
"                    return s ? -t : t;\n"
"                }\n"
"                const l = s << 63n | a << 52n | (c >> 60n) + BigInt((c & 2n ** 60n - 1n) >= 2n ** 59n);\n"
"                return r.setBigUint64(0, l, e), r.getFloat64(0, e);\n"
"            } : function(t, e, n) {\n"
"                r.setFloat64(0, e, n);\n"
"                const i = r.getBigUint64(0, n), o = i >> 63n, c = (0x7ff0000000000000n & i) >> 52n, a = 0x000fffffffffffffn & i;\n"
"                let l;\n"
"                l = 0n === c ? o << 127n | a << 60n : 0x07ffn === c ? o << 127n | 0x7fffn << 112n | (a ? 1n : 0n) : o << 127n | c - 1023n + 16383n << 112n | a << 60n, \n"
"                s.call(this, t, l, n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorFloat16(t, e) {\n"
"            const n = new DataView(new ArrayBuffer(4)), r = DataView.prototype.setUint16, i = DataView.prototype.getUint16;\n"
"            return \"get\" === t ? function(t, e) {\n"
"                const r = i.call(this, t, e), s = r >>> 15, o = (31744 & r) >> 10, c = 1023 & r;\n"
"                if (0 === o) return s ? -0 : 0;\n"
"                if (31 === o) return c ? NaN : s ? -1 / 0 : 1 / 0;\n"
"                const a = s << 31 | o - 15 + 127 << 23 | c << 13;\n"
"                return n.setUint32(0, a, e), n.getFloat32(0, e);\n"
"            } : function(t, e, i) {\n"
"                n.setFloat32(0, e, i);\n"
"                const s = n.getUint32(0, i), o = s >>> 31, c = (2139095040 & s) >> 23, a = 8388607 & s, l = c - 127 + 15;\n"
"                let u;\n"
"                u = 0 === c ? o << 15 : 255 === c ? o << 15 | 31744 | (a ? 1 : 0) : l >= 31 ? o << 15 | 31744 : o << 15 | l << 10 | a >> 13, \n"
"                r.call(this, t, u, i);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorFloat80(t, e) {\n"
"            const {byteSize: n} = e, r = new DataView(new ArrayBuffer(8)), i = function(t, e) {\n"
"                return BigInt(this.getUint32(t + (e ? 0 : n - 4), e)) | BigInt(this.getUint32(t + (e ? 4 : n - 8), e)) << 32n | BigInt(this.getUint32(t + (e ? 8 : n - 12), e)) << 64n;\n"
"            }, s = function(t, e, r) {\n"
"                const i = 0xffffffffn & e, s = e >> 32n & 0xffffffffn, o = e >> 64n & 0xffffffffn;\n"
"                this.setUint32(t + (r ? 0 : n - 4), Number(i), r), this.setUint32(t + (r ? 4 : n - 8), Number(s), r), \n"
"                this.setUint32(t + (r ? 8 : n - 12), Number(o), r);\n"
"            };\n"
"            return \"get\" === t ? function(t, e) {\n"
"                const n = i.call(this, t, e), s = n >> 79n, o = (0x7fff0000000000000000n & n) >> 64n, c = 0x00007fffffffffffffffn & n;\n"
"                if (0n === o) {\n"
"                    const t = c ? Number.MIN_VALUE : 0;\n"
"                    return s ? -t : t;\n"
"                }\n"
"                if (0x7fffn === o) return c ? NaN : s ? -1 / 0 : 1 / 0;\n"
"                const a = o - 16383n + 1023n;\n"
"                if (a >= 2047n) {\n"
"                    const t = 1 / 0;\n"
"                    return s ? -t : t;\n"
"                }\n"
"                const l = s << 63n | a << 52n | (c >> 11n) + BigInt((c & 2n ** 11n - 1n) >= 2n ** 10n);\n"
"                return r.setBigUint64(0, l, e), r.getFloat64(0, e);\n"
"            } : function(t, e, n) {\n"
"                r.setFloat64(0, e, n);\n"
"                const i = r.getBigUint64(0, n), o = i >> 63n, c = (0x7ff0000000000000n & i) >> 52n, a = 0x000fffffffffffffn & i;\n"
"                let l;\n"
"                l = 0n === c ? o << 79n | a << 11n : 0x07ffn === c ? o << 79n | 0x7fffn << 64n | (a ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n : o << 79n | c - 1023n + 16383n << 64n | a << 11n | 0x00008000000000000000n, \n"
"                s.call(this, t, l, n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorInt(t, e) {\n"
"            const {bitSize: n, byteSize: r} = e;\n"
"            if (r) {\n"
"                const e = this.getAccessor(t, {\n"
"                    type: D.Uint,\n"
"                    bitSize: 8 * r,\n"
"                    byteSize: r\n"
"                }), i = 2 ** (n - 1), s = i - 1;\n"
"                return \"get\" === t ? function(t, n) {\n"
"                    const r = e.call(this, t, n);\n"
"                    return (r & s) - (r & i);\n"
"                } : function(t, n, r) {\n"
"                    const o = n < 0 ? i | n & s : n & s;\n"
"                    e.call(this, t, o, r);\n"
"                };\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        getAccessorJumboInt(t, e) {\n"
"            const {bitSize: n} = e, r = this.getJumboAccessor(t, n), i = 2n ** BigInt(n - 1), s = i - 1n;\n"
"            return \"get\" === t ? function(t, e) {\n"
"                const n = r.call(this, t, e);\n"
"                return (n & s) - (n & i);\n"
"            } : function(t, e, n) {\n"
"                const o = e < 0 ? i | e & s : e & s;\n"
"                r.call(this, t, o, n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorJumboUint(t, e) {\n"
"            const {bitSize: n} = e, r = this.getJumboAccessor(t, n), i = 2n ** BigInt(n) - 1n;\n"
"            return \"get\" === t ? function(t, e) {\n"
"                return r.call(this, t, e) & i;\n"
"            } : function(t, e, n) {\n"
"                const s = e & i;\n"
"                r.call(this, t, s, n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getJumboAccessor(t, e) {\n"
"            const n = e + 63 >> 6;\n"
"            return \"get\" === t ? function(t, e) {\n"
"                let r = 0n;\n"
"                if (e) for (let i = 0, s = t + 8 * (n - 1); i < n; i++, s -= 8) {\n"
"                    r = r << 64n | this.getBigUint64(s, e);\n"
"                } else for (let i = 0, s = t; i < n; i++, s += 8) {\n"
"                    r = r << 64n | this.getBigUint64(s, e);\n"
"                }\n"
"                return r;\n"
"            } : function(t, e, r) {\n"
"                let i = e;\n"
"                const s = 0xffffffffffffffffn;\n"
"                if (r) for (let e = 0, o = t; e < n; e++, o += 8) {\n"
"                    const t = i & s;\n"
"                    this.setBigUint64(o, t, r), i >>= 64n;\n"
"                } else for (let e = 0, o = t + 8 * (n - 1); e < n; e++, o -= 8) {\n"
"                    const t = i & s;\n"
"                    this.setBigUint64(o, t, r), i >>= 64n;\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorUint(t, e) {\n"
"            const {bitSize: n, byteSize: r} = e;\n"
"            if (r) {\n"
"                const i = this.getAccessor(t, {\n"
"                    ...e,\n"
"                    bitSize: 8 * r\n"
"                }), s = 2 ** n - 1;\n"
"                return \"get\" === t ? function(t, e) {\n"
"                    return i.call(this, t, e) & s;\n"
"                } : function(t, e, n) {\n"
"                    const r = e & s;\n"
"                    i.call(this, t, r, n);\n"
"                };\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        getAccessorUnalignedBool1(t, e) {\n"
"            const {bitOffset: n} = e, r = 1 << (7 & n);\n"
"            return \"get\" === t ? function(t) {\n"
"                return !!(this.getInt8(t) & r);\n"
"            } : function(t, e) {\n"
"                const n = this.getInt8(t), i = e ? n | r : n & ~r;\n"
"                this.setInt8(t, i);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        getAccessorUnalignedInt(t, e) {\n"
"            const {bitSize: n, bitOffset: r} = e, i = 7 & r;\n"
"            if (i + n <= 8) {\n"
"                const e = 2 ** (n - 1), r = e - 1;\n"
"                if (\"get\" === t) return function(t) {\n"
"                    const n = this.getUint8(t) >>> i;\n"
"                    return (n & r) - (n & e);\n"
"                };\n"
"                {\n"
"                    const t = 255 ^ (r | e) << i;\n"
"                    return function(n, s) {\n"
"                        let o = this.getUint8(n);\n"
"                        o = o & t | (s < 0 ? e | s & r : s & r) << i, this.setUint8(n, o);\n"
"                    };\n"
"                }\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        getAccessorUnalignedUint(t, e) {\n"
"            const {bitSize: n, bitOffset: r} = e, i = 7 & r;\n"
"            if (i + n <= 8) {\n"
"                const e = 2 ** n - 1;\n"
"                if (\"get\" === t) return function(t) {\n"
"                    return this.getUint8(t) >>> i & e;\n"
"                };\n"
"                {\n"
"                    const t = 255 ^ e << i;\n"
"                    return function(n, r) {\n"
"                        const s = this.getUint8(n) & t | (r & e) << i;\n"
"                        this.setUint8(n, s);\n"
"                    };\n"
"                }\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        getAccessorUnaligned(t, e) {\n"
"            const {bitSize: n, bitOffset: r} = e, i = 7 & r, s = [ 1, 2, 4, 8 ].find((t => 8 * t >= n)) ?? 64 * Math.ceil(n / 64), o = new DataView(new ArrayBuffer(s));\n"
"            if (\"get\" === t) {\n"
"                const t = this.getAccessor(\"get\", {\n"
"                    ...e,\n"
"                    byteSize: s\n"
"                }), r = $e(i, n, !0);\n"
"                return function(e, n) {\n"
"                    return r(o, this, e), t.call(o, 0, n);\n"
"                };\n"
"            }\n"
"            {\n"
"                const t = this.getAccessor(\"set\", {\n"
"                    ...e,\n"
"                    byteSize: s\n"
"                }), r = $e(i, n, !1);\n"
"                return function(e, n, i) {\n"
"                    t.call(o, 0, n, i), r(this, o, e);\n"
"                };\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        createSignal(t, e) {\n"
"            const {constructor: {child: n}} = t.instance.members[0].structure, r = new Int32Array([ e?.aborted ? 1 : 0 ]), i = n(r);\n"
"            return e && e.addEventListener(\"abort\", (() => {\n"
"                Atomics.store(r, 0, 1);\n"
"            }), {\n"
"                once: !0\n"
"            }), {\n"
"                ptr: i\n"
"            };\n"
"        },\n"
"        createInboundSignal(t) {\n"
"            const e = new AbortController;\n"
"            if (t.ptr[\"*\"]) e.abort(); else {\n"
"                const n = setInterval((() => {\n"
"                    t.ptr[\"*\"] && (e.abort(), clearInterval(n));\n"
"                }), 50);\n"
"            }\n"
"            return e.signal;\n"
"        }\n"
"    });\n"
"    class InvalidIntConversion extends SyntaxError {\n"
"        constructor(t) {\n"
"            super(`Cannot convert ${t} to an Int`);\n"
"        }\n"
"    }\n"
"    class Unsupported extends TypeError {\n"
"        constructor() {\n"
"            super(\"Unsupported\");\n"
"        }\n"
"    }\n"
"    class NoInitializer extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`An initializer must be provided to the constructor of ${e}, even when the intended value is undefined`);\n"
"        }\n"
"    }\n"
"    class BufferSizeMismatch extends TypeError {\n"
"        constructor(t, n, r = null) {\n"
"            const {name: i, type: s, byteSize: o} = t, c = n.byteLength, a = 1 !== o ? \"s\" : \"\";\n"
"            let l;\n"
"            if (s !== e.Slice || r) {\n"
"                l = `${i} has ${s === e.Slice ? r.length * o : o} byte${a}, received ${c}`;\n"
"            } else l = `${i} has elements that are ${o} byte${a} in length, received ${c}`;\n"
"            super(l);\n"
"        }\n"
"    }\n"
"    class BufferExpected extends TypeError {\n"
"        constructor(t) {\n"
"            const {type: n, byteSize: r, typedArray: i} = t, s = 1 !== r ? \"s\" : \"\", o = [ \"ArrayBuffer\", \"DataView\" ].map(Be);\n"
"            let c;\n"
"            i && o.push(Be(i.name)), c = n === e.Slice ? `Expecting ${Ne(o)} that can accommodate items ${r} byte${s} in length` : `Expecting ${Ne(o)} that is ${r} byte${s} in length`, \n"
"            super(c);\n"
"        }\n"
"    }\n"
"    class EnumExpected extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {name: n} = t;\n"
"            let r;\n"
"            r = \"number\" == typeof e || \"bigint\" == typeof e ? `Value given does not correspond to an item of enum ${n}: ${e}` : `Enum item of the type ${n} expected, received ${e}`, \n"
"            super(r);\n"
"        }\n"
"    }\n"
"    class ErrorExpected extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {name: n} = t, r = typeof e;\n"
"            let i;\n"
"            \"string\" === r || \"number\" === r || Ce(e) ? (Ce(e) && (e = `{ error: ${JSON.stringify(e.error)} }`), \n"
"            i = `Error ${r} does not corresponds to any error in error set ${n}: ${e}`) : i = `Error of the type ${n} expected, received ${e}`, \n"
"            super(i);\n"
"        }\n"
"    }\n"
"    class NotInErrorSet extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`Error given is not a part of error set ${e}`);\n"
"        }\n"
"    }\n"
"    class MultipleUnionInitializers extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`Only one property of ${e} can be given a value`);\n"
"        }\n"
"    }\n"
"    class InactiveUnionProperty extends TypeError {\n"
"        constructor(t, e, n) {\n"
"            super(`Accessing property ${e} when ${n} is active`);\n"
"        }\n"
"    }\n"
"    class MissingUnionInitializer extends TypeError {\n"
"        constructor(t, e, n) {\n"
"            const {name: r, instance: {members: i}} = t;\n"
"            super(`${r} needs an initializer for one of its union properties: ${i.slice(0, n ? -1 : void 0).map((t => t.name)).join(\", \")}`);\n"
"        }\n"
"    }\n"
"    class InvalidInitializer extends TypeError {\n"
"        constructor(t, e, n) {\n"
"            const {name: r} = t, i = [];\n"
"            if (Array.isArray(e)) for (const t of e) i.push(Be(t)); else i.push(Be(e));\n"
"            const s = Fe(n);\n"
"            super(`${r} expects ${Ne(i)} as argument, received ${s}`);\n"
"        }\n"
"    }\n"
"    class InvalidArrayInitializer extends InvalidInitializer {\n"
"        constructor(t, n, r = !1) {\n"
"            const {instance: {members: [i]}, type: s, constructor: o} = t, c = [], a = se(i);\n"
"            if (a) {\n"
"                let t;\n"
"                switch (i.structure?.type) {\n"
"                  case e.Enum:\n"
"                    t = \"enum item\";\n"
"                    break;\n"
"\n"
"                  case e.ErrorSet:\n"
"                    t = \"error\";\n"
"                    break;\n"
"\n"
"                  default:\n"
"                    t = a;\n"
"                }\n"
"                c.push(`array of ${t}s`);\n"
"            } else c.push(\"array of objects\");\n"
"            o[jt] && c.push(o[jt].name), s === e.Slice && r && c.push(\"length\"), super(t, c.join(\" or \"), n);\n"
"        }\n"
"    }\n"
"    class ArrayLengthMismatch extends TypeError {\n"
"        constructor(t, e, n) {\n"
"            const {name: r, length: i, instance: {members: [s]}} = t, {structure: {constructor: o}} = s, {length: c, constructor: a} = n, l = e?.length ?? i, u = 1 !== l ? \"s\" : \"\";\n"
"            let f;\n"
"            f = a === o ? \"only a single one\" : a.child === o ? `a slice/array that has ${c}` : `${c} initializer${c > 1 ? \"s\" : \"\"}`, \n"
"            super(`${r} has ${l} element${u}, received ${f}`);\n"
"        }\n"
"    }\n"
"    class InvalidSliceLength extends TypeError {\n"
"        constructor(t, e) {\n"
"            super(t < 0 ? \"Length of slice cannot be negative\" : `Length of slice can be ${e} or less, received ${t}`);\n"
"        }\n"
"    }\n"
"    class MissingInitializers extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {name: n} = t;\n"
"            super(`Missing initializers for ${n}: ${e.join(\", \")}`);\n"
"        }\n"
"    }\n"
"    class NoProperty extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {name: n, instance: {members: r}} = t;\n"
"            let i;\n"
"            i = r.find((t => t.name === e)) ? `Comptime value cannot be changed: ${e}` : `${n} does not have a property with that name: ${e}`, \n"
"            super(i);\n"
"        }\n"
"    }\n"
"    class ArgumentCountMismatch extends Error {\n"
"        constructor(t, e, n = !1) {\n"
"            super();\n"
"            const r = r => {\n"
"                e -= r;\n"
"                const i = 1 !== (t -= r) ? \"s\" : \"\", s = n ? \"at least \" : \"\";\n"
"                this.message = `Expecting ${s}${t} argument${i}, received ${e}`, this.stack = Ue(this.stack, \"new Arg(\");\n"
"            };\n"
"            r(0), ee(this, Zt, {\n"
"                value: r,\n"
"                enumerable: !1\n"
"            });\n"
"        }\n"
"    }\n"
"    class UndefinedArgument extends Error {\n"
"        constructor() {\n"
"            super(\"Undefined argument\");\n"
"        }\n"
"    }\n"
"    class NoCastingToPointer extends TypeError {\n"
"        constructor() {\n"
"            super(\"Non-slice pointers can only be created with the help of the new operator\");\n"
"        }\n"
"    }\n"
"    class NoCastingToFunction extends TypeError {\n"
"        constructor() {\n"
"            super(\"Casting to function is not allowed\");\n"
"        }\n"
"    }\n"
"    class ConstantConstraint extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {name: n} = t, {constructor: {name: r}} = e;\n"
"            super(`Conversion of ${r} to ${n} requires an explicit cast`);\n"
"        }\n"
"    }\n"
"    class MisplacedSentinel extends TypeError {\n"
"        constructor(t, e, n, r) {\n"
"            const {name: i} = t;\n"
"            super(`${i} expects the sentinel value ${e} at ${r - 1}, found at ${n}`);\n"
"        }\n"
"    }\n"
"    class MissingSentinel extends TypeError {\n"
"        constructor(t, e, n) {\n"
"            const {name: r} = t;\n"
"            super(`${r} expects the sentinel value ${e} at ${n - 1}`);\n"
"        }\n"
"    }\n"
"    class AlignmentConflict extends TypeError {\n"
"        constructor(t, e) {\n"
"            super(`Unable to simultaneously align memory to ${e}-byte and ${t}-byte boundary`);\n"
"        }\n"
"    }\n"
"    class TypeMismatch extends TypeError {\n"
"        constructor(t, e) {\n"
"            const n = Fe(e);\n"
"            super(`Expected ${Be(t)}, received ${n}`);\n"
"        }\n"
"    }\n"
"    class InaccessiblePointer extends TypeError {\n"
"        constructor() {\n"
"            super(\"Pointers within an untagged union are not accessible\");\n"
"        }\n"
"    }\n"
"    class NullPointer extends TypeError {\n"
"        constructor() {\n"
"            super(\"Null pointer\");\n"
"        }\n"
"    }\n"
"    class PreviouslyFreed extends TypeError {\n"
"        constructor(t) {\n"
"            super(`Object has been freed already: ${t.constructor.name}`);\n"
"        }\n"
"    }\n"
"    class InvalidPointerTarget extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {name: n} = t;\n"
"            let r;\n"
"            if (null != e) {\n"
"                const t = e instanceof Object && e.constructor !== Object ? `${e.constructor.name} object` : typeof e;\n"
"                r = `${je(t)} ${t}`;\n"
"            } else r = e + \"\";\n"
"            super(`${n} cannot point to ${r}`);\n"
"        }\n"
"    }\n"
"    class ZigMemoryTargetRequired extends TypeError {\n"
"        constructor() {\n"
"            super(\"Pointers in Zig memory cannot point to garbage-collected object\");\n"
"        }\n"
"    }\n"
"    class Overflow extends TypeError {\n"
"        constructor(t, e) {\n"
"            const {type: n, bitSize: r} = t;\n"
"            super(`${(r > 32 ? \"Big\" : \"\") + R[n] + r} cannot represent the value given: ${e}`);\n"
"        }\n"
"    }\n"
"    class OutOfBound extends RangeError {\n"
"        constructor(t, e) {\n"
"            const {name: n} = t;\n"
"            super(`Index exceeds the size of ${n ?? \"array\"}: ${e}`);\n"
"        }\n"
"    }\n"
"    class NotUndefined extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`${void 0 !== e ? `Property ${e}` : \"Element\"} can only be undefined`);\n"
"        }\n"
"    }\n"
"    class NotOnByteBoundary extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e, structure: {name: n}} = t;\n"
"            super(`Unable to create ${n} as it is not situated on a byte boundary: ${e}`);\n"
"        }\n"
"    }\n"
"    class ReadOnly extends TypeError {\n"
"        constructor() {\n"
"            super(\"Unable to modify read-only object\");\n"
"        }\n"
"    }\n"
"    class ReadOnlyTarget extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`${e} cannot point to a read-only object`);\n"
"        }\n"
"    }\n"
"    class AccessingOpaque extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`Unable to access opaque structure ${e}`);\n"
"        }\n"
"    }\n"
"    class CreatingOpaque extends TypeError {\n"
"        constructor(t) {\n"
"            const {name: e} = t;\n"
"            super(`Unable to create instance of ${e}, as it is opaque`);\n"
"        }\n"
"    }\n"
"    class InvalidVariadicArgument extends TypeError {\n"
"        constructor() {\n"
"            super(\"Arguments passed to variadic function must be casted to a Zig type\");\n"
"        }\n"
"    }\n"
"    class UnexpectedGenerator extends TypeError {\n"
"        constructor() {\n"
"            super(\"Unexpected async generator\");\n"
"        }\n"
"    }\n"
"    class ZigError extends Error {\n"
"        constructor(t, e = 0) {\n"
"            if (t instanceof Error) return super(t.message), t.stack = Ue(this.stack, e), t;\n"
"            super(t ?? \"Error encountered in Zig code\");\n"
"        }\n"
"    }\n"
"    function Te(t, e) {\n"
"        const n = n => {\n"
"            e -= n, t.message = `args[${e}]: ${t.message}`, t.stack = Ue(t.stack, \"new Arg(\");\n"
"        };\n"
"        return n(0), ee(t, Zt, {\n"
"            value: n,\n"
"            enumerable: !1\n"
"        }), t;\n"
"    }\n"
"    function Ue(t, e) {\n"
"        if (\"string\" == typeof t) {\n"
"            const n = t.split(\"\\n\"), r = n.findIndex((t => t.includes(e)));\n"
"            -1 !== r && (n.splice(1, r), t = n.join(\"\\n\"));\n"
"        }\n"
"        return t;\n"
"    }\n"
"    function ze() {\n"
"        throw new ReadOnly;\n"
"    }\n"
"    function Ce(t) {\n"
"        return \"object\" == typeof t && \"string\" == typeof t.error && 1 === Object.keys(t).length;\n"
"    }\n"
"    function Fe(t) {\n"
"        const e = typeof t;\n"
"        let n;\n"
"        return n = \"object\" === e ? t ? Object.prototype.toString.call(t) : \"null\" : e, \n"
"        Be(n);\n"
"    }\n"
"    function Be(t) {\n"
"        return `${je(t)} ${t}`;\n"
"    }\n"
"    function je(t) {\n"
"        return /^\\W*[aeiou]/i.test(t) ? \"an\" : \"a\";\n"
"    }\n"
"    function Ne(t, e = \"or\") {\n"
"        const n = ` ${e} `;\n"
"        return t.length > 2 ? t.slice(0, -1).join(\", \") + n + t[t.length - 1] : t.join(n);\n"
"    }\n"
"    function ke(t) {\n"
"        let n, r = 1, i = null;\n"
"        if (t instanceof DataView) {\n"
"            n = t;\n"
"            const e = n?.[ct]?.align;\n"
"            e && (r = e);\n"
"        } else if (t instanceof ArrayBuffer) n = new DataView(t); else if (t) if (t[it]) t.constructor[lt] === e.Pointer && (t = t[\"*\"]), \n"
"        n = t[it], i = t.constructor, r = i[$t]; else {\n"
"            \"string\" == typeof t && (t = ce(t));\n"
"            const {buffer: e, byteOffset: i, byteLength: s, BYTES_PER_ELEMENT: o} = t;\n"
"            e && void 0 !== i && void 0 !== s && (n = new DataView(e, i, s), r = o);\n"
"        }\n"
"        return {\n"
"            dv: n,\n"
"            align: r,\n"
"            constructor: i\n"
"        };\n"
"    }\n"
"    xe({\n"
"        defineAlloc: () => ({\n"
"            value(t, e = 1) {\n"
"                const n = 31 - Math.clz32(e), {vtable: {alloc: r}, ptr: i} = this, s = r(i, t, n, 0);\n"
"                if (!s) throw new Error(\"Out of memory\");\n"
"                s.length = t;\n"
"                const o = s[\"*\"][it];\n"
"                return o[ct].align = e, o;\n"
"            }\n"
"        }),\n"
"        defineFree() {\n"
"            const t = this;\n"
"            return {\n"
"                value(e) {\n"
"                    const {dv: n, align: r} = ke(e), i = n?.[ct];\n"
"                    if (!i) throw new TypeMismatch(\"object containing allocated Zig memory\", e);\n"
"                    const {address: s} = i;\n"
"                    if (s === ge) throw new PreviouslyFreed(e);\n"
"                    const o = 31 - Math.clz32(r), {vtable: {free: c}, ptr: a} = this;\n"
"                    c(a, n, o, 0), t.releaseZigView(n);\n"
"                }\n"
"            };\n"
"        },\n"
"        defineDupe() {\n"
"            const t = this.getCopyFunction();\n"
"            return {\n"
"                value(e) {\n"
"                    const {dv: n, align: r, constructor: i} = ke(e);\n"
"                    if (!n) throw new TypeMismatch(\"string, DataView, typed array, or Zig object\", e);\n"
"                    const s = this.alloc(n.byteLength, r);\n"
"                    return t(s, n), i ? i(s) : s;\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.variables = [];\n"
"        },\n"
"        getSpecialExports() {\n"
"            const t = t => {\n"
"                if (void 0 === t) throw new Error(\"Not a Zig type\");\n"
"                return t;\n"
"            };\n"
"            return {\n"
"                init: (...t) => this.initialize?.(...t),\n"
"                abandon: () => this.abandonModule?.(),\n"
"                released: () => this.released,\n"
"                connect: t => this.consoleObject = t,\n"
"                sizeOf: e => t(e?.[xt]),\n"
"                alignOf: e => t(e?.[$t]),\n"
"                typeOf: e => n[t(e?.[lt])]?.toLowerCase()\n"
"            };\n"
"        },\n"
"        recreateStructures(t, e) {\n"
"            Object.assign(this, e);\n"
"            const n = (t, e) => {\n"
"                for (const [n, r] of Object.entries(e)) t[n] = i(r);\n"
"                return t;\n"
"            }, r = t => t.length ? t.buffer : new ArrayBuffer(0), i = t => {\n"
"                const {memory: e, structure: i, actual: s} = t;\n"
"                if (e) {\n"
"                    if (s) return s;\n"
"                    {\n"
"                        const {array: s, offset: o, length: c} = e, a = this.obtainView(r(s), o, c), {handle: l, const: u} = t, f = i?.constructor, h = t.actual = f.call(Ut, a);\n"
"                        return u && this.makeReadOnly(h), t.slots && n(h[st], t.slots), l && this.variables.push({\n"
"                            handle: l,\n"
"                            object: h\n"
"                        }), h;\n"
"                    }\n"
"                }\n"
"                return i;\n"
"            };\n"
"            this.resetGlobalErrorSet?.();\n"
"            const s = new Map;\n"
"            for (const e of t) {\n"
"                for (const t of [ e.instance, e.static ]) if (t.template) {\n"
"                    const {slots: e, memory: n, handle: i} = t.template, o = t.template = {};\n"
"                    if (n) {\n"
"                        const {array: t, offset: e, length: s} = n;\n"
"                        o[it] = this.obtainView(r(t), e, s), i && this.variables.push({\n"
"                            handle: i,\n"
"                            object: o\n"
"                        });\n"
"                    }\n"
"                    if (e) {\n"
"                        const t = o[st] = {};\n"
"                        s.set(t, e);\n"
"                    }\n"
"                }\n"
"                this.defineStructure(e);\n"
"            }\n"
"            for (const [t, e] of s) n(t, e);\n"
"            for (const e of t) this.finalizeStructure(e);\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.jsFunctionThunkMap = new Map, this.jsFunctionCallerMap = new Map, this.jsFunctionControllerMap = new Map, \n"
"            this.jsFunctionIdMap = new WeakMap, this.jsFunctionNextId = 1;\n"
"        },\n"
"        getFunctionId(t) {\n"
"            let e = this.jsFunctionIdMap.get(t);\n"
"            return void 0 === e && (e = this.jsFunctionNextId++, this.jsFunctionIdMap.set(t, e)), \n"
"            e;\n"
"        },\n"
"        getFunctionThunk(t, e) {\n"
"            const n = this.getFunctionId(t);\n"
"            let r = this.jsFunctionThunkMap.get(n);\n"
"            if (void 0 === r) {\n"
"                const t = this.getViewAddress(e[it]), i = this.createJsThunk(t, n);\n"
"                if (!i) throw new Error(\"Unable to create function thunk\");\n"
"                r = this.obtainZigView(i, 0), this.jsFunctionThunkMap.set(n, r), this.jsFunctionControllerMap.set(n, e);\n"
"            }\n"
"            return r;\n"
"        },\n"
"        createInboundCaller(t, e) {\n"
"            const n = this.getFunctionId(t);\n"
"            return this.jsFunctionCallerMap.set(n, ((n, r) => {\n"
"                let i = W, s = !1;\n"
"                try {\n"
"                    const o = e(n);\n"
"                    if (Gt in o) {\n"
"                        o[Gt](\"reset\");\n"
"                        const t = this.startContext();\n"
"                        this.updatePointerTargets(t, o, !0), this.updateShadowTargets(t), this.endContext();\n"
"                    }\n"
"                    const c = function(t) {\n"
"                        try {\n"
"                            if (!(e[Nt] && t instanceof Error)) throw t;\n"
"                            o[Qt](t);\n"
"                        } catch (e) {\n"
"                            i = H, console.error(t);\n"
"                        }\n"
"                    }, a = function(t) {\n"
"                        try {\n"
"                            o[Qt](t);\n"
"                        } catch (t) {\n"
"                            i = H, console.error(t);\n"
"                        }\n"
"                    };\n"
"                    try {\n"
"                        const e = t(...o), n = o.hasOwnProperty(Qt);\n"
"                        if (\"Promise\" === e?.[Symbol.toStringTag]) if (r || n) {\n"
"                            const t = e.then(a, c);\n"
"                            r && t.then((() => this.finalizeAsyncCall(r, i))), s = !0, i = W;\n"
"                        } else i = X; else if (e?.[Symbol.asyncIterator]) {\n"
"                            if (!o.hasOwnProperty(te)) throw new UnexpectedGenerator;\n"
"                            this.pipeContents(e, o), i = W;\n"
"                        } else null == e && n || a(e);\n"
"                    } catch (t) {\n"
"                        c(t);\n"
"                    }\n"
"                } catch (t) {\n"
"                    console.error(t), i = H;\n"
"                }\n"
"                return r && !s && this.finalizeAsyncCall(r, i), i;\n"
"            })), function(...e) {\n"
"                return t(...e);\n"
"            };\n"
"        },\n"
"        defineArgIterator(t) {\n"
"            const n = this, r = t.filter((({structure: t}) => t.type === e.Struct && t.flags & g)).length;\n"
"            return {\n"
"                value() {\n"
"                    let i, s = 0, o = 0, c = 0;\n"
"                    const a = [];\n"
"                    for (const [l, {structure: u, type: f}] of t.entries()) try {\n"
"                        let t, h, d = this[l];\n"
"                        f === D.Object && d?.[it]?.[ct] && (d = new d.constructor(d)), u.type === e.Struct && (u.flags & g ? (t = 1 === r ? \"allocator\" : \"allocator\" + ++s, \n"
"                        h = this[Lt] = d) : u.flags & y ? (t = \"callback\", 1 == ++o && (h = n.createPromiseCallback(this, d))) : u.flags & b ? (t = \"callback\", \n"
"                        1 == ++o && (h = n.createGeneratorCallback(this, d))) : u.flags & p && (t = \"signal\", \n"
"                        1 == ++c && (h = n.createInboundSignal(d)))), void 0 !== t ? void 0 !== h && (i ||= {}, \n"
"                        i[t] = h) : a.push(d);\n"
"                    } catch (t) {\n"
"                        a.push(t);\n"
"                    }\n"
"                    return i && a.push(i), a[Symbol.iterator]();\n"
"                }\n"
"            };\n"
"        },\n"
"        handleJsCall(t, e, n, r = 0) {\n"
"            const i = this.obtainZigView(e, n, !1), s = this.jsFunctionCallerMap.get(t);\n"
"            return s ? s(i, r) : H;\n"
"        },\n"
"        releaseFunction(t) {\n"
"            const e = this.jsFunctionThunkMap.get(t), n = this.jsFunctionControllerMap.get(t);\n"
"            if (e && n) {\n"
"                const r = this.getViewAddress(n[it]), i = this.getViewAddress(e);\n"
"                this.destroyJsThunk(r, i), this.releaseZigView(e), t && (this.jsFunctionThunkMap.delete(t), \n"
"                this.jsFunctionCallerMap.delete(t), this.jsFunctionControllerMap.delete(t));\n"
"            }\n"
"        },\n"
"        exports: {\n"
"            handleJsCall: null,\n"
"            releaseFunction: null\n"
"        },\n"
"        imports: {\n"
"            createJsThunk: null,\n"
"            destroyJsThunk: null,\n"
"            finalizeAsyncCall: null\n"
"        }\n"
"    }), xe({\n"
"        createOutboundCaller(t, e) {\n"
"            const n = this, r = function(...i) {\n"
"                const s = new e(i, this?.[Lt]);\n"
"                return n.invokeThunk(t, r, s);\n"
"            };\n"
"            return r;\n"
"        },\n"
"        copyArguments(t, n, r, i, s) {\n"
"            let o = 0, c = 0, a = 0;\n"
"            const l = t[Bt];\n"
"            for (const {type: u, structure: f} of r) {\n"
"                let r, h, d, m;\n"
"                if (f.type === e.Struct) if (f.flags & g) {\n"
"                    r = (1 == ++a ? i?.allocator ?? i?.allocator1 : i?.[`allocator${a}`]) ?? this.createDefaultAllocator(t, f);\n"
"                } else f.flags & y ? (h ||= this.createPromise(t, i?.callback), r = h) : f.flags & b ? (d ||= this.createGenerator(t, i?.callback), \n"
"                r = d) : f.flags & p && (m ||= this.createSignal(f, i?.signal), r = m);\n"
"                if (void 0 === r && (r = n[c++], void 0 === r && u !== D.Void)) throw new UndefinedArgument;\n"
"                try {\n"
"                    l[o++].call(t, r, s);\n"
"                } catch (t) {\n"
"                    throw Te(t, o - 1);\n"
"                }\n"
"            }\n"
"        },\n"
"        invokeThunk(t, e, n) {\n"
"            const r = this.startContext(), i = n[zt], s = this.getViewAddress(t[it]), o = this.getViewAddress(e[it]), c = Yt in n, a = Gt in n;\n"
"            a && this.updatePointerAddresses(r, n);\n"
"            const l = this.getViewAddress(n[it]), u = i ? this.getViewAddress(i[it]) : 0;\n"
"            this.updateShadows(r);\n"
"            const f = () => {\n"
"                this.updateShadowTargets(r), a && this.updatePointerTargets(r, n), this.libc && this.flushStdout?.(), \n"
"                this.flushConsole?.(), this.endContext();\n"
"            };\n"
"            c && (n[Yt] = f);\n"
"            if (!(i ? this.runVariadicThunk(s, o, l, u, i.length) : this.runThunk(s, o, l))) throw f(), \n"
"            new ZigError;\n"
"            if (c) {\n"
"                let t = null;\n"
"                try {\n"
"                    t = n.retval;\n"
"                } catch (e) {\n"
"                    t = new ZigError(e, 1);\n"
"                }\n"
"                return null != t && n[Qt](t), n[kt] ?? n[Pt];\n"
"            }\n"
"            f();\n"
"            try {\n"
"                return n.retval;\n"
"            } catch (t) {\n"
"                throw new ZigError(t, 1);\n"
"            }\n"
"        },\n"
"        imports: {\n"
"            runThunk: null,\n"
"            runVariadicThunk: null\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            const t = {\n"
"                type: D.Int,\n"
"                bitSize: 8,\n"
"                byteSize: 1\n"
"            }, e = {\n"
"                type: D.Int,\n"
"                bitSize: 16,\n"
"                byteSize: 2\n"
"            }, n = {\n"
"                type: D.Int,\n"
"                bitSize: 32,\n"
"                byteSize: 4\n"
"            }, r = this.getAccessor(\"get\", t), i = this.getAccessor(\"set\", t), s = this.getAccessor(\"get\", e), o = this.getAccessor(\"set\", e), c = this.getAccessor(\"get\", n), a = this.getAccessor(\"set\", n);\n"
"            this.copiers = {\n"
"                0: Ee,\n"
"                1: function(t, e) {\n"
"                    i.call(t, 0, r.call(e, 0));\n"
"                },\n"
"                2: function(t, e) {\n"
"                    o.call(t, 0, s.call(e, 0, !0), !0);\n"
"                },\n"
"                4: function(t, e) {\n"
"                    a.call(t, 0, c.call(e, 0, !0), !0);\n"
"                },\n"
"                8: function(t, e) {\n"
"                    a.call(t, 0, c.call(e, 0, !0), !0), a.call(t, 4, c.call(e, 4, !0), !0);\n"
"                },\n"
"                16: function(t, e) {\n"
"                    a.call(t, 0, c.call(e, 0, !0), !0), a.call(t, 4, c.call(e, 4, !0), !0), a.call(t, 8, c.call(e, 8, !0), !0), \n"
"                    a.call(t, 12, c.call(e, 12, !0), !0);\n"
"                },\n"
"                any: function(t, e) {\n"
"                    let n = 0, s = t.byteLength;\n"
"                    for (;n + 4 <= s; ) a.call(t, n, c.call(e, n, !0), !0), n += 4;\n"
"                    for (;n + 1 <= s; ) i.call(t, n, r.call(e, n)), n++;\n"
"                }\n"
"            }, this.resetters = {\n"
"                0: Ee,\n"
"                1: function(t, e) {\n"
"                    i.call(t, e, 0);\n"
"                },\n"
"                2: function(t, e) {\n"
"                    o.call(t, e, 0, !0);\n"
"                },\n"
"                4: function(t, e) {\n"
"                    a.call(t, e, 0, !0);\n"
"                },\n"
"                8: function(t, e) {\n"
"                    a.call(t, e + 0, 0, !0), a.call(t, e + 4, 0, !0);\n"
"                },\n"
"                16: function(t, e) {\n"
"                    a.call(t, e + 0, 0, !0), a.call(t, e + 4, 0, !0), a.call(t, e + 8, 0, !0), a.call(t, e + 12, 0, !0);\n"
"                },\n"
"                any: function(t, e, n) {\n"
"                    let r = e;\n"
"                    for (;r + 4 <= n; ) a.call(t, r, 0, !0), r += 4;\n"
"                    for (;r + 1 <= n; ) i.call(t, r, 0), r++;\n"
"                }\n"
"            };\n"
"        },\n"
"        defineCopier(t, e) {\n"
"            const n = this.getCopyFunction(t, e);\n"
"            return {\n"
"                value(t) {\n"
"                    const e = t[it], r = this[it];\n"
"                    n(r, e);\n"
"                }\n"
"            };\n"
"        },\n"
"        defineResetter(t, e) {\n"
"            const n = this.getResetFunction(e);\n"
"            return {\n"
"                value() {\n"
"                    const r = this[it];\n"
"                    n(r, t, e);\n"
"                }\n"
"            };\n"
"        },\n"
"        getCopyFunction(t, e = !1) {\n"
"            return (e ? void 0 : this.copiers[t]) ?? this.copiers.any;\n"
"        },\n"
"        getResetFunction(t) {\n"
"            return this.resetters[t] ?? this.resetters.any;\n"
"        },\n"
"        imports: {\n"
"            copyExternBytes: null\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.defaultAllocator = null, this.vtableFnIds = null;\n"
"        },\n"
"        createDefaultAllocator(t, e) {\n"
"            let n = this.defaultAllocator;\n"
"            if (!n) {\n"
"                const {constructor: t} = e, {noResize: r, noRemap: i} = t, s = {\n"
"                    alloc: (t, e, n) => this.allocateHostMemory(e, 1 << n),\n"
"                    free: (t, e, n) => {\n"
"                        const r = this.getViewAddress(e[\"*\"][it]), i = e.length;\n"
"                        this.freeHostMemory(r, i, 1 << n);\n"
"                    },\n"
"                    resize: r\n"
"                };\n"
"                i && (s.remap = i);\n"
"                const o = this.obtainZigView(de, 0);\n"
"                n = this.defaultAllocator = new t({\n"
"                    ptr: o,\n"
"                    vtable: s\n"
"                }), this.vtableFnIds = [ s.alloc, s.free ].map((t => this.getFunctionId(t)));\n"
"            }\n"
"            return n;\n"
"        },\n"
"        freeDefaultAllocator() {\n"
"            if (this.vtableFnIds) {\n"
"                for (const t of this.vtableFnIds) this.releaseFunction(t);\n"
"                this.defaultAllocator = null, this.vtableFnIds = null;\n"
"            }\n"
"        },\n"
"        allocateHostMemory(t, e) {\n"
"            const n = this.allocateJSMemory(t, e);\n"
"            {\n"
"                const r = this.getViewAddress(n);\n"
"                return this.registerMemory(r, t, e, !0, n), n[ct] = {\n"
"                    address: r,\n"
"                    len: t,\n"
"                    js: !0\n"
"                }, n;\n"
"            }\n"
"        },\n"
"        freeHostMemory(t, e, n) {\n"
"            this.unregisterMemory(t, e);\n"
"        }\n"
"    }), xe({\n"
"        createGenerator(t, e) {\n"
"            if (e) {\n"
"                if (\"function\" != typeof e) throw new TypeMismatch(\"function\", e);\n"
"            } else {\n"
"                const n = t[Pt] = new AsyncGenerator;\n"
"                e = n.push.bind(n);\n"
"            }\n"
"            const n = async (r, i) => {\n"
"                const s = i instanceof Error;\n"
"                if (!1 === await (2 === e.length ? e(s ? i : null, s ? null : i) : e(i)) || s || null === i) {\n"
"                    t[Yt]();\n"
"                    const e = this.getFunctionId(n);\n"
"                    return this.releaseFunction(e), !1;\n"
"                }\n"
"                return !0;\n"
"            };\n"
"            return t[Qt] = t => n(null, t), {\n"
"                ptr: null,\n"
"                callback: n\n"
"            };\n"
"        },\n"
"        createGeneratorCallback(t, e) {\n"
"            const {ptr: n, callback: r} = e, i = r[\"*\"];\n"
"            return t[te] = e => i.call(t, n, e), (...e) => {\n"
"                const n = 2 === e.length ? e[0] ?? e[1] : e[0];\n"
"                return t[te](n);\n"
"            };\n"
"        },\n"
"        async pipeContents(t, e) {\n"
"            try {\n"
"                try {\n"
"                    const n = t[Symbol.asyncIterator]();\n"
"                    for await (const t of n) if (null !== t && !e[te](t)) break;\n"
"                    e[te](null);\n"
"                } catch (t) {\n"
"                    if (!e.constructor[Nt]) throw t;\n"
"                    e[te](t);\n"
"                }\n"
"            } catch (t) {\n"
"                console.error(t);\n"
"            }\n"
"        }\n"
"    });\n"
"    class AsyncGenerator {\n"
"        result=null;\n"
"        stopped=!1;\n"
"        finished=!1;\n"
"        promises={};\n"
"        async next() {\n"
"            if (this.stopped) return {\n"
"                done: !0\n"
"            };\n"
"            for (;;) {\n"
"                const t = this.result;\n"
"                if (null !== t) return this.result = null, this.wake(\"space\"), {\n"
"                    value: t,\n"
"                    done: !1\n"
"                };\n"
"                if (this.error) throw this.error;\n"
"                if (this.finished) return {\n"
"                    done: !0\n"
"                };\n"
"                await this.sleep(\"content\");\n"
"            }\n"
"        }\n"
"        async return(t) {\n"
"            return await this.break(), {\n"
"                value: t,\n"
"                done: !0\n"
"            };\n"
"        }\n"
"        async throw(t) {\n"
"            throw await this.break(), t;\n"
"        }\n"
"        async break() {\n"
"            this.finished || (this.stopped = !0, await this.sleep(\"break\"));\n"
"        }\n"
"        async push(t) {\n"
"            return this.stopped ? (this.wake(\"break\"), !1) : (t instanceof Error ? (this.error = t, \n"
"            this.finished = !0) : null === t ? this.finished = !0 : (null !== this.result && await this.sleep(\"space\"), \n"
"            this.result = t), this.wake(\"content\"), !this.finished);\n"
"        }\n"
"        sleep(t) {\n"
"            let e;\n"
"            const n = this.promises[t] ||= new Promise((t => e = t));\n"
"            return e && (n.resolve = e), n;\n"
"        }\n"
"        wake(t) {\n"
"            const e = this.promises[t];\n"
"            e && (this.promises[t] = null, this.finished || this.stopped ? setImmediate(e.resolve) : e.resolve());\n"
"        }\n"
"        [Symbol.asyncIterator]() {\n"
"            return this;\n"
"        }\n"
"    }\n"
"    function Pe(t, e) {\n"
"        return ue(t, e, (t => t.address));\n"
"    }\n"
"    function Le(t, n) {\n"
"        const {byteSize: r, type: i} = n;\n"
"        if (!(i === e.Slice ? t.byteLength % r == 0 : t.byteLength === r)) throw new BufferSizeMismatch(n, t);\n"
"    }\n"
"    function De(t) {\n"
"        throw new BufferExpected(t);\n"
"    }\n"
"    xe({\n"
"        addIntConversion: t => function(e, n) {\n"
"            const r = t.call(this, e, n), {flags: i, bitSize: s} = n;\n"
"            if (\"set\" === e) return s > 32 ? function(t, e, n) {\n"
"                r.call(this, t, BigInt(e), n);\n"
"            } : function(t, e, n) {\n"
"                const i = Number(e);\n"
"                if (!isFinite(i)) throw new InvalidIntConversion(e);\n"
"                r.call(this, t, i, n);\n"
"            };\n"
"            {\n"
"                const {flags: t} = n.structure;\n"
"                if (t & c && s > 32) {\n"
"                    const t = BigInt(Number.MAX_SAFE_INTEGER), e = BigInt(Number.MIN_SAFE_INTEGER);\n"
"                    return function(n, i) {\n"
"                        const s = r.call(this, n, i);\n"
"                        return e <= s && s <= t ? Number(s) : s;\n"
"                    };\n"
"                }\n"
"            }\n"
"            return r;\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.isMemoryMapping = !0, this.memoryList = [], this.contextCount = 0, this.externBufferList = [];\n"
"        },\n"
"        startContext() {\n"
"            return ++this.contextCount, {\n"
"                shadowList: []\n"
"            };\n"
"        },\n"
"        endContext() {\n"
"            if (0 == --this.contextCount) {\n"
"                for (const {shadowDV: t} of this.memoryList) t && this.freeShadowMemory(t);\n"
"                this.memoryList.splice(0);\n"
"            }\n"
"        },\n"
"        getShadowAddress(t, e, n, r) {\n"
"            const i = e[it];\n"
"            if (n) {\n"
"                if (void 0 === n.address) {\n"
"                    const {start: e, end: s, targets: o} = n;\n"
"                    let c, a = 0;\n"
"                    for (const t of o) {\n"
"                        const e = t[it], n = e.byteOffset, r = t.constructor[$t] ?? e[$t];\n"
"                        (void 0 === a || r > a) && (a = r, c = n);\n"
"                    }\n"
"                    const l = s - e, u = this.allocateShadowMemory(l + a, 1), f = this.getViewAddress(u), h = he(ye(f, c - e), a), d = ye(h, e - c);\n"
"                    for (const t of o) {\n"
"                        const n = t[it], r = n.byteOffset;\n"
"                        if (r !== c) {\n"
"                            const i = t.constructor[$t] ?? n[$t];\n"
"                            if (fe(ye(d, r - e), i)) throw new AlignmentConflict(i, a);\n"
"                        }\n"
"                    }\n"
"                    const g = u.byteOffset + Number(d - f), y = new DataView(u.buffer, g, l), b = new DataView(i.buffer, Number(e), l), p = this.registerMemory(d, l, 1, r, b, y);\n"
"                    t.shadowList.push(p), n.address = d;\n"
"                }\n"
"                return ye(n.address, i.byteOffset - n.start);\n"
"            }\n"
"            {\n"
"                const n = e.constructor[$t] ?? i[$t], s = i.byteLength, o = this.allocateShadowMemory(s, n), c = this.getViewAddress(o), a = this.registerMemory(c, s, 1, r, i, o);\n"
"                return t.shadowList.push(a), c;\n"
"            }\n"
"        },\n"
"        updateShadows(t) {\n"
"            const e = this.getCopyFunction();\n"
"            for (let {targetDV: n, shadowDV: r} of t.shadowList) e(r, n);\n"
"        },\n"
"        updateShadowTargets(t) {\n"
"            const e = this.getCopyFunction();\n"
"            for (let {targetDV: n, shadowDV: r, writable: i} of t.shadowList) i && e(n, r);\n"
"        },\n"
"        registerMemory(t, e, n, r, i, s) {\n"
"            const o = Pe(this.memoryList, t);\n"
"            let c = this.memoryList[o - 1];\n"
"            return c?.address === t && c.len === e ? c.writable ||= r : (c = {\n"
"                address: t,\n"
"                len: e,\n"
"                align: n,\n"
"                writable: r,\n"
"                targetDV: i,\n"
"                shadowDV: s\n"
"            }, this.memoryList.splice(o, 0, c)), c;\n"
"        },\n"
"        unregisterMemory(t, e) {\n"
"            const n = Pe(this.memoryList, t), r = this.memoryList[n - 1];\n"
"            if (r?.address === t && r.len === e) return this.memoryList.splice(n - 1, 1), r;\n"
"        },\n"
"        findMemory(t, e, n, r) {\n"
"            let i = n * (r ?? 0);\n"
"            const s = Pe(this.memoryList, e), o = this.memoryList[s - 1];\n"
"            let c;\n"
"            if (o?.address === e && o.len === i) c = o.targetDV; else if (o?.address <= e && ye(e, i) <= ye(o.address, o.len)) {\n"
"                const t = Number(e - o.address), n = void 0 === r, {targetDV: s} = o;\n"
"                n && (i = s.byteLength - t), c = this.obtainView(s.buffer, s.byteOffset + t, i), \n"
"                n && (c[$t] = o.align);\n"
"            }\n"
"            if (c) {\n"
"                let {targetDV: e, shadowDV: n} = o;\n"
"                if (n && t && !t.shadowList.includes(o)) {\n"
"                    this.getCopyFunction()(e, n);\n"
"                }\n"
"            } else c = this.obtainZigView(e, i);\n"
"            return c;\n"
"        },\n"
"        findShadowView(t) {\n"
"            for (const {shadowDV: e, targetDV: n} of this.memoryList) if (n === t) return e;\n"
"        },\n"
"        releaseZigView(t) {\n"
"            const e = t[ct], n = e?.address;\n"
"            n && n !== ge && (e.address = ge, this.unregisterBuffer(ye(n, -t.byteOffset)));\n"
"        },\n"
"        getViewAddress(t) {\n"
"            const e = t[ct];\n"
"            if (e) return e.address;\n"
"            {\n"
"                const e = this.getBufferAddress(t.buffer);\n"
"                return ye(e, t.byteOffset);\n"
"            }\n"
"        },\n"
"        ...{\n"
"            imports: {\n"
"                getBufferAddress: null,\n"
"                obtainExternBuffer: null\n"
"            },\n"
"            exports: {\n"
"                getViewAddress: null\n"
"            },\n"
"            allocateShadowMemory(t, e) {\n"
"                return this.allocateJSMemory(t, e);\n"
"            },\n"
"            freeShadowMemory(t) {},\n"
"            obtainZigView(t, e, n = !0) {\n"
"                if (function(t) {\n"
"                    return 0xaaaaaaaaaaaaaaaan === t;\n"
"                }(t) && (t = e > 0 ? 0 : de), !t && e) return null;\n"
"                if (n) {\n"
"                    const n = Pe(this.externBufferList, t), r = this.externBufferList[n - 1];\n"
"                    let i, s;\n"
"                    return r?.address <= t && ye(t, e) <= ye(r.address, r.len) ? (i = r.buffer, s = Number(t - r.address)) : (i = e > 0 ? this.obtainExternBuffer(t, e, Dt) : new ArrayBuffer(0), \n"
"                    i[ct] = {\n"
"                        address: t,\n"
"                        len: e\n"
"                    }, this.externBufferList.splice(n, 0, {\n"
"                        address: t,\n"
"                        len: e,\n"
"                        buffer: i\n"
"                    }), s = 0), this.obtainView(i, s, e);\n"
"                }\n"
"                {\n"
"                    const n = this.obtainExternBuffer(t, e, Dt);\n"
"                    return new DataView(n, 0, e);\n"
"                }\n"
"            },\n"
"            unregisterBuffer(t) {\n"
"                const e = Pe(this.externBufferList, t), n = this.externBufferList[e - 1];\n"
"                n?.address === t && this.externBufferList.splice(e - 1, 1);\n"
"            },\n"
"            getTargetAddress(t, e, n, r) {\n"
"                const i = e[it];\n"
"                if (n) {\n"
"                    if (void 0 === n.misaligned) {\n"
"                        const t = this.getBufferAddress(i.buffer);\n"
"                        for (const e of n.targets) {\n"
"                            const r = e[it].byteOffset, i = e.constructor[$t], s = ye(t, r);\n"
"                            if (fe(s, i)) {\n"
"                                n.misaligned = !0;\n"
"                                break;\n"
"                            }\n"
"                        }\n"
"                        void 0 === n.misaligned && (n.misaligned = !1, n.address = t);\n"
"                    }\n"
"                    if (!n.misaligned) return ye(n.address, i.byteOffset);\n"
"                } else {\n"
"                    const t = e.constructor[$t], n = this.getViewAddress(i);\n"
"                    if (!fe(n, t)) {\n"
"                        const e = i.byteLength;\n"
"                        return this.registerMemory(n, e, t, r, i), n;\n"
"                    }\n"
"                }\n"
"                return this.getShadowAddress(t, e, n, r);\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.released = !1, this.abandoned = !1;\n"
"        },\n"
"        releaseFunctions() {\n"
"            const t = () => {\n"
"                throw new Error(\"Module was abandoned\");\n"
"            };\n"
"            for (const e of Object.keys(this.imports)) this[e] && (this[e] = t);\n"
"        },\n"
"        abandonModule() {\n"
"            this.abandoned || (this.releaseFunctions(), this.unlinkVariables?.(), this.abandoned = !0);\n"
"        },\n"
"        ...{\n"
"            imports: {\n"
"                loadModule: null\n"
"            },\n"
"            exportFunctions() {\n"
"                const t = {};\n"
"                for (const [e, n] of Object.entries(this.exports)) {\n"
"                    const r = this[n ?? e];\n"
"                    r && (t[e] = r.bind(this));\n"
"                }\n"
"                return t;\n"
"            },\n"
"            importFunctions(t) {\n"
"                for (const [e, n] of Object.entries(this.imports)) {\n"
"                    const r = t[n ?? e];\n"
"                    r && (this[e] = r);\n"
"                }\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        linkVariables(t) {\n"
"            const e = this.getCopyFunction();\n"
"            for (const {object: n, handle: r} of this.variables) {\n"
"                const i = n[it], s = this.recreateAddress(r), o = n[it] = this.obtainZigView(s, i.byteLength);\n"
"                t && e(o, i), n.constructor[Mt]?.save?.(o, n);\n"
"                const c = t => {\n"
"                    const e = t[st];\n"
"                    if (e) {\n"
"                        const t = o.byteOffset;\n"
"                        for (const n of Object.values(e)) if (n) {\n"
"                            const e = n[it];\n"
"                            if (e.buffer === i.buffer) {\n"
"                                const r = t + e.byteOffset - i.byteOffset;\n"
"                                n[it] = this.obtainView(o.buffer, r, e.byteLength), n.constructor[Mt]?.save?.(o, n), \n"
"                                c(n);\n"
"                            }\n"
"                        }\n"
"                    }\n"
"                };\n"
"                c(n), n[Gt]?.((function() {\n"
"                    this[Zt]();\n"
"                }), tt.IgnoreInactive);\n"
"            }\n"
"        },\n"
"        unlinkVariables() {\n"
"            const t = this.getCopyFunction();\n"
"            for (const {object: e} of this.variables) {\n"
"                const n = e[it], r = n[ct];\n"
"                if (r) {\n"
"                    t(e[it] = this.allocateMemory(r.len), n);\n"
"                }\n"
"            }\n"
"        },\n"
"        imports: {\n"
"            recreateAddress: null\n"
"        }\n"
"    }), xe({\n"
"        updatePointerAddresses(t, e) {\n"
"            const n = new Map, r = new Map, i = [], s = function(t) {\n"
"                const e = this[gt];\n"
"                if (void 0 === n.get(e)) {\n"
"                    const t = e[st][0];\n"
"                    if (t) {\n"
"                        const o = {\n"
"                            target: t,\n"
"                            writable: !e.constructor.const\n"
"                        }, c = t[it];\n"
"                        if (c[ct]) n.set(e, null); else {\n"
"                            n.set(e, t);\n"
"                            const a = r.get(c.buffer);\n"
"                            if (a) {\n"
"                                const t = Array.isArray(a) ? a : [ a ], e = ue(t, c.byteOffset, (t => t.target[it].byteOffset));\n"
"                                t.splice(e, 0, o), Array.isArray(a) || (r.set(c.buffer, t), i.push(t));\n"
"                            } else r.set(c.buffer, o);\n"
"                            t[Gt]?.(s, 0);\n"
"                        }\n"
"                    }\n"
"                }\n"
"            }, o = tt.IgnoreRetval | tt.IgnoreInactive;\n"
"            e[Gt](s, o);\n"
"            const c = this.findTargetClusters(i), a = new Map;\n"
"            for (const t of c) for (const e of t.targets) a.set(e, t);\n"
"            for (const [e, r] of n) if (r) {\n"
"                const n = a.get(r), i = n?.writable ?? !e.constructor.const;\n"
"                e[St] = this.getTargetAddress(t, r, n, i), At in e && (e[At] = r.length);\n"
"            }\n"
"        },\n"
"        updatePointerTargets(t, e, n = !1) {\n"
"            const r = new Map, i = function(e) {\n"
"                const n = this[gt];\n"
"                if (!r.get(n)) {\n"
"                    r.set(n, !0);\n"
"                    const s = n[st][0], o = s && e & tt.IsImmutable ? s : n[Zt](t, !0, !(e & tt.IsInactive)), c = n.constructor.const ? tt.IsImmutable : 0;\n"
"                    c & tt.IsImmutable || s && !s[it][ct] && s[Gt]?.(i, c), o !== s && o && !o[it][ct] && o?.[Gt]?.(i, c);\n"
"                }\n"
"            }, s = n ? tt.IgnoreRetval : 0;\n"
"            e[Gt](i, s);\n"
"        },\n"
"        findTargetClusters(t) {\n"
"            const e = [];\n"
"            for (const n of t) {\n"
"                let t = null, r = 0, i = 0, s = null;\n"
"                for (const {target: o, writable: c} of n) {\n"
"                    const n = o[it], {byteOffset: a, byteLength: l} = n, u = a + l;\n"
"                    let f = !0;\n"
"                    t && (i > a ? (s ? s.writable ||= c : (s = {\n"
"                        targets: [ t ],\n"
"                        start: r,\n"
"                        end: i,\n"
"                        address: void 0,\n"
"                        misaligned: void 0,\n"
"                        writable: c\n"
"                    }, e.push(s)), s.targets.push(o), u > i ? s.end = u : f = !1) : s = null), f && (t = o, \n"
"                    r = a, i = u);\n"
"                }\n"
"            }\n"
"            return e;\n"
"        }\n"
"    }), xe({\n"
"        createPromise(t, e) {\n"
"            if (e) {\n"
"                if (\"function\" != typeof e) throw new TypeMismatch(\"function\", e);\n"
"            } else t[kt] = new Promise(((t, n) => {\n"
"                e = e => {\n"
"                    e?.[it]?.[ct] && (e = new e.constructor(e)), e instanceof Error ? n(e) : t(e);\n"
"                };\n"
"            }));\n"
"            const n = (r, i) => {\n"
"                if (2 === e.length) {\n"
"                    const t = i instanceof Error;\n"
"                    e(t ? i : null, t ? null : i);\n"
"                } else e(i);\n"
"                t[Yt]();\n"
"                const s = this.getFunctionId(n);\n"
"                this.releaseFunction(s);\n"
"            };\n"
"            return t[Qt] = t => n(null, t), {\n"
"                ptr: null,\n"
"                callback: n\n"
"            };\n"
"        },\n"
"        createPromiseCallback(t, e) {\n"
"            const {ptr: n, callback: r} = e, i = r[\"*\"];\n"
"            return t[Qt] = e => i.call(t, n, e), (...e) => {\n"
"                const n = 2 === e.length ? e[0] ?? e[1] : e[0];\n"
"                return t[Qt](n);\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        addRuntimeCheck: t => function(e, n) {\n"
"            const r = t.call(this, e, n);\n"
"            if (\"set\" === e) {\n"
"                const {min: t, max: e} = function(t) {\n"
"                    const {type: e, bitSize: n} = t, r = e === D.Int;\n"
"                    let i = r ? n - 1 : n;\n"
"                    if (n <= 32) {\n"
"                        return {\n"
"                            min: r ? -(2 ** i) : 0,\n"
"                            max: 2 ** i - 1\n"
"                        };\n"
"                    }\n"
"                    i = BigInt(i);\n"
"                    return {\n"
"                        min: r ? -(2n ** i) : 0n,\n"
"                        max: 2n ** i - 1n\n"
"                    };\n"
"                }(n);\n"
"                return function(i, s, o) {\n"
"                    if (s < t || s > e) throw new Overflow(n, s);\n"
"                    r.call(this, i, s, o);\n"
"                };\n"
"            }\n"
"            return r;\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.consoleObject = null, this.consolePending = [], this.consoleTimeout = 0;\n"
"        },\n"
"        writeToConsole(t) {\n"
"            try {\n"
"                const e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength).slice(), n = e.lastIndexOf(10);\n"
"                if (-1 === n) this.consolePending.push(e); else {\n"
"                    const t = e.subarray(0, n), r = e.subarray(n + 1);\n"
"                    this.writeToConsoleNow([ ...this.consolePending, t ]), this.consolePending.splice(0), \n"
"                    r.length > 0 && this.consolePending.push(r);\n"
"                }\n"
"                return clearTimeout(this.consoleTimeout), this.consoleTimeout = 0, this.consolePending.length > 0 && (this.consoleTimeout = setTimeout((() => {\n"
"                    this.writeToConsoleNow(this.consolePending), this.consolePending.splice(0);\n"
"                }), 250)), !0;\n"
"            } catch (t) {\n"
"                return console.error(t), !1;\n"
"            }\n"
"        },\n"
"        writeToConsoleNow(t) {\n"
"            const e = this.consoleObject ?? globalThis.console;\n"
"            e.log?.call?.(e, oe(t));\n"
"        },\n"
"        flushConsole() {\n"
"            this.consolePending.length > 0 && (this.writeToConsoleNow(this.consolePending), \n"
"            this.consolePending.splice(0), clearTimeout(this.consoleTimeout));\n"
"        },\n"
"        ...{\n"
"            exports: {\n"
"                writeBytes: null\n"
"            },\n"
"            imports: {\n"
"                flushStdout: null\n"
"            },\n"
"            writeBytes(t, e) {\n"
"                const n = this.obtainZigView(t, e, !1);\n"
"                return this.writeToConsole(n) ? W : H;\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        init() {\n"
"            this.comptime = !1, this.slots = {}, this.structures = [], this.structureCounters = {\n"
"                struct: 0,\n"
"                union: 0,\n"
"                errorSet: 0,\n"
"                enum: 0,\n"
"                opaque: 0\n"
"            }, this.littleEndian = !0, this.runtimeSafety = !1, this.libc = !1;\n"
"        },\n"
"        readSlot(t, e) {\n"
"            const n = t ? t[st] : this.slots;\n"
"            return n?.[e];\n"
"        },\n"
"        writeSlot(t, e, n) {\n"
"            const r = t ? t[st] : this.slots;\n"
"            r && (r[e] = n);\n"
"        },\n"
"        createTemplate: t => ({\n"
"            [it]: t,\n"
"            [st]: {}\n"
"        }),\n"
"        beginStructure(t) {\n"
"            const {type: e, name: n, length: r, signature: i = -1n, byteSize: s, align: o, flags: c} = t;\n"
"            return {\n"
"                constructor: null,\n"
"                type: e,\n"
"                flags: c,\n"
"                signature: i,\n"
"                name: n,\n"
"                length: r,\n"
"                byteSize: s,\n"
"                align: o,\n"
"                instance: {\n"
"                    members: [],\n"
"                    template: null\n"
"                },\n"
"                static: {\n"
"                    members: [],\n"
"                    template: null\n"
"                }\n"
"            };\n"
"        },\n"
"        attachMember(t, e, n = !1) {\n"
"            (n ? t.static : t.instance).members.push(e);\n"
"        },\n"
"        attachTemplate(t, e, n = !1) {\n"
"            (n ? t.static : t.instance).template = e;\n"
"        },\n"
"        endStructure(t) {\n"
"            t.name || this.inferTypeName(t), this.structures.push(t), this.finalizeStructure(t);\n"
"        },\n"
"        captureView(t, e, n, r) {\n"
"            if (n) {\n"
"                const n = this.allocateJSMemory(e, 0);\n"
"                return e > 0 && this.copyExternBytes(n, t, e), n;\n"
"            }\n"
"            {\n"
"                const n = this.obtainZigView(t, e);\n"
"                return n[ct].handle = r, n;\n"
"            }\n"
"        },\n"
"        castView(t, e, n, r, i) {\n"
"            const {constructor: o, flags: c} = r, a = this.captureView(t, e, n, i), l = o.call(Ut, a);\n"
"            return c & s && this.updatePointerTargets(null, l), n && e > 0 && this.makeReadOnly?.(l), \n"
"            l;\n"
"        },\n"
"        acquireStructures() {\n"
"            const t = this.getModuleAttributes();\n"
"            this.littleEndian = !!(t & Y), this.runtimeSafety = !!(t & K), this.libc = !!(t & Q);\n"
"            const e = this.getFactoryThunk(), n = {\n"
"                [it]: this.obtainZigView(e, 0)\n"
"            };\n"
"            this.comptime = !0, this.mixinUsage = new Map, this.invokeThunk(n, n, n), this.comptime = !1;\n"
"            for (const t of this.structures) {\n"
"                const {constructor: e, flags: n, instance: {template: r}} = t;\n"
"                if (n & s && r && r[it]) {\n"
"                    const t = Object.create(e.prototype);\n"
"                    t[it] = r[it], t[st] = r[st], this.updatePointerTargets(null, t);\n"
"                }\n"
"            }\n"
"        },\n"
"        getRootModule() {\n"
"            return this.structures[this.structures.length - 1].constructor;\n"
"        },\n"
"        hasMethods() {\n"
"            return !!this.structures.find((t => t.type === e.Function));\n"
"        },\n"
"        exportStructures() {\n"
"            this.prepareObjectsForExport();\n"
"            const {structures: t, runtimeSafety: e, littleEndian: n, libc: r} = this;\n"
"            return {\n"
"                structures: t,\n"
"                settings: {\n"
"                    runtimeSafety: e,\n"
"                    littleEndian: n,\n"
"                    libc: r\n"
"                }\n"
"            };\n"
"        },\n"
"        prepareObjectsForExport() {\n"
"            const t = [];\n"
"            for (const e of me(this.structures, st)) {\n"
"                const n = e[it]?.[ct];\n"
"                if (n) {\n"
"                    const {address: r, len: i, handle: s} = n, o = e[it] = this.captureView(r, i, !0);\n"
"                    s && (o.handle = s), t.push({\n"
"                        address: r,\n"
"                        len: i,\n"
"                        owner: e,\n"
"                        replaced: !1,\n"
"                        handle: s\n"
"                    });\n"
"                }\n"
"            }\n"
"            t.sort(((t, e) => e.len - t.len));\n"
"            for (const e of t) if (!e.replaced) for (const n of t) if (e !== n && !n.replaced && !n.handle && e.address <= n.address && n.address < ye(e.address, e.len)) {\n"
"                const t = e.owner[it], r = Number(n.address - e.address) + t.byteOffset;\n"
"                n.owner[it] = this.obtainView(t.buffer, r, n.len), n.replaced = !0;\n"
"            }\n"
"        },\n"
"        useStructures() {\n"
"            const t = this.getRootModule(), e = me(this.structures, st);\n"
"            for (const t of e) t[it]?.[ct] && this.variables.push({\n"
"                object: t\n"
"            });\n"
"            return this.slots = {}, this.structures = [], t.__zigar = this.getSpecialExports(), \n"
"            t;\n"
"        },\n"
"        inferTypeName(t) {\n"
"            const e = this[`get${n[t.type]}Name`];\n"
"            t.name = e.call(this, t);\n"
"        },\n"
"        getPrimitiveName(t) {\n"
"            const {instance: {members: [e]}, static: {template: n}, flags: r} = t;\n"
"            switch (e.type) {\n"
"              case D.Bool:\n"
"                return \"bool\";\n"
"\n"
"              case D.Int:\n"
"                return r & c ? \"isize\" : `i${e.bitSize}`;\n"
"\n"
"              case D.Uint:\n"
"                return r & c ? \"usize\" : `u${e.bitSize}`;\n"
"\n"
"              case D.Float:\n"
"                return `f${e.bitSize}`;\n"
"\n"
"              case D.Void:\n"
"                return \"void\";\n"
"\n"
"              case D.Literal:\n"
"                return \"enum_literal\";\n"
"\n"
"              case D.Null:\n"
"                return \"null\";\n"
"\n"
"              case D.Undefined:\n"
"                return \"undefined\";\n"
"\n"
"              case D.Type:\n"
"                return \"type\";\n"
"\n"
"              case D.Object:\n"
"                return \"comptime\";\n"
"\n"
"              default:\n"
"                return \"unknown\";\n"
"            }\n"
"        },\n"
"        getArrayName(t) {\n"
"            const {instance: {members: [e]}, length: n} = t;\n"
"            return `[${n}]${e.structure.name}`;\n"
"        },\n"
"        getStructName(t) {\n"
"            return \"S\" + this.structureCounters.struct++;\n"
"        },\n"
"        getUnionName(t) {\n"
"            return \"U\" + this.structureCounters.union++;\n"
"        },\n"
"        getErrorUnionName(t) {\n"
"            const {instance: {members: [e, n]}} = t;\n"
"            return `${n.structure.name}!${e.structure.name}`;\n"
"        },\n"
"        getErrorSetName(t) {\n"
"            return t.flags & F ? \"anyerror\" : \"ES\" + this.structureCounters.errorSet++;\n"
"        },\n"
"        getEnumName(t) {\n"
"            return \"EN\" + this.structureCounters.enum++;\n"
"        },\n"
"        getOptionalName(t) {\n"
"            const {instance: {members: [e]}} = t;\n"
"            return `?${e.structure.name}`;\n"
"        },\n"
"        getPointerName(t) {\n"
"            const {instance: {members: [n]}, flags: r} = t;\n"
"            let i = \"*\", s = n.structure.name;\n"
"            if (n.structure.type === e.Slice && (s = s.slice(3)), r & E && (i = r & V ? \"[]\" : r & M ? \"[*c]\" : \"[*]\"), \n"
"            !(r & M)) {\n"
"                const t = n.structure.constructor?.[yt];\n"
"                t && (i = i.slice(0, -1) + `:${t.value}` + i.slice(-1));\n"
"            }\n"
"            return r & x && (i = `${i}const `), i + s;\n"
"        },\n"
"        getSliceName(t) {\n"
"            const {instance: {members: [e]}, flags: n} = t;\n"
"            return n & C ? \"anyopaque\" : `[_]${e.structure.name}`;\n"
"        },\n"
"        getVectorName(t) {\n"
"            const {instance: {members: [e]}, length: n} = t;\n"
"            return `@Vector(${n}, ${e.structure.name})`;\n"
"        },\n"
"        getOpaqueName(t) {\n"
"            return \"O\" + this.structureCounters.opaque++;\n"
"        },\n"
"        getArgStructName(t) {\n"
"            const {instance: {members: e}} = t, n = e[0], r = e.slice(1), i = n.structure.name;\n"
"            return `Arg(fn (${r.map((t => t.structure.name)).join(\", \")}) ${i})`;\n"
"        },\n"
"        getVariadicStructName(t) {\n"
"            const {instance: {members: e}} = t, n = e[0], r = e.slice(1), i = n.structure.name;\n"
"            return `Arg(fn (${r.map((t => t.structure.name)).join(\", \")}, ...) ${i})`;\n"
"        },\n"
"        getFunctionName(t) {\n"
"            const {instance: {members: [e]}} = t;\n"
"            return e.structure.name.slice(4, -1);\n"
"        },\n"
"        exports: {\n"
"            captureView: null,\n"
"            castView: null,\n"
"            readSlot: null,\n"
"            writeSlot: null,\n"
"            beginStructure: null,\n"
"            attachMember: null,\n"
"            createTemplate: null,\n"
"            attachTemplate: null,\n"
"            defineStructure: null,\n"
"            endStructure: null\n"
"        },\n"
"        imports: {\n"
"            getFactoryThunk: null,\n"
"            getModuleAttributes: null\n"
"        }\n"
"    }), xe({}), xe({\n"
"        init() {\n"
"            this.viewMap = new WeakMap, this.needFallback = void 0;\n"
"        },\n"
"        extractView(t, n, r = De) {\n"
"            const {type: i, byteSize: s, constructor: o} = t;\n"
"            let c;\n"
"            const a = n?.[Symbol.toStringTag];\n"
"            if (a && (\"DataView\" === a ? c = this.registerView(n) : \"ArrayBuffer\" === a ? c = this.obtainView(n, 0, n.byteLength) : (a && a === o[jt]?.name || \"Uint8ClampedArray\" === a && o[jt] === Uint8Array || \"Uint8Array\" === a && n instanceof Buffer) && (c = this.obtainView(n.buffer, n.byteOffset, n.byteLength))), \n"
"            !c) {\n"
"                const r = n?.[it];\n"
"                if (r) {\n"
"                    const {constructor: o, instance: {members: [c]}} = t;\n"
"                    if (ve(n, o)) return r;\n"
"                    if (function(t) {\n"
"                        return t === e.Array || t === e.Vector || t === e.Slice;\n"
"                    }(i)) {\n"
"                        const {byteSize: o, structure: {constructor: a}} = c, l = pe(n, a);\n"
"                        if (void 0 !== l) {\n"
"                            if (i === e.Slice || l * o === s) return r;\n"
"                            throw new ArrayLengthMismatch(t, null, n);\n"
"                        }\n"
"                    }\n"
"                }\n"
"            }\n"
"            return c ? void 0 !== s && Le(c, t) : r?.(t, n), c;\n"
"        },\n"
"        assignView(t, n, r, i, s) {\n"
"            const {byteSize: o, type: c} = r, a = o ?? 1;\n"
"            if (t[it]) {\n"
"                const i = c === e.Slice ? a * t.length : a;\n"
"                if (n.byteLength !== i) throw new BufferSizeMismatch(r, n, t);\n"
"                const s = {\n"
"                    [it]: n\n"
"                };\n"
"                t.constructor[yt]?.validateData?.(s, t.length), t[_t](s);\n"
"            } else {\n"
"                void 0 !== o && Le(n, r);\n"
"                const e = n.byteLength / a, c = {\n"
"                    [it]: n\n"
"                };\n"
"                t.constructor[yt]?.validateData?.(c, e), s && (i = !0), t[Wt](i ? null : n, e, s), \n"
"                i && t[_t](c);\n"
"            }\n"
"        },\n"
"        findViewAt(t, e, n) {\n"
"            let r, i = this.viewMap.get(t);\n"
"            if (i) if (i instanceof DataView) if (i.byteOffset === e && i.byteLength === n) r = i, \n"
"            i = null; else {\n"
"                const e = i, n = `${e.byteOffset}:${e.byteLength}`;\n"
"                i = new Map([ [ n, e ] ]), this.viewMap.set(t, i);\n"
"            } else r = i.get(`${e}:${n}`);\n"
"            return {\n"
"                existing: r,\n"
"                entry: i\n"
"            };\n"
"        },\n"
"        obtainView(t, e, n) {\n"
"            const {existing: r, entry: i} = this.findViewAt(t, e, n);\n"
"            let s;\n"
"            if (r) return r;\n"
"            s = new DataView(t, e, n), i ? i.set(`${e}:${n}`, s) : this.viewMap.set(t, s);\n"
"            {\n"
"                const r = t[ct];\n"
"                r && (s[ct] = {\n"
"                    address: ye(r.address, e),\n"
"                    len: n\n"
"                });\n"
"            }\n"
"            return s;\n"
"        },\n"
"        registerView(t) {\n"
"            if (!t[ct]) {\n"
"                const {buffer: e, byteOffset: n, byteLength: r} = t, {existing: i, entry: s} = this.findViewAt(e, n, r);\n"
"                if (i) return i;\n"
"                s ? s.set(`${n}:${r}`, t) : this.viewMap.set(e, t);\n"
"            }\n"
"            return t;\n"
"        },\n"
"        allocateMemory(t, e = 0, n = null) {\n"
"            return n?.alloc?.(t, e) ?? this.allocateJSMemory(t, e);\n"
"        },\n"
"        ...{\n"
"            imports: {\n"
"                requireBufferFallback: null,\n"
"                syncExternalBuffer: null\n"
"            },\n"
"            usingBufferFallback() {\n"
"                return void 0 === this.needFallback && (this.needFallback = this.requireBufferFallback?.()), \n"
"                this.needFallback;\n"
"            },\n"
"            allocateJSMemory(t, e) {\n"
"                const n = e > Re && this.getBufferAddress ? e : 0, r = new ArrayBuffer(t + n);\n"
"                let i = 0;\n"
"                if (n) {\n"
"                    const t = this.getBufferAddress(r);\n"
"                    i = he(t, e) - t;\n"
"                }\n"
"                return this.obtainView(r, Number(i), t);\n"
"            }\n"
"        }\n"
"    });\n"
"    const Re = [ \"arm64\", \"ppc64\", \"x64\", \"s390x\" ].includes(process.arch) ? 16 : 8;\n"
"    xe({}), xe({\n"
"        makeReadOnly(t) {\n"
"            Je(t);\n"
"        }\n"
"    });\n"
"    const Ze = Object.getOwnPropertyDescriptors, qe = Object.defineProperty;\n"
"    function Je(t) {\n"
"        const e = t[gt];\n"
"        if (e) Ge(e, [ \"length\" ]); else {\n"
"            const e = t[bt];\n"
"            e ? (Ge(e), function(t) {\n"
"                qe(t, \"set\", {\n"
"                    value: ze\n"
"                });\n"
"                const e = t.get;\n"
"                qe(t, \"get\", {\n"
"                    value: function(t) {\n"
"                        const n = e.call(this, t);\n"
"                        return null === n?.[Tt] && Je(n), n;\n"
"                    }\n"
"                });\n"
"            }(e)) : Ge(t);\n"
"        }\n"
"    }\n"
"    function Ge(t, e = []) {\n"
"        const n = Ze(t.constructor.prototype);\n"
"        for (const [r, i] of Object.entries(n)) i.set && !e.includes(r) && (i.set = ze, \n"
"        qe(t, r, i));\n"
"        qe(t, Tt, {\n"
"            value: t\n"
"        });\n"
"    }\n"
"    function _e() {\n"
"        const t = this[bt] ?? this, e = this.length;\n"
"        let n = 0;\n"
"        return {\n"
"            next() {\n"
"                let r, i;\n"
"                if (n < e) {\n"
"                    const e = n++;\n"
"                    r = t.get(e), i = !1;\n"
"                } else i = !0;\n"
"                return {\n"
"                    value: r,\n"
"                    done: i\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function We(t) {\n"
"        const e = ie(t), n = this[bt] ?? this, r = this.length;\n"
"        let i = 0;\n"
"        return {\n"
"            next() {\n"
"                let t, s;\n"
"                if (i < r) {\n"
"                    const r = i++;\n"
"                    t = [ r, e((() => n.get(r))) ], s = !1;\n"
"                } else s = !0;\n"
"                return {\n"
"                    value: t,\n"
"                    done: s\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function He(t) {\n"
"        return {\n"
"            [Symbol.iterator]: We.bind(this, t),\n"
"            length: this.length\n"
"        };\n"
"    }\n"
"    function Xe(t) {\n"
"        return {\n"
"            [Symbol.iterator]: Ke.bind(this, t),\n"
"            length: this[dt].length\n"
"        };\n"
"    }\n"
"    function Ye(t) {\n"
"        return Xe.call(this, t)[Symbol.iterator]();\n"
"    }\n"
"    function Ke(t) {\n"
"        const e = ie(t), n = this, r = this[dt];\n"
"        let i = 0;\n"
"        return {\n"
"            next() {\n"
"                let t, s;\n"
"                if (i < r.length) {\n"
"                    const o = r[i++];\n"
"                    t = [ o, e((() => n[o])) ], s = !1;\n"
"                } else s = !0;\n"
"                return {\n"
"                    value: t,\n"
"                    done: s\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function Qe(t) {\n"
"        return {\n"
"            [Symbol.iterator]: en.bind(this, t),\n"
"            length: this[dt].length\n"
"        };\n"
"    }\n"
"    function tn(t) {\n"
"        return Qe.call(this, t)[Symbol.iterator]();\n"
"    }\n"
"    function en(t) {\n"
"        const e = ie(t), n = this, r = this[dt], i = this[Ft];\n"
"        let s = 0;\n"
"        return {\n"
"            next() {\n"
"                let t, o;\n"
"                if (s < r.length) {\n"
"                    const c = r[s++];\n"
"                    t = [ c, e((() => i[c].call(n))) ], o = !1;\n"
"                } else o = !0;\n"
"                return {\n"
"                    value: t,\n"
"                    done: o\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function nn() {\n"
"        const t = this, e = this.length;\n"
"        let n = 0;\n"
"        return {\n"
"            next() {\n"
"                let r, i;\n"
"                if (n < e) {\n"
"                    const e = n++;\n"
"                    r = t[e], i = !1;\n"
"                } else i = !0;\n"
"                return {\n"
"                    value: r,\n"
"                    done: i\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function rn() {\n"
"        const t = this, e = this.length;\n"
"        let n = 0;\n"
"        return {\n"
"            next() {\n"
"                let r, i;\n"
"                if (n < e) {\n"
"                    const e = n++;\n"
"                    r = [ e, t[e] ], i = !1;\n"
"                } else i = !0;\n"
"                return {\n"
"                    value: r,\n"
"                    done: i\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function sn() {\n"
"        return {\n"
"            [Symbol.iterator]: rn.bind(this),\n"
"            length: this.length\n"
"        };\n"
"    }\n"
"    function on(t = {}) {\n"
"        const e = this, n = 1 === e.next.length ? [ t ] : [];\n"
"        return {\n"
"            next() {\n"
"                const t = e.next(...n);\n"
"                return {\n"
"                    value: t,\n"
"                    done: null === t\n"
"                };\n"
"            }\n"
"        };\n"
"    }\n"
"    function cn(t, {get: e, set: n}) {\n"
"        return void 0 !== t ? {\n"
"            get: function() {\n"
"                return e.call(this, t);\n"
"            },\n"
"            set: n ? function(e, r) {\n"
"                return n.call(this, t, e, r);\n"
"            } : void 0\n"
"        } : {\n"
"            get: e,\n"
"            set: n\n"
"        };\n"
"    }\n"
"    function an(t) {\n"
"        return (this[st][t] ?? this[Jt](t)).$;\n"
"    }\n"
"    function ln(t) {\n"
"        return this[st][t] ?? this[Jt](t);\n"
"    }\n"
"    function un(t, e, n) {\n"
"        (this[st][t] ?? this[Jt](t))[Ht](e, n);\n"
"    }\n"
"    xe({\n"
"        defineArrayEntries: () => re(He),\n"
"        defineArrayIterator: () => re(_e)\n"
"    }), xe({\n"
"        defineStructEntries: () => re(Xe),\n"
"        defineStructIterator: () => re(Ye)\n"
"    }), xe({\n"
"        defineUnionEntries: () => re(Qe),\n"
"        defineUnionIterator: () => re(tn)\n"
"    }), xe({\n"
"        defineVectorEntries: () => re(sn),\n"
"        defineVectorIterator: () => re(nn)\n"
"    }), xe({\n"
"        defineZigIterator: () => re(on)\n"
"    }), xe({\n"
"        defineMember(t, e = !0) {\n"
"            if (!t) return {};\n"
"            const {type: r, structure: i} = t, s = this[`defineMember${R[r]}`].call(this, t);\n"
"            if (e && i) {\n"
"                const {type: e} = i, r = this[`transformDescriptor${n[e]}`];\n"
"                if (r) return r.call(this, s, t);\n"
"            }\n"
"            return s;\n"
"        }\n"
"    }), xe({\n"
"        defineBase64(t) {\n"
"            const e = this;\n"
"            return Se({\n"
"                get() {\n"
"                    return function(t) {\n"
"                        if (\"function\" == typeof Buffer && Buffer.prototype instanceof Uint8Array) return Buffer.from(t.buffer, t.byteOffset, t.byteLength).toString(\"base64\");\n"
"                        const e = new Uint8Array(t.buffer, t.byteOffset, t.byteLength), n = String.fromCharCode.apply(null, e);\n"
"                        return btoa(n);\n"
"                    }(this.dataView);\n"
"                },\n"
"                set(n, r) {\n"
"                    if (\"string\" != typeof n) throw new TypeMismatch(\"string\", n);\n"
"                    const i = function(t) {\n"
"                        if (\"function\" == typeof Buffer && Buffer.prototype instanceof Uint8Array) {\n"
"                            const e = Buffer.from(t, \"base64\");\n"
"                            return new DataView(e.buffer, e.byteOffset, e.byteLength);\n"
"                        }\n"
"                        const e = atob(t), n = new Uint8Array(e.length);\n"
"                        for (let t = 0; t < n.byteLength; t++) n[t] = e.charCodeAt(t);\n"
"                        return new DataView(n.buffer);\n"
"                    }(n);\n"
"                    e.assignView(this, i, t, !1, r);\n"
"                }\n"
"            });\n"
"        }\n"
"    }), xe({\n"
"        defineMemberBool(t) {\n"
"            return this.defineMemberUsing(t, this.getAccessor);\n"
"        }\n"
"    }), xe({\n"
"        defineClampedArray(t) {\n"
"            const e = this, n = Uint8ClampedArray;\n"
"            return Se({\n"
"                get() {\n"
"                    const t = this.typedArray;\n"
"                    return new n(t.buffer, t.byteOffset, t.length);\n"
"                },\n"
"                set(r, i) {\n"
"                    if (r?.[Symbol.toStringTag] !== n.name) throw new TypeMismatch(n.name, r);\n"
"                    const s = new DataView(r.buffer, r.byteOffset, r.byteLength);\n"
"                    e.assignView(this, s, t, !0, i);\n"
"                }\n"
"            });\n"
"        }\n"
"    }), xe({\n"
"        defineDataView(t) {\n"
"            const e = this;\n"
"            return Se({\n"
"                get() {\n"
"                    const t = this[it];\n"
"                    if (e.usingBufferFallback()) {\n"
"                        const n = t.buffer[Dt];\n"
"                        void 0 !== n && e.syncExternalBuffer(t.buffer, n);\n"
"                    }\n"
"                    return t;\n"
"                },\n"
"                set(n, r) {\n"
"                    if (\"DataView\" !== n?.[Symbol.toStringTag]) throw new TypeMismatch(\"DataView\", n);\n"
"                    e.assignView(this, n, t, !0, r);\n"
"                }\n"
"            });\n"
"        },\n"
"        imports: {\n"
"            syncExternalBuffer: null\n"
"        }\n"
"    }), xe({\n"
"        defineMemberFloat(t) {\n"
"            return this.defineMemberUsing(t, this.getAccessor);\n"
"        }\n"
"    }), xe({\n"
"        defineMemberInt(t) {\n"
"            let e = this.getAccessor;\n"
"            return this.runtimeSafety && (e = this.addRuntimeCheck(e)), e = this.addIntConversion(e), \n"
"            this.defineMemberUsing(t, e);\n"
"        }\n"
"    }), xe({\n"
"        defineMemberLiteral(t) {\n"
"            const {slot: e} = t;\n"
"            return cn(e, {\n"
"                get(t) {\n"
"                    return this[st][t].string;\n"
"                },\n"
"                set: ze\n"
"            });\n"
"        }\n"
"    }), xe({\n"
"        defineMemberNull: t => ({\n"
"            get: function() {\n"
"                return null;\n"
"            },\n"
"            set: ze\n"
"        })\n"
"    }), xe({\n"
"        defineMemberObject: t => cn(t.slot, {\n"
"            get: t.structure.flags & r ? an : ln,\n"
"            set: t.flags & q ? ze : un\n"
"        })\n"
"    }), xe({\n"
"        ...{\n"
"            defineMemberUsing(t, e) {\n"
"                const {littleEndian: n} = this, {bitOffset: r, byteSize: i} = t, s = e.call(this, \"get\", t), o = e.call(this, \"set\", t);\n"
"                if (void 0 !== r) {\n"
"                    const t = r >> 3;\n"
"                    return {\n"
"                        get: function() {\n"
"                            return s.call(this[it], t, n);\n"
"                        },\n"
"                        set: function(e) {\n"
"                            return o.call(this[it], t, e, n);\n"
"                        }\n"
"                    };\n"
"                }\n"
"                return {\n"
"                    get: function(e) {\n"
"                        try {\n"
"                            return s.call(this[it], e * i, n);\n"
"                        } catch (n) {\n"
"                            throw function(t, e, n) {\n"
"                                return n instanceof RangeError && !(n instanceof OutOfBound) && (n = new OutOfBound(t, e)), \n"
"                                n;\n"
"                            }(t, e, n);\n"
"                        }\n"
"                    },\n"
"                    set: function(t, e) {\n"
"                        return o.call(this[it], t * i, e, n);\n"
"                    }\n"
"                };\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        defineSentinel(t) {\n"
"            const {byteSize: e, instance: {members: [n, r], template: i}} = t, {get: s} = this.defineMember(r), {get: o} = this.defineMember(n), c = s.call(i, 0), a = !!(r.flags & Z), {runtimeSafety: l} = this;\n"
"            return re({\n"
"                value: c,\n"
"                bytes: i[it],\n"
"                validateValue(e, n, r) {\n"
"                    if (a) {\n"
"                        if (l && e === c && n !== r - 1) throw new MisplacedSentinel(t, e, n, r);\n"
"                        if (e !== c && n === r - 1) throw new MissingSentinel(t, c, r);\n"
"                    }\n"
"                },\n"
"                validateData(n, r) {\n"
"                    if (a) if (l) for (let e = 0; e < r; e++) {\n"
"                        const i = o.call(n, e);\n"
"                        if (i === c && e !== r - 1) throw new MisplacedSentinel(t, c, e, r);\n"
"                        if (i !== c && e === r - 1) throw new MissingSentinel(t, c, r);\n"
"                    } else if (r > 0 && r * e === n[it].byteLength) {\n"
"                        if (o.call(n, r - 1) !== c) throw new MissingSentinel(t, c, r);\n"
"                    }\n"
"                },\n"
"                isRequired: a\n"
"            });\n"
"        },\n"
"        imports: {\n"
"            findSentinel: null\n"
"        }\n"
"    }), xe({\n"
"        defineString(t) {\n"
"            const e = this, {byteSize: n} = t.instance.members[0], r = \"utf-\" + 8 * n;\n"
"            return Se({\n"
"                get() {\n"
"                    let t = oe(this.typedArray, r);\n"
"                    const e = this.constructor[yt]?.value;\n"
"                    return void 0 !== e && t.charCodeAt(t.length - 1) === e && (t = t.slice(0, -1)), \n"
"                    t;\n"
"                },\n"
"                set(n, i) {\n"
"                    if (\"string\" != typeof n) throw new TypeMismatch(\"string\", n);\n"
"                    const s = this.constructor[yt]?.value;\n"
"                    void 0 !== s && n.charCodeAt(n.length - 1) !== s && (n += String.fromCharCode(s));\n"
"                    const o = ce(n, r), c = new DataView(o.buffer);\n"
"                    e.assignView(this, c, t, !1, i);\n"
"                }\n"
"            });\n"
"        }\n"
"    }), xe({\n"
"        defineValueOf: () => ({\n"
"            value() {\n"
"                return dn(this, !1);\n"
"            }\n"
"        })\n"
"    });\n"
"    const fn = BigInt(Number.MAX_SAFE_INTEGER), hn = BigInt(Number.MIN_SAFE_INTEGER);\n"
"    function dn(t, n) {\n"
"        const r = n ? t => {\n"
"            try {\n"
"                return t();\n"
"            } catch (t) {\n"
"                return t;\n"
"            }\n"
"        } : t => t(), i = new Map, s = function(t) {\n"
"            const o = \"function\" == typeof t ? e.Struct : t?.constructor?.[lt];\n"
"            if (void 0 === o) {\n"
"                if (n) {\n"
"                    if (\"bigint\" == typeof t && hn <= t && t <= fn) return Number(t);\n"
"                    if (t instanceof Error) return {\n"
"                        error: t.message\n"
"                    };\n"
"                }\n"
"                return t;\n"
"            }\n"
"            let c = i.get(t);\n"
"            if (void 0 === c) {\n"
"                let n;\n"
"                switch (o) {\n"
"                  case e.Struct:\n"
"                    n = t[mt](), c = t.constructor[ut] & d ? [] : {};\n"
"                    break;\n"
"\n"
"                  case e.Union:\n"
"                    n = t[mt](), c = {};\n"
"                    break;\n"
"\n"
"                  case e.Array:\n"
"                  case e.Vector:\n"
"                  case e.Slice:\n"
"                    n = t[mt](), c = [];\n"
"                    break;\n"
"\n"
"                  case e.Pointer:\n"
"                    try {\n"
"                        c = t[\"*\"];\n"
"                    } catch (t) {\n"
"                        c = Symbol.for(\"inaccessible\");\n"
"                    }\n"
"                    break;\n"
"\n"
"                  case e.Enum:\n"
"                    c = r((() => String(t)));\n"
"                    break;\n"
"\n"
"                  case e.Opaque:\n"
"                    c = {};\n"
"                    break;\n"
"\n"
"                  default:\n"
"                    c = r((() => t.$));\n"
"                }\n"
"                if (c = s(c), i.set(t, c), n) for (const [t, e] of n) c[t] = s(e);\n"
"            }\n"
"            return c;\n"
"        };\n"
"        return s(t);\n"
"    }\n"
"    xe({\n"
"        defineToJSON: () => ({\n"
"            value() {\n"
"                return dn(this, !0);\n"
"            }\n"
"        })\n"
"    }), xe({\n"
"        defineMemberType(t, e) {\n"
"            const {slot: n} = t;\n"
"            return cn(n, {\n"
"                get(t) {\n"
"                    const e = this[st][t];\n"
"                    return e?.constructor;\n"
"                },\n"
"                set: ze\n"
"            });\n"
"        }\n"
"    }), xe({\n"
"        defineTypedArray(t) {\n"
"            const e = this, n = this.getTypedArray(t);\n"
"            return Se({\n"
"                get() {\n"
"                    const t = this.dataView, e = t.byteLength / n.BYTES_PER_ELEMENT;\n"
"                    return new n(t.buffer, t.byteOffset, e);\n"
"                },\n"
"                set(r, i) {\n"
"                    if (r?.[Symbol.toStringTag] !== n.name) throw new TypeMismatch(n.name, r);\n"
"                    const s = new DataView(r.buffer, r.byteOffset, r.byteLength);\n"
"                    e.assignView(this, s, t, !0, i);\n"
"                }\n"
"            });\n"
"        }\n"
"    }), xe({\n"
"        defineMemberUint(t) {\n"
"            let e = this.getAccessor;\n"
"            return this.runtimeSafety && (e = this.addRuntimeCheck(e)), e = this.addIntConversion(e), \n"
"            this.defineMemberUsing(t, e);\n"
"        }\n"
"    }), xe({\n"
"        defineMemberUndefined: t => ({\n"
"            get: function() {},\n"
"            set: ze\n"
"        })\n"
"    }), xe({\n"
"        defineMemberUnsupported(t) {\n"
"            const e = function() {\n"
"                throw new Unsupported;\n"
"            };\n"
"            return {\n"
"                get: e,\n"
"                set: e\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineMemberVoid(t, e) {\n"
"            const {bitOffset: n} = t;\n"
"            return {\n"
"                get() {},\n"
"                set: void 0 !== n ? function(e) {\n"
"                    if (void 0 !== e) throw new NotUndefined(t);\n"
"                } : function(e, n) {\n"
"                    if (void 0 !== n) throw new NotUndefined(t);\n"
"                    if (e < 0 || e >= this.length) throw new OutOfBound(t, e);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineStructure(t) {\n"
"            const {type: e, byteSize: r} = t, i = this[`define${n[e]}`], s = [], o = {}, c = {\n"
"                dataView: this.defineDataView(t),\n"
"                base64: this.defineBase64(t),\n"
"                toJSON: this.defineToJSON(),\n"
"                valueOf: this.defineValueOf(),\n"
"                [Tt]: {\n"
"                    value: null\n"
"                },\n"
"                [Bt]: re(o),\n"
"                [vt]: re(s),\n"
"                [_t]: this.defineCopier(r)\n"
"            }, a = t.constructor = i.call(this, t, c);\n"
"            for (const [t, e] of Object.entries(c)) {\n"
"                const n = e?.set;\n"
"                n && !o[t] && \"$\" !== t && (o[t] = n, s.push(t));\n"
"            }\n"
"            return ne(a.prototype, c), a;\n"
"        },\n"
"        finalizeStructure(t) {\n"
"            const {name: r, type: i, constructor: s, align: o, byteSize: c, flags: a, signature: l, static: {members: u, template: f}} = t, h = [], d = {\n"
"                name: re(r),\n"
"                toJSON: this.defineToJSON(),\n"
"                valueOf: this.defineValueOf(),\n"
"                [Rt]: re(l),\n"
"                [Ut]: re(this),\n"
"                [$t]: re(o),\n"
"                [xt]: re(c),\n"
"                [lt]: re(i),\n"
"                [ut]: re(a),\n"
"                [dt]: re(h),\n"
"                [jt]: re(this.getTypedArray(t)),\n"
"                [Symbol.iterator]: this.defineStructIterator(),\n"
"                [mt]: this.defineStructEntries(),\n"
"                [dt]: re(h)\n"
"            }, g = {\n"
"                [Symbol.toStringTag]: re(r)\n"
"            };\n"
"            for (const t of u) {\n"
"                const {name: n, slot: r} = t;\n"
"                if (t.structure.type === e.Function) {\n"
"                    const e = f[st][r];\n"
"                    d[n] = re(e), e.name || ee(e, \"name\", re(n));\n"
"                    const [i, s] = /^(get|set)\\s+([\\s\\S]+)/.exec(n)?.slice(1) ?? [], o = \"get\" === i ? 0 : 1;\n"
"                    if (i && e.length === o) {\n"
"                        d[s] ||= {};\n"
"                        d[s][i] = e;\n"
"                    }\n"
"                    if (t.flags & G) {\n"
"                        const t = function(...t) {\n"
"                            try {\n"
"                                return e(this, ...t);\n"
"                            } catch (t) {\n"
"                                throw t[Zt]?.(1), t;\n"
"                            }\n"
"                        };\n"
"                        if (ne(t, {\n"
"                            name: re(n),\n"
"                            length: re(e.length - 1)\n"
"                        }), g[n] = re(t), i && t.length === o) {\n"
"                            (g[s] ||= {})[i] = t;\n"
"                        }\n"
"                    }\n"
"                } else d[n] = this.defineMember(t), h.push(n);\n"
"            }\n"
"            d[st] = h.length > 0 && re(f[st]);\n"
"            const y = this[`finalize${n[i]}`];\n"
"            !1 !== y?.call(this, t, d, g) && (ne(s.prototype, g), ne(s, d));\n"
"        },\n"
"        createConstructor(t, n = {}) {\n"
"            const {type: r, byteSize: i, align: s, flags: c, instance: {members: a, template: l}} = t, {onCastError: u} = n;\n"
"            let f;\n"
"            if (l?.[st]) {\n"
"                const t = a.filter((t => t.flags & q));\n"
"                t.length > 0 && (f = t.map((t => t.slot)));\n"
"            }\n"
"            const h = new ObjectCache, d = this, g = function(n, a = {}) {\n"
"                const {allocator: y} = a, b = this instanceof g;\n"
"                let p, m;\n"
"                if (b) {\n"
"                    if (0 === arguments.length) throw new NoInitializer(t);\n"
"                    if (p = this, c & o && (p[st] = {}), Wt in p) p[Ht](n, y), m = p[it]; else {\n"
"                        const t = r !== e.Pointer ? y : null;\n"
"                        p[it] = m = d.allocateMemory(i, s, t);\n"
"                    }\n"
"                } else {\n"
"                    if (Kt in g && (p = g[Kt].call(this, n, a), !1 !== p)) return p;\n"
"                    if (m = d.extractView(t, n, u), p = h.find(m)) return p;\n"
"                    p = Object.create(g.prototype), Wt in p ? d.assignView(p, m, t, !1, !1) : p[it] = m, \n"
"                    c & o && (p[st] = {});\n"
"                }\n"
"                if (f) for (const t of f) p[st][t] = l[st][t];\n"
"                return p[Xt]?.(), b && (Wt in p || p[Ht](n, y)), Yt in p && (p = p[Yt]()), h.save(m, p);\n"
"            };\n"
"            return ee(g, Mt, re(h)), g;\n"
"        },\n"
"        createApplier(t) {\n"
"            const {instance: {template: e}} = t;\n"
"            return function(n, r) {\n"
"                const i = Object.keys(n), s = this[vt], o = this[Bt];\n"
"                for (const e of i) if (!(e in o)) throw new NoProperty(t, e);\n"
"                let c = 0, a = 0, l = 0, u = 0;\n"
"                for (const t of s) {\n"
"                    const e = o[t];\n"
"                    e.special ? t in n && u++ : (c++, t in n ? a++ : e.required && l++);\n"
"                }\n"
"                if (0 !== l && 0 === u) {\n"
"                    const e = s.filter((t => o[t].required && !(t in n)));\n"
"                    throw new MissingInitializers(t, e);\n"
"                }\n"
"                if (u + a > i.length) for (const t of s) t in n && (i.includes(t) || i.push(t));\n"
"                a < c && 0 === u && e && e[it] && this[_t](e);\n"
"                for (const t of i) {\n"
"                    o[t].call(this, n[t], r);\n"
"                }\n"
"                return i.length;\n"
"            };\n"
"        },\n"
"        getTypedArray(t) {\n"
"            const {type: n, instance: r} = t;\n"
"            if (void 0 !== n && r) {\n"
"                const [t] = r.members;\n"
"                switch (n) {\n"
"                  case e.Enum:\n"
"                  case e.ErrorSet:\n"
"                  case e.Primitive:\n"
"                    {\n"
"                        const {byteSize: e, type: n} = t;\n"
"                        return globalThis[(e > 4 && n !== D.Float ? \"Big\" : \"\") + (n === D.Float ? \"Float\" : n === D.Int ? \"Int\" : \"Uint\") + 8 * e + \"Array\"];\n"
"                    }\n"
"\n"
"                  case e.Array:\n"
"                  case e.Slice:\n"
"                  case e.Vector:\n"
"                    return this.getTypedArray(t.structure);\n"
"                }\n"
"            }\n"
"        }\n"
"    }), xe({\n"
"        defineArgStruct(t, e) {\n"
"            const {flags: n, byteSize: r, align: c, length: a, instance: {members: l}} = t, u = this, f = l.slice(1), h = function(t, e) {\n"
"                const i = this instanceof h;\n"
"                let s, l;\n"
"                if (i ? (s = this, l = u.allocateMemory(r, c)) : (s = Object.create(h.prototype), \n"
"                l = t), s[it] = l, n & o && (s[st] = {}), !i) return s;\n"
"                {\n"
"                    let r;\n"
"                    if (n & k && t.length === a + 1 && (r = t.pop()), t.length !== a) throw new ArgumentCountMismatch(a, t.length);\n"
"                    n & L && (s[Yt] = null), u.copyArguments(s, t, f, r, e);\n"
"                }\n"
"            };\n"
"            for (const t of l) e[t.name] = this.defineMember(t);\n"
"            const d = e.retval.set;\n"
"            return e.length = re(f.length), e[Jt] = n & i && this.defineVivificatorStruct(t), \n"
"            e[Gt] = n & s && this.defineVisitorArgStruct(l), e[Qt] = re((function(t) {\n"
"                d.call(this, t, this[Lt]);\n"
"            })), e[Symbol.iterator] = this.defineArgIterator?.(f), h;\n"
"        },\n"
"        finalizeArgStruct(t, e) {\n"
"            const {flags: n} = t;\n"
"            e[Nt] = re(!!(n & P));\n"
"        }\n"
"    }), xe({\n"
"        defineFinalizerArray: ({get: t, set: e}) => ({\n"
"            value() {\n"
"                const n = new Proxy(this, gn);\n"
"                return ne(this, {\n"
"                    [Et]: {\n"
"                        value: n\n"
"                    },\n"
"                    get: {\n"
"                        value: t.bind(this)\n"
"                    },\n"
"                    set: e && {\n"
"                        value: e.bind(this)\n"
"                    }\n"
"                }), n;\n"
"            }\n"
"        }),\n"
"        defineVivificatorArray(t) {\n"
"            const {instance: {members: [e]}} = t, {byteSize: n, structure: r} = e, i = this;\n"
"            return {\n"
"                value: function(t) {\n"
"                    const {constructor: e} = r, s = this[it], o = s.byteOffset + n * t, c = i.obtainView(s.buffer, o, n);\n"
"                    return this[st][t] = e.call(ot, c);\n"
"                }\n"
"            };\n"
"        }\n"
"    });\n"
"    const gn = {\n"
"        get(t, e) {\n"
"            const n = \"symbol\" == typeof e ? 0 : 0 | e;\n"
"            return 0 !== n || n == e ? t.get(n) : e === bt ? t : t[e];\n"
"        },\n"
"        set(t, e, n) {\n"
"            const r = \"symbol\" == typeof e ? 0 : 0 | e;\n"
"            return 0 !== r || r == e ? t.set(r, n) : t[e] = n, !0;\n"
"        },\n"
"        deleteProperty(t, e) {\n"
"            const n = \"symbol\" == typeof e ? 0 : 0 | e;\n"
"            return 0 === n && n != e && (delete t[e], !0);\n"
"        },\n"
"        has(t, e) {\n"
"            const n = \"symbol\" == typeof e ? 0 : 0 | e;\n"
"            return 0 !== n || n == e ? n >= 0 && n < t.length : t[e];\n"
"        },\n"
"        ownKeys(t) {\n"
"            const e = [];\n"
"            for (let n = 0, r = t.length; n < r; n++) e.push(`${n}`);\n"
"            return e.push(\"length\", Et), e;\n"
"        },\n"
"        getOwnPropertyDescriptor(t, e) {\n"
"            const n = \"symbol\" == typeof e ? 0 : 0 | e;\n"
"            return 0 === n && n != e ? Object.getOwnPropertyDescriptor(t, e) : n >= 0 && n < t.length ? {\n"
"                value: t.get(n),\n"
"                enumerable: !0,\n"
"                writable: !0,\n"
"                configurable: !0\n"
"            } : void 0;\n"
"        }\n"
"    };\n"
"    xe({\n"
"        defineArray(t, e) {\n"
"            const {length: n, instance: {members: [r]}, flags: o} = t, c = this.createApplier(t), a = this.defineMember(r), {set: h} = a, d = this.createConstructor(t), g = function(e, r) {\n"
"                if (ve(e, d)) this[_t](e), o & s && this[Gt](\"copy\", tt.Vivificate, e); else if (\"string\" == typeof e && o & l && (e = {\n"
"                    string: e\n"
"                }), e?.[Symbol.iterator]) {\n"
"                    if ((e = be(e)).length !== n) throw new ArrayLengthMismatch(t, this, e);\n"
"                    let i = 0;\n"
"                    for (const t of e) h.call(this, i++, t, r);\n"
"                } else if (e && \"object\" == typeof e) {\n"
"                    if (0 === c.call(this, e)) throw new InvalidArrayInitializer(t, e);\n"
"                } else if (void 0 !== e) throw new InvalidArrayInitializer(t, e);\n"
"            };\n"
"            return e.$ = {\n"
"                get: Ie,\n"
"                set: g\n"
"            }, e.length = re(n), e.entries = e[mt] = this.defineArrayEntries(), o & u && (e.typedArray = this.defineTypedArray(t), \n"
"            o & l && (e.string = this.defineString(t)), o & f && (e.clampedArray = this.defineClampedArray(t))), \n"
"            e[Symbol.iterator] = this.defineArrayIterator(), e[Ht] = re(g), e[Yt] = this.defineFinalizerArray(a), \n"
"            e[Jt] = o & i && this.defineVivificatorArray(t), e[Gt] = o & s && this.defineVisitorArray(), \n"
"            d;\n"
"        },\n"
"        finalizeArray(t, e) {\n"
"            const {flags: n, instance: {members: [r]}} = t;\n"
"            e.child = re(r.structure.constructor), e[yt] = n & a && this.defineSentinel(t);\n"
"        }\n"
"    }), xe({\n"
"        defineEnum(t, e) {\n"
"            const {instance: {members: [n]}} = t, r = this.defineMember(n), {get: i, set: s} = r, {get: o} = this.defineMember(n, !1), c = this.createApplier(t), a = [ \"string\", \"number\", \"tagged union\" ], l = this.createConstructor(t, {\n"
"                onCastError(t, e) {\n"
"                    throw new InvalidInitializer(t, a, e);\n"
"                }\n"
"            });\n"
"            return e.$ = r, e.toString = re(Ve), e[Symbol.toPrimitive] = {\n"
"                value(t) {\n"
"                    switch (t) {\n"
"                      case \"string\":\n"
"                      case \"default\":\n"
"                        return this.$[at];\n"
"\n"
"                      default:\n"
"                        return o.call(this);\n"
"                    }\n"
"                }\n"
"            }, e[Ht] = re((function(e) {\n"
"                if (e && \"object\" == typeof e) {\n"
"                    if (0 === c.call(this, e)) throw new InvalidInitializer(t, a, e);\n"
"                } else void 0 !== e && s.call(this, e);\n"
"            })), l;\n"
"        },\n"
"        finalizeEnum(t, e) {\n"
"            const {flags: n, constructor: r, instance: {members: [i]}, static: {members: s, template: o}} = t, c = o[st], {get: a, set: l} = this.defineMember(i, !1);\n"
"            for (const {name: t, flags: n, slot: r} of s) if (n & J) {\n"
"                const n = c[r];\n"
"                ee(n, at, re(t));\n"
"                const i = a.call(n);\n"
"                e[t] = e[i] = {\n"
"                    value: n,\n"
"                    writable: !1\n"
"                };\n"
"            }\n"
"            e[Kt] = {\n"
"                value(t) {\n"
"                    if (\"string\" == typeof t || \"number\" == typeof t || \"bigint\" == typeof t) {\n"
"                        let e = r[t];\n"
"                        return e || n & A && \"string\" != typeof t && (e = new r(void 0), l.call(e, t), ee(e, at, re(t)), \n"
"                        ee(r, t, re(e))), e;\n"
"                    }\n"
"                    return t instanceof r ? t : t?.[ht] instanceof r && t[ht];\n"
"                }\n"
"            }, e[jt] = re(this.getTypedArray(t));\n"
"        },\n"
"        transformDescriptorEnum(t, e) {\n"
"            const {type: n, structure: r} = e;\n"
"            if (n === D.Object) return t;\n"
"            const i = function(t) {\n"
"                const {constructor: e} = r, n = e(t);\n"
"                if (!n) throw new EnumExpected(r, t);\n"
"                return n;\n"
"            }, {get: s, set: o} = t;\n"
"            return {\n"
"                get: 0 === s.length ? function() {\n"
"                    const t = s.call(this);\n"
"                    return i(t);\n"
"                } : function(t) {\n"
"                    const e = s.call(this, t);\n"
"                    return i(e);\n"
"                },\n"
"                set: 1 === o.length ? function(t) {\n"
"                    t = i(t)[Symbol.toPrimitive](), o.call(this, t);\n"
"                } : function(t, e) {\n"
"                    const n = i(e);\n"
"                    o.call(this, t, n[Symbol.toPrimitive]());\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        currentGlobalSet: void 0,\n"
"        currentErrorClass: void 0,\n"
"        defineErrorSet(t, n) {\n"
"            const {instance: {members: [r]}, flags: i} = t;\n"
"            if (!this.currentErrorClass) {\n"
"                this.currentErrorClass = class Error extends ZigErrorBase {};\n"
"                const t = {\n"
"                    type: e.ErrorSet,\n"
"                    name: \"anyerror\",\n"
"                    instance: {\n"
"                        members: [ r ]\n"
"                    },\n"
"                    static: {\n"
"                        members: [],\n"
"                        template: {\n"
"                            SLOTS: {}\n"
"                        }\n"
"                    }\n"
"                };\n"
"                this.currentGlobalSet = this.defineStructure(t), this.finalizeStructure(t);\n"
"            }\n"
"            if (this.currentGlobalSet && i & F) return this.currentGlobalSet;\n"
"            const s = this.defineMember(r), {set: o} = s, c = [ \"string\", \"number\" ], a = this.createApplier(t), l = this.createConstructor(t, {\n"
"                onCastError(t, e) {\n"
"                    throw new InvalidInitializer(t, c, e);\n"
"                }\n"
"            });\n"
"            return n.$ = s, n[Ht] = re((function(e) {\n"
"                if (e instanceof l[ft]) o.call(this, e); else if (e && \"object\" == typeof e && !Ce(e)) {\n"
"                    if (0 === a.call(this, e)) throw new InvalidInitializer(t, c, e);\n"
"                } else void 0 !== e && o.call(this, e);\n"
"            })), l;\n"
"        },\n"
"        finalizeErrorSet(t, e) {\n"
"            const {constructor: n, flags: r, instance: {members: [i]}, static: {members: s, template: o}} = t;\n"
"            if (this.currentGlobalSet && r & F) return !1;\n"
"            const c = o?.[st] ?? {}, {get: a} = this.defineMember(i, !1);\n"
"            for (const {name: t, slot: n} of s) {\n"
"                const r = c[n], i = a.call(r);\n"
"                let s = this.currentGlobalSet[i], o = !0;\n"
"                s || (s = new this.currentErrorClass(t, i), o = !1);\n"
"                const l = re(s), u = String(s);\n"
"                e[t] = e[u] = e[i] = l, o || (ne(this.currentGlobalSet, {\n"
"                    [i]: l,\n"
"                    [u]: l,\n"
"                    [t]: l\n"
"                }), this.currentGlobalSet[dt].push(t));\n"
"            }\n"
"            e[Kt] = {\n"
"                value: t => \"number\" == typeof t || \"string\" == typeof t ? n[t] : t instanceof n[ft] ? n[Number(t)] : Ce(t) ? n[`Error: ${t.error}`] : t instanceof Error && void 0\n"
"            }, e[ft] = re(this.currentErrorClass);\n"
"        },\n"
"        transformDescriptorErrorSet(t, e) {\n"
"            const {type: n, structure: r} = e;\n"
"            if (n === D.Object) return t;\n"
"            const i = function(t) {\n"
"                const {constructor: e} = r, n = e(t);\n"
"                if (!n) throw t instanceof Error ? new NotInErrorSet(r) : new ErrorExpected(r, t);\n"
"                return n;\n"
"            }, {get: s, set: o} = t;\n"
"            return {\n"
"                get: 0 === s.length ? function() {\n"
"                    const t = s.call(this);\n"
"                    return i(t);\n"
"                } : function(t) {\n"
"                    const e = s.call(this, t);\n"
"                    return i(e);\n"
"                },\n"
"                set: 1 === o.length ? function(t) {\n"
"                    const e = i(t);\n"
"                    t = Number(e), o.call(this, t);\n"
"                } : function(t, e) {\n"
"                    const n = i(e);\n"
"                    e = Number(n), o.call(this, t, e);\n"
"                }\n"
"            };\n"
"        },\n"
"        resetGlobalErrorSet() {\n"
"            this.currentErrorClass = this.currentGlobalSet = void 0;\n"
"        }\n"
"    });\n"
"    class ZigErrorBase extends Error {\n"
"        constructor(t, e) {\n"
"            super(function(t) {\n"
"                let e = t.replace(/_/g, \" \");\n"
"                try {\n"
"                    e = e.replace(/(\\p{Uppercase}+)(\\p{Lowercase}*)/gu, ((t, e, n) => 1 === e.length ? ` ${e.toLocaleLowerCase()}${n}` : n ? t : ` ${e}`)).trimStart();\n"
"                } catch (t) {}\n"
"                return e.charAt(0).toLocaleUpperCase() + e.substring(1);\n"
"            }(t)), this.number = e, this.stack = void 0;\n"
"        }\n"
"        [Symbol.toPrimitive](t) {\n"
"            switch (t) {\n"
"              case \"string\":\n"
"              case \"default\":\n"
"                return Error.prototype.toString.call(this, t);\n"
"\n"
"              default:\n"
"                return this.number;\n"
"            }\n"
"        }\n"
"        toJSON() {\n"
"            return {\n"
"                error: this.message\n"
"            };\n"
"        }\n"
"    }\n"
"    function yn(t, e) {\n"
"        return we(t?.constructor?.child, e) && t[\"*\"];\n"
"    }\n"
"    function bn(t, e, n) {\n"
"        if (n & E) {\n"
"            if (t?.constructor?.child?.child === e.child && t[\"*\"]) return !0;\n"
"            if (n & M && yn(t, e.child)) return !0;\n"
"        }\n"
"        return !1;\n"
"    }\n"
"    xe({\n"
"        defineErrorUnion(t, e) {\n"
"            const {instance: {members: [n, r]}, flags: o} = t, {get: c, set: a} = this.defineMember(n), {get: l, set: u} = this.defineMember(r), {get: f, set: h} = this.defineMember(r, !1), d = n.type === D.Void, g = r.structure.constructor, y = function() {\n"
"                this[qt](), this[Gt]?.(\"clear\");\n"
"            }, b = this.createApplier(t), p = function(e, n) {\n"
"                if (ve(e, v)) this[_t](e), o & s && (f.call(this) || this[Gt](\"copy\", 0, e)); else if (e instanceof g[ft] && g(e)) u.call(this, e), \n"
"                y.call(this); else if (void 0 !== e || d) try {\n"
"                    a.call(this, e, n), h.call(this, 0);\n"
"                } catch (n) {\n"
"                    if (e instanceof Error) {\n"
"                        const n = g[e] ?? g.Unexpected;\n"
"                        if (!n) throw new NotInErrorSet(t);\n"
"                        u.call(this, n), y.call(this);\n"
"                    } else if (Ce(e)) u.call(this, e), y.call(this); else {\n"
"                        if (!e || \"object\" != typeof e) throw n;\n"
"                        if (0 === b.call(this, e)) throw n;\n"
"                    }\n"
"                }\n"
"            }, {bitOffset: m, byteSize: w} = n, v = this.createConstructor(t);\n"
"            return e.$ = {\n"
"                get: function() {\n"
"                    if (f.call(this)) throw l.call(this);\n"
"                    return c.call(this);\n"
"                },\n"
"                set: p\n"
"            }, e[Ht] = re(p), e[Jt] = o & i && this.defineVivificatorStruct(t), e[qt] = this.defineResetter(m / 8, w), \n"
"            e[Gt] = o & s && this.defineVisitorErrorUnion(n, f), v;\n"
"        }\n"
"    }), xe({\n"
"        defineFunction(t, n) {\n"
"            const {instance: {members: [r], template: i}, static: {template: s}} = t, o = new ObjectCache, {structure: {constructor: c}} = r, a = this, l = function(n) {\n"
"                const r = this instanceof l;\n"
"                let u, f;\n"
"                if (r) {\n"
"                    if (0 === arguments.length) throw new NoInitializer(t);\n"
"                    if (\"function\" != typeof n) throw new TypeMismatch(\"function\", n);\n"
"                    if (c[lt] === e.VariadicStruct || !s) throw new Unsupported;\n"
"                    u = a.getFunctionThunk(n, s);\n"
"                } else {\n"
"                    if (this !== Ut) throw new NoCastingToFunction;\n"
"                    u = n;\n"
"                }\n"
"                if (f = o.find(u)) return f;\n"
"                const h = c.prototype.length, d = r ? a.createInboundCaller(n, c) : a.createOutboundCaller(i, c);\n"
"                return ne(d, {\n"
"                    length: re(h),\n"
"                    name: re(r ? n.name : \"\")\n"
"                }), Object.setPrototypeOf(d, l.prototype), d[it] = u, o.save(u, d), d;\n"
"            };\n"
"            return Object.setPrototypeOf(l.prototype, Function.prototype), n.valueOf = n.toJSON = re(Ae), \n"
"            l;\n"
"        },\n"
"        finalizeFunction(t, e, n) {\n"
"            n[Symbol.toStringTag] = void 0;\n"
"        }\n"
"    }), xe({\n"
"        defineOpaque(t, e) {\n"
"            const {flags: n} = t, r = () => {\n"
"                throw new AccessingOpaque(t);\n"
"            }, i = this.createConstructor(t);\n"
"            return e.$ = {\n"
"                get: r,\n"
"                set: r\n"
"            }, e[Symbol.iterator] = n & B && this.defineZigIterator(), e[Symbol.toPrimitive] = {\n"
"                value(e) {\n"
"                    const {name: n} = t;\n"
"                    return `[opaque ${n}]`;\n"
"                }\n"
"            }, e[Ht] = re((() => {\n"
"                throw new CreatingOpaque(t);\n"
"            })), i;\n"
"        }\n"
"    }), xe({\n"
"        defineOptional(t, e) {\n"
"            const {instance: {members: [n, r]}, flags: o} = t, {get: c, set: a} = this.defineMember(n), {get: l, set: u} = this.defineMember(r), f = n.type === D.Void, h = function(t, e) {\n"
"                ve(t, d) ? (this[_t](t), o & s && l.call(this) && this[Gt](\"copy\", tt.Vivificate, t)) : null === t ? (u.call(this, 0), \n"
"                this[qt]?.(), this[Gt]?.(\"clear\")) : (void 0 !== t || f) && (a.call(this, t, e), \n"
"                o & I ? u.call(this, 1) : o & s && (l.call(this) || u.call(this, 13)));\n"
"            }, d = t.constructor = this.createConstructor(t), {bitOffset: g, byteSize: y} = n;\n"
"            return e.$ = {\n"
"                get: function() {\n"
"                    return l.call(this) ? c.call(this) : (this[Gt]?.(\"clear\"), null);\n"
"                },\n"
"                set: h\n"
"            }, e[Ht] = re(h), e[qt] = o & I && this.defineResetter(g / 8, y), e[Jt] = o & i && this.defineVivificatorStruct(t), \n"
"            e[Gt] = o & s && this.defineVisitorOptional(n, l), d;\n"
"        }\n"
"    }), xe({\n"
"        definePointer(t, n) {\n"
"            const {flags: i, byteSize: s, instance: {members: [o]}} = t, {structure: a} = o, {type: l, flags: u, byteSize: f = 1} = a, h = i & V ? s / 2 : s, {get: d, set: g} = this.defineMember({\n"
"                type: D.Uint,\n"
"                bitOffset: 0,\n"
"                bitSize: 8 * h,\n"
"                byteSize: h,\n"
"                structure: {\n"
"                    byteSize: h\n"
"                }\n"
"            }), {get: y, set: b} = i & V ? this.defineMember({\n"
"                type: D.Uint,\n"
"                bitOffset: 8 * h,\n"
"                bitSize: 8 * h,\n"
"                byteSize: h,\n"
"                structure: {\n"
"                    flags: c,\n"
"                    byteSize: h\n"
"                }\n"
"            }) : {}, p = function(t, n = !0, r = !0) {\n"
"                if (n || this[it][ct]) {\n"
"                    if (!r) return this[st][0] = void 0;\n"
"                    {\n"
"                        const n = z.child, r = d.call(this), s = i & V ? y.call(this) : l === e.Slice && u & $ ? T.findSentinel(r, n[yt].bytes) + 1 : 1;\n"
"                        if (r !== this[It] || s !== this[Vt]) {\n"
"                            const e = T.findMemory(t, r, s, n[xt]), o = e ? n.call(Ut, e) : null;\n"
"                            return this[st][0] = o, this[It] = r, this[Vt] = s, i & V && (this[wt] = null), \n"
"                            o;\n"
"                        }\n"
"                    }\n"
"                }\n"
"                return this[st][0];\n"
"            }, m = function(t) {\n"
"                g.call(this, t), this[It] = t;\n"
"            }, w = u & $ ? 1 : 0, v = i & V || u & $ ? function(t) {\n"
"                b?.call?.(this, t - w), this[Vt] = t;\n"
"            } : null, S = function() {\n"
"                const t = this[gt] ?? this, e = !t[st][0], n = p.call(t, null, e);\n"
"                if (!n) {\n"
"                    if (i & O) return null;\n"
"                    throw new NullPointer;\n"
"                }\n"
"                return i & x ? mn(n) : n;\n"
"            }, A = u & r ? function() {\n"
"                return S.call(this).$;\n"
"            } : S, I = i & x ? ze : function(t) {\n"
"                return S.call(this).$ = t;\n"
"            }, T = this, U = function(n, r) {\n"
"                const s = a.constructor;\n"
"                if (yn(n, s)) {\n"
"                    if (!(i & x) && n.constructor.const) throw new ConstantConstraint(t, n);\n"
"                    n = n[st][0];\n"
"                } else if (i & E) bn(n, s, i) && (n = s(n[st][0][it])); else if (l === e.Slice && u & C && n) if (n.constructor[lt] === e.Pointer) n = n[pt]?.[it]; else if (n[it]) n = n[it]; else if (n?.buffer instanceof ArrayBuffer && !(n instanceof Uint8Array || n instanceof DataView)) {\n"
"                    const {byteOffset: t, byteLength: e} = n;\n"
"                    void 0 !== t && void 0 !== e && (n = new DataView(n.buffer, t, e));\n"
"                }\n"
"                if (n instanceof s) {\n"
"                    const e = n[Tt];\n"
"                    if (e) {\n"
"                        if (!(i & x)) throw new ReadOnlyTarget(t);\n"
"                        n = e;\n"
"                    }\n"
"                } else if (ve(n, s)) n = s.call(Ut, n[it]); else if (i & M && i & E && n instanceof s.child) n = s(n[it]); else if (function(t, e) {\n"
"                    const n = t?.[Symbol.toStringTag];\n"
"                    if (n) {\n"
"                        const r = e[jt];\n"
"                        if (r) switch (n) {\n"
"                          case r.name:\n"
"                          case \"DataView\":\n"
"                            return !0;\n"
"\n"
"                          case \"ArrayBuffer\":\n"
"                            return r === Uint8Array || r === Int8Array;\n"
"\n"
"                          case \"Uint8ClampedArray\":\n"
"                            return r === Uint8Array;\n"
"                        }\n"
"                        if (e.child && void 0 !== pe(t, e.child)) return !0;\n"
"                    }\n"
"                    return !1;\n"
"                }(n, s)) {\n"
"                    n = s(T.extractView(a, n));\n"
"                } else if (null == n || n[it]) {\n"
"                    if (!(void 0 === n || i & O && null === n)) throw new InvalidPointerTarget(t, n);\n"
"                } else {\n"
"                    if (i & M && i & E && \"object\" == typeof n && !n[Symbol.iterator]) {\n"
"                        let t = !0;\n"
"                        const e = s.prototype[Bt];\n"
"                        for (const r of Object.keys(n)) {\n"
"                            const n = e[r];\n"
"                            if (n?.special) {\n"
"                                t = !1;\n"
"                                break;\n"
"                            }\n"
"                        }\n"
"                        t && (n = [ n ]);\n"
"                    }\n"
"                    if (jt in s && n?.buffer && n[Symbol.iterator]) throw new InvalidPointerTarget(t, n);\n"
"                    n = new s(n, {\n"
"                        allocator: r\n"
"                    });\n"
"                }\n"
"                const o = n?.[it]?.[ct];\n"
"                if (o?.address === ge) throw new PreviouslyFreed(n);\n"
"                this[pt] = n;\n"
"            }, z = this.createConstructor(t);\n"
"            return n[\"*\"] = {\n"
"                get: A,\n"
"                set: I\n"
"            }, n.$ = {\n"
"                get: Ie,\n"
"                set: U\n"
"            }, n.length = {\n"
"                get: function() {\n"
"                    const t = S.call(this);\n"
"                    return t ? t.length : 0;\n"
"                },\n"
"                set: function(t) {\n"
"                    t |= 0;\n"
"                    const e = S.call(this);\n"
"                    if (!e) {\n"
"                        if (0 !== t) throw new InvalidSliceLength(t, 0);\n"
"                        return;\n"
"                    }\n"
"                    if (e.length === t) return;\n"
"                    const n = e[it], r = n[ct];\n"
"                    let s;\n"
"                    if (!r) if (i & V) this[wt] ||= e.length, s = this[wt]; else {\n"
"                        s = (n.buffer.byteLength - n.byteOffset) / f | 0;\n"
"                    }\n"
"                    if (t < 0 || t > s) throw new InvalidSliceLength(t, s);\n"
"                    const o = t * f, c = r ? T.obtainZigView(r.address, o) : T.obtainView(n.buffer, n.byteOffset, o), l = a.constructor;\n"
"                    this[st][0] = l.call(Ut, c), v?.call?.(this, t);\n"
"                }\n"
"            }, n.slice = l === e.Slice && {\n"
"                value(t, e) {\n"
"                    const n = this[pt].slice(t, e);\n"
"                    return new z(n);\n"
"                }\n"
"            }, n.subarray = l === e.Slice && {\n"
"                value(t, e, n) {\n"
"                    const r = this[pt].subarray(t, e, n);\n"
"                    return new z(r);\n"
"                }\n"
"            }, n[Symbol.toPrimitive] = l === e.Primitive && {\n"
"                value(t) {\n"
"                    return this[pt][Symbol.toPrimitive](t);\n"
"                }\n"
"            }, n[Ht] = re(U), n[Yt] = {\n"
"                value() {\n"
"                    const t = l !== e.Pointer ? wn : {};\n"
"                    let n;\n"
"                    l === e.Function ? (n = function() {}, n[it] = this[it], n[st] = this[st], Object.setPrototypeOf(n, z.prototype)) : n = this;\n"
"                    const r = new Proxy(n, t);\n"
"                    return Object.defineProperty(n, Et, {\n"
"                        value: r\n"
"                    }), r;\n"
"                }\n"
"            }, n[pt] = {\n"
"                get: S,\n"
"                set: function(t) {\n"
"                    if (void 0 === t) return;\n"
"                    const e = this[gt] ?? this;\n"
"                    if (t) {\n"
"                        const n = t[it][ct];\n"
"                        if (n) {\n"
"                            const {address: e, js: r} = n;\n"
"                            m.call(this, e), v?.call?.(this, t.length), r && (t[it][ct] = void 0);\n"
"                        } else if (e[it][ct]) throw new ZigMemoryTargetRequired;\n"
"                    } else e[it][ct] && (m.call(this, 0), v?.call?.(this, 0));\n"
"                    e[st][0] = t ?? null, i & V && (e[wt] = null);\n"
"                }\n"
"            }, n[Zt] = re(p), n[St] = {\n"
"                set: m\n"
"            }, n[At] = {\n"
"                set: v\n"
"            }, n[Gt] = this.defineVisitor(), n[It] = re(0), n[Vt] = re(0), n[wt] = i & V && re(null), \n"
"            n.dataView = n.base64 = void 0, z;\n"
"        },\n"
"        finalizePointer(t, n) {\n"
"            const {flags: r, constructor: i, instance: {members: [s]}} = t, {structure: o} = s, {type: c, constructor: a} = o;\n"
"            n.child = a ? re(a) : {\n"
"                get: () => o.constructor\n"
"            }, n.const = re(!!(r & x)), n[Kt] = {\n"
"                value(n, s) {\n"
"                    if (this === Ut || this === ot || n instanceof i) return !1;\n"
"                    if (yn(n, a)) return new i(a(n[\"*\"]), s);\n"
"                    if (bn(n, a, r)) return new i(n);\n"
"                    if (c === e.Slice) return new i(a(n), s);\n"
"                    throw new NoCastingToPointer(t);\n"
"                }\n"
"            };\n"
"        }\n"
"    });\n"
"    const pn = new WeakMap;\n"
"    function mn(t) {\n"
"        if (!t) return null;\n"
"        let e = pn.get(t);\n"
"        if (!e) {\n"
"            const n = t[gt];\n"
"            e = n ? new Proxy(n, vn) : new Proxy(t, Sn), pn.set(t, e);\n"
"        }\n"
"        return e;\n"
"    }\n"
"    const wn = {\n"
"        get(t, e) {\n"
"            if (e === gt) return t;\n"
"            if (e in t) return t[e];\n"
"            return t[pt][e];\n"
"        },\n"
"        set(t, e, n) {\n"
"            if (e in t) t[e] = n; else {\n"
"                t[pt][e] = n;\n"
"            }\n"
"            return !0;\n"
"        },\n"
"        deleteProperty(t, e) {\n"
"            if (e in t) delete t[e]; else {\n"
"                delete t[pt][e];\n"
"            }\n"
"            return !0;\n"
"        },\n"
"        has(t, e) {\n"
"            if (e in t) return !0;\n"
"            return e in t[pt];\n"
"        },\n"
"        apply: (t, e, n) => t[\"*\"].apply(e, n)\n"
"    }, vn = {\n"
"        ...wn,\n"
"        set(t, e, n) {\n"
"            if (e in t) ze(); else {\n"
"                t[pt][e] = n;\n"
"            }\n"
"            return !0;\n"
"        }\n"
"    }, Sn = {\n"
"        get(t, e) {\n"
"            if (e === Tt) return t;\n"
"            {\n"
"                const n = t[e];\n"
"                return n?.[it] ? mn(n) : n;\n"
"            }\n"
"        },\n"
"        set(t, e, n) {\n"
"            ze();\n"
"        }\n"
"    };\n"
"    function An() {\n"
"        return this[At];\n"
"    }\n"
"    function In(t, e) {\n"
"        return (t |= 0) < 0 ? (t = e + t) < 0 && (t = 0) : t > e && (t = e), t;\n"
"    }\n"
"    function Vn() {\n"
"        throw new InaccessiblePointer;\n"
"    }\n"
"    function En() {\n"
"        const t = {\n"
"            get: Vn,\n"
"            set: Vn\n"
"        };\n"
"        ne(this[gt], {\n"
"            \"*\": t,\n"
"            $: t,\n"
"            [gt]: t,\n"
"            [pt]: t\n"
"        });\n"
"    }\n"
"    function Mn(t, e, n, r) {\n"
"        let i, s = this[st][t];\n"
"        if (!s) {\n"
"            if (n & tt.IgnoreUncreated) return;\n"
"            s = this[Jt](t);\n"
"        }\n"
"        r && (i = r[st][t], !i) || s[Gt](e, n, i);\n"
"    }\n"
"    xe({\n"
"        definePrimitive(t, e) {\n"
"            const {instance: {members: [n]}} = t, r = this.createApplier(t), {get: i, set: s} = this.defineMember(n), o = function(e) {\n"
"                if (ve(e, c)) this[_t](e); else if (e && \"object\" == typeof e) {\n"
"                    if (0 === r.call(this, e)) {\n"
"                        const r = se(n);\n"
"                        throw new InvalidInitializer(t, r, e);\n"
"                    }\n"
"                } else void 0 !== e && s.call(this, e);\n"
"            }, c = this.createConstructor(t);\n"
"            return e.$ = {\n"
"                get: i,\n"
"                set: o\n"
"            }, e[Ht] = re(o), e[Symbol.toPrimitive] = re(i), c;\n"
"        },\n"
"        finalizePrimitive(t, e) {\n"
"            const {instance: {members: [n]}} = t;\n"
"            e[Ot] = re(n.bitSize), e[Ct] = re(n.type);\n"
"        }\n"
"    }), xe({\n"
"        defineSlice(t, e) {\n"
"            const {align: n, flags: r, byteSize: o, name: c, instance: {members: [a]}} = t, {byteSize: l, structure: u} = a, f = this, h = function(t, e, r) {\n"
"                t || (t = f.allocateMemory(e * l, n, r)), this[it] = t, this[At] = e;\n"
"            }, d = function(e, n) {\n"
"                if (n !== this[At]) throw new ArrayLengthMismatch(t, this, e);\n"
"            }, g = this.defineMember(a), {set: y} = g, b = this.createApplier(t), p = function(e, n) {\n"
"                if (ve(e, w)) this[it] ? d.call(this, e, e.length) : h.call(this, null, e.length, n), \n"
"                this[_t](e), r & s && this[Gt](\"copy\", tt.Vivificate, e); else if (\"string\" == typeof e && r & T) p.call(this, {\n"
"                    string: e\n"
"                }, n); else if (e?.[Symbol.iterator]) {\n"
"                    e = be(e), this[it] ? d.call(this, e, e.length) : h.call(this, null, e.length, n);\n"
"                    let t = 0;\n"
"                    for (const r of e) w[yt]?.validateValue(r, t, e.length), y.call(this, t++, r, n);\n"
"                } else if (\"number\" == typeof e) {\n"
"                    if (!(!this[it] && e >= 0 && isFinite(e))) throw new InvalidArrayInitializer(t, e, !this[it]);\n"
"                    h.call(this, null, e, n);\n"
"                } else if (e && \"object\" == typeof e) {\n"
"                    if (0 === b.call(this, e, n)) throw new InvalidArrayInitializer(t, e);\n"
"                } else if (void 0 !== e) throw new InvalidArrayInitializer(t, e);\n"
"            }, m = function(t, e) {\n"
"                const n = this[At], r = this[it];\n"
"                t = void 0 === t ? 0 : In(t, n), e = void 0 === e ? n : In(e, n);\n"
"                const i = t * l, s = e * l - i;\n"
"                return f.obtainView(r.buffer, r.byteOffset + i, s);\n"
"            }, w = this.createConstructor(t);\n"
"            return e.$ = {\n"
"                get: Ie,\n"
"                set: p\n"
"            }, e.length = {\n"
"                get: An\n"
"            }, r & U && (e.typedArray = this.defineTypedArray(t), r & T && (e.string = this.defineString(t)), \n"
"            r & z && (e.clampedArray = this.defineClampedArray(t))), e.entries = e[mt] = this.defineArrayEntries(), \n"
"            e.subarray = {\n"
"                value(t, e) {\n"
"                    const n = m.call(this, t, e);\n"
"                    return w(n);\n"
"                }\n"
"            }, e.slice = {\n"
"                value(t, e, r = {}) {\n"
"                    const {zig: i = !1} = r, s = m.call(this, t, e), o = f.allocateMemory(s.byteLength, n, i), c = w(o);\n"
"                    return c[_t]({\n"
"                        [it]: s\n"
"                    }), c;\n"
"                }\n"
"            }, e[Symbol.iterator] = this.defineArrayIterator(), e[Wt] = re(h), e[_t] = this.defineCopier(o, !0), \n"
"            e[Ht] = re(p), e[Yt] = this.defineFinalizerArray(g), e[Jt] = r & i && this.defineVivificatorArray(t), \n"
"            e[Gt] = r & s && this.defineVisitorArray(), w;\n"
"        },\n"
"        finalizeSlice(t, e) {\n"
"            const {flags: n, instance: {members: [r]}} = t;\n"
"            e.child = re(r.structure.constructor), e[yt] = n & $ && this.defineSentinel(t);\n"
"        }\n"
"    }), xe({\n"
"        defineVivificatorStruct(t) {\n"
"            const {instance: {members: e}} = t, n = {};\n"
"            for (const t of e.filter((t => t.type === D.Object))) n[t.slot] = t;\n"
"            const r = this;\n"
"            return {\n"
"                value(t) {\n"
"                    const e = n[t], {bitOffset: i, byteSize: s, structure: {constructor: o}} = e, c = this[it], a = c.byteOffset + (i >> 3);\n"
"                    let l = s;\n"
"                    if (void 0 === l) {\n"
"                        if (7 & i) throw new NotOnByteBoundary(e);\n"
"                        l = e.bitSize >> 3;\n"
"                    }\n"
"                    const u = r.obtainView(c.buffer, a, l);\n"
"                    return this[st][t] = o.call(ot, u);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineStruct(t, e) {\n"
"            const {flags: n, length: r, instance: {members: o}} = t, c = o.find((t => t.flags & _)), a = c && this.defineMember(c), l = this.createApplier(t), u = function(e, r) {\n"
"                if (ve(e, f)) this[_t](e), n & s && this[Gt](\"copy\", 0, e); else if (e && \"object\" == typeof e) l.call(this, e, r); else if (\"number\" != typeof e && \"bigint\" != typeof e || !a) {\n"
"                    if (void 0 !== e) throw new InvalidInitializer(t, \"object\", e);\n"
"                } else a.set.call(this, e);\n"
"            }, f = this.createConstructor(t), y = e[Bt].value, b = e[vt].value, p = [];\n"
"            for (const t of o.filter((t => !!t.name))) {\n"
"                const {name: n, flags: r} = t, {set: i} = e[n] = this.defineMember(t);\n"
"                i && (r & Z && (i.required = !0), y[n] = i, b.push(n)), p.push(n);\n"
"            }\n"
"            return e.$ = {\n"
"                get: Ae,\n"
"                set: u\n"
"            }, e.length = re(r), e.entries = n & d && this.defineVectorEntries(), e[Symbol.toPrimitive] = a && {\n"
"                value(t) {\n"
"                    return \"string\" === t ? Object.prototype.toString.call(this) : a.get.call(this);\n"
"                }\n"
"            }, e[Symbol.iterator] = n & h ? this.defineZigIterator() : n & d ? this.defineVectorIterator() : this.defineStructIterator(), \n"
"            e[Ht] = re(u), e[Jt] = n & i && this.defineVivificatorStruct(t), e[Gt] = n & s && this.defineVisitorStruct(o), \n"
"            e[mt] = n & d ? this.defineVectorEntries() : this.defineStructEntries(), e[dt] = re(p), \n"
"            n & g && (e.alloc = this.defineAlloc(), e.free = this.defineFree(), e.dupe = this.defineDupe()), \n"
"            f;\n"
"        }\n"
"    }), xe({\n"
"        defineUnion(t, e) {\n"
"            const {flags: n, instance: {members: r}} = t, o = !!(n & m), c = o ? r.slice(0, -1) : r, a = o ? r[r.length - 1] : null, {get: l, set: u} = this.defineMember(a), {get: f} = this.defineMember(a, !1), h = n & w ? function() {\n"
"                return l.call(this)[at];\n"
"            } : function() {\n"
"                const t = l.call(this);\n"
"                return c[t].name;\n"
"            }, d = n & w ? function(t) {\n"
"                const {constructor: e} = a.structure;\n"
"                u.call(this, e[t]);\n"
"            } : function(t) {\n"
"                const e = c.findIndex((e => e.name === t));\n"
"                u.call(this, e);\n"
"            }, g = this.createApplier(t), y = function(e, r) {\n"
"                if (ve(e, b)) this[_t](e), n & s && this[Gt](\"copy\", tt.Vivificate, e); else if (e && \"object\" == typeof e) {\n"
"                    let n = 0;\n"
"                    for (const t of V) t in e && n++;\n"
"                    if (n > 1) throw new MultipleUnionInitializers(t);\n"
"                    if (0 === g.call(this, e, r)) throw new MissingUnionInitializer(t, e, o);\n"
"                } else if (void 0 !== e) throw new InvalidInitializer(t, \"object with a single property\", e);\n"
"            }, b = this.createConstructor(t), p = {}, A = e[Bt].value, I = e[vt].value, V = [];\n"
"            for (const r of c) {\n"
"                const {name: i} = r, {get: s, set: c} = this.defineMember(r), a = o ? function() {\n"
"                    const e = h.call(this);\n"
"                    if (i !== e) {\n"
"                        if (n & w) return null;\n"
"                        throw new InactiveUnionProperty(t, i, e);\n"
"                    }\n"
"                    return this[Gt]?.(\"clear\"), s.call(this);\n"
"                } : s, l = o && c ? function(e) {\n"
"                    const n = h.call(this);\n"
"                    if (i !== n) throw new InactiveUnionProperty(t, i, n);\n"
"                    c.call(this, e);\n"
"                } : c, u = o && c ? function(t) {\n"
"                    d.call(this, i), c.call(this, t), this[Gt]?.(\"clear\");\n"
"                } : c;\n"
"                e[i] = {\n"
"                    get: a,\n"
"                    set: l\n"
"                }, A[i] = u, p[i] = s, I.push(i), V.push(i);\n"
"            }\n"
"            e.$ = {\n"
"                get: function() {\n"
"                    return this;\n"
"                },\n"
"                set: y\n"
"            }, e[Symbol.iterator] = n & S ? this.defineZigIterator() : this.defineUnionIterator(), \n"
"            e[Symbol.toPrimitive] = n & w && {\n"
"                value(t) {\n"
"                    switch (t) {\n"
"                      case \"string\":\n"
"                      case \"default\":\n"
"                        return h.call(this);\n"
"\n"
"                      default:\n"
"                        return f.call(this);\n"
"                    }\n"
"                }\n"
"            };\n"
"            const {comptime: E} = this;\n"
"            return e[Xt] = n & v && {\n"
"                value() {\n"
"                    return E || this[Gt](En), this[Gt] = Ee, this;\n"
"                }\n"
"            }, e[Ht] = re(y), e[ht] = n & w && {\n"
"                get: l,\n"
"                set: u\n"
"            }, e[Jt] = n & i && this.defineVivificatorStruct(t), e[Gt] = n & s && this.defineVisitorUnion(c, n & w ? f : null), \n"
"            e[mt] = this.defineUnionEntries(), e[dt] = n & w ? {\n"
"                get() {\n"
"                    return [ h.call(this) ];\n"
"                }\n"
"            } : re(V), e[Ft] = re(p), b;\n"
"        },\n"
"        finalizeUnion(t, e) {\n"
"            const {flags: n, instance: {members: r}} = t;\n"
"            n & w && (e.tag = re(r[r.length - 1].structure.constructor));\n"
"        }\n"
"    }), xe({\n"
"        defineVariadicStruct(t, e) {\n"
"            const {byteSize: n, align: r, flags: s, length: o, instance: {members: c}} = t, a = this, l = c.slice(1);\n"
"            for (const t of c) e[t.name] = this.defineMember(t);\n"
"            const u = e.retval.set, f = function(t) {\n"
"                this[it] = a.allocateMemory(8 * t, 4), this.length = t, this.littleEndian = a.littleEndian;\n"
"            };\n"
"            return ne(f, {\n"
"                [$t]: {\n"
"                    value: 4\n"
"                }\n"
"            }), ne(f.prototype, {\n"
"                set: re((function(t, e, n, r, i) {\n"
"                    const s = this[it], o = a.littleEndian;\n"
"                    s.setUint16(8 * t, e, o), s.setUint16(8 * t + 2, n, o), s.setUint16(8 * t + 4, r, o), \n"
"                    s.setUint8(8 * t + 6, i == D.Float), s.setUint8(8 * t + 7, i == D.Int || i == D.Float);\n"
"                }))\n"
"            }), e[Jt] = s & i && this.defineVivificatorStruct(t), e[Gt] = this.defineVisitorVariadicStruct(c), \n"
"            e[Qt] = re((function(t) {\n"
"                u.call(this, t, this[ALLOCATOR]);\n"
"            })), function(t) {\n"
"                if (t.length < o) throw new ArgumentCountMismatch(o, t.length, !0);\n"
"                let e = n, i = r;\n"
"                const s = t.slice(o), c = {};\n"
"                for (const [t, n] of s.entries()) {\n"
"                    const r = n?.[it], s = n?.constructor?.[$t];\n"
"                    if (!r || !s) {\n"
"                        throw Te(new InvalidVariadicArgument, o + t);\n"
"                    }\n"
"                    s > i && (i = s);\n"
"                    e = (c[t] = e + (s - 1) & ~(s - 1)) + r.byteLength;\n"
"                }\n"
"                const u = new f(t.length), h = a.allocateMemory(e, i);\n"
"                h[$t] = i, this[it] = h, this[st] = {}, a.copyArguments(this, t, l);\n"
"                let d = -1;\n"
"                for (const [t, {bitOffset: e, bitSize: n, type: r, slot: i, structure: {align: s}}] of l.entries()) u.set(t, e / 8, n, s, r), \n"
"                i > d && (d = i);\n"
"                for (const [t, e] of s.entries()) {\n"
"                    const n = d + t + 1, {byteLength: r} = e[it], i = c[t], s = a.obtainView(h.buffer, i, r), l = this[st][n] = e.constructor.call(ot, s), f = e.constructor[Ot] ?? 8 * r, g = e.constructor[$t], y = e.constructor[Ct];\n"
"                    l.$ = e, u.set(o + t, i, f, g, y);\n"
"                }\n"
"                this[zt] = u;\n"
"            };\n"
"        },\n"
"        finalizeVariadicStruct(t, e) {\n"
"            const {flags: n} = t;\n"
"            e[Nt] = re(!!(n & P)), e[$t] = re(void 0);\n"
"        }\n"
"    }), xe({\n"
"        defineVector(t, e) {\n"
"            const {flags: n, length: r, instance: {members: [o]}} = t, c = this.createApplier(t), a = function(e) {\n"
"                if (ve(e, l)) this[_t](e), n & s && this[Gt](\"copy\", tt.Vivificate, e); else if (e?.[Symbol.iterator]) {\n"
"                    let n = e.length;\n"
"                    if (\"number\" != typeof n && (n = (e = [ ...e ]).length), n !== r) throw new ArrayLengthMismatch(t, this, e);\n"
"                    let i = 0;\n"
"                    for (const t of e) this[i++] = t;\n"
"                } else if (e && \"object\" == typeof e) {\n"
"                    if (0 === c.call(this, e)) throw new InvalidArrayInitializer(t, e);\n"
"                } else if (void 0 !== e) throw new InvalidArrayInitializer(t, e);\n"
"            }, l = this.createConstructor(t, {\n"
"                initializer: a\n"
"            }), {bitSize: u} = o;\n"
"            for (let t = 0, i = 0; t < r; t++, i += u) e[t] = n & s ? this.defineMember({\n"
"                ...o,\n"
"                slot: t\n"
"            }) : this.defineMember({\n"
"                ...o,\n"
"                bitOffset: i\n"
"            });\n"
"            return e.$ = {\n"
"                get: Ae,\n"
"                set: a\n"
"            }, e.length = re(r), n & j && (e.typedArray = this.defineTypedArray(t), n & N && (e.clampedArray = this.defineClampedArray(t))), \n"
"            e.entries = e[mt] = this.defineVectorEntries(), e[Symbol.iterator] = this.defineVectorIterator(), \n"
"            e[Ht] = re(a), e[Jt] = n & i && this.defineVivificatorArray(t), e[Gt] = n & s && this.defineVisitorArray(), \n"
"            l;\n"
"        },\n"
"        finalizeVector(t, e) {\n"
"            const {instance: {members: [n]}} = t;\n"
"            e.child = re(n.structure.constructor);\n"
"        }\n"
"    }), xe({\n"
"        defineVisitor: () => ({\n"
"            value(t, e, n) {\n"
"                let r;\n"
"                r = \"string\" == typeof t ? xn[t] : t, r.call(this, e, n);\n"
"            }\n"
"        })\n"
"    });\n"
"    const xn = {\n"
"        copy(t, e) {\n"
"            const n = e[st][0];\n"
"            if (this[it][ct] && n && !n[it][ct]) throw new ZigMemoryTargetRequired;\n"
"            this[st][0] = n;\n"
"        },\n"
"        clear(t) {\n"
"            t & tt.IsInactive && (this[st][0] = void 0);\n"
"        },\n"
"        reset() {\n"
"            this[st][0] = void 0, this[It] = void 0;\n"
"        }\n"
"    };\n"
"    return xe({\n"
"        defineVisitorArgStruct(t) {\n"
"            const e = [];\n"
"            let n;\n"
"            for (const [r, {slot: i, structure: o}] of t.entries()) o.flags & s && (0 === r ? n = i : e.push(i));\n"
"            return {\n"
"                value(t, r, i) {\n"
"                    if (!(r & tt.IgnoreArguments) && e.length > 0) for (const n of e) Mn.call(this, n, t, r | tt.IsImmutable, i);\n"
"                    r & tt.IgnoreRetval || void 0 === n || Mn.call(this, n, t, r, i);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineVisitorArray: () => ({\n"
"            value(t, e, n) {\n"
"                for (let r = 0, i = this.length; r < i; r++) Mn.call(this, r, t, e, n);\n"
"            }\n"
"        })\n"
"    }), xe({\n"
"        defineVisitorErrorUnion(t, e) {\n"
"            const {slot: n} = t;\n"
"            return {\n"
"                value(t, r, i) {\n"
"                    e.call(this) && (r |= tt.IsInactive), r & tt.IsInactive && r & tt.IgnoreInactive || Mn.call(this, n, t, r, i);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineVisitorOptional(t, e) {\n"
"            const {slot: n} = t;\n"
"            return {\n"
"                value(t, r, i) {\n"
"                    e.call(this) || (r |= tt.IsInactive), r & tt.IsInactive && r & tt.IgnoreInactive || Mn.call(this, n, t, r, i);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineVisitorStruct(t) {\n"
"            const e = t.filter((t => t.structure?.flags & s)).map((t => t.slot));\n"
"            return {\n"
"                value(t, n, r) {\n"
"                    for (const i of e) Mn.call(this, i, t, n, r);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineVisitorUnion(t, e) {\n"
"            const n = [];\n"
"            for (const [e, {slot: r, structure: i}] of t.entries()) i?.flags & s && n.push({\n"
"                index: e,\n"
"                slot: r\n"
"            });\n"
"            return {\n"
"                value(t, r, i) {\n"
"                    const s = e?.call(this);\n"
"                    for (const {index: e, slot: o} of n) {\n"
"                        let n = r;\n"
"                        e !== s && (n |= tt.IsInactive), n & tt.IsInactive && n & tt.IgnoreInactive || Mn.call(this, o, t, n, i);\n"
"                    }\n"
"                }\n"
"            };\n"
"        }\n"
"    }), xe({\n"
"        defineVisitorVariadicStruct(t) {\n"
"            const e = t[0], n = e.structure.flags & s ? e.slot : void 0;\n"
"            return {\n"
"                value(t, e, r) {\n"
"                    if (!(e & tt.IgnoreArguments)) for (const [i, s] of Object.entries(this[st])) i !== n && Gt in s && Mn.call(this, i, t, e | tt.IsImmutable, r);\n"
"                    e & tt.IgnoreRetval || void 0 === n || Mn.call(this, n, t, e, r);\n"
"                }\n"
"            };\n"
"        }\n"
"    }), t.createEnvironment = function() {\n"
"        try {\n"
"            return new (Oe());\n"
"        } catch (t) {\n"
"            throw console.error(t), t;\n"
"        }\n"
"    }, t;\n"
"}({}))"
