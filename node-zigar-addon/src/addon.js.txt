"((function (exports) {\n"
"  'use strict';\n"
"\n"
"  const MEMORY = Symbol('memory');\n"
"  const SLOTS = Symbol('slots');\n"
"  const PARENT = Symbol('parent');\n"
"  const ENUM_NAME = Symbol('enumName');\n"
"  const ENUM_INDEX = Symbol('enumIndex');\n"
"  const ENUM_ITEMS = Symbol('enumItems');\n"
"  const ERROR_INDEX = Symbol('errorIndex');\n"
"  const ENUM_ITEM = Symbol('enumItem');\n"
"  const TAG = Symbol('TAG');\n"
"  const GETTER = Symbol('getter');\n"
"  const SETTER = Symbol('setter');\n"
"  const LENGTH = Symbol('length');\n"
"  const PROXY = Symbol('proxy');\n"
"  const COMPAT = Symbol('compat');\n"
"  const SELF = Symbol('self');\n"
"  const CHILD_VIVIFICATOR = Symbol('childVivificator');\n"
"  const POINTER_VISITOR = Symbol('pointerVisitor');\n"
"  const TARGET_ACQUIRER = Symbol('targetAcquirer');\n"
"  const ADDRESS_UPDATER = Symbol('addressUpdater');\n"
"  const FIELD_VALIDATOR$1 = Symbol('fieldValidator');\n"
"  const RELEASE_THUNK = Symbol('releaseThunk');\n"
"  const ENVIRONMENT = Symbol('environment');\n"
"\n"
"  function getPointerAlign(align) {\n"
"    return (align) ? Math.log2(align) : 0;\n"
"  }\n"
"\n"
"  function getBitAlignFunction(bitPos, bitSize, toAligned) {\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const mask = (2 ** bitSize) - 1;\n"
"      if (toAligned) {\n"
"        // from single byte\n"
"        return function(dest, src, offset) {\n"
"          const n = src.getUint8(offset);\n"
"          const b = (n >> bitPos) & mask;\n"
"          dest.setUint8(0, b);\n"
"        };\n"
"      } else {\n"
"        // to single byte\n"
"        const destMask = 0xFF ^ (mask << bitPos);\n"
"        return function(dest, src, offset) {\n"
"          const n = src.getUint8(0);\n"
"          const d = dest.getUint8(offset);\n"
"          const b = (d & destMask) | ((n & mask) << bitPos);\n"
"          dest.setUint8(offset, b);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      const leadBits = 8 - bitPos;\n"
"      const leadMask = (2 ** leadBits) - 1;\n"
"      if (toAligned) {\n"
"        const trailBits = bitSize % 8;\n"
"        const trailMask = (2 ** trailBits) - 1;\n"
"        return function(dest, src, offset) {\n"
"          let i = offset, j = 0;\n"
"          let n = src.getUint8(i++), b;\n"
"          let bitBuf = (n >> bitPos) & leadMask;\n"
"          let bitCount = leadBits;\n"
"          let remaining = bitSize;\n"
"          do {\n"
"            if (remaining > bitCount) {\n"
"              n = src.getUint8(i++);\n"
"              bitBuf = bitBuf | (n << bitCount);\n"
"              //bitCount += 8;\n"
"            }\n"
"            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;\n"
"            dest.setUint8(j++, b);\n"
"            bitBuf >>= 8;\n"
"            //bitCount -= 8;\n"
"            remaining -= 8;\n"
"          } while (remaining > 0);\n"
"        }\n"
"      } else {\n"
"        const trailBits = (bitSize - leadBits) % 8;\n"
"        const trailMask = (2 ** trailBits) - 1;\n"
"        const destMask1 = 0xFF ^ (leadMask << bitPos);\n"
"        const destMask2 = 0xFF ^ trailMask;\n"
"        return function(dest, src, offset) {\n"
"          let i = 0, j = offset;\n"
"          // preserve bits ahead of bitPos\n"
"          let d = dest.getUint8(j), n, b;\n"
"          let bitBuf = d & destMask1;\n"
"          let bitCount = bitPos;\n"
"          let remaining = bitSize + bitCount;\n"
"          do {\n"
"            if (remaining > bitCount) {\n"
"              n = src.getUint8(i++);\n"
"              bitBuf = bitBuf | (n << bitCount);\n"
"              bitCount += 8;\n"
"            }\n"
"            if (remaining >= 8) {\n"
"              b = bitBuf & 0xFF;\n"
"            } else {\n"
"              // preserve bits at the destination sitting behind the trailing bits\n"
"              d = dest.getUint8(j);\n"
"              b = (d & destMask2) | (bitBuf & trailMask);\n"
"            }\n"
"            dest.setUint8(j++, b);\n"
"            bitBuf >>= 8;\n"
"            bitCount -= 8;\n"
"            remaining -= 8;\n"
"          } while (remaining > 0);\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function getMemoryCopier(size, multiple = false) {\n"
"    if (!multiple) {\n"
"      switch (size) {\n"
"        case 1: return copy1;\n"
"        case 2: return copy2;\n"
"        case 4: return copy4;\n"
"        case 8: return copy8;\n"
"        case 16: return copy16;\n"
"        case 32: return copy32;\n"
"      }\n"
"    }\n"
"    if (!(size & 0x07)) return copy8x;\n"
"    if (!(size & 0x03)) return copy4x;\n"
"    if (!(size & 0x01)) return copy2x;\n"
"    return copy1x;\n"
"  }\n"
"\n"
"  function copy1x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i++) {\n"
"      dest.setInt8(i, src.getInt8(i));\n"
"    }\n"
"  }\n"
"\n"
"  function copy2x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 2) {\n"
"      dest.setInt16(i, src.getInt16(i, true), true);\n"
"    }\n"
"  }\n"
"\n"
"  function copy4x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 4) {\n"
"      dest.setInt32(i, src.getInt32(i, true), true);\n"
"    }\n"
"  }\n"
"\n"
"  function copy8x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 8) {\n"
"      dest.setInt32(i, src.getInt32(i, true), true);\n"
"      dest.setInt32(i + 4, src.getInt32(i + 4, true), true);\n"
"    }\n"
"  }\n"
"\n"
"  function copy1(dest, src) {\n"
"    dest.setInt8(0, src.getInt8(0));\n"
"  }\n"
"\n"
"  function copy2(dest, src) {\n"
"    dest.setInt16(0, src.getInt16(0, true), true);\n"
"  }\n"
"\n"
"  function copy4(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"  }\n"
"\n"
"  function copy8(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\n"
"  }\n"
"\n"
"  function copy16(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\n"
"    dest.setInt32(8, src.getInt32(8, true), true);\n"
"    dest.setInt32(12, src.getInt32(12, true), true);\n"
"  }\n"
"\n"
"  function copy32(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\n"
"    dest.setInt32(8, src.getInt32(8, true), true);\n"
"    dest.setInt32(12, src.getInt32(12, true), true);\n"
"    dest.setInt32(16, src.getInt32(16, true), true);\n"
"    dest.setInt32(20, src.getInt32(20, true), true);\n"
"    dest.setInt32(24, src.getInt32(24, true), true);\n"
"    dest.setInt32(28, src.getInt32(28, true), true);\n"
"  }\n"
"\n"
"  function getMemoryResetter(size) {\n"
"    switch (size) {\n"
"      case 1: return reset1;\n"
"      case 2: return reset2;\n"
"      case 4: return reset4;\n"
"      case 8: return reset8;\n"
"      case 16: return reset16;\n"
"      case 32: return reset32;\n"
"      default:\n"
"        if (!(size & 0x07)) return reset8x;\n"
"        if (!(size & 0x03)) return reset4x;\n"
"        if (!(size & 0x01)) return reset2x;\n"
"        return reset1x;\n"
"    }\n"
"  }\n"
"\n"
"  function reset1x(dest) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i++) {\n"
"      dest.setInt8(i, 0);\n"
"    }\n"
"  }\n"
"\n"
"  function reset2x(dest) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 2) {\n"
"      dest.setInt16(i, 0, true);\n"
"    }\n"
"  }\n"
"\n"
"  function reset4x(dest) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 4) {\n"
"      dest.setInt32(i, 0, true);\n"
"    }\n"
"  }\n"
"\n"
"  function reset8x(dest) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 8) {\n"
"      dest.setInt32(i, 0, true);\n"
"      dest.setInt32(i + 4, 0, true);\n"
"    }\n"
"  }\n"
"\n"
"  function reset1(dest) {\n"
"    dest.setInt8(0, 0);\n"
"  }\n"
"\n"
"  function reset2(dest) {\n"
"    dest.setInt16(0, 0, true);\n"
"  }\n"
"\n"
"  function reset4(dest) {\n"
"    dest.setInt32(0, 0, true);\n"
"  }\n"
"\n"
"  function reset8(dest) {\n"
"    dest.setInt32(0, 0, true);\n"
"    dest.setInt32(4, 0, true);\n"
"  }\n"
"\n"
"  function reset16(dest) {\n"
"    dest.setInt32(0, 0, true);\n"
"    dest.setInt32(4, 0, true);\n"
"    dest.setInt32(8, 0, true);\n"
"    dest.setInt32(12, 0, true);\n"
"  }\n"
"\n"
"  function reset32(dest) {\n"
"    dest.setInt32(0, 0, true);\n"
"    dest.setInt32(4, 0, true);\n"
"    dest.setInt32(8, 0, true);\n"
"    dest.setInt32(12, 0, true);\n"
"    dest.setInt32(16, 0, true);\n"
"    dest.setInt32(20, 0, true);\n"
"    dest.setInt32(24, 0, true);\n"
"    dest.setInt32(28, 0, true);\n"
"  }\n"
"  /* c8 ignore end */\n"
"\n"
"  function restoreMemory() {\n"
"  }\n"
"\n"
"  function throwNoInitializer(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when it's undefined`);\n"
"  }\n"
"\n"
"  function throwBufferSizeMismatch(structure, dv, target = null) {\n"
"    const { type, byteSize } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const actual = dv.byteLength;\n"
"    const s = (byteSize > 1) ? 's' : '';\n"
"    if (type === StructureType.Slice && !target) {\n"
"      throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);\n"
"    } else {\n"
"      const total = (type === StructureType.Slice) ? target.length * byteSize : byteSize;\n"
"      throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);\n"
"    }\n"
"  }\n"
"\n"
"  function throwBufferExpected(structure) {\n"
"    const { type, byteSize, typedArray } = structure;\n"
"    const s = (byteSize > 1) ? 's' : '';\n"
"    const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle);\n"
"    if (typedArray) {\n"
"      acceptable.push(addArticle(typedArray.name));\n"
"    }\n"
"    if (type === StructureType.Slice) {\n"
"      throw new TypeError(`Expecting ${formatList(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);\n"
"    } else {\n"
"      throw new TypeError(`Expecting ${formatList(acceptable)} that is ${byteSize} byte${s} in length`);\n"
"    }\n"
"  }\n"
"\n"
"  function throwInvalidEnum(structure, value) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${value}`);\n"
"  }\n"
"\n"
"  function throwEnumExpected(structure, arg) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);\n"
"  }\n"
"\n"
"  function throwNoNewEnum(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Cannot create new enum item\\nCall ${name} without the use of \"new\" to obtain an enum object`);\n"
"  }\n"
"\n"
"  function throwNoNewError(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Cannot create new error\\nCall ${name} without the use of \"new\" to obtain an error object`);\n"
"  }\n"
"\n"
"  function throwNotInErrorSet(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Error given is not a part of error set ${name}`);\n"
"  }\n"
"\n"
"  function throwUnknownErrorNumber(structure, number) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Error number does not corresponds to any error in error set ${name}: #${number}`);\n"
"  }\n"
"\n"
"  function throwMultipleUnionInitializers(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Only one property of ${name} can be given a value`);\n"
"  }\n"
"\n"
"  function throwInactiveUnionProperty(structure, name, currentName) {\n"
"    throw new TypeError(`Accessing property ${name} when ${currentName} is active`);\n"
"  }\n"
"\n"
"  function throwMissingUnionInitializer(structure, arg, exclusion) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);\n"
"    throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);\n"
"  }\n"
"\n"
"  function throwInvalidInitializer(structure, expected, arg) {\n"
"    const name = getStructureName(structure);\n"
"    const acceptable = [];\n"
"    if (Array.isArray(expected)) {\n"
"      for (const type of expected) {\n"
"        acceptable.push(addArticle(type));\n"
"      }\n"
"    } else {\n"
"      acceptable.push(addArticle(expected));\n"
"    }\n"
"    const received = getDescription(arg);\n"
"    throw new TypeError(`${name} expects ${formatList(acceptable)} as argument, received ${received}`);\n"
"  }\n"
"\n"
"  function throwInvalidArrayInitializer(structure, arg, shapeless = false) {\n"
"    const { instance: { members: [ member ] }, type, typedArray } = structure;\n"
"    const acceptable = [];\n"
"    const primitive = getPrimitiveType(member);\n"
"    if (primitive) {\n"
"      acceptable.push(`array of ${primitive}s`);\n"
"    } else if (member.type === MemberType.EnumerationItem) {\n"
"      acceptable.push(`array of enum items`);\n"
"    } else {\n"
"      acceptable.push(`array of objects`);\n"
"    }\n"
"    if (typedArray) {\n"
"      acceptable.push(typedArray.name);\n"
"    }\n"
"    if (type === StructureType.Slice && shapeless) {\n"
"      acceptable.push(`length`);\n"
"    }\n"
"    throwInvalidInitializer(structure, acceptable.join(' or '), arg);\n"
"  }\n"
"\n"
"  function throwArrayLengthMismatch(structure, target, arg) {\n"
"    const { length, instance: { members: [ member ] } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const { structure: { constructor: elementConstructor} } = member;\n"
"    const { length: argLength, constructor: argConstructor } = arg;\n"
"    // get length from object whech it's a slice\n"
"    const actualLength = target?.length ?? length;\n"
"    const s = (actualLength > 1) ? 's' : '';\n"
"    let received;\n"
"    if (argConstructor === elementConstructor) {\n"
"      received = `only a single one`;\n"
"    } else if (argConstructor.child === elementConstructor) {\n"
"      received = `a slice/array that has ${argLength}`;\n"
"    } else {\n"
"      received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;\n"
"    }\n"
"    throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);\n"
"  }\n"
"\n"
"  function throwMissingInitializers(structure, arg) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const missing = [];\n"
"    for (const { name, isRequired } of members) {\n"
"      if (isRequired) {\n"
"        if (arg?.[name] === undefined) {\n"
"          missing.push(name);\n"
"        }\n"
"      }\n"
"    }\n"
"    throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);\n"
"  }\n"
"\n"
"  function throwNoProperty$1(structure, propName) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} does not have a property with that name: ${propName}`);\n"
"  }\n"
"\n"
"  function throwArgumentCountMismatch(structure, actual) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const argCount = members.length - 1;\n"
"    const s = (argCount > 1) ? 's' : '';\n"
"    throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);\n"
"  }\n"
"\n"
"  function rethrowArgumentError(structure, index, err) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    // Zig currently does not provide the argument name\n"
"    const argName = `args[${index}]`;\n"
"    const argCount = members.length - 1;\n"
"    const prefix = (index !== 0) ? '..., ' : '';\n"
"    const suffix = (index !== argCount - 1) ? ', ...' : '';\n"
"    const argLabel = prefix + argName + suffix;\n"
"    const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);\n"
"    newError.stack = err.stack;\n"
"    throw newError;\n"
"  }\n"
"\n"
"  function throwNoCastingToPointer(structure) {\n"
"    throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);\n"
"  }\n"
"\n"
"  function throwConstantConstraint(structure, pointer) {\n"
"    const name1 = getStructureName(structure);\n"
"    const { constructor: { name: name2 } } = pointer;\n"
"    throw new TypeError(`Conversion of ${name2} to ${name1} requires an explicit cast`);\n"
"  }\n"
"\n"
"  function throwMisplacedSentinel(structure, value, index, length) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);\n"
"  }\n"
"\n"
"  function throwMissingSentinel(structure, value, length) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);\n"
"  }\n"
"\n"
"  function throwAssigningToConstant(pointer) {\n"
"    const { constructor: { name } } = pointer;\n"
"    throw new TypeError(`${name} cannot be modified`);\n"
"  }\n"
"\n"
"  function throwTypeMismatch(expected, arg) {\n"
"    const received = getDescription(arg);\n"
"    throw new TypeError(`Expected ${addArticle(expected)}, received ${received}`)\n"
"  }\n"
"\n"
"  function throwInaccessiblePointer() {\n"
"    throw new TypeError(`Pointers within an untagged union are not accessible`);\n"
"  }\n"
"\n"
"  function throwInvalidPointerTarget(structure, arg) {\n"
"    const name = getStructureName(structure);\n"
"    let target;\n"
"    if (arg != null) {\n"
"      const type = typeof(arg);\n"
"      const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;\n"
"      const a = article(noun);\n"
"      target = `${a} ${noun}`;\n"
"    } else {\n"
"      target = arg + '';\n"
"    }\n"
"    throw new TypeError(`${name} cannot point to ${target}`)\n"
"  }\n"
"\n"
"  function throwFixedMemoryTargetRequired(structure, arg) {\n"
"    throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);\n"
"  }\n"
"\n"
"\n"
"  function throwOverflow(member, value) {\n"
"    const typeName = getTypeName(member);\n"
"    throw new TypeError(`${typeName} cannot represent the value given: ${value}`);\n"
"  }\n"
"\n"
"  function throwOutOfBound(member, index) {\n"
"    const { name } = member;\n"
"    throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);\n"
"  }\n"
"\n"
"  function rethrowRangeError(member, index, err) {\n"
"    if (err instanceof RangeError) {\n"
"      throwOutOfBound(member, index);\n"
"    } else {\n"
"      throw err;\n"
"    }\n"
"  }\n"
"\n"
"  function throwNotNull(member) {\n"
"    const { name } = member;\n"
"    throw new RangeError(`Property ${name} can only be null`);\n"
"  }\n"
"\n"
"  function throwZigError(name) {\n"
"    throw new Error(decamelizeErrorName(name));\n"
"  }\n"
"\n"
"  function decamelizeErrorName(name) {\n"
"    // use a try block in case Unicode regex fails\n"
"    try {\n"
"      const lc = name.replace(/(\\p{Uppercase}+)(\\p{Lowercase}*)/gu, (m0, m1, m2) => {\n"
"        if (m1.length === 1) {\n"
"          return ` ${m1.toLocaleLowerCase()}${m2}`;\n"
"        } else {\n"
"          if (m2) {\n"
"            const acronym = m1.substring(0, m1.length - 1);\n"
"            const letter = m1.charAt(m1.length - 1).toLocaleLowerCase();\n"
"            return ` ${acronym} ${letter}${m2}`;\n"
"          } else {\n"
"            return ` ${m1}`;\n"
"          }\n"
"        }\n"
"      }).trimStart();\n"
"      return lc.charAt(0).toLocaleUpperCase() + lc.substring(1);\n"
"      /* c8 ignore next 3 */\n"
"    } catch (err) {\n"
"      return name;\n"
"    }\n"
"  }\n"
"\n"
"  function getDescription(arg) {\n"
"    const type = typeof(arg);\n"
"    let s;\n"
"    if (type === 'object') {\n"
"      s = (arg) ? Object.prototype.toString.call(arg) : 'null';\n"
"    } else {\n"
"      s = type;\n"
"    }\n"
"    return addArticle(s);\n"
"  }\n"
"\n"
"  function addArticle(noun) {\n"
"    return `${article(noun)} ${noun}`;\n"
"  }\n"
"\n"
"  function article(noun) {\n"
"    return /^\\W*[aeiou]/i.test(noun) ? 'an' : 'a';\n"
"  }\n"
"\n"
"  function formatList(list, conj = 'or') {\n"
"    const sep = ` ${conj} `;\n"
"    if (list.length > 2) {\n"
"      return list.slice(0, -1).join(', ') + sep + list[list.length - 1];\n"
"    } else {\n"
"      return list.join(sep);\n"
"    }\n"
"  }\n"
"\n"
"  function getDataViewBoolAccessor(access, member) {\n"
"    return cacheMethod(access, member, () => {\n"
"      const { byteSize } = member;\n"
"      if (byteSize === undefined) {\n"
"        return undefined;\n"
"      }\n"
"      const typeName = getTypeName({ type: MemberType.Int, bitSize: byteSize * 8 });\n"
"      if (access === 'get') {\n"
"        const get = DataView.prototype[`get${typeName}`];\n"
"        return function(offset, littleEndian) {\n"
"          return !!get.call(this, offset, littleEndian);\n"
"        };\n"
"      } else {\n"
"        const set = DataView.prototype[`set${typeName}`];\n"
"        const T = (byteSize > 4) ? 1n : 1;\n"
"        const F = (byteSize > 4) ? 0n : 0;\n"
"        return function(offset, value, littleEndian) {\n"
"          set.call(this, offset, value ? T : F, littleEndian);\n"
"        };\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewBoolAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, () => {\n"
"      if (isByteAligned(member)) {\n"
"        return getDataViewBoolAccessor(access, member);\n"
"      }\n"
"      const { bitOffset } = member;\n"
"      const bitPos = bitOffset & 0x07;\n"
"      const mask = 1 << bitPos;\n"
"      const get = DataView.prototype.getInt8;\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = get.call(this, offset);\n"
"          return !!(n & mask);\n"
"        };\n"
"      } else {\n"
"        const set = DataView.prototype.setInt8;\n"
"        return function(offset, value) {\n"
"          const n = get.call(this, offset);\n"
"          const b = (value) ? n | mask : n & ~mask;\n"
"          set.call(this, offset, b);\n"
"        };\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewIntAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      if (DataView.prototype[name]) {\n"
"        return DataView.prototype[name];\n"
"      }\n"
"      if (isByteAligned(member)) {\n"
"        return defineAlignedIntAccessor(access, member)\n"
"      } else {\n"
"        return defineUnalignedIntAccessor(access, member);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewUintAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      if (DataView.prototype[name]) {\n"
"        return DataView.prototype[name];\n"
"      }\n"
"      if (isByteAligned(member)) {\n"
"        return defineAlignedUintAccessor(access, member)\n"
"      } else {\n"
"        return defineUnalignedUintAccessor(access, member);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewFloatAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      if (DataView.prototype[name]) {\n"
"        return DataView.prototype[name];\n"
"      }\n"
"      if (isByteAligned(member)) {\n"
"        return defineAlignedFloatAccessor(access, member)\n"
"      } else {\n"
"        return defineUnalignedFloatAccessor(access, member);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataView(structure, arg) {\n"
"    const { type, byteSize, typedArray } = structure;\n"
"    let dv;\n"
"    // not using instanceof just in case we're getting objects created in other contexts\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    if (tag === 'DataView') {\n"
"      dv = arg;\n"
"    } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {\n"
"      dv = new DataView(arg);\n"
"    } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {\n"
"      dv = new DataView(arg.buffer, arg.byteOffset, arg.byteLength);\n"
"    } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {\n"
"      dv = new DataView(arg.buffer, arg.byteOffset, arg.byteLength);\n"
"    } else {\n"
"      const memory = arg?.[MEMORY];\n"
"      if (memory && (type === StructureType.Array || type === StructureType.Slice || type === StructureType.Vector)) {\n"
"        const { instance: { members: [ member ] } } = structure;\n"
"        const { byteSize: elementSize, structure: { constructor: Child } } = member;\n"
"        const number = findElements(arg, Child);\n"
"        if (number !== undefined) {\n"
"          if (type === StructureType.Slice || number * elementSize === byteSize) {\n"
"            return memory;\n"
"          } else {\n"
"            throwArrayLengthMismatch(structure, null, arg);\n"
"          }\n"
"        }\n"
"      }\n"
"    }\n"
"    if (dv) {\n"
"      checkDataViewSize(structure, dv);\n"
"    }\n"
"    return dv;\n"
"  }\n"
"\n"
"  function checkDataViewSize(structure, dv) {\n"
"    const { type, byteSize } = structure;\n"
"    if (type === StructureType.Slice ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {\n"
"      throwBufferSizeMismatch(structure, dv);\n"
"    }\n"
"  }\n"
"\n"
"  function findElements(arg, Child) {\n"
"    // casting to a array/slice\n"
"    const { constructor: Arg } = arg;\n"
"    if (Arg === Child) {\n"
"      // matching object\n"
"      return 1;\n"
"    } else if (Arg.child === Child) {\n"
"      // matching slice/array\n"
"      return arg.length;\n"
"    }\n"
"  }\n"
"\n"
"  function requireDataView(structure, arg) {\n"
"    const dv = getDataView(structure, arg);\n"
"    if (!dv) {\n"
"      throwBufferExpected(structure);\n"
"    }\n"
"    return dv;\n"
"  }\n"
"\n"
"  function getTypedArrayClass(structure) {\n"
"    const { type, instance: { members } } = structure;\n"
"    if (type === StructureType.Primitive) {\n"
"      const { type: memberType, byteSize } = members[0];\n"
"      if (memberType === MemberType.Int) {\n"
"        switch (byteSize) {\n"
"          case 1: return Int8Array;\n"
"          case 2: return Int16Array;\n"
"          case 4: return Int32Array;\n"
"          case 8: return BigInt64Array;\n"
"        }\n"
"      } else if (memberType === MemberType.Uint) {\n"
"        switch (byteSize) {\n"
"          case 1: return Uint8Array;\n"
"          case 2: return Uint16Array;\n"
"          case 4: return Uint32Array;\n"
"          case 8: return BigUint64Array;\n"
"        }\n"
"      } else if (memberType === MemberType.Float) {\n"
"        switch (byteSize) {\n"
"          case 4: return Float32Array;\n"
"          case 8: return Float64Array;\n"
"        }\n"
"      }\n"
"    } else if (type === StructureType.Array || type === StructureType.Slice || type === StructureType.Vector) {\n"
"      const { structure: { typedArray } } = members[0];\n"
"      return typedArray;\n"
"    }\n"
"    return null;\n"
"  }\n"
"\n"
"  function addTypedArray(structure) {\n"
"    return structure.typedArray = getTypedArrayClass(structure);\n"
"  }\n"
"\n"
"  function isTypedArray(arg, TypedArray) {\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    return (!!TypedArray && tag === TypedArray.name);\n"
"  }\n"
"\n"
"  function isCompatible(arg, constructor) {\n"
"    const tags = constructor[COMPAT];\n"
"    if (tags) {\n"
"      const tag = arg?.[Symbol.toStringTag];\n"
"      if (tags.includes(tag)) {\n"
"        return true;\n"
"      }\n"
"    }\n"
"    if (constructor.child) {\n"
"      if (findElements(arg, constructor.child) !== undefined) {\n"
"        return true;\n"
"      }\n"
"    }\n"
"    return false;\n"
"  }\n"
"\n"
"  function getCompatibleTags(structure) {\n"
"    const { typedArray } = structure;\n"
"    const tags = [];\n"
"    if (typedArray) {\n"
"      tags.push(typedArray.name);\n"
"      tags.push('DataView');\n"
"      if (typedArray === Uint8Array) {\n"
"        tags.push('Uint8ClampedArray');\n"
"        tags.push('ArrayBuffer');\n"
"        tags.push('SharedArrayBuffer');\n"
"      }\n"
"    }\n"
"    return tags;\n"
"  }\n"
"\n"
"  function isBuffer(arg, typedArray) {\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {\n"
"      return true;\n"
"    } else if (typedArray && tag === typedArray.name) {\n"
"      return true;\n"
"    } else {\n"
"      return false;\n"
"    }\n"
"  }\n"
"\n"
"  function getTypeName(member) {\n"
"    const { type, bitSize, byteSize, structure } = member;\n"
"    if (structure?.name === 'usize') {\n"
"      return 'USize';\n"
"    } else if (structure?.name === 'isize') {\n"
"      return 'ISize';\n"
"    } else if (type === MemberType.Int) {\n"
"      return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;\n"
"    } else if (type === MemberType.Uint) {\n"
"      return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;\n"
"    } else if (type === MemberType.Float) {\n"
"      return `Float${bitSize}`;\n"
"    } else if (type === MemberType.Bool) {\n"
"      const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;\n"
"      return `Bool${boolSize}`;\n"
"    } else if (type === MemberType.Void) {\n"
"      return `Null`;\n"
"    }\n"
"  }\n"
"\n"
"  function getBigIntAccessors(bitSize) {\n"
"    const getWord = DataView.prototype.getBigUint64;\n"
"    const setWord = DataView.prototype.setBigUint64;\n"
"    const wordCount = Math.ceil(bitSize / 64);\n"
"    return {\n"
"      get: function(offset, littleEndian) {\n"
"        let n = 0n;\n"
"        if (littleEndian) {\n"
"          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\n"
"            const w = getWord.call(this, j, littleEndian);\n"
"            n = (n << 64n) | w;\n"
"          }\n"
"        } else {\n"
"          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\n"
"            const w = getWord.call(this, j, littleEndian);\n"
"            n = (n << 64n) | w;\n"
"          }\n"
"        }\n"
"        return n;\n"
"      },\n"
"      set: function(offset, value, littleEndian) {\n"
"        let n = value;\n"
"        const mask = 0xFFFFFFFFFFFFFFFFn;\n"
"        if (littleEndian) {\n"
"          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\n"
"            const w = n & mask;\n"
"            setWord.call(this, j, w, littleEndian);\n"
"            n >>= 64n;\n"
"          }\n"
"        } else {\n"
"          n <<= BigInt(wordCount * 64 - bitSize);\n"
"          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\n"
"            const w = n & mask;\n"
"            setWord.call(this, j, w, littleEndian);\n"
"            n >>= 64n;\n"
"          }\n"
"        }\n"
"        return n;\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function defineAlignedIntAccessor(access, member) {\n"
"    const { bitSize, byteSize } = member;\n"
"    if (bitSize < 64) {\n"
"      // actual number of bits needed when stored aligned\n"
"      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });\n"
"      const get = DataView.prototype[`get${typeName}`];\n"
"      const set = DataView.prototype[`set${typeName}`];\n"
"      const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);\n"
"      const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return (n & valueMask) - (n & signMask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      // larger than 64 bits\n"
"      const { get, set } = getBigIntAccessors(bitSize);\n"
"      const signMask = 2n ** BigInt(bitSize - 1);\n"
"      const valueMask = signMask - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return (n & valueMask) - (n & signMask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineAlignedUintAccessor(access, member) {\n"
"    const { bitSize, byteSize } = member;\n"
"    if (bitSize < 64) {\n"
"      // actual number of bits needed when stored aligned\n"
"      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });\n"
"      const get = DataView.prototype[`get${typeName}`];\n"
"      const set = DataView.prototype[`set${typeName}`];\n"
"      const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return n & valueMask;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      // larger than 64 bits\n"
"      const { get, set } = getBigIntAccessors(bitSize);\n"
"      const valueMask = (2n ** BigInt(bitSize)) - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return n & valueMask;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineUnalignedIntAccessor(access, member) {\n"
"    const { bitSize, bitOffset } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const set = DataView.prototype.setUint8;\n"
"      const get = DataView.prototype.getUint8;\n"
"      // sub-8-bit numbers have real use cases\n"
"      const signMask = 2 ** (bitSize - 1);\n"
"      const valueMask = signMask - 1;\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = get.call(this, offset);\n"
"          const s = n >>> bitPos;\n"
"          return (s & valueMask) - (s & signMask);\n"
"        };\n"
"      } else {\n"
"        const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);\n"
"        return function(offset, value) {\n"
"          let b = get.call(this, offset);\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          b = (b & outsideMask) | (n << bitPos);\n"
"          set.call(this, offset, b);\n"
"        };\n"
"      }\n"
"    }\n"
"    return defineUnalignedAccessorUsing(access, member, getDataViewIntAccessorEx);\n"
"  }\n"
"\n"
"  function defineUnalignedUintAccessor(access, member) {\n"
"    const { bitSize, bitOffset } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const set = DataView.prototype.setUint8;\n"
"      const get = DataView.prototype.getUint8;\n"
"      const valueMask = (2 ** bitSize - 1);\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = get.call(this, offset);\n"
"          const s = n >>> bitPos;\n"
"          return s & valueMask;\n"
"        };\n"
"      } else {\n"
"        const outsideMask = 0xFF ^ (valueMask << bitPos);\n"
"        return function(offset, value) {\n"
"          const n = get.call(this, offset);\n"
"          const b = (n & outsideMask) | ((value & valueMask) << bitPos);\n"
"          set.call(this, offset, b);\n"
"        };\n"
"      }\n"
"    }\n"
"    return defineUnalignedAccessorUsing(access, member, getDataViewUintAccessorEx);\n"
"  }\n"
"\n"
"  function defineAlignedFloatAccessor(access, member) {\n"
"    const { bitSize } = member;\n"
"    if (bitSize === 16) {\n"
"      const buf = new DataView(new ArrayBuffer(4));\n"
"      const set = DataView.prototype.setUint16;\n"
"      const get = DataView.prototype.getUint16;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >>> 15;\n"
"          const exp = (n & 0x7C00) >> 10;\n"
"          const frac = n & 0x03FF;\n"
"          if (exp === 0) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x1F) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);\n"
"          buf.setUint32(0, n32, littleEndian);\n"
"          return buf.getFloat32(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat32(0, value, littleEndian);\n"
"          const n = buf.getUint32(0, littleEndian);\n"
"          const sign = n >>> 31;\n"
"          const exp = (n & 0x7F800000) >> 23;\n"
"          const frac = n & 0x007FFFFF;\n"
"          const exp16 = (exp - 127 + 15);\n"
"          let n16;\n"
"          if (exp === 0) {\n"
"            n16 = sign << 15;\n"
"          } else if (exp === 0xFF) {\n"
"            n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);\n"
"          } else if (exp16 >= 31) {\n"
"            n16 = sign << 15 | 0x1F << 10;\n"
"          } else {\n"
"            n16 = sign << 15 | exp16 << 10 | (frac >> 13);\n"
"          }\n"
"          set.call(this, offset, n16, littleEndian);\n"
"        }\n"
"      }\n"
"    } else if (bitSize === 80) {\n"
"      const buf = new DataView(new ArrayBuffer(8));\n"
"      const setWord = DataView.prototype.setBigUint64;\n"
"      const getWord = DataView.prototype.getBigUint64;\n"
"      const get = function(offset, littleEndian) {\n"
"        const w1 = getWord.call(this, offset, littleEndian);\n"
"        const w2 = getWord.call(this, offset + 8, littleEndian);\n"
"        return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;\n"
"      };\n"
"      const set = function(offset, value, littleEndian) {\n"
"        const w1 = value & 0xFFFFFFFFFFFFFFFFn;\n"
"        const w2 = value >> 64n;\n"
"        setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);\n"
"        setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);\n"
"      };\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >> 79n;\n"
"          const exp = (n & 0x7FFF0000000000000000n) >> 64n;\n"
"          const frac = n & 0x00007FFFFFFFFFFFFFFFn;\n"
"          if (exp === 0n) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x7FFFn) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const exp64 = exp - 16383n + 1023n;\n"
"          if (exp64 >= 2047n) {\n"
"            return (sign) ? -Infinity : Infinity;\n"
"          }\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n);\n"
"          buf.setBigUint64(0, n64, littleEndian);\n"
"          return buf.getFloat64(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat64(0, value, littleEndian);\n"
"          const n = buf.getBigUint64(0, littleEndian);\n"
"          const sign = n >> 63n;\n"
"          const exp = (n & 0x7FF0000000000000n) >> 52n;\n"
"          const frac = n & 0x000FFFFFFFFFFFFFn;\n"
"          let n80;\n"
"          if (exp === 0n) {\n"
"            n80 = sign << 79n | (frac << 11n);\n"
"          } else if (exp === 0x07FFn) {\n"
"            n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;\n"
"            //                                                 ^ bit 61                       ^ bit 63\n"
"          } else {\n"
"            n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;\n"
"          }\n"
"          set.call(this, offset, n80, littleEndian);\n"
"        }\n"
"      }\n"
"    } else if (bitSize === 128) {\n"
"      const buf = new DataView(new ArrayBuffer(8));\n"
"      const getWord = DataView.prototype.getBigUint64;\n"
"      const setWord = DataView.prototype.setBigUint64;\n"
"      const get = function(offset, littleEndian) {\n"
"        const w1 = getWord.call(this, offset, littleEndian);\n"
"        const w2 = getWord.call(this, offset + 8, littleEndian);\n"
"        return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;\n"
"      };\n"
"      const set = function(offset, value, littleEndian) {\n"
"        const w1 = value & 0xFFFFFFFFFFFFFFFFn;\n"
"        const w2 = value >> 64n;\n"
"        setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);\n"
"        setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);\n"
"      };\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >> 127n;\n"
"          const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;\n"
"          const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;\n"
"          if (exp === 0n) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x7FFFn) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const exp64 = exp - 16383n + 1023n;\n"
"          if (exp64 >= 2047n) {\n"
"            return (sign) ? -Infinity : Infinity;\n"
"          }\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n);\n"
"          buf.setBigUint64(0, n64, littleEndian);\n"
"          return buf.getFloat64(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat64(0, value, littleEndian);\n"
"          const n = buf.getBigUint64(0, littleEndian);\n"
"          const sign = n >> 63n;\n"
"          const exp = (n & 0x7FF0000000000000n) >> 52n;\n"
"          const frac = n & 0x000FFFFFFFFFFFFFn;\n"
"          let n128;\n"
"          if (exp === 0n) {\n"
"            n128 = sign << 127n | (frac << 60n);\n"
"          } else if (exp === 0x07FFn) {\n"
"            n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);\n"
"          } else {\n"
"            n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);\n"
"          }\n"
"          set.call(this, offset, n128, littleEndian);\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineUnalignedFloatAccessor(access, member) {\n"
"    return defineUnalignedAccessorUsing(access, member, getDataViewFloatAccessorEx);\n"
"  }\n"
"\n"
"  function defineUnalignedAccessorUsing(access, member, getDataViewAccessor) {\n"
"    // pathological usage scenario--handle it anyway by copying the bitSize into a\n"
"    // temporary buffer, bit-aligning the data\n"
"    const { bitSize, bitOffset } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;\n"
"    const buf = new DataView(new ArrayBuffer(byteSize));\n"
"    if (access === 'get') {\n"
"      const getAligned = getDataViewAccessor('get', { ...member, byteSize });\n"
"      const copyBits = getBitAlignFunction(bitPos, bitSize, true);\n"
"      return function(offset, littleEndian) {\n"
"        copyBits(buf, this, offset);\n"
"        return getAligned.call(buf, 0, littleEndian);\n"
"      };\n"
"    } else {\n"
"      const setAligned = getDataViewAccessor('set', { ...member, byteSize });\n"
"      const applyBits = getBitAlignFunction(bitPos, bitSize, false);\n"
"      return function(offset, value, littleEndian) {\n"
"        setAligned.call(buf, 0, value, littleEndian);\n"
"        applyBits(this, buf, offset);\n"
"      };\n"
"    }\n"
"  }\n"
"\n"
"  function cacheMethod(access, member, cb) {\n"
"    const { type, bitOffset, bitSize } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    const typeName = getTypeName(member);\n"
"    const suffix = isByteAligned(member) ? `` : `Bit${bitPos}`;\n"
"    const name = `${access}${typeName}${suffix}`;\n"
"    let fn = methodCache[name];\n"
"    if (!fn) {\n"
"      // usize and isize can return/accept number or bigint\n"
"      if ((type === MemberType.Int && typeName === 'ISize')\n"
"       || (type === MemberType.Uint && typeName === 'USize')) {\n"
"        if (bitSize === 64) {\n"
"          const realTypeName = (type === MemberType.Int) ? 'BigInt64' : 'BigUint64';\n"
"          const realName = `${access}${realTypeName}`;\n"
"          if (access === 'get') {\n"
"            const get = cb(realName);\n"
"            const min = BigInt(Number.MIN_SAFE_INTEGER);\n"
"            const max = BigInt(Number.MAX_SAFE_INTEGER);\n"
"            fn = function(offset, littleEndian) {\n"
"              const value = get.call(this, offset, littleEndian);\n"
"              if (min <= value && value <= max) {\n"
"                return Number(value);\n"
"              } else {\n"
"                return value;\n"
"              }\n"
"            };\n"
"          } else {\n"
"            const set = cb(realName);\n"
"            fn = function(offset, value, littleEndian) {\n"
"              // automatically convert number to bigint\n"
"              if (typeof(value) === 'number') {\n"
"                value = BigInt(value);\n"
"              }\n"
"              set.call(this, offset, value, littleEndian);\n"
"            };\n"
"          }\n"
"        } else if (bitSize === 32) {\n"
"          const realTypeName = (type === MemberType.Int) ? 'Int32' : 'Uint32';\n"
"          const realName = `${access}${realTypeName}`;\n"
"          if (access === 'get') {\n"
"            fn = cb(realName);\n"
"          } else {\n"
"            const set = cb(realName);\n"
"            fn = function(offset, value, littleEndian) {\n"
"              if (typeof(value) === 'bigint') {\n"
"                value = Number(value);\n"
"              }\n"
"              set.call(this, offset, value, littleEndian);\n"
"            };\n"
"          }\n"
"        }\n"
"      } else {\n"
"        fn = cb(name);\n"
"      }\n"
"      if (fn && fn.name !== name) {\n"
"        Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });\n"
"      }\n"
"      methodCache[name] = fn;\n"
"    }\n"
"    return fn;\n"
"  }\n"
"\n"
"  const methodCache = {};\n"
"\n"
"  function addSpecialAccessors(s) {\n"
"    const {\n"
"      constructor,\n"
"      instance: {\n"
"        members,\n"
"      },\n"
"    } = s;\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      dataView: { ...getDataViewAccessors(s), configurable: true },\n"
"      base64: { ...getBase64Accessors(), configurable: true },\n"
"      toJSON: { value: getValueOf, configurable: true, writable: true },\n"
"      valueOf: { value: getValueOf, configurable: true, writable: true },\n"
"    });\n"
"    if (canBeString(s)) {\n"
"      Object.defineProperty(constructor.prototype, 'string', {\n"
"        ...getStringAccessors(s), configurable: true\n"
"      });\n"
"    }\n"
"    if (canBeTypedArray(s)) {\n"
"      Object.defineProperty(constructor.prototype, 'typedArray', {\n"
"        ...getTypedArrayAccessors(s), configurable: true\n"
"      });\n"
"    }\n"
"  }\n"
"\n"
"  function canBeString(s) {\n"
"    if (s.type === StructureType.Array || s.type === StructureType.Slice) {\n"
"      const { type, bitSize } = s.instance.members[0];\n"
"      if (type === MemberType.Uint && (bitSize === 8 || bitSize === 16)) {\n"
"        return true;\n"
"      }\n"
"    }\n"
"    return false;\n"
"  }\n"
"\n"
"  function canBeTypedArray(s) {\n"
"    return !!s.typedArray;\n"
"  }\n"
"\n"
"  function getSpecialKeys(s) {\n"
"    const keys = [ 'dataView', 'base64' ];\n"
"    if (canBeString(s)) {\n"
"      keys.push('string');\n"
"    }\n"
"    if (canBeTypedArray(s)) {\n"
"      keys.push('typedArray');\n"
"    }\n"
"    return keys;\n"
"  }\n"
"\n"
"  function getDataViewAccessors(structure) {\n"
"    const { type, byteSize, sentinel } = structure;\n"
"    const copy = getMemoryCopier(byteSize, type === StructureType.Slice);\n"
"    return {\n"
"      get() {\n"
"        restoreMemory.call(this);\n"
"        return this[MEMORY];\n"
"      },\n"
"      set(dv) {\n"
"        checkDataView(dv);\n"
"        restoreMemory.call(this);\n"
"        const dest = this[MEMORY];\n"
"        if (dest.byteLength !== dv.byteLength) {\n"
"          throwBufferSizeMismatch(structure, dv, this);\n"
"        }\n"
"        sentinel?.validateData(dv, this.length);\n"
"        copy(dest, dv);\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function checkDataView(dv) {\n"
"    if (dv?.[Symbol.toStringTag] !== 'DataView') {\n"
"      throwTypeMismatch('a DataView', dv);\n"
"    }\n"
"    return dv;\n"
"  }\n"
"\n"
"  function getBase64Accessors() {\n"
"    return {\n"
"      get() {\n"
"        const dv = this.dataView;\n"
"        const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);\n"
"        const bstr = String.fromCharCode.apply(null, ta);\n"
"        return btoa(bstr);\n"
"      },\n"
"      set(str) {\n"
"        this.dataView = getDataViewFromBase64(str);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function getDataViewFromBase64(str) {\n"
"    if (typeof(str) !== 'string') {\n"
"      throwTypeMismatch('a string', str);\n"
"    }\n"
"    const bstr = atob(str);\n"
"    const ta = new Uint8Array(bstr.length);\n"
"    for (let i = 0; i < ta.byteLength; i++) {\n"
"      ta[i] = bstr.charCodeAt(i);\n"
"    }\n"
"    return new DataView(ta.buffer);\n"
"  }\n"
"\n"
"  const decoders = {};\n"
"\n"
"  function getStringAccessors(structure) {\n"
"    const { sentinel, instance: { members: [ member ] } } = structure;\n"
"    const { byteSize } = member;\n"
"    return {\n"
"      get() {\n"
"        let decoder = decoders[byteSize];\n"
"        if (!decoder) {\n"
"          decoder = decoders[byteSize] = new TextDecoder(`utf-${byteSize * 8}`);\n"
"        }\n"
"        const dv = this.dataView;\n"
"        const TypedArray = (byteSize === 1) ? Int8Array : Int16Array;\n"
"        const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);\n"
"        const s = decoder.decode(ta);\n"
"        return (sentinel?.value === undefined) ? s : s.slice(0, -1);\n"
"      },\n"
"      set(src) {\n"
"        this.dataView = getDataViewFromUTF8(src, byteSize, sentinel?.value);\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  let encoder;\n"
"\n"
"  function getDataViewFromUTF8(str, byteSize, sentinelValue) {\n"
"    if (typeof(str) !== 'string') {\n"
"      throwTypeMismatch('a string', str);\n"
"    }\n"
"    if (sentinelValue !== undefined) {\n"
"      if (str.charCodeAt(str.length - 1) !== sentinelValue) {\n"
"        str = str + String.fromCharCode(sentinelValue);\n"
"      }\n"
"    }\n"
"    let ta;\n"
"    if (byteSize === 1) {\n"
"      if (!encoder) {\n"
"        encoder = new TextEncoder(`utf-${byteSize * 8}`);\n"
"      }\n"
"      ta = encoder.encode(str);\n"
"    } else if (byteSize === 2) {\n"
"      const { length } = str;\n"
"      ta = new Uint16Array(length);\n"
"      for (let i = 0; i < length; i++) {\n"
"        ta[i] = str.charCodeAt(i);\n"
"      }\n"
"    }\n"
"    return new DataView(ta.buffer);\n"
"  }\n"
"\n"
"  function getTypedArrayAccessors(structure) {\n"
"    const { typedArray } = structure;\n"
"    return {\n"
"      get() {\n"
"        const dv = this.dataView;\n"
"        const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;\n"
"        return new typedArray(dv.buffer, dv.byteOffset, length);\n"
"      },\n"
"      set(ta) {\n"
"        this.dataView = getDataViewFromTypedArray(ta, typedArray);\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getDataViewFromTypedArray(ta, TypedArray) {\n"
"    if (!isTypedArray(ta, TypedArray)) {\n"
"      throwTypeMismatch(TypedArray.name, ta);\n"
"    }\n"
"    return new DataView(ta.buffer, ta.byteOffset, ta.byteLength);}\n"
"\n"
"  function getValueOf() {\n"
"    const map = new WeakMap();\n"
"    function extract(object) {\n"
"      if (object[Symbol.iterator]) {\n"
"        const array = [];\n"
"        for (const element of object) {\n"
"          array.push(extract(element));\n"
"        }\n"
"        return array;\n"
"      } else if (object && (typeof(object) === 'object' || typeof(object) === 'function')) {\n"
"        let result = map.get(object);\n"
"        if (!result) {\n"
"          result = {};\n"
"          map.set(object, result);\n"
"          for (const [ name, child ] of Object.entries(object)) {\n"
"            const childResult = extract(child);\n"
"            if (childResult !== undefined) {\n"
"              result[name] = childResult;\n"
"            }\n"
"          }\n"
"          return result;\n"
"        }\n"
"        return result;\n"
"      } else {\n"
"        return object;\n"
"      }\n"
"    }  return extract(this.$);\n"
"  }\n"
"\n"
"  function finalizePrimitive(s, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"      options,\n"
"    } = s;\n"
"    addTypedArray(s);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = requireDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      } else {\n"
"        return self;\n"
"      }\n"
"    };\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const specialKeys = getSpecialKeys(s);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"      } else {\n"
"        if (arg && typeof(arg) === 'object') {\n"
"          for (const key of Object.keys(arg)) {\n"
"            if (!(key in this)) {\n"
"              throwNoProperty$1(s, key);\n"
"            }\n"
"          }\n"
"          let specialFound = 0;\n"
"          for (const key of specialKeys) {\n"
"            if (key in arg) {\n"
"              specialFound++;\n"
"            }\n"
"          }\n"
"          if (specialFound === 0) {\n"
"            const type = getPrimitiveType(member);\n"
"            throwInvalidInitializer(s, type, arg);\n"
"          }\n"
"          for (const key of specialKeys) {\n"
"            if (key in arg) {\n"
"              this[key] = arg[key];\n"
"            }\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          this.$ = arg;\n"
"        }\n"
"      }\n"
"    };\n"
"    const { get, set } = getAccessors(member, options);\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      $: { get, set, configurable: true },\n"
"      [Symbol.toPrimitive]: { value: get, configurable: true, writable: true },\n"
"    });\n"
"    Object.defineProperty(constructor, COMPAT, { value: getCompatibleTags(s) });\n"
"    addSpecialAccessors(s);\n"
"    return constructor;\n"
"  }\n"
"  function getIntRange(member) {\n"
"    const { type, bitSize } = member;\n"
"    const signed = (type === MemberType.Int);\n"
"    let magBits = (signed) ? bitSize - 1 : bitSize;\n"
"    if (bitSize <= 32) {\n"
"      const max = 2 ** magBits - 1;\n"
"      const min = (signed) ? -(2 ** magBits) : 0;\n"
"      return { min, max };\n"
"    } else {\n"
"      magBits = BigInt(magBits);\n"
"      const max = 2n ** magBits - 1n;\n"
"      const min = (signed) ? -(2n ** magBits) : 0n;\n"
"      return { min, max };\n"
"    }\n"
"  }\n"
"\n"
"  function getPrimitiveClass({ type, bitSize }) {\n"
"    if (type === MemberType.Int || type === MemberType.Uint) {\n"
"      if (bitSize <= 32) {\n"
"        return Number;\n"
"      } else {\n"
"        return BigInt;\n"
"      }\n"
"    } else if (type === MemberType.Float) {\n"
"      return Number;\n"
"    } else if (type === MemberType.Bool) {\n"
"      return Boolean;\n"
"    }\n"
"  }\n"
"\n"
"  function getPrimitiveType(member) {\n"
"    const Primitive = getPrimitiveClass(member);\n"
"    if (Primitive) {\n"
"      return typeof(Primitive(0));\n"
"    }\n"
"  }\n"
"\n"
"  function finalizePointer(s, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"      isConst,\n"
"      options,\n"
"    } = s;\n"
"    const {\n"
"      runtimeSafety = true,\n"
"    } = options;\n"
"    const { structure: targetStructure } = member;\n"
"    const isTargetSlice = (targetStructure.type === StructureType.Slice);\n"
"    const isTargetPointer = (targetStructure.type === StructureType.Pointer);\n"
"    const hasLength = isTargetSlice && !targetStructure.sentinel;\n"
"    const addressSize = (hasLength) ? byteSize / 2 : byteSize;\n"
"    const { get: getAddress, set: setAddress } = getAccessors({\n"
"      type: MemberType.Uint,\n"
"      bitOffset: 0,\n"
"      bitSize: addressSize * 8,\n"
"      byteSize: addressSize,\n"
"      structure: { byteSize: addressSize },\n"
"    }, options);\n"
"    const { get: getLength, set: setLength } = (hasLength) ? getAccessors({\n"
"      type: MemberType.Uint,\n"
"      bitOffset: addressSize * 8,\n"
"      bitSize: addressSize * 8,\n"
"      byteSize: addressSize,\n"
"      structure: { name: 'usize', byteSize: addressSize },\n"
"    }, options) : {};\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const calledFromEnviroment = this === ENVIRONMENT;\n"
"      const calledFromParent = this === PARENT;\n"
"      let creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        if (calledFromEnviroment || calledFromParent) {\n"
"          dv = requireDataView(s, arg);\n"
"        } else {\n"
"          const Target = targetStructure.constructor;\n"
"          if (isPointerOf(arg, Target)) {\n"
"            creating = true;\n"
"            arg = arg['*'];\n"
"          } else if (isTargetSlice) {\n"
"            // allow casting to slice through constructor of its pointer\n"
"            creating = true;\n"
"            arg = Target(arg);\n"
"          } else {\n"
"            throwNoCastingToPointer();\n"
"          }\n"
"          dv = env.allocMemory(byteSize, ptrAlign);\n"
"        }\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      self[SLOTS] = { 0: null };\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      }\n"
"      return createProxy$1.call(self, isConst, isTargetPointer);\n"
"    };\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        if (env.isShared(this[MEMORY])) {\n"
"          // initialize with the other pointer's target\n"
"          initializer.call(this, arg[SLOTS][0]);\n"
"        } else {\n"
"          // copy the object stored in slots 0, not copying memory of the other object\n"
"          // since the value stored there likely isn't valid\n"
"          copyPointer.call(this, arg);\n"
"        }\n"
"      } else {\n"
"        const Target = targetStructure.constructor;\n"
"        if (isPointerOf(arg, Target)) {\n"
"          if (!isConst && arg.constructor.const) {\n"
"            throwConstantConstraint(s, arg);\n"
"          }\n"
"          copyPointer.call(this, arg);\n"
"        } else {\n"
"          if (!(arg instanceof Target)) {\n"
"            if (isCompatible(arg, Target)) {\n"
"              // autocast to target type\n"
"              const dv = getDataView(targetStructure, arg);\n"
"              arg = Target(dv);\n"
"            } else if (isTargetSlice) {\n"
"              // autovivificate target object\n"
"              const autoObj = new Target(arg);\n"
"              if (runtimeSafety) {\n"
"                // creation of a new slice using a typed array is probably\n"
"                // not what the user wants; it's more likely that the intention\n"
"                // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)\n"
"                if (targetStructure.typedArray && isBuffer(arg?.buffer)) {\n"
"                  const created = addArticle(targetStructure.typedArray.name);\n"
"                  const source = addArticle(arg.constructor.name);\n"
"                  console.warn(`Implicitly creating ${created} from ${source}`);\n"
"                }\n"
"              }\n"
"              arg = autoObj;\n"
"            } else {\n"
"              throwInvalidPointerTarget(s, arg);\n"
"            }\n"
"          }\n"
"          if (env.isShared(this[MEMORY])) {\n"
"            // the pointer sits in shared memory--apply the change immediately\n"
"            if (env.isShared(arg[MEMORY])) {\n"
"              const address = env.getViewAddress(arg[MEMORY]);\n"
"              setAddress.call(this, address);\n"
"              if (setLength) {\n"
"                setLength.call(this, arg.length);\n"
"              }\n"
"            } else {\n"
"              throwFixedMemoryTargetRequired();\n"
"            }\n"
"          }\n"
"          this[SLOTS][0] = arg;\n"
"        }\n"
"      }\n"
"    };\n"
"    const targetAcquirer = function() {\n"
"      // obtain address (and possibly length) from memory\n"
"      const address = getAddress.call(this);\n"
"      let len = 1;\n"
"      if (isTargetSlice) {\n"
"        if (hasLength) {\n"
"          len = getLength.call(this);\n"
"        } else {\n"
"          len = env.findSentinel(address, targetStructure.sentinel.bytes) + 1;\n"
"        }\n"
"      }\n"
"      // get view of memory that pointer points to\n"
"      const dv = env.obtainView(address, len * targetStructure.byteSize);\n"
"      // create the target\n"
"      const Target = targetStructure.constructor;\n"
"      const target = Target.call(this, dv);\n"
"      this[SLOTS][0] = target;\n"
"    };\n"
"    const addressUpdater = function() {\n"
"      const target = this[SLOTS][0];\n"
"      if (target) {\n"
"        const address = env.getAddress(target[MEMORY].buffer);\n"
"        setAddress.call(this, address);\n"
"        if (hasLength) {\n"
"          setLength.call(this, target.length);\n"
"        }\n"
"      }\n"
"    };\n"
"    // return the proxy object if one is used\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      '*': { get: getTarget, set: (isConst) ? undefined : setTarget, configurable: true },\n"
"      '$': { get: getProxy, set: initializer, configurable: true, },\n"
"      'valueOf': { value: getTargetValue, configurable: true, writable: true },\n"
"      [TARGET_ACQUIRER]: { value: targetAcquirer },\n"
"      [ADDRESS_UPDATER]: { value: addressUpdater },\n"
"      [POINTER_VISITOR]: { value: visitPointer },\n"
"    });\n"
"    Object.defineProperties(constructor, {\n"
"      child: { get: () => targetStructure.constructor },\n"
"      const: { value: isConst },\n"
"    });\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function getProxy() {\n"
"    return this[PROXY];\n"
"  }\n"
"\n"
"  function copyPointer(src) {\n"
"    this[SLOTS][0] = src[SLOTS][0];\n"
"  }\n"
"\n"
"  function resetPointer() {\n"
"    this[SLOTS][0] = null;\n"
"  }\n"
"\n"
"  function acquireTarget() {\n"
"    this[TARGET_ACQUIRER]();\n"
"  }\n"
"\n"
"  function updateAddress() {\n"
"    this[ADDRESS_UPDATER]();\n"
"  }\n"
"\n"
"  function disablePointer() {\n"
"    Object.defineProperty(this[SLOTS], 0, {\n"
"      get: throwInaccessiblePointer,\n"
"      set: throwInaccessiblePointer,\n"
"      configurable: true\n"
"    });\n"
"  }\n"
"\n"
"  function getTarget() {\n"
"    const object = this[SLOTS][0];\n"
"    return object.$;\n"
"  }\n"
"\n"
"  function setTarget(value) {\n"
"    const object = this[SLOTS][0];\n"
"    object.$ = value;\n"
"  }\n"
"\n"
"  function getTargetValue() {\n"
"    const object = this[SLOTS][0];\n"
"    return object.$.valueOf();\n"
"  }\n"
"\n"
"  function visitPointer(fn, options) {\n"
"    const { source } = options;\n"
"    fn.call(this, source);\n"
"  }\n"
"\n"
"  function isPointerOf(arg, Target) {\n"
"    return (arg?.constructor?.child === Target && arg['*']);\n"
"  }\n"
"\n"
"  function createProxy$1(isConst, isTargetPointer) {\n"
"    const handlers = (!isTargetPointer) ? (isConst) ? constProxyHandlers : proxyHandlers$1 : {};\n"
"    const proxy = new Proxy(this, handlers);\n"
"    // hide the proxy so console wouldn't display a recursive structure\n"
"    Object.defineProperty(this, PROXY, { value: proxy });\n"
"    return proxy;\n"
"  }\n"
"\n"
"  const isPointerKeys = {\n"
"    '$': true,\n"
"    '*': true,\n"
"    constructor: true,\n"
"    valueOf: true,\n"
"    [SLOTS]: true,\n"
"    [MEMORY]: true,\n"
"    [PROXY]: true,\n"
"    [TARGET_ACQUIRER]: true,\n"
"    [ADDRESS_UPDATER]: true,\n"
"    [POINTER_VISITOR]: true,\n"
"    [Symbol.toStringTag]: true,\n"
"    [Symbol.toPrimitive]: true,\n"
"  };\n"
"\n"
"  const proxyHandlers$1 = {\n"
"    get(pointer, name) {\n"
"      if (isPointerKeys[name]) {\n"
"        return pointer[name];\n"
"      } else {\n"
"        return pointer[SLOTS][0][name];\n"
"      }\n"
"    },\n"
"    set(pointer, name, value) {\n"
"      if (isPointerKeys[name]) {\n"
"        pointer[name] = value;\n"
"      } else {\n"
"        pointer[SLOTS][0][name] = value;\n"
"      }\n"
"      return true;\n"
"    },\n"
"    deleteProperty(pointer, name) {\n"
"      if (isPointerKeys[name]) {\n"
"        delete pointer[name];\n"
"      } else {\n"
"        delete pointer[SLOTS][0][name];\n"
"      }\n"
"      return true;\n"
"    },\n"
"    has(pointer, name) {\n"
"      return isPointerKeys[name] || name in pointer[SLOTS][0];\n"
"    },\n"
"    ownKeys(pointer) {\n"
"      const targetKeys = Object.getOwnPropertyNames(pointer[SLOTS][0]);\n"
"      return [ ...targetKeys, PROXY, POINTER_VISITOR ];\n"
"    },\n"
"    getOwnPropertyDescriptor(pointer, name) {\n"
"      if (isPointerKeys[name]) {\n"
"        return Object.getOwnPropertyDescriptor(pointer, name);\n"
"      } else {\n"
"        return Object.getOwnPropertyDescriptor(pointer[SLOTS][0], name);\n"
"      }\n"
"    },\n"
"  };\n"
"\n"
"  const constProxyHandlers = {\n"
"    ...proxyHandlers$1,\n"
"    set(pointer, name, value) {\n"
"      if (isPointerKeys[name]) {\n"
"        pointer[name] = value;\n"
"      } else {\n"
"        throwAssigningToConstant(pointer);\n"
"      }\n"
"      return true;\n"
"    },\n"
"    getOwnPropertyDescriptor(pointer, name) {\n"
"      if (isPointerKeys[name]) {\n"
"        return Object.getOwnPropertyDescriptor(pointer, name);\n"
"      } else {\n"
"        const descriptor = Object.getOwnPropertyDescriptor(pointer[SLOTS][0], name);\n"
"        if (descriptor?.set) {\n"
"          descriptor.set = undefined;\n"
"        }\n"
"        return descriptor;\n"
"      }\n"
"      /* c8 ignore next -- unreachable */\n"
"    },\n"
"  };\n"
"\n"
"  function finalizeArray(s, env) {\n"
"    const {\n"
"      length,\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"      hasPointer,\n"
"      options,\n"
"    } = s;\n"
"    addTypedArray(s);\n"
"    const hasObject = (member.type === MemberType.Object);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = requireDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      self[GETTER] = null;\n"
"      self[SETTER] = null;\n"
"      if (hasObject) {\n"
"        self[SLOTS] = {};\n"
"      }\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      }\n"
"      return createProxy.call(self);\n"
"    };\n"
"    const { structure: elementStructure } = member;\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const specialKeys = getSpecialKeys(s);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"        if (hasPointer) {\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true });\n"
"        }\n"
"      } else {\n"
"        if (typeof(arg) === 'string' && specialKeys.includes('string')) {\n"
"          arg = { string: arg };\n"
"        }\n"
"        if (arg?.[Symbol.iterator]) {\n"
"          let argLen = arg.length;\n"
"          if (typeof(argLen) !== 'number') {\n"
"            arg = [ ...arg ];\n"
"            argLen = arg.length;\n"
"          }\n"
"          if (argLen !== length) {\n"
"            throwArrayLengthMismatch(s, this, arg);\n"
"          }\n"
"          let i = 0;\n"
"          for (const value of arg) {\n"
"            set.call(this, i++, value);\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          for (const key of Object.keys(arg)) {\n"
"            if (!(key in this)) {\n"
"              throwNoProperty(s, key);\n"
"            }\n"
"          }\n"
"          let specialFound = 0;\n"
"          for (const key of specialKeys) {\n"
"            if (key in arg) {\n"
"              specialFound++;\n"
"            }\n"
"          }\n"
"          if (specialFound === 0) {\n"
"            throwInvalidArrayInitializer(s, arg);\n"
"          }\n"
"          for (const key of specialKeys) {\n"
"            if (key in arg) {\n"
"              this[key] = arg[key];\n"
"            }\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throwInvalidArrayInitializer(s, arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    const { get, set } = getAccessors(member, options);\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      get: { value: get, configurable: true, writable: true },\n"
"      set: { value: set, configurable: true, writable: true },\n"
"      length: { value: length, configurable: true },\n"
"      $: { get: getProxy, set: initializer, configurable: true },\n"
"      [Symbol.iterator]: { value: getArrayIterator, configurable: true, writable: true },\n"
"      entries: { value: createArrayEntries, configurable: true, writable: true }\n"
"    });\n"
"    Object.defineProperties(constructor, {\n"
"      child: { get: () => elementStructure.constructor },\n"
"      [COMPAT]: { value: getCompatibleTags(s) },\n"
"    });\n"
"    if (hasObject) {\n"
"      addChildVivificator(s);\n"
"      if (hasPointer) {\n"
"        addPointerVisitor$1(s);\n"
"      }\n"
"    }\n"
"    addSpecialAccessors(s);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function addChildVivificator(s) {\n"
"    const { constructor: { prototype }, instance: { members: [ member ]} } = s;\n"
"    const { byteSize, structure } = member;\n"
"    const vivificator = function getChild(index) {\n"
"      let object = this[SLOTS][index];\n"
"      if (!object) {\n"
"        const { constructor } = structure;\n"
"        const dv = this[MEMORY];\n"
"        const parentOffset = dv.byteOffset;\n"
"        const offset = parentOffset + byteSize * index;\n"
"        const childDV = new DataView(dv.buffer, offset, byteSize);\n"
"        object = this[SLOTS][index] = constructor.call(PARENT, childDV);\n"
"      }\n"
"      return object;\n"
"    };\n"
"    Object.defineProperty(prototype, CHILD_VIVIFICATOR, { value: vivificator });\n"
"  }\n"
"\n"
"  function addPointerVisitor$1(s) {\n"
"    const { constructor: { prototype } } = s;\n"
"    const visitor = function visitPointers(cb, options = {}) {\n"
"      const {\n"
"        source,\n"
"        vivificate = false,\n"
"      } = options;\n"
"      const childOptions = { ...options };\n"
"      for (let i = 0, len = this.length; i < len; i++) {\n"
"        // no need to check for empty slots, since that isn't possible\n"
"        if (source) {\n"
"          childOptions.source = src?.[SLOTS][i];\n"
"        }\n"
"        const child = (vivificate) ? this[CHILD_VIVIFICATOR](i) : this[SLOTS][i];\n"
"        if (child) {\n"
"          child[POINTER_VISITOR](cb, childOptions);\n"
"        }\n"
"      }\n"
"    };\n"
"    Object.defineProperty(prototype, POINTER_VISITOR, { value: visitor });\n"
"  }\n"
"\n"
"  function getArrayIterator() {\n"
"    const self = this[SELF] ?? this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = self.get(index);\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getArrayEntriesIterator() {\n"
"    const self = this[SELF] ?? this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = [ index, self.get(index) ];\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function createArrayEntries() {\n"
"    return {\n"
"      [Symbol.iterator]: getArrayEntriesIterator.bind(this),\n"
"      length: this.length,\n"
"    };\n"
"  }\n"
"\n"
"  function createProxy() {\n"
"    const proxy = new Proxy(this, proxyHandlers);\n"
"    // hide the proxy so console wouldn't display a recursive structure\n"
"    Object.defineProperty(this, PROXY, { value: proxy });\n"
"    return proxy;\n"
"  }\n"
"\n"
"  const proxyHandlers = {\n"
"    get(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return array.get(index);\n"
"      } else {\n"
"        switch (name) {\n"
"          case 'get':\n"
"            if (!array[GETTER]) {\n"
"              array[GETTER] = array.get.bind(array);\n"
"            }\n"
"            return array[GETTER];\n"
"          case 'set':\n"
"            if (!array[SETTER]) {\n"
"              array[SETTER] = array.set.bind(array);\n"
"            }\n"
"            return array[SETTER];\n"
"          case SELF:\n"
"            return array;\n"
"          default:\n"
"            return array[name];\n"
"        }\n"
"      }\n"
"    },\n"
"    set(array, name, value) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        array.set(index, value);\n"
"      } else {\n"
"        switch (name) {\n"
"          case 'get':\n"
"            array[GETTER] = value;\n"
"            break;\n"
"          case 'set':\n"
"            array[SETTER] = value;\n"
"            break;\n"
"          default:\n"
"            array[name] = value;\n"
"        }\n"
"      }\n"
"      return true;\n"
"    },\n"
"    deleteProperty(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return false;\n"
"      } else {\n"
"        switch (name) {\n"
"          case 'get':\n"
"            delete array[GETTER];\n"
"            break;\n"
"          case 'set':\n"
"            delete array[SETTER];\n"
"            break;\n"
"          default:\n"
"            delete array[name];\n"
"        }\n"
"        return true;\n"
"      }\n"
"    },\n"
"    has(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return (index >= 0 && index < array.length);\n"
"      } else {\n"
"        return array[name];\n"
"      }\n"
"    },\n"
"    ownKeys(array) {\n"
"      const keys = [];\n"
"      for (let i = 0, len = array.length; i < len; i++) {\n"
"        keys.push(`${i}`);\n"
"      }\n"
"      keys.push('length', PROXY);\n"
"      return keys;\n"
"    },\n"
"    getOwnPropertyDescriptor(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        if (index >= 0 && index < array.length) {\n"
"          return { value: array.get(index), enumerable: true, writable: true, configurable: true };\n"
"        }\n"
"      } else {\n"
"        return Object.getOwnPropertyDescriptor(array, name);\n"
"      }\n"
"    },\n"
"  };\n"
"\n"
"  function addStaticMembers(s, env) {\n"
"    const {\n"
"      constructor,\n"
"      static: {\n"
"        members,\n"
"        template,\n"
"      },\n"
"      options,\n"
"    } = s;\n"
"    const vivificators = {};\n"
"    for (const member of members) {\n"
"      // static members are either Pointer or Type\n"
"      let { get, set } = getAccessors(member, options);\n"
"      const { type, slot, structure: { isConst } } = member;\n"
"      if (type === MemberType.Object) {\n"
"        const getPtr = get;\n"
"        get = function() {\n"
"          // dereference pointer\n"
"          const ptr = getPtr.call(this);\n"
"          return ptr['*'];\n"
"        };\n"
"        set = (isConst) ? undefined : function(value) {\n"
"          const ptr = getPtr.call(this);\n"
"          ptr['*'] = value;\n"
"        };\n"
"        vivificators[slot] = () => template[SLOTS][slot];\n"
"      }\n"
"      Object.defineProperty(constructor, member.name, { get, set, configurable: true, enumerable: true });\n"
"    }\n"
"    Object.defineProperty(constructor, CHILD_VIVIFICATOR, { value: vivificators });\n"
"  }\n"
"\n"
"  function addMethods(s, env) {\n"
"    const {\n"
"      constructor,\n"
"      instance: { methods: instanceMembers },\n"
"      static: { methods: staticMethods },\n"
"    } = s;\n"
"    const Environment = env.constructor;\n"
"    for (const method of staticMethods) {\n"
"      let {\n"
"        name,\n"
"        argStruct,\n"
"        thunk\n"
"      } = method;\n"
"      const f = function(...args) {\n"
"        const { constructor } = argStruct;\n"
"        const a = new constructor(args);\n"
"        return invokeThunk(thunk, a, Environment);\n"
"      };\n"
"      {\n"
"        // need to set the local variables as well as the property of the method object\n"
"        /* c8 ignore next */\n"
"        f[RELEASE_THUNK] = r => thunk = argStruct = method.thunk = r;\n"
"      }\n"
"      Object.defineProperty(f, 'name', { value: name, writable: false });\n"
"      Object.defineProperty(constructor, name, { value: f, configurable: true, writable: true });\n"
"    }\n"
"    for (const method of instanceMembers) {\n"
"      let {\n"
"        name,\n"
"        argStruct,\n"
"        thunk,\n"
"      } = method;\n"
"      const f = function(...args) {\n"
"        const { constructor } = argStruct;\n"
"        const a = new constructor([ this, ...args ]);\n"
"        return invokeThunk(thunk, a, Environment);\n"
"      };\n"
"      {\n"
"        /* c8 ignore next */\n"
"        f[RELEASE_THUNK] = r => thunk = argStruct = method.thunk = r;\n"
"      }\n"
"      Object.defineProperty(f, 'name', { value: name, writable: false });\n"
"      Object.defineProperty(Object.prototype, name, { value: f, configurable: true, writable: true });\n"
"    }\n"
"  }\n"
"\n"
"  function invokeThunk(thunk, args, Environment) {\n"
"    args[POINTER_VISITOR]?.(updateAddress, {});\n"
"    const env = new Environment;\n"
"    const err = thunk.call(env, args[MEMORY]);\n"
"    args[POINTER_VISITOR]?.(acquireTarget, { vivificate: true });\n"
"\n"
"    // errors returned by exported Zig functions are normally written into the\n"
"    // argument object and get thrown when we access its retval property (a zig error union)\n"
"    // error strings returned by the thunk are due to problems in the thunking process\n"
"    // (i.e. bugs in export.zig)\n"
"    if (err) {\n"
"      throwZigError(err);\n"
"    }\n"
"    return args.retval;\n"
"  }\n"
"\n"
"  function finalizeStruct(s, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members,\n"
"        template,\n"
"      },\n"
"      hasPointer,\n"
"      options,\n"
"    } = s;\n"
"    const descriptors = {};\n"
"    for (const member of members) {\n"
"      if (member.type === MemberType.Comptime) {\n"
"        // extract value of comptime field from template\n"
"        const { slot } = member;\n"
"        const pointer = template[SLOTS][slot];\n"
"        const value = pointer['*'];\n"
"        descriptors[member.name] = { value, configurable: true, enumerable: true };\n"
"        delete template[SLOTS][slot];\n"
"      } else {\n"
"        const { get, set } = getAccessors(member, options);\n"
"        descriptors[member.name] = { get, set, configurable: true, enumerable: true };\n"
"      }\n"
"    }\n"
"    const keys = Object.keys(descriptors);\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = getDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      Object.defineProperties(self, descriptors);\n"
"      if (hasObject) {\n"
"        self[SLOTS] = {};\n"
"      }\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      } else {\n"
"        return self;\n"
"      }\n"
"    };\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const specialKeys = getSpecialKeys(s);\n"
"    const requiredKeys = members.filter(m => m.isRequired).map(m => m.name);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"        if (hasPointer) {\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"        }\n"
"      } else {\n"
"        if (arg && typeof(arg) === 'object') {\n"
"          // checking each name so that we would see inenumerable initializers as well\n"
"          let found = 0;\n"
"          for (const key of keys) {\n"
"            if (key in arg) {\n"
"              found++;\n"
"            }\n"
"          }\n"
"          let requiredFound = 0;\n"
"          for (const key of requiredKeys) {\n"
"            if (key in arg) {\n"
"              requiredFound++;\n"
"            }\n"
"          }\n"
"          let specialFound = 0;\n"
"          if (!arg[MEMORY]) {\n"
"            // only look for special keys in non-zigar objects\n"
"            for (const key of specialKeys) {\n"
"              if (key in arg) {\n"
"                specialFound++;\n"
"              }\n"
"            }\n"
"          }\n"
"          // don't accept unknown enumerable props\n"
"          for (const key of Object.keys(arg)) {\n"
"            if (!(key in this)) {\n"
"              throwNoProperty$1(s, key);\n"
"            }\n"
"          }\n"
"          if (specialFound === 0 && requiredFound < requiredKeys.length) {\n"
"            throwMissingInitializers(s, arg);\n"
"          }\n"
"          // apply default values unless all properties are initialized\n"
"          if (template && specialFound === 0 && found < keys.length) {\n"
"            copy(this[MEMORY], template[MEMORY]);\n"
"            if (hasPointer) {\n"
"              this[POINTER_VISITOR](copyPointer, { vivificate: true, source: template });\n"
"            }\n"
"          }\n"
"          if (specialFound > 0) {\n"
"            for (const key of specialKeys) {\n"
"              if (key in arg) {\n"
"                this[key] = arg[key];\n"
"              }\n"
"            }\n"
"          } else if (found > 0) {\n"
"            for (const key of keys) {\n"
"              if (key in arg) {\n"
"                this[key] = arg[key];\n"
"              }\n"
"            }\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throwInvalidInitializer(s, 'object', arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    Object.defineProperty(constructor.prototype, '$', { get: getSelf, set: initializer, configurable: true });\n"
"    addSpecialAccessors(s);\n"
"    if (hasObject) {\n"
"      addChildVivificators(s);\n"
"      if (hasPointer) {\n"
"        addPointerVisitor(s);\n"
"      }\n"
"    }\n"
"    addStaticMembers(s);\n"
"    addMethods(s, env);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function getSelf() {\n"
"    return this;\n"
"  }\n"
"\n"
"  function addChildVivificators(s) {\n"
"    const { constructor: { prototype }, instance: { members } } = s;\n"
"    const objectMembers = members.filter(m => m.type === MemberType.Object);\n"
"    const vivificators = {};\n"
"    for (const { slot, bitOffset, byteSize, structure } of objectMembers) {\n"
"      vivificators[slot] = function getChild() {\n"
"        let object = this[SLOTS][slot];\n"
"        if (!object) {\n"
"          const { constructor } = structure;\n"
"          const dv = this[MEMORY];\n"
"          const parentOffset = dv.byteOffset;\n"
"          const offset = parentOffset + (bitOffset >> 3);\n"
"          const childDV = new DataView(dv.buffer, offset, byteSize);\n"
"          object = this[SLOTS][slot] = constructor.call(PARENT, childDV);\n"
"        }\n"
"        return object;\n"
"      };\n"
"    }\n"
"    Object.defineProperty(prototype, CHILD_VIVIFICATOR, { value: vivificators });\n"
"  }\n"
"\n"
"  function addPointerVisitor(s) {\n"
"    const { constructor: { prototype }, instance: { members } } = s;\n"
"    const pointerMembers = members.filter(m => m.structure.hasPointer);\n"
"    const visitor = function visitPointers(cb, options = {}) {\n"
"      const {\n"
"        source,\n"
"        vivificate = false,\n"
"        ignoreInactive = true,\n"
"      } = options;\n"
"      const childOptions = { ...options };\n"
"      for (const { name, slot } of pointerMembers) {\n"
"        if (ignoreInactive) {\n"
"          const active = this[FIELD_VALIDATOR$1]?.(name) ?? true;\n"
"          if (!active) {\n"
"            continue;\n"
"          }\n"
"        }\n"
"        if (source) {\n"
"          // when src is a the struct's template, most slots will likely be empty,\n"
"          // since point fields aren't likely to have default values\n"
"          const srcChild = source[SLOTS]?.[slot];\n"
"          if (!srcChild) {\n"
"            continue;\n"
"          }\n"
"          childOptions.source = srcChild;\n"
"        }\n"
"        const child = (vivificate) ? this[CHILD_VIVIFICATOR][slot].call(this) : this[SLOTS][slot];\n"
"        if (child) {\n"
"          child[POINTER_VISITOR](cb, childOptions);\n"
"        }\n"
"      }\n"
"    };\n"
"    Object.defineProperty(prototype, POINTER_VISITOR, { value: visitor });\n"
"  }\n"
"\n"
"  function finalizeUnion(s, env) {\n"
"    const {\n"
"      type,\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members,\n"
"        template,\n"
"      },\n"
"      options,\n"
"      hasPointer,\n"
"    } = s;\n"
"    const {\n"
"      runtimeSafety = true,\n"
"    } = options;\n"
"    const descriptors = {};\n"
"    let getEnumItem;\n"
"    let valueMembers;\n"
"    const isTagged = (type === StructureType.TaggedUnion);\n"
"    const exclusion = (isTagged || (type === StructureType.BareUnion && runtimeSafety));\n"
"    let getName, setName;\n"
"    if (exclusion) {\n"
"      valueMembers = members.slice(0, -1);\n"
"      const selectorMember = members[members.length - 1];\n"
"      const { get: getSelector, set: setSelector } = getAccessors(selectorMember, options);\n"
"      if (type === StructureType.TaggedUnion) {\n"
"        const { structure: { constructor } } = selectorMember;\n"
"        getEnumItem = getSelector;\n"
"        getName = function() {\n"
"          const item = getSelector.call(this);\n"
"          return item[ENUM_NAME];\n"
"        };\n"
"        setName = function(name) {\n"
"          setSelector.call(this, constructor[name]);\n"
"        };\n"
"      } else {\n"
"        const names = valueMembers.map(m => m.name);\n"
"        getName = function() {\n"
"          const index = getSelector.call(this);\n"
"          return names[index];\n"
"        };\n"
"        setName = function(name) {\n"
"          const index = names.indexOf(name);\n"
"          setSelector.call(this, index);\n"
"        };\n"
"      }\n"
"      for (const member of valueMembers) {\n"
"        const { name, slot, structure: { hasPointer } } = member;\n"
"        const { get: getValue, set: setValue } = getAccessors(member, options);\n"
"        const update = (isTagged) ? function(name) {\n"
"          if (this[TAG]?.name !== name) {\n"
"            this[TAG]?.clear?.();\n"
"            this[TAG] = { name };\n"
"            if (hasPointer) {\n"
"              this[TAG].clear = () => {\n"
"                const object = this[SLOTS][slot];\n"
"                object[POINTER_VISITOR](resetPointer);\n"
"              };\n"
"            }\n"
"          }\n"
"        } : null;\n"
"        const get = function() {\n"
"          const currentName = getName.call(this);\n"
"          update?.call(this, currentName);\n"
"          if (name !== currentName) {\n"
"            if (isTagged) {\n"
"              return null;\n"
"            } else {\n"
"              throwInactiveUnionProperty(s, name, currentName);\n"
"            }\n"
"          }\n"
"          return getValue.call(this);\n"
"        };\n"
"        const set = function(value) {\n"
"          const currentName = getName.call(this);\n"
"          update?.call(this, currentName);\n"
"          if (name !== currentName) {\n"
"            throwInactiveUnionProperty(s, name, currentName);\n"
"          }\n"
"          setValue.call(this, value);\n"
"        };\n"
"        const init = function(value) {\n"
"          setName.call(this, name);\n"
"          setValue.call(this, value);\n"
"          update?.call(this, name);\n"
"        };\n"
"        descriptors[member.name] = { get, set, init, update, configurable: true, enumerable: true };\n"
"      }\n"
"    } else {\n"
"      // extern union\n"
"      valueMembers = members;\n"
"      for (const member of members) {\n"
"        const { get, set } = getAccessors(member, options);\n"
"        descriptors[member.name] = { get, set, init: set, configurable: true, enumerable: true };\n"
"      }\n"
"    }\n"
"    const keys = Object.keys(descriptors);\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const pointerMembers = members.filter(m => m.structure.hasPointer);\n"
"    // non-tagged union as marked as not having pointers--if there're actually\n"
"    // members with pointers, we need to disable them\n"
"    const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = getDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      if (isTagged) {\n"
"        // don't know the TAG property in the console, since it's not always up-to-date\n"
"        Object.defineProperties(self, TAG, { value: null, writable: true });\n"
"      }\n"
"      Object.defineProperties(self, descriptors);\n"
"      if (hasObject) {\n"
"        self[SLOTS] = {};\n"
"        if (hasInaccessiblePointer) {\n"
"          // make pointer access throw\n"
"          self[POINTER_VISITOR](disablePointer, { vivificate: true, ignoreInactive: false });\n"
"        }\n"
"      }\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      }\n"
"      if (isTagged) {\n"
"        return new Proxy(self, taggedProxyHandlers);\n"
"      } else {\n"
"        return (creating) ? undefined : self;\n"
"      }\n"
"    };\n"
"    const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const specialKeys = getSpecialKeys(s);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"        if (hasPointer) {\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"        }\n"
"      } else {\n"
"        if (arg && typeof(arg) === 'object') {\n"
"          // checking each name so that we would see inenumerable initializers as well\n"
"          let found = 0;\n"
"          for (const key of keys) {\n"
"            if (key in arg) {\n"
"              found++;\n"
"            }\n"
"          }\n"
"          let specialFound = 0;\n"
"          if (!arg[MEMORY]) {\n"
"            for (const key of specialKeys) {\n"
"              if (key in arg) {\n"
"                specialFound++;\n"
"              }\n"
"            }\n"
"          }\n"
"          // don't accept unknown enumerable props\n"
"          for (const key of Object.keys(arg)) {\n"
"            if (!(key in this)) {\n"
"              throwNoProperty$1(s, key);\n"
"            }\n"
"          }\n"
"          if (found !== 1) {\n"
"            if (found === 0) {\n"
"              if (specialFound === 0 && !hasDefaultMember) {\n"
"                throwMissingUnionInitializer(s, arg, exclusion);\n"
"              }\n"
"            } else {\n"
"              throwMultipleUnionInitializers(s);\n"
"            }\n"
"          }\n"
"          if (specialFound > 0) {\n"
"            for (const key of specialKeys) {\n"
"              if (key in arg) {\n"
"                this[key] = arg[key];\n"
"              }\n"
"            }\n"
"          } else if (found === 0) {\n"
"            if (template) {\n"
"              restoreMemory.call(this);\n"
"              copy(this[MEMORY], template[MEMORY]);\n"
"              if (hasPointer) {\n"
"                this[POINTER_VISITOR](copyPointer, { vivificate: true, source: template });\n"
"              }\n"
"            }\n"
"          } else {\n"
"            for (const key of keys) {\n"
"              if (key in arg) {\n"
"                // can't just set the property, since it would throw when a field other than the\n"
"                // active one is being set\n"
"                const { init } = descriptors[key];\n"
"                init.call(this, arg[key]);\n"
"              }\n"
"            }\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throwInvalidInitializer(s, 'object with a single property', arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    if (isTagged) {\n"
"      // enable casting to enum\n"
"      Object.defineProperty(constructor.prototype, ENUM_ITEM, { get: getEnumItem, configurable: true });\n"
"    }\n"
"    Object.defineProperty(constructor.prototype, '$', { get: getSelf, set: initializer, configurable: true });\n"
"    if (hasObject) {\n"
"      addChildVivificators(s);\n"
"      if (hasPointer || hasInaccessiblePointer) {\n"
"        // add means to check whether a field is active\n"
"        const validator = (isTagged) ? function(name) { return getName(this) === name } : function() { return false };\n"
"        Object.defineProperty(constructor.prototype, FIELD_VALIDATOR$1, { value: validator });\n"
"        addPointerVisitor(s);\n"
"      }\n"
"    }\n"
"    addSpecialAccessors(s);\n"
"    addStaticMembers(s);\n"
"    addMethods(s, env);\n"
"    return constructor;\n"
"  }\n"
"  const taggedProxyHandlers = {\n"
"    ownKeys(union) {\n"
"      const item = union[ENUM_ITEM];\n"
"      const name = item[ENUM_NAME];\n"
"      return [ name, MEMORY ];\n"
"    },\n"
"  };\n"
"\n"
"  function finalizeErrorUnion(s, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members },\n"
"      options,\n"
"      hasPointer,\n"
"    } = s;\n"
"\n"
"    const { get: getValue, set: setValue } = getAccessors(members[0], options);\n"
"    const { get: getError, set: setError } = getAccessors(members[1], options);\n"
"    const { structure: errorStructure } = members[1];\n"
"    const { constructor: ErrorSet } = errorStructure;\n"
"    const reset = getMemoryResetter(byteSize);\n"
"    const set = function(value) {\n"
"      if (value instanceof Error) {\n"
"        if (!(value instanceof ErrorSet)) {\n"
"          throwNotInErrorSet(errorStructure);\n"
"        }\n"
"        reset(this[MEMORY]);\n"
"        setError.call(this, value.index);\n"
"        this[POINTER_VISITOR]?.(resetPointer);\n"
"      } else {\n"
"        setValue.call(this, value);\n"
"        setError.call(this, 0);\n"
"      }\n"
"    };\n"
"    const get = function() {\n"
"      const errorNumber = getError.call(this);\n"
"      if (errorNumber !== 0) {\n"
"        const err = ErrorSet(errorNumber);\n"
"        if (!err) {\n"
"          throwUnknownErrorNumber(errorStructure, errorNumber);\n"
"        }\n"
"        this[POINTER_VISITOR]?.(resetPointer);\n"
"        throw err;\n"
"      } else {\n"
"        return getValue.call(this);\n"
"      }\n"
"    };\n"
"    const check = function() {\n"
"      const errorNumber = getError.call(this);\n"
"      return (errorNumber === 0);\n"
"    };\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = requireDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      if (hasObject) {\n"
"        self[SLOTS] = {};\n"
"      }\n"
"      if (creating) {\n"
"        initializer.call(this, arg);\n"
"      } else {\n"
"        return self;\n"
"      }\n"
"    };\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"        if (hasPointer) {\n"
"          if (check.call(this)) {\n"
"            this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"          }\n"
"        }\n"
"      } else {\n"
"        this.$ = arg;\n"
"      }\n"
"    };\n"
"    Object.defineProperty(constructor.prototype, '$', { get, set, configurable: true });\n"
"    if (hasObject) {\n"
"      addChildVivificators(s);\n"
"      if (hasPointer) {\n"
"        // function used by pointer visitor to see whether pointer field is active\n"
"        Object.defineProperty(constructor.prototype, FIELD_VALIDATOR, { value: check });\n"
"        addPointerVisitor(s);\n"
"      }\n"
"    }\n"
"    addSpecialAccessors(s);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  let currentErrorSets;\n"
"\n"
"  function finalizeErrorSet(s, env) {\n"
"    const {\n"
"      name,\n"
"      instance: {\n"
"        members,\n"
"      },\n"
"    } = s;\n"
"    const errors = currentErrorSets;\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      if (creating) {\n"
"        throwNoNewError(s);\n"
"      }\n"
"      const index = Number(arg);\n"
"      return errors[index];\n"
"    };\n"
"    Object.setPrototypeOf(constructor.prototype, Error.prototype);\n"
"    const getIndex = function() { return this[ERROR_INDEX] };\n"
"    const toStringTag = function() { return 'Error' };\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      // provide a way to retrieve the error index\n"
"      index: { get: getIndex, configurable: true },\n"
"      // ensure that libraries that rely on the string tag for type detection will\n"
"      // correctly identify the object as an error\n"
"      [Symbol.toStringTag]: { get: toStringTag, configurable: true },\n"
"    });\n"
"    // attach the errors to the constructor and the\n"
"    let errorIndices;\n"
"    for (const [ index, { name, slot } ] of members.entries()) {\n"
"      let error = errors[slot];\n"
"      if (error) {\n"
"        // error already exists in a previously defined set\n"
"        // see if we should make that set a subclass or superclass of this one\n"
"        if (!(error instanceof constructor)) {\n"
"          if (!errorIndices) {\n"
"            errorIndices = members.map(m => m.slot);\n"
"          }\n"
"          const otherSet = error.constructor;\n"
"          const otherErrors = Object.values(otherSet);\n"
"          if (otherErrors.every(e => errorIndices.includes(e[ERROR_INDEX]))) {\n"
"            // this set contains the all errors of the other one, so it's a superclass\n"
"            Object.setPrototypeOf(otherSet.prototype, constructor.prototype);\n"
"          } else {\n"
"            // make this set a subclass of the other\n"
"            Object.setPrototypeOf(constructor.prototype, otherSet.prototype);\n"
"            for (const otherError of otherErrors) {\n"
"              if (errorIndices.includes(otherError[ERROR_INDEX])) {\n"
"                // this set should be this error object's class\n"
"                Object.setPrototypeOf(otherError, constructor.prototype);\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"      } else {\n"
"        // need to create the error object--can't use the constructor since it would throw\n"
"        error = Object.create(constructor.prototype);\n"
"        const message = decamelizeErrorName(name);\n"
"        Object.defineProperties(error, {\n"
"          message: { value: message, configurable: true, enumerable: true, writable: false },\n"
"          [ERROR_INDEX]: { value: slot },\n"
"        });\n"
"        errors[slot] = error;\n"
"      }\n"
"      Object.defineProperties(constructor, {\n"
"        [name]: { value: error, configurable: true, enumerable: true, writable: true },\n"
"      });\n"
"    }\n"
"    return constructor;\n"
"  }\n"
"  function initializeErrorSets() {\n"
"    currentErrorSets = {};\n"
"  }\n"
"\n"
"  function finalizeEnumeration(s, env) {\n"
"    const {\n"
"      instance: {\n"
"        members,\n"
"        template,\n"
"      },\n"
"      options,\n"
"    } = s;\n"
"    const Primitive = getPrimitiveClass(members[0]);\n"
"    const { get: getValue } = getAccessors(members[0], options);\n"
"    const count = members.length;\n"
"    const items = {};\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      if (creating) {\n"
"        // the \"constructor\" is only used to convert a number into an enum object\n"
"        // new enum items cannot be created\n"
"        throwNoNewEnum(s);\n"
"      }\n"
"      if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {\n"
"        let index = -1;\n"
"        if (isSequential) {\n"
"          // normal enums start at 0 and go up, so the value is the index\n"
"          index = Number(arg);\n"
"        } else {\n"
"          // values aren't sequential, so we need to compare values\n"
"          const given = Primitive(arg);\n"
"          for (let i = 0; i < count; i++) {\n"
"            const value = getValue.call(constructor, i);\n"
"            if (value === given) {\n"
"              index = i;\n"
"              break;\n"
"            }\n"
"          }\n"
"        }\n"
"        // return the enum object (created down below)\n"
"        return items[index];\n"
"      } else if (arg && typeof(arg) === 'object' && arg[ENUM_ITEM]) {\n"
"        // a tagged union, return the active tag\n"
"        return arg[ENUM_ITEM];\n"
"      } else if (typeof(arg)  === 'string') {\n"
"        return constructor[arg];\n"
"      } else {\n"
"        throwInvalidInitializer(s, [ 'number', 'string', 'tagged union' ], arg);\n"
"      }\n"
"    };\n"
"    // attach the numeric values to the class as its binary data\n"
"    // this allows us to reuse the array getter\n"
"    Object.defineProperties(constructor, {\n"
"      [MEMORY]: { value: template[MEMORY] },\n"
"      [ENUM_ITEMS]: { value: items },\n"
"    });\n"
"    const valueOf = function() {\n"
"      const index = this[ENUM_INDEX] ;\n"
"      return getValue.call(constructor, index);\n"
"    };\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      [Symbol.toPrimitive]: { value: valueOf, configurable: true, writable: true },\n"
"      $: { get: valueOf, configurable: true },\n"
"    });\n"
"    // now that the class has the right hidden properties, getValue() will work\n"
"    // scan the array to see if the enum's numeric representation is sequential\n"
"    const isSequential = (() => {\n"
"      // try-block in the event that the enum has bigInt items\n"
"      try {\n"
"        for (let i = 0; i < count; i++) {\n"
"          if (getValue.call(constructor, i) !== i) {\n"
"            return false;\n"
"          }\n"
"        }\n"
"        return true;\n"
"        /* c8 ignore next 3 */\n"
"      } catch (err) {\n"
"        return false;\n"
"      }\n"
"    })();\n"
"    // attach the enum items to the constructor\n"
"    for (const [ index, { name } ] of members.entries()) {\n"
"      // can't use the constructor since it would throw\n"
"      const item = Object.create(constructor.prototype);\n"
"      Object.defineProperties(item, {\n"
"        [ENUM_INDEX]: { value: index },\n"
"        [ENUM_NAME]: { value: name },\n"
"      });\n"
"      Object.defineProperties(constructor, {\n"
"        [name]: { value: item, configurable: true, enumerable: true, writable: true },\n"
"      });\n"
"      items[index] = item;\n"
"    }\n"
"    addSpecialAccessors(s);\n"
"    addStaticMembers(s);\n"
"    addMethods(s, env);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function finalizeOptional(s, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members },\n"
"      options,\n"
"      hasPointer,\n"
"    } = s;\n"
"    const { get: getValue, set: setValue } = getAccessors(members[0], options);\n"
"    const { get: getPresent, set: setPresent } = getAccessors(members[1], options);\n"
"    const reset = getMemoryResetter(byteSize);\n"
"    const get = function() {\n"
"      const present = getPresent.call(this);\n"
"      if (present) {\n"
"        return getValue.call(this);\n"
"      } else {\n"
"        this[POINTER_VISITOR]?.(resetPointer);\n"
"        return null;\n"
"      }\n"
"    };\n"
"    const set = function(value) {\n"
"      if (value != null) {\n"
"        setPresent.call(this, true);\n"
"        setValue.call(this, value);\n"
"      } else {\n"
"        reset(this[MEMORY]);\n"
"        this[POINTER_VISITOR]?.(resetPointer);\n"
"      }\n"
"    };\n"
"    const check = getPresent;\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = requireDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      if (hasObject) {\n"
"        self[SLOTS] = {};\n"
"      }\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      } else {\n"
"        return self;\n"
"      }\n"
"    };\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"        if (hasPointer) {\n"
"          // don't bother copying pointers when it's empty\n"
"          if (check.call(this)) {\n"
"            this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg});\n"
"          }\n"
"        }\n"
"      } else {\n"
"        this.$ = arg;\n"
"      }\n"
"    };\n"
"    Object.defineProperty(constructor.prototype, '$', { get, set, configurable: true });\n"
"    if (hasObject) {\n"
"      addChildVivificators(s);\n"
"      if (hasPointer) {\n"
"        // function used by pointer visitor to see whether pointer field is active\n"
"        Object.defineProperty(constructor.prototype, FIELD_VALIDATOR, { value: check });\n"
"        addPointerVisitor(s);\n"
"      }\n"
"    }\n"
"    addSpecialAccessors(s);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function finalizeSlice(s, env) {\n"
"    const {\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"      hasPointer,\n"
"      options,\n"
"    } = s;\n"
"    const typedArray = addTypedArray(s);\n"
"    const hasObject = (member.type === MemberType.Object);\n"
"    const { byteSize: elementSize, structure: elementStructure } = member;\n"
"    const sentinel = getSentinel(s, options);\n"
"    if (sentinel) {\n"
"      // zero-terminated strings aren't expected to be commonly used\n"
"      // so we're not putting this prop into the standard structure\n"
"      s.sentinel = sentinel;\n"
"    }\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    // the slices are different from other structures due to variability of their sizes\n"
"    // we only know the \"shape\" of an object after we've processed the initializers\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        initializer.call(self, arg);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        const dv = requireDataView(s, arg);\n"
"        shapeDefiner.call(self, dv, dv.byteLength / elementSize, this);\n"
"      }\n"
"      return createProxy.call(self);\n"
"    };\n"
"    const copy = getMemoryCopier(elementSize, true);\n"
"    const specialKeys = getSpecialKeys(s);\n"
"    const shapeDefiner = function(dv, length) {\n"
"      if (!dv) {\n"
"        dv = env.allocMemory(length * elementSize, ptrAlign);\n"
"      }\n"
"      this[MEMORY] = dv;\n"
"      this[GETTER] = null;\n"
"      this[SETTER] = null;\n"
"      this[LENGTH] = length;\n"
"      if (hasObject) {\n"
"        this[SLOTS] = {};\n"
"      }\n"
"    };\n"
"    const shapeChecker = function(arg, length) {\n"
"      if (length !== this[LENGTH]) {\n"
"        throwArrayLengthMismatch(s, this, arg);\n"
"      }\n"
"    };\n"
"    // the initializer behave differently depending on whether it's called  by the\n"
"    // constructor or by a member setter (i.e. after object's shape has been established)\n"
"    const initializer = function(arg) {\n"
"      let shapeless = !this.hasOwnProperty(MEMORY);\n"
"      if (arg instanceof constructor) {\n"
"        if (shapeless) {\n"
"          shapeDefiner.call(this, null, arg.length);\n"
"        } else {\n"
"          shapeChecker.call(this, arg, arg.length);\n"
"        }\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"        if (hasPointer) {\n"
"          this[POINTER_VISITOR](copyPointer, { source: arg });\n"
"        }\n"
"      } else {\n"
"        if (typeof(arg) === 'string' && specialKeys.includes('string')) {\n"
"          arg = { string: arg };\n"
"        }\n"
"        if (arg?.[Symbol.iterator]) {\n"
"          let argLen = arg.length;\n"
"          if (typeof(argLen) !== 'number') {\n"
"            arg = [ ...arg ];\n"
"            argLen = arg.length;\n"
"          }\n"
"          if (!this[MEMORY]) {\n"
"            shapeDefiner.call(this, null, argLen);\n"
"          } else {\n"
"            shapeChecker.call(this, arg, argLen);\n"
"          }\n"
"          let i = 0;\n"
"          for (const value of arg) {\n"
"            sentinel?.validateValue(value, i, argLen);\n"
"            set.call(this, i++, value);\n"
"          }\n"
"        } else if (typeof(arg) === 'number') {\n"
"          if (shapeless && arg >= 0 && isFinite(arg)) {\n"
"            shapeDefiner.call(this, null, arg);\n"
"          } else {\n"
"            throwInvalidArrayInitializer(s, arg, shapeless);\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          for (const key of Object.keys(arg)) {\n"
"            if (!(key in this)) {\n"
"              throwNoProperty$1(s, key);\n"
"            }\n"
"          }\n"
"          let specialFound = 0;\n"
"          for (const key of specialKeys) {\n"
"            if (key in arg) {\n"
"              specialFound++;\n"
"            }\n"
"          }\n"
"          if (specialFound === 0) {\n"
"            throwInvalidArrayInitializer(s, arg);\n"
"          }\n"
"          for (const key of specialKeys) {\n"
"            if (key in arg) {\n"
"              if (shapeless) {\n"
"                // can't use accessors since the object has no memory yet\n"
"                let dv, dup = true;\n"
"                switch (key) {\n"
"                  case 'dataView':\n"
"                    dv = arg[key];\n"
"                    checkDataView(dv);\n"
"                    break;\n"
"                  case 'typedArray':\n"
"                    dv = getDataViewFromTypedArray(arg[key], typedArray);\n"
"                    break;\n"
"                  case 'string':\n"
"                    dv = getDataViewFromUTF8(arg[key], elementSize, sentinel?.value);\n"
"                    dup = false;\n"
"                    break;\n"
"                  case 'base64':\n"
"                    dv = getDataViewFromBase64(arg[key]);\n"
"                    dup = false;\n"
"                    break;\n"
"                }\n"
"                checkDataViewSize(s, dv);\n"
"                const length = dv.byteLength / elementSize;\n"
"                sentinel?.validateData(dv, length);\n"
"                if (dup) {\n"
"                  shapeDefiner.call(this, null, length);\n"
"                  copy(this[MEMORY], dv);\n"
"                } else {\n"
"                  // reuse memory from string decoding\n"
"                  shapeDefiner.call(this, dv, length);\n"
"                }\n"
"                shapeless = false;\n"
"              } else {\n"
"                this[key] = arg[key];\n"
"              }\n"
"            }\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throwInvalidArrayInitializer(s, arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    const { get, set } = getAccessors(member, options);\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      get: { value: get, configurable: true, writable: true },\n"
"      set: { value: set, configurable: true, writable: true },\n"
"      length: { get: getLength, configurable: true },\n"
"      $: { get: getSelf, set: initializer, configurable: true },\n"
"      [Symbol.iterator]: { value: getArrayIterator, configurable: true, writable: true },\n"
"      entries: { value: createArrayEntries, configurable: true, writable: true },\n"
"    });\n"
"    Object.defineProperties(constructor, {\n"
"      child: { get: () => elementStructure.constructor },\n"
"      [COMPAT]: { value: getCompatibleTags(s) },\n"
"    });\n"
"    if (hasObject) {\n"
"      addChildVivificator(s);\n"
"      if (hasPointer) {\n"
"        addPointerVisitor$1(s);\n"
"      }\n"
"    }\n"
"    addSpecialAccessors(s);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function getLength() {\n"
"    return this[LENGTH];\n"
"  }\n"
"\n"
"  function getSentinel(structure, options) {\n"
"    const {\n"
"      runtimeSafety = true,\n"
"    } = options;\n"
"    const {\n"
"      instance: { members: [ member, sentinel ], template },\n"
"    } = structure;\n"
"    if (!sentinel) {\n"
"      return;\n"
"    }\n"
"    const { get: getSentinelValue } = getAccessors(sentinel, options);\n"
"    const value = getSentinelValue.call(template, 0);\n"
"    const { get } = getAccessors(member, options);\n"
"    const validateValue = (runtimeSafety) ? function(v, i, l) {\n"
"      if (v === value && i !== l - 1) {\n"
"        throwMisplacedSentinel(structure, v, i, l);\n"
"      } else if (v !== value && i === l - 1) {\n"
"        throwMissingSentinel(structure, value, i);\n"
"      }\n"
"    } : function(v, i, l) {\n"
"      if (v !== value && i === l - 1) {\n"
"        throwMissingSentinel(structure, value, l);\n"
"      }\n"
"    };\n"
"    const validateData = (runtimeSafety) ? function(dv, l) {\n"
"      const object = { [MEMORY]: dv };\n"
"      for (let i = 0; i < l; i++) {\n"
"        const v = get.call(object, i);\n"
"        if (v === value && i !== l - 1) {\n"
"          throwMisplacedSentinel(structure, value, i, l);\n"
"        } else if (v !== value && i === l - 1) {\n"
"          throwMissingSentinel(structure, value, l);\n"
"        }\n"
"      }\n"
"    } : function(dv, l) {\n"
"      const object = { [MEMORY]: dv };\n"
"      if (l > 0) {\n"
"        const i = l - 1;\n"
"        const v = get.call(object, i);\n"
"        if (v !== value) {\n"
"          throwMissingSentinel(structure, value, l);\n"
"        }\n"
"      }\n"
"    };\n"
"    const bytes = template[MEMORY];\n"
"    return { value, bytes, validateValue, validateData };\n"
"  }\n"
"\n"
"  function finalizeVector(s, env) {\n"
"    const {\n"
"      length,\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"      options,\n"
"    } = s;\n"
"    addTypedArray(s);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(arg) {\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(s);\n"
"        }\n"
"        self = this;\n"
"        dv = env.allocMemory(byteSize, ptrAlign);\n"
"      } else {\n"
"        self = Object.create(constructor.prototype);\n"
"        dv = requireDataView(s, arg);\n"
"      }\n"
"      self[MEMORY] = dv;\n"
"      if (creating) {\n"
"        initializer.call(self, arg);\n"
"      } else {\n"
"        return self;\n"
"      }\n"
"    };\n"
"    const { bitSize: elementBitSize, structure: elementStructure } = member;\n"
"    const copy = getMemoryCopier(byteSize);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        restoreMemory.call(this);\n"
"        restoreMemory.call(arg);\n"
"        copy(this[MEMORY], arg[MEMORY]);\n"
"      } else {\n"
"        if (arg?.[Symbol.iterator]) {\n"
"          let argLen = arg.length;\n"
"          if (typeof(argLen) !== 'number') {\n"
"            arg = [ ...arg ];\n"
"            argLen = arg.length;\n"
"          }\n"
"          if (argLen !== length) {\n"
"            throwArrayLengthMismatch(s, this, arg);\n"
"          }\n"
"          let i = 0;\n"
"          for (const value of arg) {\n"
"            this[i++] = value;\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throwInvalidArrayInitializer(s, arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {\n"
"      const { get, set } = getAccessors({ ...member, bitOffset }, options);\n"
"      Object.defineProperty(constructor.prototype, i, { get, set, configurable: true });\n"
"    }\n"
"    Object.defineProperties(constructor.prototype, {\n"
"      length: { value: length, configurable: true },\n"
"      $: { get: getSelf, set: initializer, configurable: true },\n"
"      [Symbol.iterator]: { value: getVectorIterator, configurable: true, writable: true },\n"
"      entries: { value: createVectorEntries, configurable: true, writable: true },\n"
"    });\n"
"    Object.defineProperties(constructor, {\n"
"      child: { get: () => elementStructure.constructor },\n"
"      [COMPAT]: { value: getCompatibleTags(s) },\n"
"    });\n"
"    addSpecialAccessors(s);\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function getVectorIterator() {\n"
"    const self = this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = self[index];\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getVectorEntriesIterator() {\n"
"    const self = this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = [ index, self[index] ];\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function createVectorEntries() {\n"
"    return {\n"
"      [Symbol.iterator]: getVectorEntriesIterator.bind(this),\n"
"      length: this.length,\n"
"    };\n"
"  }\n"
"\n"
"  function finalizeArgStruct(s, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members,\n"
"      },\n"
"      hasPointer,\n"
"      options,\n"
"    } = s;\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const ptrAlign = getPointerAlign(align);\n"
"    const constructor = s.constructor = function(args) {\n"
"      const dv = env.allocMemory(byteSize, ptrAlign);\n"
"      this[MEMORY] = dv;\n"
"      if (hasObject) {\n"
"        this[SLOTS] = {};\n"
"      }\n"
"      initializer.call(this, args);\n"
"    };\n"
"    const argNames = members.slice(0, -1).map(m => m.name);\n"
"    const argCount = argNames.length;\n"
"    const initializer = function(args) {\n"
"      if (args.length !== argCount) {\n"
"        throwArgumentCountMismatch(s, args.length);\n"
"      }\n"
"      for (const [ index, name ] of argNames.entries()) {\n"
"        try {\n"
"          this[name] = args[index];\n"
"        } catch (err) {\n"
"          rethrowArgumentError(s, index, err);\n"
"        }\n"
"      }\n"
"    };\n"
"    for (const member of members) {\n"
"      const accessors = getAccessors(member, options);\n"
"      Object.defineProperty(constructor.prototype, member.name, accessors);\n"
"    }\n"
"    if (hasObject) {\n"
"      addChildVivificators(s);\n"
"      if (hasPointer) {\n"
"        addPointerVisitor(s);\n"
"      }\n"
"    }\n"
"    return constructor;\n"
"  }\n"
"\n"
"  const StructureType = {\n"
"    Primitive: 0,\n"
"    Array: 1,\n"
"    Struct: 2,\n"
"    ArgStruct: 3,\n"
"    ExternUnion: 4,\n"
"    BareUnion: 5,\n"
"    TaggedUnion: 6,\n"
"    ErrorUnion: 7,\n"
"    ErrorSet: 8,\n"
"    Enumeration: 9,\n"
"    Optional: 10,\n"
"    Pointer: 11,\n"
"    Slice: 12,\n"
"    Vector: 13,\n"
"    Opaque: 14,\n"
"    Function: 15,\n"
"  };\n"
"\n"
"  const factories$1 = Array(Object.values(StructureType).length);\n"
"\n"
"  function usePrimitive() {\n"
"    factories$1[StructureType.Primitive] = finalizePrimitive;\n"
"  }\n"
"\n"
"  function useArray() {\n"
"    factories$1[StructureType.Array] = finalizeArray;\n"
"  }\n"
"\n"
"  function useStruct() {\n"
"    factories$1[StructureType.Struct] = finalizeStruct;\n"
"  }\n"
"\n"
"  function useExternUnion() {\n"
"    factories$1[StructureType.ExternUnion] = finalizeUnion;\n"
"  }\n"
"\n"
"  function useBareUnion() {\n"
"    factories$1[StructureType.BareUnion] = finalizeUnion;\n"
"  }\n"
"\n"
"  function useTaggedUnion() {\n"
"    factories$1[StructureType.TaggedUnion] = finalizeUnion;\n"
"  }\n"
"\n"
"  function useErrorUnion() {\n"
"    factories$1[StructureType.ErrorUnion] = finalizeErrorUnion;\n"
"  }\n"
"\n"
"  function useErrorSet() {\n"
"    factories$1[StructureType.ErrorSet] = finalizeErrorSet;\n"
"  }\n"
"\n"
"  function useEnumeration() {\n"
"    factories$1[StructureType.Enumeration] = finalizeEnumeration;\n"
"  }\n"
"\n"
"  function useOptional() {\n"
"    factories$1[StructureType.Optional] = finalizeOptional;\n"
"  }\n"
"\n"
"  function usePointer() {\n"
"    factories$1[StructureType.Pointer] = finalizePointer;\n"
"  }\n"
"\n"
"  function useSlice() {\n"
"    factories$1[StructureType.Slice] = finalizeSlice;\n"
"  }\n"
"\n"
"  function useVector() {\n"
"    factories$1[StructureType.Vector] = finalizeVector;\n"
"  }\n"
"\n"
"  function useOpaque() {\n"
"    factories$1[StructureType.Opaque] = finalizeStruct;\n"
"  }\n"
"\n"
"  function useArgStruct() {\n"
"    factories$1[StructureType.ArgStruct] = finalizeArgStruct;\n"
"  }\n"
"\n"
"  function getStructureName(s, full = false) {\n"
"    let r = s.name;\n"
"    if (!full) {\n"
"      r = r.replace(/{.*}/, '');\n"
"      r = r.replace(/[^. ]*?\\./g, '');\n"
"    }\n"
"    return r;\n"
"  }\n"
"\n"
"  function getStructureFactory(type) {\n"
"    const f = factories$1[type];\n"
"    return f;\n"
"  }\n"
"\n"
"  const MemberType = {\n"
"    Void: 0,\n"
"    Bool: 1,\n"
"    Int: 2,\n"
"    Uint: 3,\n"
"    Float: 4,\n"
"    EnumerationItem: 5,\n"
"    Object: 6,\n"
"    Type: 7,\n"
"    Comptime: 8,\n"
"  };\n"
"\n"
"  const factories = Array(Object.values(MemberType).length);\n"
"\n"
"  function useVoid() {\n"
"    factories[MemberType.Void] = getVoidAccessor;\n"
"  }\n"
"\n"
"  function useBoolEx() {\n"
"    factories[MemberType.Bool] = getBoolAccessorEx;\n"
"  }\n"
"\n"
"  function useIntEx() {\n"
"    factories[MemberType.Int] = getIntAccessorEx;\n"
"  }\n"
"\n"
"  function useUintEx() {\n"
"    factories[MemberType.Uint] = getUintAccessorEx;\n"
"  }\n"
"\n"
"  function useFloatEx() {\n"
"    factories[MemberType.Float] = getFloatAccessorEx;\n"
"  }\n"
"\n"
"  function useEnumerationItemEx() {\n"
"    factories[MemberType.EnumerationItem] = getEnumerationItemAccessorEx;\n"
"  }\n"
"\n"
"  function useObject() {\n"
"    factories[MemberType.Object] = getObjectAccessor;\n"
"  }\n"
"\n"
"  function useType() {\n"
"    factories[MemberType.Type] = getTypeAccessor;\n"
"  }\n"
"\n"
"  function isByteAligned({ bitOffset, bitSize, byteSize }) {\n"
"    return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;\n"
"  }\n"
"\n"
"  function getAccessors(member, options = {}) {\n"
"    const f = factories[member.type];\n"
"    return {\n"
"      get: f('get', member, options),\n"
"      set: f('set', member, options)\n"
"    };\n"
"  }\n"
"\n"
"  function getVoidAccessor(type, member, options) {\n"
"    const { runtimeSafety } = options;\n"
"    if (type === 'get') {\n"
"      return function() {\n"
"        return null;\n"
"      };\n"
"    } else {\n"
"      if (runtimeSafety) {\n"
"        return function(value) {\n"
"          if (value != null) {\n"
"            throwNotNull(member);\n"
"          }\n"
"        };\n"
"        } else {\n"
"        return function() {};\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function getBoolAccessorEx(access, member, options) {\n"
"    return getAccessorUsing(access, member, options, getDataViewBoolAccessorEx)\n"
"  }\n"
"\n"
"  function getIntAccessorEx(access, member, options) {\n"
"    const getDataViewAccessor = addRuntimeCheck(options, getDataViewIntAccessorEx);\n"
"    return getAccessorUsing(access, member, options, getDataViewAccessor)\n"
"  }\n"
"\n"
"  function getUintAccessorEx(access, member, options) {\n"
"    const getDataViewAccessor = addRuntimeCheck(options, getDataViewUintAccessorEx);\n"
"    return getAccessorUsing(access, member, options, getDataViewAccessor)\n"
"  }\n"
"\n"
"  function addRuntimeCheck(options, getDataViewAccessor) {\n"
"    return function (access, member) {\n"
"      const {\n"
"        runtimeSafety = true,\n"
"      } = options;\n"
"      const accessor = getDataViewAccessor(access, member);\n"
"      if (runtimeSafety && access === 'set') {\n"
"        const { min, max } = getIntRange(member);\n"
"        return function(offset, value, littleEndian) {\n"
"          if (value < min || value > max) {\n"
"            throwOverflow(member, value);\n"
"          }\n"
"          accessor.call(this, offset, value, littleEndian);\n"
"        };\n"
"      }\n"
"      return accessor;\n"
"    };\n"
"  }\n"
"\n"
"  function getFloatAccessorEx(access, member, options) {\n"
"    return getAccessorUsing(access, member, options, getDataViewFloatAccessorEx)\n"
"  }\n"
"\n"
"  function getEnumerationItemAccessorEx(access, member, options) {\n"
"    const getDataViewAccessor = addEnumerationLookup(getDataViewIntAccessorEx);\n"
"    return getAccessorUsing(access, member, options, getDataViewAccessor) ;\n"
"  }\n"
"\n"
"  function addEnumerationLookup(getDataViewIntAccessor) {\n"
"    return function(access, member) {\n"
"      // no point in using non-standard int accessor to read enum values unless they aren't byte-aligned\n"
"      let { bitSize, byteSize } = member;\n"
"      if (byteSize) {\n"
"        bitSize = byteSize * 8;\n"
"      }\n"
"      const intMember = { type: MemberType.Int, bitSize, byteSize };\n"
"      const accessor = getDataViewIntAccessor(access, intMember);\n"
"      const { structure } = member;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const { constructor } = structure;\n"
"          const value = accessor.call(this, offset, littleEndian);\n"
"          // the enumeration constructor returns the object for the int value\n"
"          const object = constructor(value);\n"
"          if (!object) {\n"
"            throwInvalidEnum(structure, value);\n"
"          }\n"
"          return object;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const { constructor } = structure;\n"
"          let item;\n"
"          if (value instanceof constructor) {\n"
"            item = value;\n"
"          } else {\n"
"            item = constructor(value);\n"
"          }\n"
"          if (!item) {\n"
"            throwEnumExpected(structure, value);\n"
"          }\n"
"          accessor.call(this, offset, item.valueOf(), littleEndian);\n"
"        };\n"
"      }\n"
"    };\n"
"  }\n"
"\n"
"  function getObjectAccessor(access, member, options) {\n"
"    const { structure, slot } = member;\n"
"    let returnValue = false;\n"
"    switch (structure.type) {\n"
"      case StructureType.ErrorUnion:\n"
"      case StructureType.Optional:\n"
"        returnValue = true;\n"
"        break;\n"
"    }\n"
"    if (slot !== undefined) {\n"
"      if (access === 'get') {\n"
"        if (returnValue) {\n"
"          return function getValue() {\n"
"            const object = this[CHILD_VIVIFICATOR][slot].call(this);\n"
"            return object.$;\n"
"          };\n"
"        } else {\n"
"          return function getObject() {\n"
"            const object = this[CHILD_VIVIFICATOR][slot].call(this);\n"
"            return object;\n"
"          };\n"
"        }\n"
"      } else {\n"
"        return function setValue(value) {\n"
"          const object = this[CHILD_VIVIFICATOR][slot].call(this);\n"
"          object.$ = value;\n"
"        };\n"
"      }\n"
"    } else {\n"
"      // array accessors\n"
"      if (access === 'get') {\n"
"        if (returnValue) {\n"
"          return function getValue(index) {\n"
"            const object = this[CHILD_VIVIFICATOR](index);\n"
"            return object.$;\n"
"          };\n"
"        } else {\n"
"          return function getObject(index) {\n"
"            const object = this[CHILD_VIVIFICATOR](index);\n"
"            return object;\n"
"          };\n"
"        }\n"
"      } else {\n"
"        return function setValue(index, value) {\n"
"          const object = this[CHILD_VIVIFICATOR](index);\n"
"          object.$ = value;\n"
"        };\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function getTypeAccessor(type, member, options) {\n"
"    const { structure } = member;\n"
"    if (type === 'get') {\n"
"      return function() {\n"
"        const { constructor } = structure;\n"
"        return constructor;\n"
"      };\n"
"    }\n"
"  }\n"
"\n"
"  function getAccessorUsing(access, member, options, getDataViewAccessor) {\n"
"    const {\n"
"      littleEndian = true,\n"
"    } = options;\n"
"    const { bitOffset, byteSize } = member;\n"
"    const accessor = getDataViewAccessor(access, member);\n"
"    if (bitOffset !== undefined) {\n"
"      const offset = bitOffset >> 3;\n"
"      {\n"
"        if (access === 'get') {\n"
"          return function() {\n"
"            return accessor.call(this[MEMORY], offset, littleEndian);\n"
"          };\n"
"        } else {\n"
"          return function(value) {\n"
"            return accessor.call(this[MEMORY], offset, value, littleEndian);\n"
"          }\n"
"        }\n"
"      }\n"
"    } else {\n"
"      {\n"
"        if (access === 'get') {\n"
"          return function(index) {\n"
"            try {\n"
"              return accessor.call(this[MEMORY], index * byteSize, littleEndian);\n"
"            } catch (err) {\n"
"              rethrowRangeError(member, index, err);\n"
"            }\n"
"          };\n"
"        } else {\n"
"          return function(index, value) {\n"
"            try {\n"
"              return accessor.call(this[MEMORY], index * byteSize, value, littleEndian);\n"
"            } catch (err) {\n"
"              rethrowRangeError(member, index, err);\n"
"            }\n"
"          }\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  let decoder;\n"
"\n"
"  function decodeText(data, encoding = 'utf-8') {\n"
"    if (!decoder) {\n"
"      decoder = new TextDecoder;\n"
"    }\n"
"    return decoder.decode(data);\n"
"  }\n"
"\n"
"  const default_alignment = 16;\n"
"  const globalSlots = {};\n"
"\n"
"  let consolePending = '';\n"
"  let consoleTimeout = 0;\n"
"\n"
"  class BaseEnvironment {\n"
"    memoryPool = null;\n"
"\n"
"    /*\n"
"    Functions to be defined in subclass:\n"
"\n"
"    getAddress(buffer: ArrayBuffer): bigInt|number {\n"
"      // return a buffer's address\n"
"    }\n"
"    obtainView(address: bigInt|number, len: number): DataView {\n"
"      // obtain a data view of memory at given address\n"
"    }\n"
"    copyBytes(dst: DataView, address: bigInt|number, len: number): void {\n"
"      // copy memory at given address into destination view\n"
"    }\n"
"    findSentinel(address, bytes: DataView): number {\n"
"      // return offset where sentinel value is found\n"
"    }\n"
"\n"
"    */\n"
"\n"
"    getViewAddress(dv) {\n"
"      const address = this.getAddress(dv.buffer);\n"
"      const offset = (typeof(address) === 'bigint') ? BigInt(dv.byteOffset) : dv.byteOffset;\n"
"      return address + offset;\n"
"    }\n"
"\n"
"    allocMemory(len, ptrAlign) {\n"
"      const extra = getExtraCount(ptrAlign);\n"
"      const buffer = new ArrayBuffer(len + extra);\n"
"      let offset = 0;\n"
"      if (extra !== 0) {\n"
"        const address = this.getAddress(buffer);\n"
"        const mask = ~(extra - 1);\n"
"        const aligned = (address & mask) + extra;\n"
"        offset = aligned - address;\n"
"      }\n"
"      const dv = new DataView(buffer, offset, len);\n"
"      return dv;\n"
"    }\n"
"\n"
"    freeMemory(address, len, ptrAlign) {\n"
"    }\n"
"\n"
"    isShared(dv) {\n"
"      return dv.buffer instanceof SharedArrayBuffer;\n"
"    }\n"
"\n"
"    createView(address, len, ptrAlign, copy) {\n"
"      if (copy) {\n"
"        const dv = this.allocMemory(len, ptrAlign);\n"
"        this.copyBytes(dv, address, len);\n"
"        return dv;\n"
"      } else {\n"
"        return this.obtainView(address, len);\n"
"      }\n"
"    }\n"
"\n"
"    castView(structure, dv) {\n"
"      const { constructor, hasPointer } = structure;\n"
"      const object = constructor.call(ENVIRONMENT, dv);\n"
"      if (hasPointer) {\n"
"        // vivificate pointers and acquire their targets\n"
"        object[POINTER_VISITOR](acquireTarget, { vivificate: true });\n"
"      }\n"
"      return object;\n"
"    }\n"
"\n"
"    createObject(structure, arg) {\n"
"      const { constructor } = structure;\n"
"      return new constructor(arg);\n"
"    }\n"
"\n"
"    readSlot(target, slot) {\n"
"      const slots = target ? target[SLOTS] : globalSlots;\n"
"      return slots?.[slot];\n"
"    }\n"
"\n"
"    writeSlot(target, slot, value) {\n"
"      const slots = target ? target[SLOTS] : globalSlots;\n"
"      if (slots) {\n"
"        slots[slot] = value;\n"
"      }\n"
"    }\n"
"\n"
"    createTemplate(dv) {\n"
"      return {\n"
"        [MEMORY]: dv,\n"
"        [SLOTS]: {}\n"
"      };\n"
"    }\n"
"\n"
"    beginStructure(def, options = {}) {\n"
"      const {\n"
"        type,\n"
"        name,\n"
"        length,\n"
"        byteSize,\n"
"        align,\n"
"        isConst,\n"
"        hasPointer,\n"
"      } = def;\n"
"      return {\n"
"        constructor: null,\n"
"        typedArray: null,\n"
"        type,\n"
"        name,\n"
"        length,\n"
"        byteSize,\n"
"        align,\n"
"        isConst,\n"
"        hasPointer,\n"
"        instance: {\n"
"          members: [],\n"
"          methods: [],\n"
"          template: null,\n"
"        },\n"
"        static: {\n"
"          members: [],\n"
"          methods: [],\n"
"          template: null,\n"
"        },\n"
"        options,\n"
"      };\n"
"    }\n"
"\n"
"    attachMember(s, member, isStatic = false) {\n"
"      const target = (isStatic) ? s.static : s.instance;\n"
"      target.members.push(member);\n"
"    }\n"
"\n"
"    attachMethod(s, method, isStaticOnly = false) {\n"
"      s.static.methods.push(method);\n"
"      if (!isStaticOnly) {\n"
"        s.instance.methods.push(method);\n"
"      }\n"
"    }\n"
"\n"
"    attachTemplate(s, template, isStatic = false) {\n"
"      const target = (isStatic) ? s.static : s.instance;\n"
"      target.template = template;\n"
"    }\n"
"\n"
"    finalizeStructure(s) {\n"
"      try {\n"
"        const f = getStructureFactory(s.type);\n"
"        const constructor = f(s, this);\n"
"        if (typeof(constructor) === 'function') {\n"
"          Object.defineProperties(constructor, {\n"
"            name: { value: getStructureName(s), writable: false }\n"
"          });\n"
"          if (!constructor.prototype.hasOwnProperty(Symbol.toStringTag)) {\n"
"            Object.defineProperties(constructor.prototype, {\n"
"              [Symbol.toStringTag]: { value: s.name, configurable: true, writable: false }\n"
"            });\n"
"          }\n"
"        }\n"
"        return constructor;\n"
"        /* c8 ignore next 4 */\n"
"      } catch (err) {\n"
"        console.error(err);\n"
"        throw err;\n"
"      }\n"
"    }\n"
"\n"
"    writeToConsole(buffer) {\n"
"      try {\n"
"        const s = decodeText(buffer);\n"
"        // send text up to the last newline character\n"
"        const index = s.lastIndexOf('\\n');\n"
"        if (index === -1) {\n"
"          consolePending += s;\n"
"        } else {\n"
"          console.log(consolePending + s.substring(0, index));\n"
"          consolePending = s.substring(index + 1);\n"
"        }\n"
"        clearTimeout(consoleTimeout);\n"
"        if (consolePending) {\n"
"          consoleTimeout = setTimeout(() => {\n"
"            console.log(consolePending);\n"
"            consolePending = '';\n"
"          }, 250);\n"
"        }\n"
"        /* c8 ignore next 3 */\n"
"      } catch (err) {\n"
"        console.error(err);\n"
"      }\n"
"    }\n"
"\n"
"    flushConsole() {\n"
"      if (consolePending) {\n"
"        console.log(consolePending);\n"
"        consolePending = '';\n"
"        clearTimeout(consoleTimeout);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function getExtraCount(ptrAlign) {\n"
"    const alignment = (1 << ptrAlign);\n"
"    return (alignment <= default_alignment) ? 0 : alignment;\n"
"  }\n"
"\n"
"  // enable all member types (including extend types)\n"
"  useVoid();\n"
"  useBoolEx();\n"
"  useIntEx();\n"
"  useUintEx();\n"
"  useFloatEx();\n"
"  useEnumerationItemEx();\n"
"  useObject();\n"
"  useType();\n"
"\n"
"  // enable all structure types\n"
"  usePrimitive();\n"
"  useArray();\n"
"  useStruct();\n"
"  useArgStruct();\n"
"  useExternUnion();\n"
"  useBareUnion();\n"
"  useTaggedUnion();\n"
"  useErrorUnion();\n"
"  useErrorSet();\n"
"  useEnumeration();\n"
"  useOptional();\n"
"  usePointer();\n"
"  useSlice();\n"
"  useVector();\n"
"  useOpaque();\n"
"\n"
"  class Environment extends BaseEnvironment {\n"
"    invokeFactory(thunk) {\n"
"      initializeErrorSets();\n"
"      const env = new Environment;\n"
"      const result = thunk.call(env);\n"
"      if (typeof(result) === 'string') {\n"
"        // an error message\n"
"        throwZigError(result);\n"
"      }\n"
"      let module = result.constructor;\n"
"      // attach __zigar object\n"
"      const initPromise = Promise.resolve();\n"
"      module.__zigar = {\n"
"        init: () => initPromise,\n"
"        abandon: () => initPromise.then(() => {\n"
"          if (module) {\n"
"            releaseModule(module);\n"
"          }\n"
"          module = null;\n"
"        }),\n"
"        released: () => initPromise.then(() => !module),\n"
"      };\n"
"      return module;\n"
"    }\n"
"  }\n"
"\n"
"  function releaseModule(module) {\n"
"    const released = new Map();\n"
"    const replacement = function() {\n"
"      throw new Error(`Shared library was abandoned`);\n"
"    };\n"
"    const releaseClass = (cls) => {\n"
"      if (!cls || released.get(cls)) {\n"
"        return;\n"
"      }\n"
"      released.set(cls, true);\n"
"      // release static variables--vivificators return pointers\n"
"      const vivificators = cls[CHILD_VIVIFICATOR];\n"
"      if (vivificators) {\n"
"        for (const vivificator of Object.values(vivificators)) {\n"
"          const ptr = vivificator.call(cls);\n"
"          if (ptr) {\n"
"            releaseObject(ptr);\n"
"          }\n"
"        }\n"
"      }\n"
"      for (const [ name, { value, get, set }  ] of Object.entries(Object.getOwnPropertyDescriptors(cls))) {\n"
"        if (typeof(value) === 'function') {\n"
"          // release thunk of static function\n"
"          value[RELEASE_THUNK]?.(replacement);\n"
"        } else if (get && !set) {\n"
"          // the getter might return a type/class/constuctor\n"
"          const child = cls[name];\n"
"          if (typeof(child) === 'function') {\n"
"            releaseClass(child);\n"
"          }\n"
"        }\n"
"      }\n"
"      for (const [ name, { value } ] of Object.entries(Object.getOwnPropertyDescriptors(cls.prototype))) {\n"
"        if (typeof(value) === 'function') {\n"
"          // release thunk of instance function\n"
"          value[RELEASE_THUNK]?.(replacement);\n"
"        }\n"
"      }\n"
"    };\n"
"    const releaseObject = (obj) => {\n"
"      if (!obj || released.get(obj)) {\n"
"        return;\n"
"      }\n"
"      released.set(obj, true);\n"
"      const dv = obj[MEMORY];\n"
"      if (dv.buffer instanceof SharedArrayBuffer) {\n"
"        // create new buffer and copy content from shared memory\n"
"        const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);\n"
"        const ta2 = new Uint8Array(ta);\n"
"        const dv2 = new DataView(ta2.buffer);\n"
"        obj[MEMORY] = dv2;\n"
"      }\n"
"      obj[SLOTS];\n"
"    };\n"
"    releaseClass(module);\n"
"  }\n"
"\n"
"  exports.Environment = Environment;\n"
"\n"
"  return exports;\n"
"\n"
"})({}))"
