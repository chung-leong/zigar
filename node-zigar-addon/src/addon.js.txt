"((function (exports) {\n"
"  'use strict';\n"
"\n"
"  const MemberType = {\r\n"
"    Void: 0,\r\n"
"    Bool: 1,\r\n"
"    Int: 2,\r\n"
"    Uint: 3,\r\n"
"    Float: 4,\r\n"
"    Object: 5,\r\n"
"    Type: 6,\r\n"
"    Comptime: 7,\r\n"
"    Static: 8,\r\n"
"    Literal: 9,\r\n"
"    Null: 10,\r\n"
"    Undefined: 11,\r\n"
"    Unsupported: 12,\r\n"
"  };\r\n"
"\r\n"
"  const StructureType = {\r\n"
"    Primitive: 0,\r\n"
"    Array: 1,\r\n"
"    Struct: 2,\r\n"
"    ExternStruct: 3,\r\n"
"    PackedStruct: 4,\r\n"
"    ArgStruct: 5,\r\n"
"    VariadicStruct: 6,\r\n"
"    ExternUnion: 7,\r\n"
"    BareUnion: 8,\r\n"
"    TaggedUnion: 9,\r\n"
"    ErrorUnion: 10,\r\n"
"    ErrorSet: 11,\r\n"
"    Enum: 12,\r\n"
"    Optional: 13,\r\n"
"    SinglePointer: 14,\r\n"
"    SlicePointer: 15,\r\n"
"    MultiPointer: 16,\r\n"
"    CPointer: 17,\r\n"
"    Slice: 18,\r\n"
"    Vector: 19,\r\n"
"    Opaque: 20,\r\n"
"    Function: 21,\r\n"
"  };\r\n"
"\r\n"
"  function getTypeName(member) {\r\n"
"    const { type, bitSize, byteSize } = member;\r\n"
"    if (type === MemberType.Int) {\r\n"
"      return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;\r\n"
"    } else if (type === MemberType.Uint) {\r\n"
"      return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;\r\n"
"    } else if (type === MemberType.Float) {\r\n"
"      return `Float${bitSize}`;\r\n"
"    } else if (type === MemberType.Bool) {\r\n"
"      const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;\r\n"
"      return `Bool${boolSize}`;\r\n"
"    } else if (type === MemberType.Void) {\r\n"
"      return `Null`;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getStructureName(n) {\r\n"
"    for (const [ name, value ] of Object.entries(StructureType)) {\r\n"
"      if (value === n) {\r\n"
"        return name.replace(/\\B[A-Z]/g, m => ` ${m}`).toLowerCase();\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getIntRange(member) {\r\n"
"    const { type, bitSize } = member;\r\n"
"    const signed = (type === MemberType.Int);\r\n"
"    let magBits = (signed) ? bitSize - 1 : bitSize;\r\n"
"    if (bitSize <= 32) {\r\n"
"      const max = 2 ** magBits - 1;\r\n"
"      const min = (signed) ? -(2 ** magBits) : 0;\r\n"
"      return { min, max };\r\n"
"    } else {\r\n"
"      magBits = BigInt(magBits);\r\n"
"      const max = 2n ** magBits - 1n;\r\n"
"      const min = (signed) ? -(2n ** magBits) : 0n;\r\n"
"      return { min, max };\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getPrimitiveClass({ type, bitSize }) {\r\n"
"    if (type === MemberType.Int || type === MemberType.Uint) {\r\n"
"      if (bitSize <= 32) {\r\n"
"        return Number;\r\n"
"      } else {\r\n"
"        return BigInt;\r\n"
"      }\r\n"
"    } else if (type === MemberType.Float) {\r\n"
"      return Number;\r\n"
"    } else if (type === MemberType.Bool) {\r\n"
"      return Boolean;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getPrimitiveType(member) {\r\n"
"    const Primitive = getPrimitiveClass(member);\r\n"
"    if (Primitive) {\r\n"
"      return typeof(Primitive(0));\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function isPointer(type) {\r\n"
"    switch (type) {\r\n"
"      case StructureType.SinglePointer:\r\n"
"      case StructureType.SlicePointer:\r\n"
"      case StructureType.MultiPointer:\r\n"
"      case StructureType.CPointer:\r\n"
"        return true;\r\n"
"      default:\r\n"
"        return false;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function isArrayLike(type) {\r\n"
"    return type === StructureType.Array || type === StructureType.Vector || type === StructureType.Slice;\r\n"
"  }\r\n"
"\r\n"
"  function isByteAligned({ bitOffset, bitSize, byteSize }) {\r\n"
"    return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;\r\n"
"  }\r\n"
"\r\n"
"  function isErrorJSON(arg) {\r\n"
"    return typeof(arg) === 'object' && typeof(arg.error) === 'string' && Object.keys(arg).length === 1  ;\r\n"
"  }\n"
"\n"
"  class Unsupported extends TypeError {\r\n"
"    constructor() {\r\n"
"      super(`Unsupported`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NoInitializer extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { name } = structure;\r\n"
"      super(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class BufferSizeMismatch extends TypeError {\r\n"
"    constructor(structure, dv, target = null) {\r\n"
"      const { name, type, byteSize } = structure;\r\n"
"      const actual = dv.byteLength;\r\n"
"      const s = (byteSize !== 1) ? 's' : '';\r\n"
"      let msg;\r\n"
"      if (type === StructureType.Slice && !target) {\r\n"
"        msg = `${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`;\r\n"
"      } else {\r\n"
"        const total = (type === StructureType.Slice) ? target.length * byteSize : byteSize;\r\n"
"        msg = `${name} has ${total} byte${s}, received ${actual}`;\r\n"
"      }\r\n"
"      super(msg);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class BufferExpected extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { type, byteSize, typedArray } = structure;\r\n"
"      const s = (byteSize !== 1) ? 's' : '';\r\n"
"      const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle);\r\n"
"      if (typedArray) {\r\n"
"        acceptable.push(addArticle(typedArray.name));\r\n"
"      }\r\n"
"      let msg;\r\n"
"      if (type === StructureType.Slice) {\r\n"
"        msg = `Expecting ${formatList(acceptable)} that can accommodate items ${byteSize} byte${s} in length`;\r\n"
"      } else {\r\n"
"        msg = `Expecting ${formatList(acceptable)} that is ${byteSize} byte${s} in length`;\r\n"
"      }\r\n"
"      super(msg);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class EnumExpected extends TypeError {\r\n"
"    constructor(structure, arg) {\r\n"
"      const { name } = structure;\r\n"
"      let msg;\r\n"
"      if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {\r\n"
"        msg = `Value given does not correspond to an item of enum ${name}: ${arg}`;\r\n"
"      } else {\r\n"
"        msg = `Enum item of the type ${name} expected, received ${arg}`;\r\n"
"      }\r\n"
"      super(msg);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ErrorExpected extends TypeError {\r\n"
"    constructor(structure, arg) {\r\n"
"      const { name } = structure;\r\n"
"      const type = typeof(arg);\r\n"
"      let msg;\r\n"
"      if (type === 'string' || type === 'number' || isErrorJSON(arg)) {\r\n"
"        if (isErrorJSON(arg)) {\r\n"
"          arg = `{ error: ${JSON.stringify(arg.error)} }`;\r\n"
"        }\r\n"
"        msg = `Error ${type} does not corresponds to any error in error set ${name}: ${arg}`;\r\n"
"      } else {\r\n"
"        msg = `Error of the type ${name} expected, received ${arg}`;\r\n"
"      }\r\n"
"      super(msg);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NotInErrorSet extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { name } = structure;\r\n"
"      super(`Error given is not a part of error set ${name}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class MultipleUnionInitializers extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { name } = structure;\r\n"
"      super(`Only one property of ${name} can be given a value`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InactiveUnionProperty extends TypeError {\r\n"
"    constructor(structure, name, currentName) {\r\n"
"      super(`Accessing property ${name} when ${currentName} is active`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class MissingUnionInitializer extends TypeError {\r\n"
"    constructor(structure, arg, exclusion) {\r\n"
"      const { name, instance: { members } } = structure;\r\n"
"      const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);\r\n"
"      super(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InvalidInitializer extends TypeError {\r\n"
"    constructor(structure, expected, arg) {\r\n"
"      const { name } = structure;\r\n"
"      const acceptable = [];\r\n"
"      if (Array.isArray(expected)) {\r\n"
"        for (const type of expected) {\r\n"
"          acceptable.push(addArticle(type));\r\n"
"        }\r\n"
"      } else {\r\n"
"        acceptable.push(addArticle(expected));\r\n"
"      }\r\n"
"      const received = getDescription(arg);\r\n"
"      super(`${name} expects ${formatList(acceptable)} as argument, received ${received}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InvalidArrayInitializer extends InvalidInitializer {\r\n"
"    constructor(structure, arg, shapeless = false) {\r\n"
"      const { instance: { members: [ member ] }, type, typedArray } = structure;\r\n"
"      const acceptable = [];\r\n"
"      const primitive = getPrimitiveType(member);\r\n"
"      if (primitive) {\r\n"
"        let object;\r\n"
"        switch (member.structure?.type) {\r\n"
"          case StructureType.Enum: object = 'enum item'; break;\r\n"
"          case StructureType.ErrorSet: object = 'error'; break;\r\n"
"          default: object = primitive;\r\n"
"        }\r\n"
"        acceptable.push(`array of ${object}s`);\r\n"
"      } else {\r\n"
"        acceptable.push(`array of objects`);\r\n"
"      }\r\n"
"      if (typedArray) {\r\n"
"        acceptable.push(typedArray.name);\r\n"
"      }\r\n"
"      if (type === StructureType.Slice && shapeless) {\r\n"
"        acceptable.push(`length`);\r\n"
"      }\r\n"
"      super(structure, acceptable.join(' or '), arg);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ArrayLengthMismatch extends TypeError {\r\n"
"    constructor(structure, target, arg) {\r\n"
"      const { name, length, instance: { members: [ member ] } } = structure;\r\n"
"      const { structure: { constructor: elementConstructor} } = member;\r\n"
"      const { length: argLength, constructor: argConstructor } = arg;\r\n"
"      // get length from object whech it's a slice\r\n"
"      const actualLength = target?.length ?? length;\r\n"
"      const s = (actualLength !== 1) ? 's' : '';\r\n"
"      let received;\r\n"
"      if (argConstructor === elementConstructor) {\r\n"
"        received = `only a single one`;\r\n"
"      } else if (argConstructor.child === elementConstructor) {\r\n"
"        received = `a slice/array that has ${argLength}`;\r\n"
"      } else {\r\n"
"        received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;\r\n"
"      }\r\n"
"      super(`${name} has ${actualLength} element${s}, received ${received}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InvalidSliceLength extends TypeError {\r\n"
"    constructor(length, max) {\r\n"
"      if (length < 0) {\r\n"
"        super(`Length of slice cannot be negative`);\r\n"
"      } else {\r\n"
"        super(`Length of slice must be less than ${max}, received ${length}`);\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class MissingInitializers extends TypeError {\r\n"
"    constructor(structure, missing) {\r\n"
"      const { name } = structure;\r\n"
"      super(`Missing initializers for ${name}: ${missing.join(', ')}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NoProperty extends TypeError {\r\n"
"    constructor(structure, propName) {\r\n"
"      const { name, instance: { members } } = structure;\r\n"
"      const member = members.find(m => m.name === propName);\r\n"
"      let msg;\r\n"
"      if (member) {\r\n"
"        msg = `Comptime value cannot be changed: ${propName}`;\r\n"
"      } else {\r\n"
"        msg = `${name} does not have a property with that name: ${propName}`;\r\n"
"      }\r\n"
"      super(msg);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ArgumentCountMismatch extends Error {\r\n"
"    constructor(name, expected, actual) {\r\n"
"      const s = (expected !== 1) ? 's' : '';\r\n"
"      super(`${name}() expects ${expected} argument${s}, received ${actual}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NoCastingToPointer extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      super(`Non-slice pointers can only be created with the help of the new operator`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ConstantConstraint extends TypeError {\r\n"
"    constructor(structure, pointer) {\r\n"
"      const { name: target } = structure;\r\n"
"      const { constructor: { name } } = pointer;\r\n"
"      super(`Conversion of ${name} to ${target} requires an explicit cast`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class MisplacedSentinel extends TypeError {\r\n"
"    constructor(structure, value, index, length) {\r\n"
"      const { name } = structure;\r\n"
"      super(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class MissingSentinel extends TypeError {\r\n"
"    constructor(structure, value, length) {\r\n"
"      const { name } = structure;\r\n"
"      super(`${name} expects the sentinel value ${value} at ${length - 1}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class AlignmentConflict extends TypeError {\r\n"
"    constructor(align1, align2) {\r\n"
"      super(`Unable to simultaneously align memory to ${align2}-byte and ${align1}-byte boundary`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class TypeMismatch extends TypeError {\r\n"
"    constructor(expected, arg) {\r\n"
"      const received = getDescription(arg);\r\n"
"      super(`Expected ${addArticle(expected)}, received ${received}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InaccessiblePointer extends TypeError {\r\n"
"    constructor() {\r\n"
"      super(`Pointers within an untagged union are not accessible`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NullPointer extends TypeError {\r\n"
"    constructor() {\r\n"
"      super(`Null pointer`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InvalidPointerTarget extends TypeError {\r\n"
"    constructor(structure, arg) {\r\n"
"      const { name } = structure;\r\n"
"      let target;\r\n"
"      if (arg != null) {\r\n"
"        const type = typeof(arg);\r\n"
"        const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;\r\n"
"        const a = article(noun);\r\n"
"        target = `${a} ${noun}`;\r\n"
"      } else {\r\n"
"        target = arg + '';\r\n"
"      }\r\n"
"      super(`${name} cannot point to ${target}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class FixedMemoryTargetRequired extends TypeError {\r\n"
"    constructor(structure, arg) {\r\n"
"      super(`Pointers in fixed memory cannot point to garbage-collected object`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class Overflow extends TypeError {\r\n"
"    constructor(member, value) {\r\n"
"      const typeName = getTypeName(member);\r\n"
"      super(`${typeName} cannot represent the value given: ${value}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class OutOfBound extends RangeError {\r\n"
"    constructor(member, index) {\r\n"
"      const { name } = member;\r\n"
"      super(`Index exceeds the size of ${name ?? 'array'}: ${index}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NotUndefined extends TypeError {\r\n"
"    constructor(member) {\r\n"
"      const { name } = member;\r\n"
"      const rvalue = (name !== undefined) ? `Property ${name}` : `Element`;\r\n"
"      super(`${rvalue} can only be undefined`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class NotOnByteBoundary extends TypeError {\r\n"
"    constructor(member) {\r\n"
"      const { name, structure: { name: { struct }} } = member;\r\n"
"      super(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ReadOnly extends TypeError {\r\n"
"    constructor() {\r\n"
"      super(`Unable to modify read-only object`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ReadOnlyTarget extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { name } = structure;\r\n"
"      super(`${name} cannot point to a read-only object`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class AccessingOpaque extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { name } = structure;\r\n"
"      super(`Unable to access opaque structure ${name}`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class CreatingOpaque extends TypeError {\r\n"
"    constructor(structure) {\r\n"
"      const { name } = structure;\r\n"
"      super(`Unable to create instance of ${name}, as it is opaque`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class InvalidVariadicArgument extends TypeError {\r\n"
"    constructor() {\r\n"
"      super(`Arguments passed to variadic function must be casted to a Zig type`);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  class ZigError extends Error {\r\n"
"    constructor(name) {\r\n"
"      super(deanimalizeErrorName(name));\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function adjustArgumentError(name, index, argCount, err) {\r\n"
"    // Zig currently does not provide the argument name\r\n"
"    const argName = `args[${index}]`;\r\n"
"    const prefix = (index !== 0) ? '..., ' : '';\r\n"
"    const suffix = (index !== argCount - 1) ? ', ...' : '';\r\n"
"    const argLabel = prefix + argName + suffix;\r\n"
"    const newError = Object.create(err.constructor.prototype);\r\n"
"    newError.message = `${name}(${argLabel}): ${err.message}`;\r\n"
"    newError.stack = err.stack;\r\n"
"    return newError;\r\n"
"  }\r\n"
"\r\n"
"  function adjustRangeError(member, index, err) {\r\n"
"    if (err instanceof RangeError && !(err instanceof OutOfBound)) {\r\n"
"      err = new OutOfBound(member, index);\r\n"
"    }\r\n"
"    return err;\r\n"
"  }\r\n"
"\r\n"
"  function throwReadOnly() {\r\n"
"    throw new ReadOnly();\r\n"
"  }\r\n"
"\r\n"
"  function warnImplicitArrayCreation(structure, arg) {\r\n"
"    const created = addArticle(structure.typedArray.name);\r\n"
"    const source = addArticle(arg.constructor.name);\r\n"
"    console.warn(`Implicitly creating ${created} from ${source}`);\r\n"
"  }\r\n"
"\r\n"
"  function deanimalizeErrorName(name) {\r\n"
"    // deal with snake_case first\r\n"
"    let s = name.replace(/_/g, ' ');\r\n"
"    // then camelCase, using a try block in case Unicode regex fails\r\n"
"    try {\r\n"
"      s = s.replace(/(\\p{Uppercase}+)(\\p{Lowercase}*)/gu, (m0, m1, m2) => {\r\n"
"        if (m1.length === 1) {\r\n"
"          return ` ${m1.toLocaleLowerCase()}${m2}`;\r\n"
"        } else {\r\n"
"          if (m2) {\r\n"
"            return m0;\r\n"
"          } else {\r\n"
"            return ` ${m1}`;\r\n"
"          }\r\n"
"        }\r\n"
"      }).trimStart();\r\n"
"      /* c8 ignore next 2 */\r\n"
"    } catch (err) {\r\n"
"    }\r\n"
"    return s.charAt(0).toLocaleUpperCase() + s.substring(1);\r\n"
"  }\r\n"
"\r\n"
"  function getDescription(arg) {\r\n"
"    const type = typeof(arg);\r\n"
"    let s;\r\n"
"    if (type === 'object') {\r\n"
"      s = (arg) ? Object.prototype.toString.call(arg) : 'null';\r\n"
"    } else {\r\n"
"      s = type;\r\n"
"    }\r\n"
"    return addArticle(s);\r\n"
"  }\r\n"
"\r\n"
"  function addArticle(noun) {\r\n"
"    return `${article(noun)} ${noun}`;\r\n"
"  }\r\n"
"\r\n"
"  function article(noun) {\r\n"
"    return /^\\W*[aeiou]/i.test(noun) ? 'an' : 'a';\r\n"
"  }\r\n"
"\r\n"
"  function formatList(list, conj = 'or') {\r\n"
"    const sep = ` ${conj} `;\r\n"
"    if (list.length > 2) {\r\n"
"      return list.slice(0, -1).join(', ') + sep + list[list.length - 1];\r\n"
"    } else {\r\n"
"      return list.join(sep);\r\n"
"    }\r\n"
"  }\n"
"\n"
"  const MEMORY = Symbol('memory');\r\n"
"  const SLOTS = Symbol('slots');\r\n"
"  const PARENT = Symbol('parent');\r\n"
"  const FIXED = Symbol('fixed');\r\n"
"  const NAME = Symbol('name');\r\n"
"  const TYPE = Symbol('type');\r\n"
"  const TUPLE = Symbol('tuple');\r\n"
"  const CLASS = Symbol('class');\r\n"
"  const TAG = Symbol('tag');\r\n"
"  const PROPS = Symbol('props');\r\n"
"  const GETTER = Symbol('getter');\r\n"
"  const SETTER = Symbol('setter');\r\n"
"  const ELEMENT_GETTER = Symbol('elementGetter');\r\n"
"  const ELEMENT_SETTER = Symbol('elementSetter');\r\n"
"  const TARGET_GETTER = Symbol('targetGetter');\r\n"
"  const TARGET_SETTER = Symbol('targetSetter');\r\n"
"  const ENTRIES_GETTER = Symbol('entriesGetter');\r\n"
"  const ADDRESS_SETTER = Symbol('addressSetter');\r\n"
"  const LENGTH_SETTER = Symbol('lengthSetter');\r\n"
"  const TARGET_UPDATER = Symbol('targetUpdater');\r\n"
"  const MAX_LENGTH = Symbol('maxLength');\r\n"
"  const PROP_GETTERS = Symbol('propGetters');\r\n"
"  const PROP_SETTERS = Symbol('propSetters');\r\n"
"  const WRITE_DISABLER = Symbol('writeDisabler');\r\n"
"  const ALL_KEYS = Symbol('allKeys');\r\n"
"  const ADDRESS = Symbol('address');\r\n"
"  const LENGTH = Symbol('length');\r\n"
"  const PROXY = Symbol('proxy');\r\n"
"  const COMPAT = Symbol('compat');\r\n"
"  const CACHE = Symbol('cache');\r\n"
"  const SIZE = Symbol('size');\r\n"
"  const ALIGN = Symbol('align');\r\n"
"  const ARRAY = Symbol('array');\r\n"
"  const POINTER = Symbol('pointer');\r\n"
"  const CONST_TARGET = Symbol('constTarget');\r\n"
"  const CONST_PROXY = Symbol('constProxy');\r\n"
"  const COPIER = Symbol('copier');\r\n"
"  const RESETTER = Symbol('resetter');\r\n"
"  const VIVIFICATOR = Symbol('vivificator');\r\n"
"  const POINTER_VISITOR = Symbol('pointerVisitor');\r\n"
"  const ENVIRONMENT = Symbol('environment');\r\n"
"  const ATTRIBUTES = Symbol('attributes');\r\n"
"  const MORE = Symbol('more');\r\n"
"  const PRIMITIVE = Symbol('primitive');\n"
"\n"
"  function getDestructor(env) {\r\n"
"    return function() {\r\n"
"      const dv = this[MEMORY];\r\n"
"      this[MEMORY] = null;\r\n"
"      if (this[SLOTS]) {\r\n"
"        this[SLOTS] = {};\r\n"
"      }\r\n"
"      if (dv[FIXED]) {\r\n"
"        env.releaseFixedView(dv);\r\n"
"      }\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getBitAlignFunction(bitPos, bitSize, toAligned) {\r\n"
"    if (bitPos + bitSize <= 8) {\r\n"
"      const mask = (2 ** bitSize) - 1;\r\n"
"      if (toAligned) {\r\n"
"        // from single byte\r\n"
"        return function(dest, src, offset) {\r\n"
"          const n = src.getUint8(offset);\r\n"
"          const b = (n >> bitPos) & mask;\r\n"
"          dest.setUint8(0, b);\r\n"
"        };\r\n"
"      } else {\r\n"
"        // to single byte\r\n"
"        const destMask = 0xFF ^ (mask << bitPos);\r\n"
"        return function(dest, src, offset) {\r\n"
"          const n = src.getUint8(0);\r\n"
"          const d = dest.getUint8(offset);\r\n"
"          const b = (d & destMask) | ((n & mask) << bitPos);\r\n"
"          dest.setUint8(offset, b);\r\n"
"        };\r\n"
"      }\r\n"
"    } else {\r\n"
"      const leadBits = 8 - bitPos;\r\n"
"      const leadMask = (2 ** leadBits) - 1;\r\n"
"      if (toAligned) {\r\n"
"        const trailBits = bitSize % 8;\r\n"
"        const trailMask = (2 ** trailBits) - 1;\r\n"
"        return function(dest, src, offset) {\r\n"
"          let i = offset, j = 0;\r\n"
"          let n = src.getUint8(i++), b;\r\n"
"          let bitBuf = (n >> bitPos) & leadMask;\r\n"
"          let bitCount = leadBits;\r\n"
"          let remaining = bitSize;\r\n"
"          do {\r\n"
"            if (remaining > bitCount) {\r\n"
"              n = src.getUint8(i++);\r\n"
"              bitBuf = bitBuf | (n << bitCount);\r\n"
"              //bitCount += 8;\r\n"
"            }\r\n"
"            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;\r\n"
"            dest.setUint8(j++, b);\r\n"
"            bitBuf >>= 8;\r\n"
"            //bitCount -= 8;\r\n"
"            remaining -= 8;\r\n"
"          } while (remaining > 0);\r\n"
"        }\r\n"
"      } else {\r\n"
"        const trailBits = (bitSize - leadBits) % 8;\r\n"
"        const trailMask = (2 ** trailBits) - 1;\r\n"
"        const destMask1 = 0xFF ^ (leadMask << bitPos);\r\n"
"        const destMask2 = 0xFF ^ trailMask;\r\n"
"        return function(dest, src, offset) {\r\n"
"          let i = 0, j = offset;\r\n"
"          // preserve bits ahead of bitPos\r\n"
"          let d = dest.getUint8(j), n, b;\r\n"
"          let bitBuf = d & destMask1;\r\n"
"          let bitCount = bitPos;\r\n"
"          let remaining = bitSize + bitCount;\r\n"
"          do {\r\n"
"            if (remaining > bitCount) {\r\n"
"              n = src.getUint8(i++);\r\n"
"              bitBuf = bitBuf | (n << bitCount);\r\n"
"              bitCount += 8;\r\n"
"            }\r\n"
"            if (remaining >= 8) {\r\n"
"              b = bitBuf & 0xFF;\r\n"
"            } else {\r\n"
"              // preserve bits at the destination sitting behind the trailing bits\r\n"
"              d = dest.getUint8(j);\r\n"
"              b = (d & destMask2) | (bitBuf & trailMask);\r\n"
"            }\r\n"
"            dest.setUint8(j++, b);\r\n"
"            bitBuf >>= 8;\r\n"
"            bitCount -= 8;\r\n"
"            remaining -= 8;\r\n"
"          } while (remaining > 0);\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getMemoryCopier(size, multiple = false) {\r\n"
"    const copy = getCopyFunction(size, multiple);\r\n"
"    return function(target) {\r\n"
"\r\n"
"      const src = target[MEMORY];\r\n"
"      const dest = this[MEMORY];\r\n"
"      copy(dest, src);\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getCopyFunction(size, multiple = false) {\r\n"
"    if (size !== undefined) {\r\n"
"      if (!multiple) {\r\n"
"        const copier = copiers[size];\r\n"
"        if (copier) {\r\n"
"          return copier;\r\n"
"        }\r\n"
"      }\r\n"
"      if (!(size & 0x07)) return copy8x;\r\n"
"      if (!(size & 0x03)) return copy4x;\r\n"
"      if (!(size & 0x01)) return copy2x;\r\n"
"      return copy1x;\r\n"
"    } else {\r\n"
"      return copyAny;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function copyAny(dest, src) {\r\n"
"    const copy = getCopyFunction(dest.byteLength);\r\n"
"    copy(dest, src);\r\n"
"  }\r\n"
"\r\n"
"  const copiers = {\r\n"
"    1: copy1,\r\n"
"    2: copy2,\r\n"
"    4: copy4,\r\n"
"    8: copy8,\r\n"
"    16: copy16,\r\n"
"    32: copy32,\r\n"
"  };\r\n"
"\r\n"
"  function copy1x(dest, src) {\r\n"
"    for (let i = 0, len = dest.byteLength; i < len; i++) {\r\n"
"      dest.setInt8(i, src.getInt8(i));\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function copy2x(dest, src) {\r\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 2) {\r\n"
"      dest.setInt16(i, src.getInt16(i, true), true);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function copy4x(dest, src) {\r\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 4) {\r\n"
"      dest.setInt32(i, src.getInt32(i, true), true);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function copy8x(dest, src) {\r\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 8) {\r\n"
"      dest.setInt32(i, src.getInt32(i, true), true);\r\n"
"      dest.setInt32(i + 4, src.getInt32(i + 4, true), true);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function copy1(dest, src) {\r\n"
"    dest.setInt8(0, src.getInt8(0));\r\n"
"  }\r\n"
"\r\n"
"  function copy2(dest, src) {\r\n"
"    dest.setInt16(0, src.getInt16(0, true), true);\r\n"
"  }\r\n"
"\r\n"
"  function copy4(dest, src) {\r\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\r\n"
"  }\r\n"
"\r\n"
"  function copy8(dest, src) {\r\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\r\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\r\n"
"  }\r\n"
"\r\n"
"  function copy16(dest, src) {\r\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\r\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\r\n"
"    dest.setInt32(8, src.getInt32(8, true), true);\r\n"
"    dest.setInt32(12, src.getInt32(12, true), true);\r\n"
"  }\r\n"
"\r\n"
"  function copy32(dest, src) {\r\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\r\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\r\n"
"    dest.setInt32(8, src.getInt32(8, true), true);\r\n"
"    dest.setInt32(12, src.getInt32(12, true), true);\r\n"
"    dest.setInt32(16, src.getInt32(16, true), true);\r\n"
"    dest.setInt32(20, src.getInt32(20, true), true);\r\n"
"    dest.setInt32(24, src.getInt32(24, true), true);\r\n"
"    dest.setInt32(28, src.getInt32(28, true), true);\r\n"
"  }\r\n"
"\r\n"
"  function getMemoryResetter(offset, size) {\r\n"
"    const reset = getResetFunction(size);\r\n"
"    return function() {\r\n"
"\r\n"
"      const dest = this[MEMORY];\r\n"
"      reset(dest, offset, size);\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getResetFunction(size) {\r\n"
"    const resetter = resetters[size];\r\n"
"    if (resetter) {\r\n"
"      return resetter;\r\n"
"    }\r\n"
"    if (!(size & 0x07)) return reset8x;\r\n"
"    if (!(size & 0x03)) return reset4x;\r\n"
"    if (!(size & 0x01)) return reset2x;\r\n"
"    return reset1x;\r\n"
"  }\r\n"
"\r\n"
"  const resetters = {\r\n"
"    1: reset1,\r\n"
"    2: reset2,\r\n"
"    4: reset4,\r\n"
"    8: reset8,\r\n"
"    16: reset16,\r\n"
"    32: reset32,\r\n"
"  };\r\n"
"\r\n"
"  function reset1x(dest, offset, size) {\r\n"
"    for (let i = offset, limit = offset + size; i < limit; i++) {\r\n"
"      dest.setInt8(i, 0);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function reset2x(dest, offset, size) {\r\n"
"    for (let i = offset, limit = offset + size; i < limit; i += 2) {\r\n"
"      dest.setInt16(i, 0, true);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function reset4x(dest, offset, size) {\r\n"
"    for (let i = offset, limit = offset + size; i < limit; i += 4) {\r\n"
"      dest.setInt32(i, 0, true);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function reset8x(dest, offset, size) {\r\n"
"    for (let i = offset, limit = offset + size; i < limit; i += 8) {\r\n"
"      dest.setInt32(i, 0, true);\r\n"
"      dest.setInt32(i + 4, 0, true);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function reset1(dest, offset) {\r\n"
"    dest.setInt8(offset, 0);\r\n"
"  }\r\n"
"\r\n"
"  function reset2(dest, offset) {\r\n"
"    dest.setInt16(offset, 0, true);\r\n"
"  }\r\n"
"\r\n"
"  function reset4(dest, offset) {\r\n"
"    dest.setInt32(offset, 0, true);\r\n"
"  }\r\n"
"\r\n"
"  function reset8(dest, offset) {\r\n"
"    dest.setInt32(offset + 0, 0, true);\r\n"
"    dest.setInt32(offset + 4, 0, true);\r\n"
"  }\r\n"
"\r\n"
"  function reset16(dest, offset) {\r\n"
"    dest.setInt32(offset + 0, 0, true);\r\n"
"    dest.setInt32(offset + 4, 0, true);\r\n"
"    dest.setInt32(offset + 8, 0, true);\r\n"
"    dest.setInt32(offset + 12, 0, true);\r\n"
"  }\r\n"
"\r\n"
"  function reset32(dest, offset) {\r\n"
"    dest.setInt32(offset + 0, 0, true);\r\n"
"    dest.setInt32(offset + 4, 0, true);\r\n"
"    dest.setInt32(offset + 8, 0, true);\r\n"
"    dest.setInt32(offset + 12, 0, true);\r\n"
"    dest.setInt32(offset + 16, 0, true);\r\n"
"    dest.setInt32(offset + 20, 0, true);\r\n"
"    dest.setInt32(offset + 24, 0, true);\r\n"
"    dest.setInt32(offset + 28, 0, true);\r\n"
"  }\n"
"\n"
"  function getBoolAccessor(access, member) {\r\n"
"    return cacheMethod(access, member, () => {\r\n"
"      if (isByteAligned(member)) {\r\n"
"        const { byteSize } = member;\r\n"
"        const typeName = getTypeName({ type: MemberType.Int, bitSize: byteSize * 8 });\r\n"
"        if (access === 'get') {\r\n"
"          const get = DataView.prototype[`get${typeName}`];\r\n"
"          return function(offset, littleEndian) {\r\n"
"            return !!get.call(this, offset, littleEndian);\r\n"
"          };\r\n"
"        } else {\r\n"
"          const set = DataView.prototype[`set${typeName}`];\r\n"
"          const T = (byteSize > 4) ? 1n : 1;\r\n"
"          const F = (byteSize > 4) ? 0n : 0;\r\n"
"          return function(offset, value, littleEndian) {\r\n"
"            set.call(this, offset, value ? T : F, littleEndian);\r\n"
"          };\r\n"
"        }\r\n"
"      } else {\r\n"
"        return getExtendedTypeAccessor(access, member);\r\n"
"      }\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getNumericAccessor(access, member) {\r\n"
"    return cacheMethod(access, member, (name) => {\r\n"
"      if (DataView.prototype[name]) {\r\n"
"        return DataView.prototype[name];\r\n"
"      } else {\r\n"
"        return getExtendedTypeAccessor(access, member);\r\n"
"      }\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  const factories$2 = {};\r\n"
"\r\n"
"  function useExtendedBool() {\r\n"
"    factories$2[MemberType.Bool] = getExtendedBoolAccessor;\r\n"
"  }\r\n"
"\r\n"
"  function useExtendedInt() {\r\n"
"    factories$2[MemberType.Int] = getExtendedIntAccessor;\r\n"
"  }\r\n"
"\r\n"
"  function useExtendedUint() {\r\n"
"    factories$2[MemberType.Uint] = getExtendedUintAccessor;\r\n"
"  }\r\n"
"\r\n"
"  function useExtendedFloat() {\r\n"
"    factories$2[MemberType.Float] = getExtendedFloatAccessor;\r\n"
"  }\r\n"
"\r\n"
"  function getExtendedTypeAccessor(access, member) {\r\n"
"    const f = factories$2[member.type];\r\n"
"\r\n"
"    return f(access, member);\r\n"
"  }\r\n"
"\r\n"
"  function getExtendedBoolAccessor(access, member) {\r\n"
"    const { bitOffset } = member;\r\n"
"    const bitPos = bitOffset & 0x07;\r\n"
"    const mask = 1 << bitPos;\r\n"
"    const get = DataView.prototype.getInt8;\r\n"
"    if (access === 'get') {\r\n"
"      return function(offset) {\r\n"
"        const n = get.call(this, offset);\r\n"
"        return !!(n & mask);\r\n"
"      };\r\n"
"    } else {\r\n"
"      const set = DataView.prototype.setInt8;\r\n"
"      return function(offset, value) {\r\n"
"        const n = get.call(this, offset);\r\n"
"        const b = (value) ? n | mask : n & ~mask;\r\n"
"        set.call(this, offset, b);\r\n"
"      };\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getExtendedIntAccessor(access, member) {\r\n"
"    if (isByteAligned(member)) {\r\n"
"      return getAlignedIntAccessor(access, member)\r\n"
"    } else {\r\n"
"      return getUnalignedIntAccessor(access, member);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getExtendedUintAccessor(access, member) {\r\n"
"    if (isByteAligned(member)) {\r\n"
"      return getAlignedUintAccessor(access, member)\r\n"
"    } else {\r\n"
"      return getUnalignedUintAccessor(access, member);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getExtendedFloatAccessor(access, member) {\r\n"
"    if (isByteAligned(member)) {\r\n"
"      return getAlignedFloatAccessor(access, member)\r\n"
"    } else {\r\n"
"      return getUnalignedFloatAccessor(access, member);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getDataView(structure, arg, env) {\r\n"
"    const { type, byteSize, typedArray } = structure;\r\n"
"    let dv;\r\n"
"    // not using instanceof just in case we're getting objects created in other contexts\r\n"
"    const tag = arg?.[Symbol.toStringTag];\r\n"
"    if (tag === 'DataView') {\r\n"
"      // capture relationship between the view and its buffer\r\n"
"      dv = env.registerView(arg);\r\n"
"    } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {\r\n"
"      dv = env.obtainView(arg, 0, arg.byteLength);\r\n"
"    } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {\r\n"
"      dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);\r\n"
"    } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {\r\n"
"      dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);\r\n"
"    } else {\r\n"
"      const memory = arg?.[MEMORY];\r\n"
"      if (memory) {\r\n"
"        // arg a Zig data object\r\n"
"        const { constructor, instance: { members: [ member ] } } = structure;\r\n"
"        if (arg instanceof constructor) {\r\n"
"          // same type, no problem\r\n"
"          return memory;\r\n"
"        } else {\r\n"
"          if (isArrayLike(type)) {\r\n"
"            // make sure the arg has the same type of elements\r\n"
"            const { byteSize: elementSize, structure: { constructor: Child } } = member;\r\n"
"            const number = findElements(arg, Child);\r\n"
"            if (number !== undefined) {\r\n"
"              if (type === StructureType.Slice || number * elementSize === byteSize) {\r\n"
"                return memory;\r\n"
"              } else {\r\n"
"                throw new ArrayLengthMismatch(structure, null, arg);\r\n"
"              }\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"    if (dv && byteSize !== undefined) {\r\n"
"      checkDataViewSize(dv, structure);\r\n"
"    }\r\n"
"    return dv;\r\n"
"  }\r\n"
"\r\n"
"  function checkDataView(dv) {\r\n"
"    if (dv?.[Symbol.toStringTag] !== 'DataView') {\r\n"
"      throw new TypeMismatch('a DataView', dv);\r\n"
"    }\r\n"
"    return dv;\r\n"
"  }\r\n"
"\r\n"
"  function checkDataViewSize(dv, structure) {\r\n"
"    const { byteSize, type } = structure;\r\n"
"    const isSizeMatching = type === StructureType.Slice\r\n"
"    ? dv.byteLength % byteSize === 0\r\n"
"    : dv.byteLength === byteSize;\r\n"
"    if (!isSizeMatching) {\r\n"
"      throw new BufferSizeMismatch(structure, dv);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function setDataView(dv, structure, copy, fixed, handlers) {\r\n"
"    const { byteSize, type, sentinel } = structure;\r\n"
"    if (!this[MEMORY]) {\r\n"
"      const { shapeDefiner } = handlers;\r\n"
"      checkDataViewSize(dv, structure);\r\n"
"      const len = dv.byteLength / byteSize;\r\n"
"      const source = { [MEMORY]: dv };\r\n"
"      sentinel?.validateData(source, len);\r\n"
"      if (fixed) {\r\n"
"        // need to copy when target object is in fixed memory\r\n"
"        copy = true;\r\n"
"      }\r\n"
"      shapeDefiner.call(this, copy ? null : dv, len, fixed);\r\n"
"      if (copy) {\r\n"
"        this[COPIER](source);\r\n"
"      }\r\n"
"    } else {\r\n"
"      const byteLength = (type === StructureType.Slice) ? byteSize * this.length : byteSize;\r\n"
"      if (dv.byteLength !== byteLength) {\r\n"
"        throw new BufferSizeMismatch(structure, dv, this);\r\n"
"      }\r\n"
"      const source = { [MEMORY]: dv };\r\n"
"      sentinel?.validateData(source, this.length);\r\n"
"      this[COPIER](source);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function findElements(arg, Child) {\r\n"
"    // casting to a array/slice\r\n"
"    const { constructor: Arg } = arg;\r\n"
"    if (Arg === Child) {\r\n"
"      // matching object\r\n"
"      return 1;\r\n"
"    } else if (Arg.child === Child) {\r\n"
"      // matching slice/array\r\n"
"      return arg.length;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function requireDataView(structure, arg, env) {\r\n"
"    const dv = getDataView(structure, arg, env);\r\n"
"    if (!dv) {\r\n"
"      throw new BufferExpected(structure);\r\n"
"    }\r\n"
"    return dv;\r\n"
"  }\r\n"
"\r\n"
"  function getTypedArrayClass(member) {\r\n"
"    const { type: memberType, byteSize } = member;\r\n"
"    if (memberType === MemberType.Int) {\r\n"
"      switch (byteSize) {\r\n"
"        case 1: return Int8Array;\r\n"
"        case 2: return Int16Array;\r\n"
"        case 4: return Int32Array;\r\n"
"        case 8: return BigInt64Array;\r\n"
"      }\r\n"
"    } else if (memberType === MemberType.Uint) {\r\n"
"      switch (byteSize) {\r\n"
"        case 1: return Uint8Array;\r\n"
"        case 2: return Uint16Array;\r\n"
"        case 4: return Uint32Array;\r\n"
"        case 8: return BigUint64Array;\r\n"
"      }\r\n"
"    } else if (memberType === MemberType.Float) {\r\n"
"      switch (byteSize) {\r\n"
"        case 4: return Float32Array;\r\n"
"        case 8: return Float64Array;\r\n"
"      }\r\n"
"    } else if (memberType === MemberType.Object) {\r\n"
"      return member.structure.typedArray;\r\n"
"    }\r\n"
"    return null;\r\n"
"  }\r\n"
"\r\n"
"  function isTypedArray(arg, TypedArray) {\r\n"
"    const tag = arg?.[Symbol.toStringTag];\r\n"
"    return (!!TypedArray && tag === TypedArray.name);\r\n"
"  }\r\n"
"\r\n"
"  function isCompatible(arg, constructor) {\r\n"
"    const tags = constructor[COMPAT];\r\n"
"    if (tags) {\r\n"
"      const tag = arg?.[Symbol.toStringTag];\r\n"
"      if (tags.includes(tag)) {\r\n"
"        return true;\r\n"
"      }\r\n"
"    }\r\n"
"    if (constructor.child) {\r\n"
"      if (findElements(arg, constructor.child) !== undefined) {\r\n"
"        return true;\r\n"
"      }\r\n"
"    }\r\n"
"    return false;\r\n"
"  }\r\n"
"\r\n"
"  function getCompatibleTags(structure) {\r\n"
"    const { typedArray } = structure;\r\n"
"    const tags = [];\r\n"
"    if (typedArray) {\r\n"
"      tags.push(typedArray.name);\r\n"
"      tags.push('DataView');\r\n"
"      if (typedArray === Uint8Array || typedArray === Int8Array) {\r\n"
"        tags.push('ArrayBuffer');\r\n"
"        tags.push('SharedArrayBuffer');\r\n"
"        if (typedArray === Uint8Array) {\r\n"
"          tags.push('Uint8ClampedArray');\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"    return tags;\r\n"
"  }\r\n"
"\r\n"
"  function getBigIntDescriptor(bitSize) {\r\n"
"    const getWord = DataView.prototype.getBigUint64;\r\n"
"    const setWord = DataView.prototype.setBigUint64;\r\n"
"    const wordCount = Math.ceil(bitSize / 64);\r\n"
"    return {\r\n"
"      get: function(offset, littleEndian) {\r\n"
"        let n = 0n;\r\n"
"        if (littleEndian) {\r\n"
"          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\r\n"
"            const w = getWord.call(this, j, littleEndian);\r\n"
"            n = (n << 64n) | w;\r\n"
"          }\r\n"
"        } else {\r\n"
"          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\r\n"
"            const w = getWord.call(this, j, littleEndian);\r\n"
"            n = (n << 64n) | w;\r\n"
"          }\r\n"
"        }\r\n"
"        return n;\r\n"
"      },\r\n"
"      set: function(offset, value, littleEndian) {\r\n"
"        let n = value;\r\n"
"        const mask = 0xFFFFFFFFFFFFFFFFn;\r\n"
"        if (littleEndian) {\r\n"
"          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\r\n"
"            const w = n & mask;\r\n"
"            setWord.call(this, j, w, littleEndian);\r\n"
"            n >>= 64n;\r\n"
"          }\r\n"
"        } else {\r\n"
"          n <<= BigInt(wordCount * 64 - bitSize);\r\n"
"          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\r\n"
"            const w = n & mask;\r\n"
"            setWord.call(this, j, w, littleEndian);\r\n"
"            n >>= 64n;\r\n"
"          }\r\n"
"        }\r\n"
"        return n;\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getAlignedIntAccessor(access, member) {\r\n"
"    const { bitSize, byteSize } = member;\r\n"
"    if (bitSize < 64) {\r\n"
"      // actual number of bits needed when stored aligned\r\n"
"      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });\r\n"
"      const get = DataView.prototype[`get${typeName}`];\r\n"
"      const set = DataView.prototype[`set${typeName}`];\r\n"
"      const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);\r\n"
"      const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          return (n & valueMask) - (n & signMask);\r\n"
"        };\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\r\n"
"          set.call(this, offset, n, littleEndian);\r\n"
"        };\r\n"
"      }\r\n"
"    } else {\r\n"
"      // larger than 64 bits\r\n"
"      const { get, set } = getBigIntDescriptor(bitSize);\r\n"
"      const signMask = 2n ** BigInt(bitSize - 1);\r\n"
"      const valueMask = signMask - 1n;\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          return (n & valueMask) - (n & signMask);\r\n"
"        };\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\r\n"
"          set.call(this, offset, n, littleEndian);\r\n"
"        };\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getAlignedUintAccessor(access, member) {\r\n"
"    const { bitSize, byteSize } = member;\r\n"
"    if (bitSize < 64) {\r\n"
"      // actual number of bits needed when stored aligned\r\n"
"      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });\r\n"
"      const get = DataView.prototype[`get${typeName}`];\r\n"
"      const set = DataView.prototype[`set${typeName}`];\r\n"
"      const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          return n & valueMask;\r\n"
"        };\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          const n = value & valueMask;\r\n"
"          set.call(this, offset, n, littleEndian);\r\n"
"        };\r\n"
"      }\r\n"
"    } else {\r\n"
"      // larger than 64 bits\r\n"
"      const { get, set } = getBigIntDescriptor(bitSize);\r\n"
"      const valueMask = (2n ** BigInt(bitSize)) - 1n;\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          return n & valueMask;\r\n"
"        };\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          const n = value & valueMask;\r\n"
"          set.call(this, offset, n, littleEndian);\r\n"
"        };\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getUnalignedIntAccessor(access, member) {\r\n"
"    const { bitSize, bitOffset } = member;\r\n"
"    const bitPos = bitOffset & 0x07;\r\n"
"    if (bitPos + bitSize <= 8) {\r\n"
"      const set = DataView.prototype.setUint8;\r\n"
"      const get = DataView.prototype.getUint8;\r\n"
"      // sub-8-bit numbers have real use cases\r\n"
"      const signMask = 2 ** (bitSize - 1);\r\n"
"      const valueMask = signMask - 1;\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset) {\r\n"
"          const n = get.call(this, offset);\r\n"
"          const s = n >>> bitPos;\r\n"
"          return (s & valueMask) - (s & signMask);\r\n"
"        };\r\n"
"      } else {\r\n"
"        const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);\r\n"
"        return function(offset, value) {\r\n"
"          let b = get.call(this, offset);\r\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\r\n"
"          b = (b & outsideMask) | (n << bitPos);\r\n"
"          set.call(this, offset, b);\r\n"
"        };\r\n"
"      }\r\n"
"    }\r\n"
"    return getUnalignedNumericAccessor(access, member);\r\n"
"  }\r\n"
"\r\n"
"  function getUnalignedUintAccessor(access, member) {\r\n"
"    const { bitSize, bitOffset } = member;\r\n"
"    const bitPos = bitOffset & 0x07;\r\n"
"    if (bitPos + bitSize <= 8) {\r\n"
"      const set = DataView.prototype.setUint8;\r\n"
"      const get = DataView.prototype.getUint8;\r\n"
"      const valueMask = (2 ** bitSize - 1);\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset) {\r\n"
"          const n = get.call(this, offset);\r\n"
"          const s = n >>> bitPos;\r\n"
"          return s & valueMask;\r\n"
"        };\r\n"
"      } else {\r\n"
"        const outsideMask = 0xFF ^ (valueMask << bitPos);\r\n"
"        return function(offset, value) {\r\n"
"          const n = get.call(this, offset);\r\n"
"          const b = (n & outsideMask) | ((value & valueMask) << bitPos);\r\n"
"          set.call(this, offset, b);\r\n"
"        };\r\n"
"      }\r\n"
"    }\r\n"
"    return getUnalignedNumericAccessor(access, member);\r\n"
"  }\r\n"
"\r\n"
"  function getAlignedFloatAccessor(access, member) {\r\n"
"    const { bitSize, byteSize } = member;\r\n"
"    if (bitSize === 16) {\r\n"
"      const buf = new DataView(new ArrayBuffer(4));\r\n"
"      const set = DataView.prototype.setUint16;\r\n"
"      const get = DataView.prototype.getUint16;\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          const sign = n >>> 15;\r\n"
"          const exp = (n & 0x7C00) >> 10;\r\n"
"          const frac = n & 0x03FF;\r\n"
"          if (exp === 0) {\r\n"
"            return (sign) ? -0 : 0;\r\n"
"          } else if (exp === 0x1F) {\r\n"
"            if (!frac) {\r\n"
"              return (sign) ? -Infinity : Infinity;\r\n"
"            } else {\r\n"
"              return NaN;\r\n"
"            }\r\n"
"          }\r\n"
"          const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);\r\n"
"          buf.setUint32(0, n32, littleEndian);\r\n"
"          return buf.getFloat32(0, littleEndian);\r\n"
"        }\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          buf.setFloat32(0, value, littleEndian);\r\n"
"          const n = buf.getUint32(0, littleEndian);\r\n"
"          const sign = n >>> 31;\r\n"
"          const exp = (n & 0x7F800000) >> 23;\r\n"
"          const frac = n & 0x007FFFFF;\r\n"
"          const exp16 = (exp - 127 + 15);\r\n"
"          let n16;\r\n"
"          if (exp === 0) {\r\n"
"            n16 = sign << 15;\r\n"
"          } else if (exp === 0xFF) {\r\n"
"            n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);\r\n"
"          } else if (exp16 >= 31) {\r\n"
"            n16 = sign << 15 | 0x1F << 10;\r\n"
"          } else {\r\n"
"            n16 = sign << 15 | exp16 << 10 | (frac >> 13);\r\n"
"          }\r\n"
"          set.call(this, offset, n16, littleEndian);\r\n"
"        }\r\n"
"      }\r\n"
"    } else if (bitSize === 80) {\r\n"
"      const buf = new DataView(new ArrayBuffer(8));\r\n"
"      const get = function(offset, littleEndian) {\r\n"
"        const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));\r\n"
"        const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));\r\n"
"        const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));\r\n"
"        return w1 | w2 << 32n | w3 << 64n;\r\n"
"      };\r\n"
"      const set = function(offset, value, littleEndian) {\r\n"
"        const w1 = value & 0xFFFFFFFFn;\r\n"
"        const w2 = (value >> 32n) & 0xFFFFFFFFn;\r\n"
"        const w3 = (value >> 64n) & 0xFFFFFFFFn;\r\n"
"        this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);\r\n"
"        this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);\r\n"
"        this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);\r\n"
"      };\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          const sign = n >> 79n;\r\n"
"          const exp = (n & 0x7FFF0000000000000000n) >> 64n;\r\n"
"          const frac = n & 0x00007FFFFFFFFFFFFFFFn;\r\n"
"          if (exp === 0n) {\r\n"
"            return (sign) ? -0 : 0;\r\n"
"          } else if (exp === 0x7FFFn) {\r\n"
"            if (!frac) {\r\n"
"              return (sign) ? -Infinity : Infinity;\r\n"
"            } else {\r\n"
"              return NaN;\r\n"
"            }\r\n"
"          }\r\n"
"          const exp64 = exp - 16383n + 1023n;\r\n"
"          if (exp64 >= 2047n) {\r\n"
"            return (sign) ? -Infinity : Infinity;\r\n"
"          }\r\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);\r\n"
"          buf.setBigUint64(0, n64, littleEndian);\r\n"
"          return buf.getFloat64(0, littleEndian);\r\n"
"        }\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          buf.setFloat64(0, value, littleEndian);\r\n"
"          const n = buf.getBigUint64(0, littleEndian);\r\n"
"          const sign = n >> 63n;\r\n"
"          const exp = (n & 0x7FF0000000000000n) >> 52n;\r\n"
"          const frac = n & 0x000FFFFFFFFFFFFFn;\r\n"
"          let n80;\r\n"
"          if (exp === 0n) {\r\n"
"            n80 = sign << 79n | (frac << 11n);\r\n"
"          } else if (exp === 0x07FFn) {\r\n"
"            n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;\r\n"
"            //                                                 ^ bit 61                       ^ bit 63\r\n"
"          } else {\r\n"
"            n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;\r\n"
"          }\r\n"
"          set.call(this, offset, n80, littleEndian);\r\n"
"        }\r\n"
"      }\r\n"
"    } else if (bitSize === 128) {\r\n"
"      const buf = new DataView(new ArrayBuffer(8));\r\n"
"      const get = function(offset, littleEndian) {\r\n"
"        const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));\r\n"
"        const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));\r\n"
"        const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));\r\n"
"        const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));\r\n"
"        return w1 | w2 << 32n | w3 << 64n | w4 << 96n;\r\n"
"      };\r\n"
"      const set = function(offset, value, littleEndian) {\r\n"
"        const w1 = value & 0xFFFFFFFFn;\r\n"
"        const w2 = (value >> 32n) & 0xFFFFFFFFn;\r\n"
"        const w3 = (value >> 64n) & 0xFFFFFFFFn;\r\n"
"        const w4 = (value >> 96n) & 0xFFFFFFFFn;\r\n"
"        this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);\r\n"
"        this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);\r\n"
"        this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);\r\n"
"        this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);\r\n"
"      };\r\n"
"      if (access === 'get') {\r\n"
"        return function(offset, littleEndian) {\r\n"
"          const n = get.call(this, offset, littleEndian);\r\n"
"          const sign = n >> 127n;\r\n"
"          const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;\r\n"
"          const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;\r\n"
"          if (exp === 0n) {\r\n"
"            return (sign) ? -0 : 0;\r\n"
"          } else if (exp === 0x7FFFn) {\r\n"
"            if (!frac) {\r\n"
"              return (sign) ? -Infinity : Infinity;\r\n"
"            } else {\r\n"
"              return NaN;\r\n"
"            }\r\n"
"          }\r\n"
"          const exp64 = exp - 16383n + 1023n;\r\n"
"          if (exp64 >= 2047n) {\r\n"
"            return (sign) ? -Infinity : Infinity;\r\n"
"          }\r\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);\r\n"
"          buf.setBigUint64(0, n64, littleEndian);\r\n"
"          return buf.getFloat64(0, littleEndian);\r\n"
"        }\r\n"
"      } else {\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          buf.setFloat64(0, value, littleEndian);\r\n"
"          const n = buf.getBigUint64(0, littleEndian);\r\n"
"          const sign = n >> 63n;\r\n"
"          const exp = (n & 0x7FF0000000000000n) >> 52n;\r\n"
"          const frac = n & 0x000FFFFFFFFFFFFFn;\r\n"
"          let n128;\r\n"
"          if (exp === 0n) {\r\n"
"            n128 = sign << 127n | (frac << 60n);\r\n"
"          } else if (exp === 0x07FFn) {\r\n"
"            n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);\r\n"
"          } else {\r\n"
"            n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);\r\n"
"          }\r\n"
"          set.call(this, offset, n128, littleEndian);\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getUnalignedFloatAccessor(access, member) {\r\n"
"    return getUnalignedNumericAccessor(access, member);\r\n"
"  }\r\n"
"\r\n"
"  function getUnalignedNumericAccessor(access, member) {\r\n"
"    // pathological usage scenario--handle it anyway by copying the bitSize into a\r\n"
"    // temporary buffer, bit-aligning the data\r\n"
"    const { bitSize, bitOffset } = member;\r\n"
"    const bitPos = bitOffset & 0x07;\r\n"
"    const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;\r\n"
"    const buf = new DataView(new ArrayBuffer(byteSize));\r\n"
"    if (access === 'get') {\r\n"
"      const getAligned = getNumericAccessor('get', { ...member, byteSize });\r\n"
"      const copyBits = getBitAlignFunction(bitPos, bitSize, true);\r\n"
"      return function(offset, littleEndian) {\r\n"
"        copyBits(buf, this, offset);\r\n"
"        return getAligned.call(buf, 0, littleEndian);\r\n"
"      };\r\n"
"    } else {\r\n"
"      const setAligned = getNumericAccessor('set', { ...member, byteSize });\r\n"
"      const applyBits = getBitAlignFunction(bitPos, bitSize, false);\r\n"
"      return function(offset, value, littleEndian) {\r\n"
"        setAligned.call(buf, 0, value, littleEndian);\r\n"
"        applyBits(this, buf, offset);\r\n"
"      };\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  const methodCache = {};\r\n"
"\r\n"
"  function cacheMethod(access, member, cb) {\r\n"
"    const { type, bitOffset, bitSize, structure } = member;\r\n"
"    const bitPos = bitOffset & 0x07;\r\n"
"    const typeName = getTypeName(member);\r\n"
"    const suffix = isByteAligned(member) ? `` : `Bit${bitPos}`;\r\n"
"    const isInt = type === MemberType.Int || type === MemberType.Uint;\r\n"
"    let name = `${access}${typeName}${suffix}`;\r\n"
"    let isSize = false, originalName = name;\r\n"
"    if (isInt && bitSize === 64) {\r\n"
"      const zigTypeName = structure?.name;\r\n"
"      if (zigTypeName === 'usize' || zigTypeName === 'isize') {\r\n"
"        name += 'Size';\r\n"
"        isSize = true;\r\n"
"      }\r\n"
"    }\r\n"
"    let fn = methodCache[name];\r\n"
"    if (!fn) {\r\n"
"      if (isInt && access === 'set') {\r\n"
"        // add auto-conversion between number and bigint\r\n"
"        const Primitive = getPrimitiveClass(member);\r\n"
"        const set = cb(originalName);\r\n"
"        fn = function(offset, value, littleEndian) {\r\n"
"          set.call(this, offset, Primitive(value), littleEndian);\r\n"
"        };\r\n"
"      } else if (isSize && access === 'get') {\r\n"
"        // use number instead of bigint where possible\r\n"
"        const get = cb(originalName);\r\n"
"        const min = BigInt(Number.MIN_SAFE_INTEGER);\r\n"
"        const max = BigInt(Number.MAX_SAFE_INTEGER);\r\n"
"        fn = function(offset, littleEndian) {\r\n"
"          const value = get.call(this, offset, littleEndian);\r\n"
"          if (min <= value && value <= max) {\r\n"
"            return Number(value);\r\n"
"          } else {\r\n"
"            return value;\r\n"
"          }\r\n"
"        };\r\n"
"      } else {\r\n"
"        fn = cb(name);\r\n"
"      }\r\n"
"      if (fn && fn.name !== name) {\r\n"
"        Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });\r\n"
"      }\r\n"
"      methodCache[name] = fn;\r\n"
"    }\r\n"
"    return fn;\r\n"
"  }\r\n"
"\r\n"
"  function useAllExtendedTypes() {\r\n"
"    useExtendedBool();\r\n"
"    useExtendedInt();\r\n"
"    useExtendedUint();\r\n"
"    useExtendedFloat();\r\n"
"  }\n"
"\n"
"  function isReadOnly({ type }) {\r\n"
"    switch (type) {\r\n"
"      case MemberType.Type:\r\n"
"      case MemberType.Comptime:\r\n"
"      case MemberType.Literal:\r\n"
"        return true;\r\n"
"      default:\r\n"
"        return false;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  const factories$1 = {};\r\n"
"\r\n"
"  function useVoid() {\r\n"
"    factories$1[MemberType.Void] = getVoidDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useBool() {\r\n"
"    factories$1[MemberType.Bool] = getBoolDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useInt() {\r\n"
"    factories$1[MemberType.Int] = getIntDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useUint() {\r\n"
"    factories$1[MemberType.Uint] = getUintDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useFloat() {\r\n"
"    factories$1[MemberType.Float] = getFloatDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useObject() {\r\n"
"    factories$1[MemberType.Object] = getObjectDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useType() {\r\n"
"    factories$1[MemberType.Type] = getTypeDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useComptime() {\r\n"
"    factories$1[MemberType.Comptime] = getComptimeDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useStatic() {\r\n"
"    factories$1[MemberType.Static] = getStaticDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useLiteral() {\r\n"
"    factories$1[MemberType.Literal] = getLiteralDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useNull() {\r\n"
"    factories$1[MemberType.Null] = getNullDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useUndefined() {\r\n"
"    factories$1[MemberType.Undefined] = getUndefinedDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useUnsupported() {\r\n"
"    factories$1[MemberType.Unsupported] = getUnsupportedDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  const transformers = {};\r\n"
"\r\n"
"  function useEnumerationTransform() {\r\n"
"    transformers[StructureType.Enum] = transformEnumerationDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function useErrorSetTransform() {\r\n"
"    transformers[StructureType.ErrorSet] = transformErrorSetDescriptor;\r\n"
"  }\r\n"
"\r\n"
"  function getDescriptor(member, env) {\r\n"
"    const f = factories$1[member.type];\r\n"
"\r\n"
"    return f(member, env);\r\n"
"  }\r\n"
"\r\n"
"  function transformDescriptor(descriptor, member) {\r\n"
"    const { structure } = member;\r\n"
"    const t = transformers[structure?.type];\r\n"
"    return (t) ? t(descriptor, structure) : descriptor;\r\n"
"  }\r\n"
"\r\n"
"  function getVoidDescriptor(member, env) {\r\n"
"    const { bitOffset } = member;\r\n"
"    return {\r\n"
"      get: function() {\r\n"
"        return undefined;\r\n"
"      },\r\n"
"      set: (bitOffset !== undefined)\r\n"
"      ? function(value) {\r\n"
"        if (value !== undefined) {\r\n"
"          throw new NotUndefined(member);\r\n"
"        }\r\n"
"      }\r\n"
"      : function(index, value) {\r\n"
"        if (value !== undefined) {\r\n"
"          throw new NotUndefined(member);\r\n"
"        }\r\n"
"        if (index < 0 || index >= this.length) {\r\n"
"          throw new OutOfBound(member, index);\r\n"
"        }\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getNullDescriptor(member, env) {\r\n"
"    return {\r\n"
"      get: function() {\r\n"
"        return null;\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getUndefinedDescriptor(member, env) {\r\n"
"    return {\r\n"
"      get: function() {\r\n"
"        return undefined;\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getUnsupportedDescriptor(member, env) {\r\n"
"    const throwUnsupported = function() {\r\n"
"      throw new Unsupported();\r\n"
"    };\r\n"
"    return { get: throwUnsupported, set: throwUnsupported };\r\n"
"  }\r\n"
"\r\n"
"\r\n"
"  function getBoolDescriptor(member, env) {\r\n"
"    return getDescriptorUsing(member, env, getBoolAccessor)\r\n"
"  }\r\n"
"\r\n"
"  function getIntDescriptor(member, env) {\r\n"
"    const getDataViewAccessor = addRuntimeCheck(env, getNumericAccessor);\r\n"
"    const descriptor = getDescriptorUsing(member, env, getDataViewAccessor);\r\n"
"    return transformDescriptor(descriptor, member);\r\n"
"  }\r\n"
"\r\n"
"  function getUintDescriptor(member, env) {\r\n"
"    const getDataViewAccessor = addRuntimeCheck(env, getNumericAccessor);\r\n"
"    const descriptor = getDescriptorUsing(member, env, getDataViewAccessor);\r\n"
"    return transformDescriptor(descriptor, member);\r\n"
"  }\r\n"
"\r\n"
"  function addRuntimeCheck(env, getDataViewAccessor) {\r\n"
"    return function (access, member) {\r\n"
"      const {\r\n"
"        runtimeSafety = true,\r\n"
"      } = env;\r\n"
"      const accessor = getDataViewAccessor(access, member);\r\n"
"      if (runtimeSafety && access === 'set') {\r\n"
"        const { min, max } = getIntRange(member);\r\n"
"        return function(offset, value, littleEndian) {\r\n"
"          if (value < min || value > max) {\r\n"
"            throw new Overflow(member, value);\r\n"
"          }\r\n"
"          accessor.call(this, offset, value, littleEndian);\r\n"
"        };\r\n"
"      }\r\n"
"      return accessor;\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getFloatDescriptor(member, env) {\r\n"
"    return getDescriptorUsing(member, env, getNumericAccessor)\r\n"
"  }\r\n"
"\r\n"
"  function transformEnumerationDescriptor(int, structure) {\r\n"
"    const findEnum = function(value) {\r\n"
"      const { constructor } = structure;\r\n"
"      // the enumeration constructor returns the object for the int value\r\n"
"      const item = constructor(value);\r\n"
"      if (!item) {\r\n"
"        throw new EnumExpected(structure, value);\r\n"
"      }\r\n"
"      return item\r\n"
"    };\r\n"
"    return {\r\n"
"      get: (int.get.length === 0)\r\n"
"      ? function getEnum(hint) {\r\n"
"          const value = int.get.call(this);\r\n"
"          if (hint === 'number') {\r\n"
"            return value;\r\n"
"          }\r\n"
"          return findEnum(value);\r\n"
"        }\r\n"
"      : function getEnumElement(index) {\r\n"
"          const value = int.get.call(this, index);\r\n"
"          return findEnum(value);\r\n"
"        },\r\n"
"      set: (int.set.length === 1)\r\n"
"      ? function setEnum(value, hint) {\r\n"
"          if (hint !== 'number') {\r\n"
"            const item = findEnum(value);\r\n"
"            // call Symbol.toPrimitive directly as enum can be bigint or number\r\n"
"            value = item[Symbol.toPrimitive]();\r\n"
"          }\r\n"
"          int.set.call(this, value);\r\n"
"        }\r\n"
"      : function setEnumElement(index, value) {\r\n"
"          const item = findEnum(value);\r\n"
"          int.set.call(this, index, item[Symbol.toPrimitive]());\r\n"
"        },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function transformErrorSetDescriptor(int, structure) {\r\n"
"    const findError = function(value) {\r\n"
"      const { constructor } = structure;\r\n"
"      const item = constructor(value);\r\n"
"      if (!item) {\r\n"
"        if (value instanceof Error) {\r\n"
"          throw new NotInErrorSet(structure);\r\n"
"        } else {\r\n"
"          throw new ErrorExpected(structure, value);\r\n"
"        }\r\n"
"      }\r\n"
"      return item\r\n"
"    };\r\n"
"    return {\r\n"
"      get: (int.get.length === 0)\r\n"
"      ? function getError(hint) {\r\n"
"          const value = int.get.call(this);\r\n"
"          if (hint === 'number') {\r\n"
"            return value;\r\n"
"          }\r\n"
"          return findError(value);\r\n"
"        }\r\n"
"      : function getErrorElement(index) {\r\n"
"          const value = int.get.call(this, index);\r\n"
"          return findError(value);\r\n"
"        },\r\n"
"      set: (int.set.length === 1)\r\n"
"      ? function setError(value, hint) {\r\n"
"          if (hint !== 'number') {\r\n"
"            const item = findError(value);\r\n"
"            value = Number(item);\r\n"
"          }\r\n"
"          int.set.call(this, value);\r\n"
"        }\r\n"
"      : function setError(index, value) {\r\n"
"          const item = findError(value);\r\n"
"          value = Number(item);\r\n"
"          int.set.call(this, index, value);\r\n"
"        },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function isValueExpected(structure) {\r\n"
"    switch (structure?.type) {\r\n"
"      case StructureType.Primitive:\r\n"
"      case StructureType.ErrorUnion:\r\n"
"      case StructureType.Optional:\r\n"
"      case StructureType.Enum:\r\n"
"      case StructureType.ErrorSet:\r\n"
"        return true;\r\n"
"      default:\r\n"
"        return false;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getValue(slot) {\r\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);\r\n"
"    return object[GETTER]();\r\n"
"  }\r\n"
"\r\n"
"  function getObject(slot) {\r\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);\r\n"
"    return object;\r\n"
"  }\r\n"
"\r\n"
"  function setValue(slot, value) {\r\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);\r\n"
"    object[SETTER](value);\r\n"
"  }\r\n"
"\r\n"
"  function bindSlot(slot, { get, set }) {\r\n"
"    if (slot !== undefined) {\r\n"
"      return {\r\n"
"        get: function() {\r\n"
"          return get.call(this, slot);\r\n"
"        },\r\n"
"        set: (set)\r\n"
"        ? function(arg) {\r\n"
"            return set.call(this, slot, arg);\r\n"
"          }\r\n"
"        : undefined,\r\n"
"      };\r\n"
"    } else {\r\n"
"      // array accessors\r\n"
"      return { get, set };\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getObjectDescriptor(member, env) {\r\n"
"    const { structure, slot } = member;\r\n"
"    return bindSlot(slot, {\r\n"
"      get: isValueExpected(structure) ? getValue : getObject,\r\n"
"      set: setValue,\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getType(slot) {\r\n"
"    // unsupported types will have undefined structure\r\n"
"    const structure = this[SLOTS][slot];\r\n"
"    return structure?.constructor;\r\n"
"  }\r\n"
"\r\n"
"  function getTypeDescriptor(member, env) {\r\n"
"    const { slot } = member;\r\n"
"    return bindSlot(slot, { get: getType });\r\n"
"  }\r\n"
"\r\n"
"  function getComptimeDescriptor(member, env) {\r\n"
"    const { slot, structure } = member;\r\n"
"    return bindSlot(slot, {\r\n"
"      get: isValueExpected(structure) ? getValue : getObject,\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getStaticDescriptor(member, env) {\r\n"
"    const { slot, structure } = member;\r\n"
"    return bindSlot(slot, {\r\n"
"      get: isValueExpected(structure) ? getValue : getObject,\r\n"
"      set: setValue,\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getLiteral(slot) {\r\n"
"    const object = this[SLOTS][slot];\r\n"
"    return object.string;\r\n"
"  }\r\n"
"\r\n"
"  function getLiteralDescriptor(member, env) {\r\n"
"    const { slot } = member;\r\n"
"    return bindSlot(slot, { get: getLiteral });\r\n"
"  }\r\n"
"\r\n"
"  function getDescriptorUsing(member, env, getDataViewAccessor) {\r\n"
"    const {\r\n"
"      littleEndian = true,\r\n"
"    } = env;\r\n"
"    const { bitOffset, byteSize } = member;\r\n"
"    const getter = getDataViewAccessor('get', member);\r\n"
"    const setter = getDataViewAccessor('set', member);\r\n"
"\r\n"
"    if (bitOffset !== undefined) {\r\n"
"      const offset = bitOffset >> 3;\r\n"
"      return {\r\n"
"        get: function getValue() {\r\n"
"\r\n"
"            return getter.call(this[MEMORY], offset, littleEndian);\r\n"
"\r\n"
"        },\r\n"
"        set: function setValue(value) {\r\n"
"\r\n"
"          return setter.call(this[MEMORY], offset, value, littleEndian);\r\n"
"\r\n"
"        }\r\n"
"      }\r\n"
"    } else {\r\n"
"      return {\r\n"
"        get: function getElement(index) {\r\n"
"          try {\r\n"
"            return getter.call(this[MEMORY], index * byteSize, littleEndian);\r\n"
"          } catch (err) {\r\n"
"\r\n"
"              throw adjustRangeError(member, index, err);\r\n"
"\r\n"
"          }\r\n"
"        },\r\n"
"        set: function setElement(index, value) {\r\n"
"\r\n"
"            return setter.call(this[MEMORY], index * byteSize, value, littleEndian);\r\n"
"\r\n"
"        },\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function useAllMemberTypes() {\r\n"
"    useVoid();\r\n"
"    useNull();\r\n"
"    useUndefined();\r\n"
"    useBool();\r\n"
"    useInt();\r\n"
"    useUint();\r\n"
"    useFloat();\r\n"
"    useExtendedBool();\r\n"
"    useExtendedInt();\r\n"
"    useExtendedUint();\r\n"
"    useExtendedFloat();\r\n"
"    useObject();\r\n"
"    useType();\r\n"
"    useComptime();\r\n"
"    useStatic();\r\n"
"    useLiteral();\r\n"
"    useUnsupported();\r\n"
"  }\n"
"\n"
"  function defineProperty(object, name, descriptor) {\r\n"
"    if (descriptor) {\r\n"
"      const {\r\n"
"        set,\r\n"
"        get,\r\n"
"        value,\r\n"
"        enumerable,\r\n"
"        configurable = true,\r\n"
"        writable = true,\r\n"
"      } = descriptor;\r\n"
"      Object.defineProperty(object, name, (get)\r\n"
"        ? { get, set, configurable, enumerable }\r\n"
"        : { value, configurable, enumerable, writable }\r\n"
"      );\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function defineProperties(object, descriptors) {\r\n"
"    for (const [ name, descriptor ] of Object.entries(descriptors)) {\r\n"
"      defineProperty(object, name, descriptor);\r\n"
"    }\r\n"
"    for (const symbol of Object.getOwnPropertySymbols(descriptors)) {\r\n"
"      const descriptor = descriptors[symbol];\r\n"
"      defineProperty(object, symbol, descriptor);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function attachDescriptors(constructor, instanceDescriptors, staticDescriptors, env) {\r\n"
"    // create prototype for read-only objects\r\n"
"    const propSetters = {};\r\n"
"    for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {\r\n"
"      if (descriptor?.set) {\r\n"
"        // save the setters so we can initialize read-only objects\r\n"
"        if (name !== '$') {\r\n"
"          propSetters[name] = descriptor.set;\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"    const { get, set } = instanceDescriptors.$;\r\n"
"    defineProperties(constructor.prototype, {\r\n"
"      [ALL_KEYS]: { value: Object.keys(propSetters) },\r\n"
"      [SETTER]: { value: set },\r\n"
"      [GETTER]: { value: get },\r\n"
"      [PROP_SETTERS]: { value: propSetters },\r\n"
"      [CONST_TARGET]: { value: null },\r\n"
"\r\n"
"      ...instanceDescriptors,\r\n"
"    });\r\n"
"    defineProperties(constructor, staticDescriptors);\r\n"
"    return constructor;\r\n"
"  }\r\n"
"\r\n"
"  function makeReadOnly() {\r\n"
"    const descriptors = Object.getOwnPropertyDescriptors(this.constructor.prototype);\r\n"
"    for (const [ name, descriptor ] of Object.entries(descriptors)) {\r\n"
"      if (descriptor.set) {\r\n"
"        descriptor.set = throwReadOnly;\r\n"
"        Object.defineProperty(this, name, descriptor);\r\n"
"      }\r\n"
"    }\r\n"
"    Object.defineProperty(this, SETTER, { value: throwReadOnly });\r\n"
"    Object.defineProperty(this, CONST_TARGET, { value: this });\r\n"
"  }\r\n"
"\r\n"
"  function createConstructor(structure, handlers, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members, template },\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"    const {\r\n"
"      modifier,\r\n"
"      initializer,\r\n"
"      finalizer,\r\n"
"      alternateCaster,\r\n"
"      shapeDefiner,\r\n"
"    } = handlers;\r\n"
"    const hasSlots = needSlots(members);\r\n"
"    // comptime fields are stored in the instance template's slots\r\n"
"    let comptimeFieldSlots;\r\n"
"    if (template?.[SLOTS]) {\r\n"
"      const comptimeMembers = members.filter(m => isReadOnly(m));\r\n"
"      if (comptimeMembers.length > 0) {\r\n"
"        comptimeFieldSlots = comptimeMembers.map(m => m.slot);\r\n"
"      }\r\n"
"    }\r\n"
"    const cache = new ObjectCache();\r\n"
"    const constructor = function(arg, options = {}) {\r\n"
"      const {\r\n"
"        fixed = false,\r\n"
"      } = options;\r\n"
"      const creating = this instanceof constructor;\r\n"
"      let self, dv;\r\n"
"      if (creating) {\r\n"
"        if (arguments.length === 0) {\r\n"
"          throw new NoInitializer(structure);\r\n"
"        }\r\n"
"        self = this;\r\n"
"        if (hasSlots) {\r\n"
"          self[SLOTS] = {};\r\n"
"        }\r\n"
"        if (shapeDefiner) {\r\n"
"          // provided by defineSlice(); the slice is different from other structures as it does not have\r\n"
"          // a fixed size; memory is allocated by the slice initializer based on the argument given\r\n"
"          initializer.call(self, arg, fixed);\r\n"
"          dv = self[MEMORY];\r\n"
"        } else {\r\n"
"          self[MEMORY] = dv = env.allocateMemory(byteSize, align, fixed);\r\n"
"        }\r\n"
"      } else {\r\n"
"        if (alternateCaster) {\r\n"
"          // casting from number, string, etc.\r\n"
"          self = alternateCaster.call(this, arg, options);\r\n"
"          if (self !== false) {\r\n"
"            return self;\r\n"
"          }\r\n"
"        }\r\n"
"        // look for buffer\r\n"
"        dv = requireDataView(structure, arg, env);\r\n"
"        if (self = cache.find(dv)) {\r\n"
"          return self;\r\n"
"        }\r\n"
"        self = Object.create(constructor.prototype);\r\n"
"        if (shapeDefiner) {\r\n"
"          setDataView.call(self, dv, structure, false, false, { shapeDefiner });\r\n"
"        } else {\r\n"
"          self[MEMORY] = dv;\r\n"
"        }\r\n"
"        if (hasSlots) {\r\n"
"          self[SLOTS] = {};\r\n"
"        }\r\n"
"      }\r\n"
"      if (comptimeFieldSlots) {\r\n"
"        for (const slot of comptimeFieldSlots) {\r\n"
"          self[SLOTS][slot] = template[SLOTS][slot];\r\n"
"        }\r\n"
"      }\r\n"
"      if (modifier) {\r\n"
"        modifier.call(self);\r\n"
"      }\r\n"
"      if (creating) {\r\n"
"        // initialize object unless it's been done already\r\n"
"        if (!shapeDefiner) {\r\n"
"          initializer.call(self, arg);\r\n"
"        }\r\n"
"      }\r\n"
"      if (finalizer) {\r\n"
"        self = finalizer.call(self);\r\n"
"      }\r\n"
"      return cache.save(dv, self);\r\n"
"    };\r\n"
"    defineProperty(constructor, CACHE, { value: cache });\r\n"
"    return constructor;\r\n"
"  }\r\n"
"\r\n"
"  function copyPointer({ source }) {\r\n"
"    const target = source[SLOTS][0];\r\n"
"    if (target) {\r\n"
"      this[TARGET_SETTER](target);\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function createPropertyApplier(structure) {\r\n"
"    const { instance: { template } } = structure;\r\n"
"    return function(arg, fixed) {\r\n"
"      const argKeys = Object.keys(arg);\r\n"
"      const propSetters = this[PROP_SETTERS];\r\n"
"      const allKeys = this[ALL_KEYS];\r\n"
"      // don't accept unknown props\r\n"
"      for (const key of argKeys) {\r\n"
"        if (!(key in propSetters)) {\r\n"
"          throw new NoProperty(structure, key);\r\n"
"        }\r\n"
"      }\r\n"
"      // checking each name so that we would see inenumerable initializers as well\r\n"
"      let normalCount = 0;\r\n"
"      let normalFound = 0;\r\n"
"      let normalMissing = 0;\r\n"
"      let specialFound = 0;\r\n"
"      for (const key of allKeys) {\r\n"
"        const set = propSetters[key];\r\n"
"        if (set.special) {\r\n"
"          if (key in arg) {\r\n"
"            specialFound++;\r\n"
"          }\r\n"
"        } else {\r\n"
"          normalCount++;\r\n"
"          if (key in arg) {\r\n"
"            normalFound++;\r\n"
"          } else if (set.required) {\r\n"
"            normalMissing++;\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"      if (normalMissing !== 0 && specialFound === 0) {\r\n"
"        const missing = allKeys.filter(k => propSetters[k].required && !(k in arg));\r\n"
"        throw new MissingInitializers(structure, missing);\r\n"
"      }\r\n"
"      if (specialFound + normalFound > argKeys.length) {\r\n"
"        // some props aren't enumerable\r\n"
"        for (const key of allKeys) {\r\n"
"          if (key in arg) {\r\n"
"            if (!argKeys.includes(key)) {\r\n"
"              argKeys.push(key);\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"      // apply default values unless all properties are initialized\r\n"
"      if (normalFound < normalCount && specialFound === 0) {\r\n"
"        if (template) {\r\n"
"          if (template[MEMORY]) {\r\n"
"            this[COPIER](template);\r\n"
"          }\r\n"
"          this[POINTER_VISITOR]?.(copyPointer, { vivificate: true, source: template });\r\n"
"        }\r\n"
"      }\r\n"
"      for (const key of argKeys) {\r\n"
"        const set = propSetters[key];\r\n"
"        set.call(this, arg[key], fixed);\r\n"
"      }\r\n"
"      return argKeys.length;\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function needSlots(members) {\r\n"
"    for (const { type } of members) {\r\n"
"      switch (type) {\r\n"
"        case MemberType.Object:\r\n"
"        case MemberType.Comptime:\r\n"
"        case MemberType.Type:\r\n"
"        case MemberType.Literal:\r\n"
"          return true;\r\n"
"      }\r\n"
"    }\r\n"
"    return false;\r\n"
"  }\r\n"
"\r\n"
"  function getSelf() {\r\n"
"    return this;\r\n"
"  }\r\n"
"\r\n"
"  class ObjectCache {\r\n"
"    map = new WeakMap();\r\n"
"\r\n"
"    find(dv) {\r\n"
"      return this.map.get(dv);\r\n"
"    }\r\n"
"\r\n"
"    save(dv, object) {\r\n"
"      this.map.set(dv, object);\r\n"
"      return object;\r\n"
"    }\r\n"
"  }\n"
"\n"
"  const decoders = {};\r\n"
"  const encoders = {};\r\n"
"\r\n"
"  function decodeText(arrays, encoding = 'utf-8') {\r\n"
"    let decoder = decoders[encoding];\r\n"
"    if (!decoder) {\r\n"
"      decoder = decoders[encoding] = new TextDecoder(encoding);\r\n"
"    }\r\n"
"    let array;\r\n"
"    if (Array.isArray(arrays)) {\r\n"
"      if (arrays.length === 1) {\r\n"
"        array = arrays[0];\r\n"
"      } else {\r\n"
"        let len = 0;\r\n"
"        for (const a of arrays) {\r\n"
"          len += a.length;\r\n"
"        }\r\n"
"        const { constructor } = arrays[0];\r\n"
"        array = new constructor(len);\r\n"
"        let offset = 0;\r\n"
"        for (const a of arrays) {\r\n"
"          array.set(a, offset);\r\n"
"          offset += a.length;\r\n"
"        }\r\n"
"      }\r\n"
"    } else {\r\n"
"      array = arrays;\r\n"
"    }\r\n"
"    return decoder.decode(array);\r\n"
"  }\r\n"
"\r\n"
"  function encodeText(text, encoding = 'utf-8') {\r\n"
"    switch (encoding) {\r\n"
"      case 'utf-16': {\r\n"
"        const { length } = text;\r\n"
"        const ta = new Uint16Array(length);\r\n"
"        for (let i = 0; i < length; i++) {\r\n"
"          ta[i] = text.charCodeAt(i);\r\n"
"        }\r\n"
"        return ta;\r\n"
"      }\r\n"
"      default: {\r\n"
"        let encoder = encoders[encoding];\r\n"
"        if (!encoder) {\r\n"
"          encoder = encoders[encoding] = new TextEncoder();\r\n"
"        }\r\n"
"        return encoder.encode(text);\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function encodeBase64(dv) {\r\n"
"    /* NODE-ONLY */\r\n"
"    if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {\r\n"
"      return Buffer.from(dv.buffer, dv.byteOffset, dv.byteLength).toString('base64');\r\n"
"    }\r\n"
"    /* NODE-ONLY-END */\r\n"
"    const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);\r\n"
"    const bstr = String.fromCharCode.apply(null, ta);\r\n"
"    return btoa(bstr);\r\n"
"  }\r\n"
"\r\n"
"  function decodeBase64(str) {\r\n"
"    /* NODE-ONLY */\r\n"
"    if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {\r\n"
"      const b = Buffer.from(str, 'base64');\r\n"
"      return new DataView(b.buffer, b.byteOffset, b.byteLength);\r\n"
"    }\r\n"
"    /* NODE-ONLY-END */\r\n"
"    const bstr = atob(str);\r\n"
"    const ta = new Uint8Array(bstr.length);\r\n"
"    for (let i = 0; i < ta.byteLength; i++) {\r\n"
"      ta[i] = bstr.charCodeAt(i);\r\n"
"    }\r\n"
"    return new DataView(ta.buffer);\r\n"
"  }\n"
"\n"
"  function getValueOf() {\r\n"
"    return normalizeObject(this, false);\r\n"
"  }\r\n"
"\r\n"
"  function convertToJSON() {\r\n"
"    return normalizeObject(this, true);\r\n"
"  }\r\n"
"\r\n"
"  const INT_MAX = BigInt(Number.MAX_SAFE_INTEGER);\r\n"
"  const INT_MIN = BigInt(Number.MIN_SAFE_INTEGER);\r\n"
"\r\n"
"  function normalizeObject(object, forJSON) {\r\n"
"    const error = (forJSON) ? 'return' : 'throw';\r\n"
"    const resultMap = new Map();\r\n"
"    const process = function(value) {\r\n"
"      // handle type (i.e. constructor) like a struct\r\n"
"      const type = (typeof(value) === 'function') ? StructureType.Struct : value?.constructor?.[TYPE];\r\n"
"      if (type === undefined) {\r\n"
"        if (forJSON) {\r\n"
"          if (typeof(value) === 'bigint' && INT_MIN <= value && value <= INT_MAX) {\r\n"
"            return Number(value);\r\n"
"          } else if (value instanceof Error) {\r\n"
"            return { error: value.message };\r\n"
"          }\r\n"
"        }\r\n"
"        return value;\r\n"
"      }\r\n"
"      let result = resultMap.get(value);\r\n"
"      if (result === undefined) {\r\n"
"        let entries;\r\n"
"        switch (type) {\r\n"
"          case StructureType.Struct:\r\n"
"          case StructureType.PackedStruct:\r\n"
"          case StructureType.ExternStruct:\r\n"
"          case StructureType.TaggedUnion:\r\n"
"          case StructureType.BareUnion:\r\n"
"          case StructureType.ExternUnion:\r\n"
"            entries = value[ENTRIES_GETTER]?.({ error });\r\n"
"            result = value.constructor[TUPLE] ? [] : {};\r\n"
"            break;\r\n"
"          case StructureType.Array:\r\n"
"          case StructureType.Vector:\r\n"
"          case StructureType.Slice:\r\n"
"            entries = value[ENTRIES_GETTER]?.({ error });\r\n"
"            result = [];\r\n"
"            break;\r\n"
"          case StructureType.SinglePointer:\r\n"
"          case StructureType.SlicePointer:\r\n"
"          case StructureType.MultiPointer:\r\n"
"          case StructureType.CPointer:\r\n"
"            try {\r\n"
"              result = value['*'];\r\n"
"            } catch (err) {\r\n"
"              result = Symbol.for('inaccessible');\r\n"
"            }\r\n"
"            break;\r\n"
"          case StructureType.Enum:\r\n"
"            result = handleError(() => String(value), { error });\r\n"
"            break;\r\n"
"          case StructureType.Opaque:\r\n"
"            result = {};\r\n"
"            break;\r\n"
"          default:\r\n"
"            result = handleError(() => value.$, { error });\r\n"
"        }\r\n"
"        result = process(result);\r\n"
"        resultMap.set(value, result);\r\n"
"        if (entries) {\r\n"
"          for (const [ key, child ] of entries) {\r\n"
"            result[key] = process(child);\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"      return result;\r\n"
"    };\r\n"
"    return process(object);\r\n"
"  }\r\n"
"\r\n"
"  function handleError(cb, options = {}) {\r\n"
"    const { error = 'throw' } = options;\r\n"
"    try {\r\n"
"      return cb();\r\n"
"    } catch (err) {\r\n"
"      if (error === 'return') {\r\n"
"        return err;\r\n"
"      } else {\r\n"
"        throw err;\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getDataViewDescriptor(structure, handlers = {}) {\r\n"
"    return markAsSpecial({\r\n"
"      get() {\r\n"
"\r\n"
"        return this[MEMORY];\r\n"
"      },\r\n"
"      set(dv, fixed) {\r\n"
"        checkDataView(dv);\r\n"
"        setDataView.call(this, dv, structure, true, fixed, handlers);\r\n"
"      },\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getBase64Descriptor(structure, handlers = {}) {\r\n"
"    return markAsSpecial({\r\n"
"      get() {\r\n"
"        return encodeBase64(this.dataView);\r\n"
"      },\r\n"
"      set(str, fixed) {\r\n"
"        if (typeof(str) !== 'string') {\r\n"
"          throw new TypeMismatch('string', str);\r\n"
"        }\r\n"
"        const dv = decodeBase64(str);\r\n"
"        setDataView.call(this, dv, structure, false, fixed, handlers);\r\n"
"      }\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getStringDescriptor(structure, handlers = {}) {\r\n"
"    const { sentinel, instance: { members }} = structure;\r\n"
"    const { byteSize: charSize } = members[0];\r\n"
"    return markAsSpecial({\r\n"
"      get() {\r\n"
"        const dv = this.dataView;\r\n"
"        const TypedArray = (charSize === 1) ? Int8Array : Int16Array;\r\n"
"        const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);\r\n"
"        let str = decodeText(ta, `utf-${charSize * 8}`);\r\n"
"        if (sentinel?.value !== undefined) {\r\n"
"          if (str.charCodeAt(str.length - 1) === sentinel.value) {\r\n"
"            str = str.slice(0, -1);\r\n"
"          }\r\n"
"        }\r\n"
"        return str;\r\n"
"      },\r\n"
"      set(str, fixed) {\r\n"
"        if (typeof(str) !== 'string') {\r\n"
"          throw new TypeMismatch('a string', str);\r\n"
"        }\r\n"
"        if (sentinel?.value !== undefined) {\r\n"
"          if (str.charCodeAt(str.length - 1) !== sentinel.value) {\r\n"
"            str = str + String.fromCharCode(sentinel.value);\r\n"
"          }\r\n"
"        }\r\n"
"        const ta = encodeText(str, `utf-${charSize * 8}`);\r\n"
"        const dv = new DataView(ta.buffer);\r\n"
"        setDataView.call(this, dv, structure, false, fixed, handlers);\r\n"
"      },\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function getTypedArrayDescriptor(structure, handlers = {}) {\r\n"
"    const { typedArray } = structure;\r\n"
"    return markAsSpecial({\r\n"
"      get() {\r\n"
"        const dv = this.dataView;\r\n"
"        const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;\r\n"
"        return new typedArray(dv.buffer, dv.byteOffset, length);\r\n"
"      },\r\n"
"      set(ta, fixed) {\r\n"
"        if (!isTypedArray(ta, typedArray)) {\r\n"
"          throw new TypeMismatch(typedArray.name, ta);\r\n"
"        }\r\n"
"        const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);\r\n"
"        setDataView.call(this, dv, structure, true, fixed, handlers);\r\n"
"      },\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function markAsSpecial({ get, set }) {\r\n"
"    get.special = set.special = true;\r\n"
"    return { get, set };\r\n"
"  }\n"
"\n"
"  function definePointer(structure, env) {\r\n"
"    const {\r\n"
"      type,\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members: [ member ] },\r\n"
"      isConst,\r\n"
"    } = structure;\r\n"
"    const {\r\n"
"      runtimeSafety = true,\r\n"
"    } = env;\r\n"
"    const { structure: targetStructure } = member;\r\n"
"    const { type: targetType, sentinel, byteSize: elementSize } = targetStructure;\r\n"
"    // length for slice can be zero or undefined\r\n"
"    const hasLengthInMemory = type === StructureType.SlicePointer;\r\n"
"    const addressSize = (hasLengthInMemory) ? byteSize / 2 : byteSize;\r\n"
"    const { get: getAddressInMemory, set: setAddressInMemory } = getDescriptor({\r\n"
"      type: MemberType.Uint,\r\n"
"      bitOffset: 0,\r\n"
"      bitSize: addressSize * 8,\r\n"
"      byteSize: addressSize,\r\n"
"      structure: { byteSize: addressSize },\r\n"
"    }, env);\r\n"
"    const { get: getLengthInMemory, set: setLengthInMemory } = (hasLengthInMemory) ? getDescriptor({\r\n"
"      type: MemberType.Uint,\r\n"
"      bitOffset: addressSize * 8,\r\n"
"      bitSize: addressSize * 8,\r\n"
"      byteSize: addressSize,\r\n"
"      structure: { name: 'usize', byteSize: addressSize },\r\n"
"    }, env) : {};\r\n"
"    const updateTarget = function(all = true, active = true) {\r\n"
"      if (all || this[MEMORY][FIXED]) {\r\n"
"        if (active) {\r\n"
"          const address = getAddressInMemory.call(this);\r\n"
"          const length = (hasLengthInMemory)\r\n"
"          ? getLengthInMemory.call(this)\r\n"
"          : (sentinel?.isRequired)\r\n"
"            ? env.findSentinel(address, sentinel.bytes) + 1\r\n"
"            : 1;\r\n"
"          if (address !== this[ADDRESS] || length !== this[LENGTH]) {\r\n"
"            const Target = targetStructure.constructor;\r\n"
"            const dv = env.findMemory(address, length, Target[SIZE]);\r\n"
"            const newTarget = (dv) ? Target.call(ENVIRONMENT, dv) : null;\r\n"
"            this[SLOTS][0] = newTarget;\r\n"
"            this[ADDRESS] = address;\r\n"
"            this[LENGTH] = length;\r\n"
"            if (hasLengthInMemory) {\r\n"
"              this[MAX_LENGTH] = length;\r\n"
"            }\r\n"
"            return newTarget;\r\n"
"          }\r\n"
"        } else {\r\n"
"          return this[SLOTS][0] = undefined;\r\n"
"        }\r\n"
"      }\r\n"
"      return this[SLOTS][0];\r\n"
"    };\r\n"
"    const setAddress = function(address) {\r\n"
"      setAddressInMemory.call(this, address);\r\n"
"      this[ADDRESS] = address;\r\n"
"    };\r\n"
"    const setLength = (hasLengthInMemory || sentinel)\r\n"
"    ? function(length) {\r\n"
"        setLengthInMemory?.call?.(this, length);\r\n"
"        this[LENGTH] = length;\r\n"
"      }\r\n"
"    : null;\r\n"
"    const getTargetObject = function() {\r\n"
"      const pointer = this[POINTER] ?? this;\r\n"
"      const target = updateTarget.call(pointer, false);\r\n"
"      if (!target) {\r\n"
"        throw new NullPointer();\r\n"
"      }\r\n"
"      return (isConst) ? getConstProxy(target) : target;\r\n"
"    };\r\n"
"    const setTargetObject = function(arg) {\r\n"
"      const pointer = this[POINTER] ?? this;\r\n"
"      // the target sits in fixed memory--apply the change immediately\r\n"
"      if (arg[MEMORY][FIXED]) {\r\n"
"        const address = env.getViewAddress(arg[MEMORY]);\r\n"
"        setAddress.call(this, address);\r\n"
"        if (hasLengthInMemory) {\r\n"
"          setLength.call(this, arg.length);\r\n"
"        }\r\n"
"      } else {\r\n"
"        if (pointer[MEMORY][FIXED]) {\r\n"
"          throw new FixedMemoryTargetRequired(structure, arg);\r\n"
"        }\r\n"
"      }\r\n"
"      pointer[SLOTS][0] = arg;\r\n"
"      if (hasLengthInMemory) {\r\n"
"        pointer[MAX_LENGTH] = arg.length;\r\n"
"      }\r\n"
"    };\r\n"
"    const getTarget = isValueExpected(targetStructure)\r\n"
"    ? function() {\r\n"
"        const target = getTargetObject.call(this);\r\n"
"        return target[GETTER]();\r\n"
"      }\r\n"
"    : getTargetObject;\r\n"
"    const setTarget = !isConst\r\n"
"    ? function(value) {\r\n"
"        const target = getTargetObject.call(this);\r\n"
"        return target[SETTER](value);\r\n"
"      }\r\n"
"    : throwReadOnly;\r\n"
"    const getTargetLength = function() {\r\n"
"      const target = getTargetObject.call(this);\r\n"
"      return target.length;\r\n"
"    };\r\n"
"    const setTargetLength = function(len) {\r\n"
"      len = len | 0;\r\n"
"      const target = getTargetObject.call(this);\r\n"
"      const dv = target[MEMORY];\r\n"
"      const fixed = dv[FIXED];\r\n"
"      const bytesAvailable = dv.buffer.byteLength - dv.byteOffset;\r\n"
"      // determine the maximum length\r\n"
"      let max;\r\n"
"      if (!fixed) {\r\n"
"        if (hasLengthInMemory) {\r\n"
"          max = this[MAX_LENGTH];\r\n"
"        } else {\r\n"
"          max = (bytesAvailable / elementSize) | 0;\r\n"
"        }\r\n"
"      }\r\n"
"      if (len < 0 || len > max) {\r\n"
"        throw new InvalidSliceLength(len, max);\r\n"
"      }\r\n"
"      const byteLength = len * elementSize;\r\n"
"      const newDV = (byteLength <= bytesAvailable)\r\n"
"      // can use the same buffer\r\n"
"      ? env.obtainView(dv.buffer, dv.byteOffset, byteLength)\r\n"
"      // need to ask V8 for a larger external buffer\r\n"
"      : env.obtainFixedView(fixed.address, byteLength);\r\n"
"      const Target = targetStructure.constructor;\r\n"
"      this[SLOTS][0] = Target.call(ENVIRONMENT, newDV);\r\n"
"      if (hasLengthInMemory) {\r\n"
"        setLength?.call(this, len);\r\n"
"      }\r\n"
"    };\r\n"
"    const alternateCaster = function(arg, options) {\r\n"
"      const Target = targetStructure.constructor;\r\n"
"      if ((this === ENVIRONMENT || this === PARENT) || arg instanceof constructor) {\r\n"
"        // casting from buffer to pointer is allowed only if request comes from the runtime\r\n"
"        // casting from writable to read-only is also allowed\r\n"
"        return false;\r\n"
"      } else if (isPointerOf(arg, Target)) {\r\n"
"        // const/non-const casting\r\n"
"        return new constructor(Target(arg['*']), options);\r\n"
"      } else if (targetType === StructureType.Slice) {\r\n"
"        // allow casting to slice through constructor of its pointer\r\n"
"        return new constructor(Target(arg), options);\r\n"
"      } else {\r\n"
"        throw new NoCastingToPointer(structure);\r\n"
"      }\r\n"
"    };\r\n"
"    const finalizer = function() {\r\n"
"      const handlers = isPointer(targetType) ? {} : proxyHandlers$1;\r\n"
"      const proxy = new Proxy(this, handlers);\r\n"
"      // hide the proxy so console wouldn't display a recursive structure\r\n"
"      Object.defineProperty(this, PROXY, { value: proxy });\r\n"
"      return proxy;\r\n"
"    };\r\n"
"    const initializer = function(arg) {\r\n"
"      const Target = targetStructure.constructor;\r\n"
"      if (isPointerOf(arg, Target)) {\r\n"
"        // initialize with the other pointer'structure target\r\n"
"        if (!isConst && arg.constructor.const) {\r\n"
"          throw new ConstantConstraint(structure, arg);\r\n"
"        }\r\n"
"        arg = arg[SLOTS][0];\r\n"
"      }\r\n"
"      if (arg instanceof Target) {\r\n"
"\r\n"
"        const constTarget = arg[CONST_TARGET];\r\n"
"        if (constTarget) {\r\n"
"          if (isConst) {\r\n"
"            arg = constTarget;\r\n"
"          } else {\r\n"
"            throw new ReadOnlyTarget(structure);\r\n"
"          }\r\n"
"        }\r\n"
"      } else if (type === StructureType.CPointer && arg instanceof Target.child) {\r\n"
"        arg = Target(arg[MEMORY]);\r\n"
"      } else if (isCompatible(arg, Target)) {\r\n"
"        // autocast to target type\r\n"
"        const dv = getDataView(targetStructure, arg, env);\r\n"
"        arg = Target(dv);\r\n"
"      } else if (arg !== undefined && !arg[MEMORY]) {\r\n"
"        if (type === StructureType.CPointer) {\r\n"
"          if (typeof(arg) === 'object' && !arg[Symbol.iterator]) {\r\n"
"            let single = true;\r\n"
"            // make sure the object doesn't contain special props for the slice\r\n"
"            const propSetters = Target.prototype[PROP_SETTERS];\r\n"
"            for (const key of Object.keys(arg)) {\r\n"
"              const set = propSetters[key];\r\n"
"              if (set?.special) {\r\n"
"                single = false;\r\n"
"                break;\r\n"
"              }\r\n"
"            }\r\n"
"            if (single) {\r\n"
"              arg = [ arg ];\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"        // autovivificate target object\r\n"
"        const autoObj = new Target(arg, { fixed: !!this[MEMORY][FIXED] });\r\n"
"        if (runtimeSafety) {\r\n"
"          // creation of a new slice using a typed array is probably\r\n"
"          // not what the user wants; it's more likely that the intention\r\n"
"          // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)\r\n"
"          if (targetStructure.typedArray) {\r\n"
"            const tag = arg?.buffer?.[Symbol.toStringTag];\r\n"
"            if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {\r\n"
"              warnImplicitArrayCreation(targetStructure, arg);\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"        arg = autoObj;\r\n"
"      } else if (arg !== undefined) {\r\n"
"        throw new InvalidPointerTarget(structure, arg);\r\n"
"      }\r\n"
"      this[TARGET_SETTER](arg);\r\n"
"    };\r\n"
"    const getTargetPrimitive = (targetType === StructureType.Primitive)\r\n"
"    ? function(hint) {\r\n"
"        const target = this[TARGET_GETTER]();\r\n"
"        return target[Symbol.toPrimitive](hint);\r\n"
"      }\r\n"
"    : null;\r\n"
"    const getSliceOf = (targetType === StructureType.Slice)\r\n"
"    ? function(begin, end) {\r\n"
"        const target = this[TARGET_GETTER]();\r\n"
"        const newTarget = target.slice(begin, end);\r\n"
"        return new constructor(newTarget);\r\n"
"      }\r\n"
"    : null;\r\n"
"    const getSubarrayOf = (targetType === StructureType.Slice)\r\n"
"    ? function(begin, end, options) {\r\n"
"        const target = this[TARGET_GETTER]();\r\n"
"        const newTarget = target.subarray(begin, end, options);\r\n"
"        return new constructor(newTarget);\r\n"
"      }\r\n"
"    : null;\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster, finalizer }, env);\r\n"
"    const instanceDescriptors = {\r\n"
"      '*': { get: getTarget, set: setTarget },\r\n"
"      '$': { get: getProxy, set: initializer },\r\n"
"      length: { get: getTargetLength, set: setTargetLength },\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: deleteTarget },\r\n"
"      slice: getSliceOf && { value: getSliceOf },\r\n"
"      subarray: getSubarrayOf && { value: getSubarrayOf },\r\n"
"      [Symbol.toPrimitive]: getTargetPrimitive && { value: getTargetPrimitive },\r\n"
"      [TARGET_GETTER]: { value: getTargetObject },\r\n"
"      [TARGET_SETTER]: { value: setTargetObject },\r\n"
"      [TARGET_UPDATER]: { value: updateTarget },\r\n"
"      [ADDRESS_SETTER]: { value: setAddress },\r\n"
"      [LENGTH_SETTER]: setLength && { value: setLength },\r\n"
"      [POINTER_VISITOR]: { value: visitPointer },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [WRITE_DISABLER]: { value: makePointerReadOnly },\r\n"
"      [ADDRESS]: { value: undefined, writable: true },\r\n"
"      [LENGTH]: setLength && { value: undefined, writable: true },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      child: { get: () => targetStructure.constructor },\r\n"
"      const: { value: isConst },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"\r\n"
"  function makePointerReadOnly() {\r\n"
"    const pointer = this[POINTER];\r\n"
"    const descriptor = Object.getOwnPropertyDescriptor(pointer.constructor.prototype, '$');\r\n"
"    descriptor.set = throwReadOnly;\r\n"
"    Object.defineProperty(pointer, '$', descriptor);\r\n"
"    Object.defineProperty(pointer, CONST_TARGET, { value: pointer });\r\n"
"  }\r\n"
"\r\n"
"  function deleteTarget() {\r\n"
"    const target = this[TARGET_GETTER]();\r\n"
"    target?.delete();\r\n"
"  }\r\n"
"\r\n"
"  function getProxy() {\r\n"
"    return this[PROXY];\r\n"
"  }\r\n"
"\r\n"
"  function resetPointer({ isActive }) {\r\n"
"    if (this[SLOTS][0] && !isActive(this)) {\r\n"
"      this[SLOTS][0] = undefined;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function disablePointer() {\r\n"
"    const throwError = () => { throw new InaccessiblePointer() };\r\n"
"    const disabledProp = { get: throwError, set: throwError };\r\n"
"    const disabledFunc = { value: throwError };\r\n"
"    defineProperties(this[POINTER], {\r\n"
"      '*': disabledProp,\r\n"
"      '$': disabledProp,\r\n"
"      [GETTER]: disabledFunc,\r\n"
"      [SETTER]: disabledFunc,\r\n"
"      [TARGET_GETTER]: disabledFunc,\r\n"
"    });\r\n"
"  }\r\n"
"\r\n"
"  function visitPointer(fn, options = {}) {\r\n"
"    const {\r\n"
"      source,\r\n"
"      isActive = always,\r\n"
"      isMutable = always,\r\n"
"    } = options;\r\n"
"    fn.call(this, { source, isActive, isMutable });\r\n"
"  }\r\n"
"\r\n"
"  function isPointerOf(arg, Target) {\r\n"
"    return (arg?.constructor?.child === Target && arg['*']);\r\n"
"  }\r\n"
"\r\n"
"  function getConstProxy(target) {\r\n"
"    let proxy = target[CONST_PROXY];\r\n"
"    if (!proxy) {\r\n"
"      Object.defineProperty(target, CONST_PROXY, { value: undefined, configurable: true });\r\n"
"      proxy = new Proxy(target, constTargetHandlers);\r\n"
"      Object.defineProperty(target, CONST_PROXY, { value: proxy });\r\n"
"    }\r\n"
"    return proxy;\r\n"
"  }\r\n"
"\r\n"
"  const proxyHandlers$1 = {\r\n"
"    get(pointer, name) {\r\n"
"      if (name === POINTER) {\r\n"
"        return pointer;\r\n"
"      } else if (name in pointer) {\r\n"
"        return pointer[name];\r\n"
"      } else {\r\n"
"        const target = pointer[TARGET_GETTER]();\r\n"
"        return target[name];\r\n"
"      }\r\n"
"    },\r\n"
"    set(pointer, name, value) {\r\n"
"      if (name in pointer) {\r\n"
"        pointer[name] = value;\r\n"
"      } else {\r\n"
"        const target = pointer[TARGET_GETTER]();\r\n"
"        target[name] = value;\r\n"
"      }\r\n"
"      return true;\r\n"
"    },\r\n"
"    deleteProperty(pointer, name) {\r\n"
"      if (name in pointer) {\r\n"
"        delete pointer[name];\r\n"
"      } else {\r\n"
"        const target = pointer[TARGET_GETTER]();\r\n"
"        delete target[name];\r\n"
"      }\r\n"
"      return true;\r\n"
"    },\r\n"
"    has(pointer, name) {\r\n"
"      if (name in pointer) {\r\n"
"        return true;\r\n"
"      } else {\r\n"
"        const target = pointer[TARGET_GETTER]();\r\n"
"        return name in target;\r\n"
"      }\r\n"
"    },\r\n"
"  };\r\n"
"\r\n"
"  const constTargetHandlers = {\r\n"
"    get(target, name) {\r\n"
"      if (name === CONST_TARGET) {\r\n"
"        return target;\r\n"
"      } else {\r\n"
"        const value = target[name];\r\n"
"        if (value?.[CONST_TARGET] === null) {\r\n"
"          return getConstProxy(value);\r\n"
"        }\r\n"
"        return value;\r\n"
"      }\r\n"
"    },\r\n"
"    set(target, name, value) {\r\n"
"      const ptr = target[POINTER];\r\n"
"      if (ptr && !(name in ptr)) {\r\n"
"        target[name] = value;\r\n"
"      } else {\r\n"
"        throwReadOnly();\r\n"
"      }\r\n"
"      return true;\r\n"
"    }\r\n"
"  };\r\n"
"\r\n"
"  function always() {\r\n"
"    return true;\r\n"
"  }\r\n"
"\r\n"
"  function never() {\r\n"
"    return false;\r\n"
"  }\n"
"\n"
"  function defineVector(structure, env) {\r\n"
"    const {\r\n"
"      length,\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members: [ member ] },\r\n"
"    } = structure;\r\n"
"\r\n"
"    const { bitSize: elementBitSize, structure: elementStructure } = member;\r\n"
"    const elementDescriptors = {};\r\n"
"    for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {\r\n"
"      const { get, set } = getDescriptor({ ...member, bitOffset }, env);\r\n"
"      elementDescriptors[i] = { get, set, configurable: true };\r\n"
"    }\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        this[COPIER](arg);\r\n"
"      } else if (arg?.[Symbol.iterator]) {\r\n"
"        let argLen = arg.length;\r\n"
"        if (typeof(argLen) !== 'number') {\r\n"
"          arg = [ ...arg ];\r\n"
"          argLen = arg.length;\r\n"
"        }\r\n"
"        if (argLen !== length) {\r\n"
"          throw new ArrayLengthMismatch(structure, this, arg);\r\n"
"        }\r\n"
"        let i = 0;\r\n"
"        for (const value of arg) {\r\n"
"          this[PROP_SETTERS][i++].call(this, value);\r\n"
"        }\r\n"
"      } else if (arg && typeof(arg) === 'object') {\r\n"
"        if (propApplier.call(this, arg) === 0) {\r\n"
"          throw new InvalidArrayInitializer(structure, arg);\r\n"
"        }\r\n"
"      } else if (arg !== undefined) {\r\n"
"        throw new InvalidArrayInitializer(structure, arg);\r\n"
"      }\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\r\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\r\n"
"    const instanceDescriptors = {\r\n"
"      ...elementDescriptors,\r\n"
"      $: { get: getSelf, set: initializer },\r\n"
"      length: { value: length },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      typedArray: typedArray && getTypedArrayDescriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      entries: { value: getVectorEntries },\r\n"
"      delete: { value: getDestructor(structure) },\r\n"
"      [Symbol.iterator]: { value: getVectorIterator },\r\n"
"      [ENTRIES_GETTER]: { value: getVectorEntries },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      child: { get: () => elementStructure.constructor },\r\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"\r\n"
"  function getVectorIterator() {\r\n"
"    const self = this;\r\n"
"    const length = this.length;\r\n"
"    let index = 0;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        let value, done;\r\n"
"        if (index < length) {\r\n"
"          const current = index++;\r\n"
"          value = self[current];\r\n"
"          done = false;\r\n"
"        } else {\r\n"
"          done = true;\r\n"
"        }\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getVectorEntriesIterator() {\r\n"
"    const self = this;\r\n"
"    const length = this.length;\r\n"
"    let index = 0;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        let value, done;\r\n"
"        if (index < length) {\r\n"
"          const current = index++;\r\n"
"          value = [ current, self[current] ];\r\n"
"          done = false;\r\n"
"        } else {\r\n"
"          done = true;\r\n"
"        }\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getVectorEntries() {\r\n"
"    return {\r\n"
"      [Symbol.iterator]: getVectorEntriesIterator.bind(this),\r\n"
"      length: this.length,\r\n"
"    };\r\n"
"  }\n"
"\n"
"  function defineStructShape(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members },\r\n"
"      isTuple,\r\n"
"      isIterator,\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"    const memberDescriptors = {};\r\n"
"    const fieldMembers = members.filter(m => !!m.name);\r\n"
"    const backingIntMember = members.find(m => !m.name);\r\n"
"    for (const member of fieldMembers) {\r\n"
"      const { get, set } = getDescriptor(member, env);\r\n"
"      memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };\r\n"
"      if (member.isRequired && set) {\r\n"
"        set.required = true;\r\n"
"      }\r\n"
"    }\r\n"
"    const backingInt = (backingIntMember) ? getDescriptor(backingIntMember, env) : null;\r\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        this[COPIER](arg);\r\n"
"        if (hasPointer) {\r\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\r\n"
"        }\r\n"
"      } else if (arg && typeof(arg) === 'object') {\r\n"
"        propApplier.call(this, arg);\r\n"
"      } else if ((typeof(arg) === 'number' || typeof(arg) === 'bigint') && backingInt) {\r\n"
"        backingInt.set.call(this, arg);\r\n"
"      } else if (arg !== undefined) {\r\n"
"        throw new InvalidInitializer(structure, 'object', arg);\r\n"
"      }\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\r\n"
"    const toPrimitive = (backingInt)\r\n"
"    ? function(hint) {\r\n"
"      switch (hint) {\r\n"
"        case 'string':\r\n"
"          return Object.prototype.toString.call(this);\r\n"
"        default:\r\n"
"          return backingInt.get.call(this);\r\n"
"      }\r\n"
"    }\r\n"
"    : null;\r\n"
"    const length = (isTuple && members.length > 0)\r\n"
"    ? parseInt(members[members.length - 1].name) + 1\r\n"
"    : 0;\r\n"
"    const getIterator = (isIterator)\r\n"
"    ? getIteratorIterator\r\n"
"    : (isTuple)\r\n"
"      ? getVectorIterator\r\n"
"      : getStructIterator;\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get: getSelf, set: initializer },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      length: isTuple && { value: length },\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      entries: isTuple && { value: getVectorEntries },\r\n"
"      ...memberDescriptors,\r\n"
"      [Symbol.iterator]: { value: getIterator },\r\n"
"      [Symbol.toPrimitive]: backingInt && { value: toPrimitive },\r\n"
"      [ENTRIES_GETTER]: { value: isTuple ? getVectorEntries : getStructEntries },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, always) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"      [PROPS]: { value: fieldMembers.map(m => m.name) },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"      [TUPLE]: { value: isTuple },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"\r\n"
"  function getStructEntries(options) {\r\n"
"    return {\r\n"
"      [Symbol.iterator]: getStructEntriesIterator.bind(this, options),\r\n"
"      length: this[PROPS].length,\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getIteratorIterator() {\r\n"
"    const self = this;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        const value = self.next();\r\n"
"        const done = value === null;\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getStructIterator(options) {\r\n"
"    const entries = getStructEntries.call(this, options);\r\n"
"    return entries[Symbol.iterator]();\r\n"
"  }\r\n"
"\r\n"
"  function getStructEntriesIterator(options) {\r\n"
"    const self = this;\r\n"
"    const props = this[PROPS];\r\n"
"    let index = 0;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        let value, done;\r\n"
"        if (index < props.length) {\r\n"
"          const current = props[index++];\r\n"
"          value = [ current, handleError(() => self[current], options) ];\r\n"
"          done = false;\r\n"
"        } else {\r\n"
"          done = true;\r\n"
"        }\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getChildVivificator$1(structure, env) {\r\n"
"    const { instance: { members } } = structure;\r\n"
"    const objectMembers = {};\r\n"
"    for (const member of members.filter(m => m.type === MemberType.Object)) {\r\n"
"      objectMembers[member.slot] = member;\r\n"
"    }\r\n"
"    return function vivificateChild(slot) {\r\n"
"      const member = objectMembers[slot];\r\n"
"      const { bitOffset, byteSize, structure: { constructor } } = member;\r\n"
"      const dv = this[MEMORY];\r\n"
"      const parentOffset = dv.byteOffset;\r\n"
"      const offset = parentOffset + (bitOffset >> 3);\r\n"
"      let len = byteSize;\r\n"
"      if (len === undefined) {\r\n"
"        if (bitOffset & 7) {\r\n"
"          throw new NotOnByteBoundary(member);\r\n"
"        }\r\n"
"        len = member.bitSize >> 3;\r\n"
"      }\r\n"
"      const childDV = env.obtainView(dv.buffer, offset, len);\r\n"
"      const object = this[SLOTS][slot] = constructor.call(PARENT, childDV);\r\n"
"      return object;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function getPointerVisitor$1(structure, visitorOptions = {}) {\r\n"
"    const {\r\n"
"      isChildActive = always,\r\n"
"      isChildMutable = always,\r\n"
"    } = visitorOptions;\r\n"
"    const { instance: { members } } = structure;\r\n"
"    const pointerMembers = members.filter(m => m.structure?.hasPointer);\r\n"
"    return function visitPointers(cb, options = {}) {\r\n"
"      const {\r\n"
"        source,\r\n"
"        vivificate = false,\r\n"
"        isActive = always,\r\n"
"        isMutable = always,\r\n"
"      } = options;\r\n"
"      const childOptions = {\r\n"
"        ...options,\r\n"
"        isActive: (object) => {\r\n"
"          // make sure parent object is active, then check whether the child is active\r\n"
"          return isActive(this) && isChildActive.call(this, object);\r\n"
"        },\r\n"
"        isMutable: (object) => {\r\n"
"          return isMutable(this) && isChildMutable.call(this, object);\r\n"
"        },\r\n"
"      };\r\n"
"      for (const { slot } of pointerMembers) {\r\n"
"        if (source) {\r\n"
"          // when src is a the struct's template, most slots will likely be empty,\r\n"
"          // since pointer fields aren't likely to have default values\r\n"
"          const srcChild = source[SLOTS]?.[slot];\r\n"
"          if (!srcChild) {\r\n"
"            continue;\r\n"
"          }\r\n"
"          childOptions.source = srcChild;\r\n"
"        }\r\n"
"        const child = this[SLOTS][slot] ?? (vivificate ? this[VIVIFICATOR](slot) : null);\r\n"
"        if (child) {\r\n"
"          child[POINTER_VISITOR](cb, childOptions);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"  }\n"
"\n"
"  function defineArgStruct(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members },\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\r\n"
"    const argKeys = members.slice(1).map(m => m.name);\r\n"
"    const argCount = argKeys.length;\r\n"
"    const constructor = structure.constructor = function(args, name, offset) {\r\n"
"      const dv = env.allocateMemory(byteSize, align);\r\n"
"      this[MEMORY] = dv;\r\n"
"      if (hasObject) {\r\n"
"        this[SLOTS] = {};\r\n"
"      }\r\n"
"      if (args.length !== argCount) {\r\n"
"        throw new ArgumentCountMismatch(name, argCount - offset, args.length - offset);\r\n"
"      }\r\n"
"      for (const [ index, key ] of argKeys.entries()) {\r\n"
"        try {\r\n"
"          this[key] = args[index];\r\n"
"        } catch (err) {\r\n"
"          throw adjustArgumentError(name, index - offset, argCount - offset, err);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"    const memberDescriptors = {};\r\n"
"    for (const member of members) {\r\n"
"      memberDescriptors[member.name] = getDescriptor(member, env);\r\n"
"    }\r\n"
"    const { slot: retvalSlot, type: retvalType } = members[0];\r\n"
"    const isChildMutable = (retvalType === MemberType.Object)\r\n"
"    ? function(object) {\r\n"
"        const child = this[VIVIFICATOR](retvalSlot);\r\n"
"        return object === child;\r\n"
"      }\r\n"
"    : function() { return false };\r\n"
"    defineProperties(constructor.prototype, {\r\n"
"      ...memberDescriptors,\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildMutable }) },\r\n"
"\r\n"
"    });\r\n"
"    defineProperties(constructor, {\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"    });\r\n"
"    return constructor;\r\n"
"  }\n"
"\n"
"  function defineArray(structure, env) {\r\n"
"    const {\r\n"
"      length,\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members: [ member ] },\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"\r\n"
"    const { get, set } = getDescriptor(member, env);\r\n"
"    const hasStringProp = canBeString(member);\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        this[COPIER](arg);\r\n"
"        if (hasPointer) {\r\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\r\n"
"        }\r\n"
"      } else {\r\n"
"        if (typeof(arg) === 'string' && hasStringProp) {\r\n"
"          arg = { string: arg };\r\n"
"        }\r\n"
"        if (arg?.[Symbol.iterator]) {\r\n"
"          arg = transformIterable(arg);\r\n"
"          if (arg.length !== length) {\r\n"
"            throw new ArrayLengthMismatch(structure, this, arg);\r\n"
"          }\r\n"
"          let i = 0;\r\n"
"          for (const value of arg) {\r\n"
"            set.call(this, i++, value);\r\n"
"          }\r\n"
"        } else if (arg && typeof(arg) === 'object') {\r\n"
"          if (propApplier.call(this, arg) === 0) {\r\n"
"            throw new InvalidArrayInitializer(structure, arg);\r\n"
"          }\r\n"
"        } else if (arg !== undefined) {\r\n"
"          throw new InvalidArrayInitializer(structure, arg);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"    const finalizer = createArrayProxy;\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, finalizer }, env);\r\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\r\n"
"    const hasObject = member.type === MemberType.Object;\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get: getProxy, set: initializer },\r\n"
"      length: { value: length },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      string: hasStringProp && getStringDescriptor(structure),\r\n"
"      typedArray: typedArray && getTypedArrayDescriptor(structure),\r\n"
"      get: { value: get },\r\n"
"      set: { value: set },\r\n"
"      entries: { value: getArrayEntries },\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [Symbol.iterator]: { value: getArrayIterator },\r\n"
"      [ENTRIES_GETTER]: { value: getArrayEntries },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor() },\r\n"
"      [WRITE_DISABLER]: { value: makeArrayReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      child: { get: () => member.structure.constructor },\r\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"\r\n"
"  function createArrayProxy() {\r\n"
"    const proxy = new Proxy(this, proxyHandlers);\r\n"
"    // hide the proxy so console wouldn't display a recursive structure\r\n"
"    Object.defineProperty(this, PROXY, { value: proxy });\r\n"
"    return proxy;\r\n"
"  }\r\n"
"\r\n"
"  function makeArrayReadOnly() {\r\n"
"    makeReadOnly.call(this);\r\n"
"    Object.defineProperty(this, 'set', { value: throwReadOnly });\r\n"
"    const get = this.get;\r\n"
"    const getReadOnly = function(index) {\r\n"
"      const element = get.call(this, index);\r\n"
"      if (element?.[CONST_TARGET] === null) {\r\n"
"        element[WRITE_DISABLER]?.();\r\n"
"      }\r\n"
"      return element;\r\n"
"    };\r\n"
"    Object.defineProperty(this, 'get', { value: getReadOnly });\r\n"
"  }\r\n"
"\r\n"
"  function canBeString(member) {\r\n"
"    return member.type === MemberType.Uint && [ 8, 16 ].includes(member.bitSize);\r\n"
"  }\r\n"
"\r\n"
"  function getArrayIterator() {\r\n"
"    const self = this[ARRAY] ?? this;\r\n"
"    const length = this.length;\r\n"
"    let index = 0;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        let value, done;\r\n"
"        if (index < length) {\r\n"
"          const current = index++;\r\n"
"          value = self.get(current);\r\n"
"          done = false;\r\n"
"        } else {\r\n"
"          done = true;\r\n"
"        }\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getArrayEntriesIterator(options) {\r\n"
"    const self = this[ARRAY] ?? this;\r\n"
"    const length = this.length;\r\n"
"    let index = 0;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        let value, done;\r\n"
"        if (index < length) {\r\n"
"          const current = index++;\r\n"
"          value = [ current, handleError(() => self.get(current), options) ];\r\n"
"          done = false;\r\n"
"        } else {\r\n"
"          done = true;\r\n"
"        }\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getArrayEntries(options) {\r\n"
"    return {\r\n"
"      [Symbol.iterator]: getArrayEntriesIterator.bind(this, options),\r\n"
"      length: this.length,\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getChildVivificator(structure, env) {\r\n"
"    const { instance: { members: [ member ]} } = structure;\r\n"
"    const { byteSize, structure: elementStructure } = member;\r\n"
"    return function getChild(index) {\r\n"
"      const { constructor } = elementStructure;\r\n"
"      const dv = this[MEMORY];\r\n"
"      const parentOffset = dv.byteOffset;\r\n"
"      const offset = parentOffset + byteSize * index;\r\n"
"      const childDV = env.obtainView(dv.buffer, offset, byteSize);\r\n"
"      const object = this[SLOTS][index] = constructor.call(PARENT, childDV);\r\n"
"      return object;\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getPointerVisitor(structure) {\r\n"
"    return function visitPointers(cb, options = {}) {\r\n"
"      const {\r\n"
"        source,\r\n"
"        vivificate = false,\r\n"
"        isActive = always,\r\n"
"        isMutable = always,\r\n"
"      } = options;\r\n"
"      const childOptions = {\r\n"
"        ...options,\r\n"
"        isActive: () => isActive(this),\r\n"
"        isMutable: () => isMutable(this),\r\n"
"      };\r\n"
"      for (let i = 0, len = this.length; i < len; i++) {\r\n"
"        // no need to check for empty slots, since that isn't possible\r\n"
"        if (source) {\r\n"
"          childOptions.source = source?.[SLOTS][i];\r\n"
"        }\r\n"
"        const child = this[SLOTS][i] ?? (vivificate ? this[VIVIFICATOR](i) : null);\r\n"
"        if (child) {\r\n"
"          child[POINTER_VISITOR](cb, childOptions);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function transformIterable(arg) {\r\n"
"    if (typeof(arg.length) === 'number') {\r\n"
"      // it's an array of sort\r\n"
"      return arg;\r\n"
"    }\r\n"
"    const iterator = arg[Symbol.iterator]();\r\n"
"    const first = iterator.next();\r\n"
"    const length = first.value?.length;\r\n"
"    if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {\r\n"
"      // return generator with length attached\r\n"
"      return Object.assign((function*() {\r\n"
"        let result;\r\n"
"        while (!(result = iterator.next()).done) {\r\n"
"          yield result.value;\r\n"
"        }\r\n"
"      })(), { length });\r\n"
"    } else {\r\n"
"      const array = [];\r\n"
"      let result = first;\r\n"
"      while (!result.done) {\r\n"
"        array.push(result.value);\r\n"
"        result = iterator.next();\r\n"
"      }\r\n"
"      return array;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  const proxyHandlers = {\r\n"
"    get(array, name) {\r\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\r\n"
"      if (index !== 0 || index == name) {\r\n"
"        return array.get(index);\r\n"
"      } else {\r\n"
"        switch (name) {\r\n"
"          case 'get':\r\n"
"            if (!array[ELEMENT_GETTER]) {\r\n"
"              array[ELEMENT_GETTER] = array.get.bind(array);\r\n"
"            }\r\n"
"            return array[ELEMENT_GETTER];\r\n"
"          case 'set':\r\n"
"            if (!array[ELEMENT_SETTER]) {\r\n"
"              array[ELEMENT_SETTER] = array.set.bind(array);\r\n"
"            }\r\n"
"            return array[ELEMENT_SETTER];\r\n"
"          case ARRAY:\r\n"
"            return array;\r\n"
"          default:\r\n"
"            return array[name];\r\n"
"        }\r\n"
"      }\r\n"
"    },\r\n"
"    set(array, name, value) {\r\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\r\n"
"      if (index !== 0 || index == name) {\r\n"
"        array.set(index, value);\r\n"
"      } else {\r\n"
"        switch (name) {\r\n"
"          case 'get':\r\n"
"            array[ELEMENT_GETTER] = value;\r\n"
"            break;\r\n"
"          case 'set':\r\n"
"            array[ELEMENT_SETTER] = value;\r\n"
"            break;\r\n"
"          default:\r\n"
"            array[name] = value;\r\n"
"        }\r\n"
"      }\r\n"
"      return true;\r\n"
"    },\r\n"
"    deleteProperty(array, name) {\r\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\r\n"
"      if (index !== 0 || index == name) {\r\n"
"        return false;\r\n"
"      } else {\r\n"
"        switch (name) {\r\n"
"          case 'get':\r\n"
"            delete array[ELEMENT_GETTER];\r\n"
"            break;\r\n"
"          case 'set':\r\n"
"            delete array[ELEMENT_SETTER];\r\n"
"            break;\r\n"
"          default:\r\n"
"            delete array[name];\r\n"
"        }\r\n"
"        return true;\r\n"
"      }\r\n"
"    },\r\n"
"    has(array, name) {\r\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\r\n"
"      if (index !== 0 || index == name) {\r\n"
"        return (index >= 0 && index < array.length);\r\n"
"      } else {\r\n"
"        return array[name];\r\n"
"      }\r\n"
"    },\r\n"
"    ownKeys(array) {\r\n"
"      const keys = [];\r\n"
"      for (let i = 0, len = array.length; i < len; i++) {\r\n"
"        keys.push(`${i}`);\r\n"
"      }\r\n"
"      keys.push('length', PROXY);\r\n"
"      return keys;\r\n"
"    },\r\n"
"    getOwnPropertyDescriptor(array, name) {\r\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\r\n"
"      if (index !== 0 || index == name) {\r\n"
"        if (index >= 0 && index < array.length) {\r\n"
"          return { value: array.get(index), enumerable: true, writable: true, configurable: true };\r\n"
"        }\r\n"
"      } else {\r\n"
"        return Object.getOwnPropertyDescriptor(array, name);\r\n"
"      }\r\n"
"    },\r\n"
"  };\n"
"\n"
"  function defineEnumerationShape(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: {\r\n"
"        members: [ member ],\r\n"
"      },\r\n"
"    } = structure;\r\n"
"    const { get, set } = getDescriptor(member, env);\r\n"
"    const expected = [ 'string', 'number', 'tagged union' ];\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg && typeof(arg) === 'object') {\r\n"
"        if (propApplier.call(this, arg) === 0) {\r\n"
"          throw new InvalidInitializer(structure, expected, arg);\r\n"
"        }\r\n"
"      } else if (arg !== undefined) {\r\n"
"        set.call(this, arg);\r\n"
"      }\r\n"
"    };\r\n"
"    const alternateCaster = function(arg) {\r\n"
"      if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {\r\n"
"        let item = constructor[arg];\r\n"
"        if (!item) {\r\n"
"          if (constructor[MORE] && typeof(arg) !== 'string') {\r\n"
"            // create the item on-the-fly when enum is non-exhaustive\r\n"
"            item = new constructor(undefined);\r\n"
"            set.call(item, arg, 'number');\r\n"
"            appendEnumeration(constructor, `${arg}`, item);\r\n"
"          }\r\n"
"        }\r\n"
"        return item;\r\n"
"      } else if (arg instanceof constructor) {\r\n"
"        return arg;\r\n"
"      } else if (arg?.[TAG] instanceof constructor) {\r\n"
"        // a tagged union, return the active tag\r\n"
"        return arg[TAG];\r\n"
"      } else if (!getDataView(structure, arg, env)) {\r\n"
"        throw new InvalidInitializer(structure, expected, arg);\r\n"
"      } else {\r\n"
"        return false;\r\n"
"      }\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster }, env);\r\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\r\n"
"    const toPrimitive = function(hint) {\r\n"
"      switch (hint) {\r\n"
"        case 'string':\r\n"
"        case 'default':\r\n"
"          return this.$[NAME];\r\n"
"        default:\r\n"
"          return get.call(this, 'number');\r\n"
"      }\r\n"
"    };\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get, set },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      typedArray: typedArray && getTypedArrayDescriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toString: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [Symbol.toPrimitive]: { value: toPrimitive },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"  function appendEnumeration(enumeration, name, item) {\r\n"
"    if (name !== undefined) {\r\n"
"      // enum can have static variables\r\n"
"      if (item instanceof enumeration) {\r\n"
"        // attach name to item so tagged union code can quickly find it\r\n"
"        defineProperties(item, { [NAME]: { value: name } });\r\n"
"        // call toPrimitive directly since enum can be bigint or number\r\n"
"        const index = item[Symbol.toPrimitive]();\r\n"
"        defineProperties(enumeration, {\r\n"
"          [index]: { value: item },\r\n"
"          [name]: { value: item },\r\n"
"        });\r\n"
"      }\r\n"
"    } else {\r\n"
"      // non-exhaustive enum\r\n"
"      defineProperties(enumeration, { [MORE]: { value: true } });\r\n"
"    }\r\n"
"  }\n"
"\n"
"  let currentGlobalSet;\r\n"
"  let currentErrorClass;\r\n"
"\r\n"
"  function defineErrorSet(structure, env) {\r\n"
"    const {\r\n"
"      name,\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members: [ member ] },\r\n"
"    } = structure;\r\n"
"    if (!currentErrorClass) {\r\n"
"      currentErrorClass = class ZigError extends ZigErrorBase {};\r\n"
"      currentGlobalSet = defineErrorSet({ ...structure, name: 'anyerror' }, env);\r\n"
"    }\r\n"
"    if (currentGlobalSet && name === 'anyerror') {\r\n"
"      structure.constructor = currentGlobalSet;\r\n"
"      structure.typedArray = getTypedArrayClass(member);\r\n"
"      return currentGlobalSet;\r\n"
"    }\r\n"
"    const errorClass = currentErrorClass;\r\n"
"    const { get, set } = getDescriptor(member, env);\r\n"
"    const expected = [ 'string', 'number' ];\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor[CLASS]) {\r\n"
"        set.call(this, arg);\r\n"
"      } else if (arg && typeof(arg) === 'object' && !isErrorJSON(arg)) {\r\n"
"        if (propApplier.call(this, arg) === 0) {\r\n"
"          throw new InvalidInitializer(structure, expected, arg);\r\n"
"        }\r\n"
"      } else if (arg !== undefined) {\r\n"
"        set.call(this, arg);\r\n"
"      }\r\n"
"    };\r\n"
"    const alternateCaster = function(arg) {\r\n"
"      if (typeof(arg) === 'number' || typeof(arg) === 'string') {\r\n"
"        return constructor[arg];\r\n"
"      } else if (arg instanceof constructor[CLASS]) {\r\n"
"        return constructor[Number(arg)];\r\n"
"      } else if (isErrorJSON(arg)) {\r\n"
"        return constructor[`Error: ${arg.error}`];\r\n"
"      } else if (!getDataView(structure, arg, env)) {\r\n"
"        throw new InvalidInitializer(structure, expected, arg);\r\n"
"      } else {\r\n"
"        return false;\r\n"
"      }\r\n"
"    };\r\n"
"    // items are inserted when static members get attached in static.js\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster }, env);\r\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get, set },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      typedArray: typedArray && getTypedArrayDescriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [CLASS]: { value: errorClass },\r\n"
"      // the PROPS array is normally set in static.js; it needs to be set here for anyerror\r\n"
"      // so we can add names to it as error sets are defined\r\n"
"      [PROPS]: (name === 'anyerror') ? { value: [] } : undefined,\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"  function appendErrorSet(errorSet, name, es) {\r\n"
"    // our Zig export code places error set instance into the static template, which we can't\r\n"
"    // use since all errors need to have the same parent class; here we get the error number\r\n"
"    // and create the actual error object if hasn't been created already for an earlier set\r\n"
"    const number = es[GETTER]('number');\r\n"
"    let error = currentGlobalSet[number];\r\n"
"    if (!error) {\r\n"
"      const errorClass = errorSet[CLASS];\r\n"
"      error = new errorClass(name, number);\r\n"
"    }\r\n"
"    const string = String(error);\r\n"
"    const descriptors = {\r\n"
"      [number]: { value: error },\r\n"
"      [string]: { value: error },\r\n"
"      [name]: { value: error },\r\n"
"    };\r\n"
"    defineProperties(errorSet, descriptors);\r\n"
"    defineProperties(currentGlobalSet, descriptors);\r\n"
"    // add name to prop list\r\n"
"    currentGlobalSet[PROPS].push(name);\r\n"
"  }\r\n"
"\r\n"
"  function resetGlobalErrorSet() {\r\n"
"    currentErrorClass = currentGlobalSet = undefined;\r\n"
"  }\r\n"
"\r\n"
"  class ZigErrorBase extends Error {\r\n"
"    constructor(name, number) {\r\n"
"      super(deanimalizeErrorName(name));\r\n"
"      this.number = number;\r\n"
"      this.stack = undefined;\r\n"
"    }\r\n"
"\r\n"
"    [Symbol.toPrimitive](hint) {\r\n"
"      switch (hint) {\r\n"
"        case 'string':\r\n"
"        case 'default':\r\n"
"          return Error.prototype.toString.call(this, hint);\r\n"
"        default:\r\n"
"          return this.number;\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    toJSON() {\r\n"
"      return { error: this.message };\r\n"
"    }\r\n"
"  }\n"
"\n"
"  function defineErrorUnion(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members },\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"    const { get: getValue, set: setValue } = getDescriptor(members[0], env);\r\n"
"    const { get: getError, set: setError } = getDescriptor(members[1], env);\r\n"
"    const get = function() {\r\n"
"      const errNum = getError.call(this, 'number');\r\n"
"      if (errNum) {\r\n"
"        throw getError.call(this);\r\n"
"      } else {\r\n"
"        return getValue.call(this);\r\n"
"      }\r\n"
"    };\r\n"
"    const isValueVoid = members[0].type === MemberType.Void;\r\n"
"    const errorSet = members[1].structure.constructor;\r\n"
"    const isChildActive = function() {\r\n"
"      return !getError.call(this, 'number');\r\n"
"    };\r\n"
"    const clearValue = function() {\r\n"
"      this[RESETTER]();\r\n"
"      this[POINTER_VISITOR]?.(resetPointer);\r\n"
"    };\r\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        this[COPIER](arg);\r\n"
"        if (hasPointer) {\r\n"
"          if (isChildActive.call(this)) {\r\n"
"            this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\r\n"
"          }\r\n"
"        }\r\n"
"      } else if (arg instanceof errorSet[CLASS] && errorSet(arg)) {\r\n"
"        setError.call(this, arg);\r\n"
"        clearValue.call(this);\r\n"
"      } else if (arg !== undefined || isValueVoid) {\r\n"
"        try {\r\n"
"          // call setValue() first, in case it throws\r\n"
"          setValue.call(this, arg);\r\n"
"          setError.call(this, 0, 'number');\r\n"
"        } catch (err) {\r\n"
"          if (arg instanceof Error) {\r\n"
"            // we give setValue a chance to see if the error is actually an acceptable value\r\n"
"            // now is time to throw an error\r\n"
"            throw new NotInErrorSet(structure);\r\n"
"          } else if (isErrorJSON(arg)) {\r\n"
"            setError.call(this, arg);\r\n"
"            clearValue.call(this);\r\n"
"          } else if (arg && typeof(arg) === 'object') {\r\n"
"            if (propApplier.call(this, arg) === 0) {\r\n"
"              throw err;\r\n"
"            }\r\n"
"          } else {\r\n"
"            throw err;\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\r\n"
"    const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];\r\n"
"    const instanceDescriptors = {\r\n"
"      '$': { get, set: initializer },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [RESETTER]: { value: getMemoryResetter(valueBitOffset / 8, valueByteSize) },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\n"
"\n"
"  function defineOpaque(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      isIterator,\r\n"
"    } = structure;\r\n"
"    const initializer = function() {\r\n"
"      throw new CreatingOpaque(structure);\r\n"
"    };\r\n"
"    const valueAccessor = function() {\r\n"
"      throw new AccessingOpaque(structure);\r\n"
"    };\r\n"
"    const toPrimitive = function(hint) {\r\n"
"      const { name } = structure;\r\n"
"      return `[opaque ${name}]`;\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\r\n"
"    const getIterator = (isIterator) ? getIteratorIterator : null;\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get: valueAccessor, set: valueAccessor },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [Symbol.iterator]: getIterator && { value: getIterator },\r\n"
"      [Symbol.toPrimitive]: { value: toPrimitive },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\n"
"\n"
"  function defineOptional(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members },\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"    const { get: getValue, set: setValue } = getDescriptor(members[0], env);\r\n"
"    // NOTE: getPresent returns a uint now\r\n"
"    const { get: getPresent, set: setPresent } = getDescriptor(members[1], env);\r\n"
"    const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);\r\n"
"    const get = function() {\r\n"
"      const present = getPresent.call(this);\r\n"
"      if (present) {\r\n"
"        return getValue.call(this);\r\n"
"      } else {\r\n"
"        this[POINTER_VISITOR]?.(resetPointer);\r\n"
"        return null;\r\n"
"      }\r\n"
"    };\r\n"
"    const isValueVoid = members[0].type === MemberType.Void;\r\n"
"    const isChildActive = function () {\r\n"
"      return !!getPresent.call(this);\r\n"
"    };\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        this[COPIER](arg);\r\n"
"        if (hasPointer) {\r\n"
"          // don't bother copying pointers when it's empty\r\n"
"          if (isChildActive.call(arg)) {\r\n"
"            this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\r\n"
"          }\r\n"
"        }\r\n"
"      } else if (arg === null) {\r\n"
"        setPresent.call(this, 0);\r\n"
"        this[RESETTER]?.();\r\n"
"        // clear references so objects can be garbage-collected\r\n"
"        this[POINTER_VISITOR]?.(resetPointer);\r\n"
"      } else if (arg !== undefined || isValueVoid) {\r\n"
"        // call setValue() first, in case it throws\r\n"
"        setValue.call(this, arg);\r\n"
"        if (hasPresentFlag || !this[MEMORY][FIXED]) {\r\n"
"          // since setValue() wouldn't write address into memory when the pointer is in\r\n"
"          // relocatable memory, we need to use setPresent() in order to write something\r\n"
"          // non-zero there so that we know the field is populated\r\n"
"          setPresent.call(this, 1);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\r\n"
"    const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];\r\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get, set: initializer },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer\r\n"
"      [RESETTER]: !hasPointer && { value: getMemoryResetter(valueBitOffset / 8, valueByteSize) },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\n"
"\n"
"  function definePrimitive(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members: [ member ] },\r\n"
"    } = structure;\r\n"
"    const { get, set } = getDescriptor(member, env);\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        this[COPIER](arg);\r\n"
"      } else {\r\n"
"        if (arg && typeof(arg) === 'object') {\r\n"
"          if (propApplier.call(this, arg) === 0) {\r\n"
"            const type = getPrimitiveType(member);\r\n"
"            throw new InvalidInitializer(structure, type, arg);\r\n"
"          }\r\n"
"        } else if (arg !== undefined) {\r\n"
"          set.call(this, arg);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\r\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get, set },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      typedArray: typedArray && getTypedArrayDescriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [Symbol.toPrimitive]: { value: get },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"      [PRIMITIVE]: { value: member.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\n"
"\n"
"  function defineSlice(structure, env) {\r\n"
"    const {\r\n"
"      type,\r\n"
"      align,\r\n"
"      instance: {\r\n"
"        members: [ member ],\r\n"
"      },\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"\r\n"
"    const { get, set } = getDescriptor(member, env);\r\n"
"    const { byteSize: elementSize, structure: elementStructure } = member;\r\n"
"    const sentinel = getSentinel(structure, env);\r\n"
"    if (sentinel) {\r\n"
"      // zero-terminated strings aren't expected to be commonly used\r\n"
"      // so we're not putting this prop into the standard structure\r\n"
"      structure.sentinel = sentinel;\r\n"
"    }\r\n"
"    const hasStringProp = canBeString(member);\r\n"
"    const shapeDefiner = function(dv, length, fixed = false) {\r\n"
"      if (!dv) {\r\n"
"        dv = env.allocateMemory(length * elementSize, align, fixed);\r\n"
"      }\r\n"
"      this[MEMORY] = dv;\r\n"
"      this[LENGTH] = length;\r\n"
"      if (type === StructureType.Slice) {\r\n"
"        this[MAX_LENGTH] = length;\r\n"
"      }\r\n"
"    };\r\n"
"    const shapeChecker = function(arg, length) {\r\n"
"      if (length !== this[LENGTH]) {\r\n"
"        throw new ArrayLengthMismatch(structure, this, arg);\r\n"
"      }\r\n"
"    };\r\n"
"    // the initializer behave differently depending on whether it's called by the\r\n"
"    // constructor or by a member setter (i.e. after object's shape has been established)\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg, fixed = false) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        if (!this[MEMORY]) {\r\n"
"          shapeDefiner.call(this, null, arg.length, fixed);\r\n"
"        } else {\r\n"
"          shapeChecker.call(this, arg, arg.length);\r\n"
"        }\r\n"
"        this[COPIER](arg);\r\n"
"        if (hasPointer) {\r\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\r\n"
"        }\r\n"
"      } else if (typeof(arg) === 'string' && hasStringProp) {\r\n"
"        initializer.call(this, { string: arg }, fixed);\r\n"
"      } else if (arg?.[Symbol.iterator]) {\r\n"
"        arg = transformIterable(arg);\r\n"
"        if (!this[MEMORY]) {\r\n"
"          shapeDefiner.call(this, null, arg.length, fixed);\r\n"
"        } else {\r\n"
"          shapeChecker.call(this, arg, arg.length);\r\n"
"        }\r\n"
"        let i = 0;\r\n"
"        for (const value of arg) {\r\n"
"          sentinel?.validateValue(value, i, arg.length);\r\n"
"          set.call(this, i++, value);\r\n"
"        }\r\n"
"      } else if (typeof(arg) === 'number') {\r\n"
"        if (!this[MEMORY] && arg >= 0 && isFinite(arg)) {\r\n"
"          shapeDefiner.call(this, null, arg);\r\n"
"        } else {\r\n"
"          throw new InvalidArrayInitializer(structure, arg, !this[MEMORY]);\r\n"
"        }\r\n"
"      } else if (arg && typeof(arg) === 'object') {\r\n"
"        if (propApplier.call(this, arg, fixed) === 0) {\r\n"
"          throw new InvalidArrayInitializer(structure, arg);\r\n"
"        }\r\n"
"      } else if (arg !== undefined) {\r\n"
"        throw new InvalidArrayInitializer(structure, arg);\r\n"
"      }\r\n"
"    };\r\n"
"    const getLength = function() {\r\n"
"      return this[LENGTH];\r\n"
"    };\r\n"
"    const adjustIndex = function(index, len) {\r\n"
"      index = index | 0;\r\n"
"      if (index < 0) {\r\n"
"        index = len + index;\r\n"
"        if (index < 0) {\r\n"
"          index = 0;\r\n"
"        }\r\n"
"      } else {\r\n"
"        if (index > len) {\r\n"
"          index = len;\r\n"
"        }\r\n"
"      }\r\n"
"      return index;\r\n"
"    };\r\n"
"    function getSubArrayView(begin, end) {\r\n"
"      begin = (begin === undefined) ? 0 : adjustIndex(begin, this.length);\r\n"
"      end = (end === undefined) ? this.length : adjustIndex(end, this.length);\r\n"
"      const offset = begin * elementSize;\r\n"
"      const len = (end * elementSize) - offset;\r\n"
"      return env.obtainView(this[MEMORY].buffer, offset, len);\r\n"
"    }\r\n"
"    function getSubarrayOf(begin, end) {\r\n"
"      const dv = getSubArrayView.call(this, begin, end);\r\n"
"      return constructor(dv);\r\n"
"    }  const getSliceOf = function(begin, end, options = {}) {\r\n"
"      const {\r\n"
"        fixed = false\r\n"
"      } = options;\r\n"
"      const source = { [MEMORY]: getSubArrayView.call(this, begin, end) };\r\n"
"      const dest = constructor(env.allocateMemory(source[MEMORY].byteLength, align, fixed));\r\n"
"      copier.call(dest, source);\r\n"
"      return dest;\r\n"
"    };\r\n"
"    const finalizer = createArrayProxy;\r\n"
"    const copier = getMemoryCopier(elementSize, true);\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, shapeDefiner, finalizer }, env);\r\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\r\n"
"    const hasObject = member.type === MemberType.Object;\r\n"
"    const shapeHandlers = { shapeDefiner };\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get: getProxy, set: initializer },\r\n"
"      length: { get: getLength },\r\n"
"      dataView: getDataViewDescriptor(structure, shapeHandlers),\r\n"
"      base64: getBase64Descriptor(structure, shapeHandlers),\r\n"
"      string: hasStringProp && getStringDescriptor(structure, shapeHandlers),\r\n"
"      typedArray: typedArray && getTypedArrayDescriptor(structure, shapeHandlers),\r\n"
"      get: { value: get },\r\n"
"      set: { value: set },\r\n"
"      entries: { value: getArrayEntries },\r\n"
"      slice: { value: getSliceOf },\r\n"
"      subarray: { value: getSubarrayOf },\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      [Symbol.iterator]: { value: getArrayIterator },\r\n"
"      [ENTRIES_GETTER]: { value: getArrayEntries },\r\n"
"      [COPIER]: { value: copier },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasPointer && { value: getPointerVisitor() },\r\n"
"      [WRITE_DISABLER]: { value: makeArrayReadOnly },\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      child: { get: () => elementStructure.constructor },\r\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: elementSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"  }\r\n"
"\r\n"
"  function getSentinel(structure, env) {\r\n"
"    const {\r\n"
"      runtimeSafety = true,\r\n"
"    } = env;\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      instance: { members: [ member, sentinel ], template },\r\n"
"    } = structure;\r\n"
"    if (!sentinel) {\r\n"
"      return;\r\n"
"    }\r\n"
"\r\n"
"    const { get: getSentinelValue } = getDescriptor(sentinel, env);\r\n"
"    const value = getSentinelValue.call(template, 0);\r\n"
"    const { get } = getDescriptor(member, env);\r\n"
"    const { isRequired } = member;\r\n"
"    const validateValue = (isRequired)\r\n"
"    ? (runtimeSafety)\r\n"
"      ? function(v, i, l) {\r\n"
"        if (v === value && i !== l - 1) {\r\n"
"          throw new MisplacedSentinel(structure, v, i, l);\r\n"
"        } else if (v !== value && i === l - 1) {\r\n"
"          throw new MissingSentinel(structure, value, i, l);\r\n"
"        }\r\n"
"      } : function(v, i, l) {\r\n"
"        if (v !== value && i === l - 1) {\r\n"
"          throw new MissingSentinel(structure, value, l);\r\n"
"        }\r\n"
"      }\r\n"
"    : function() {};\r\n"
"    const validateData = (isRequired)\r\n"
"    ? (runtimeSafety)\r\n"
"      ? function(source, len) {\r\n"
"          for (let i = 0; i < len; i++) {\r\n"
"            const v = get.call(source, i);\r\n"
"            if (v === value && i !== len - 1) {\r\n"
"              throw new MisplacedSentinel(structure, value, i, len);\r\n"
"            } else if (v !== value && i === len - 1) {\r\n"
"              throw new MissingSentinel(structure, value, len);\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"      : function(source, len) {\r\n"
"          if (len * byteSize === source[MEMORY].byteLength) {\r\n"
"            const i = len - 1;\r\n"
"            const v = get.call(source, i);\r\n"
"            if (v !== value) {\r\n"
"              throw new MissingSentinel(structure, value, len);\r\n"
"            }\r\n"
"          }\r\n"
"      }\r\n"
"    : function () {};\r\n"
"    const bytes = template[MEMORY];\r\n"
"    return { value, bytes, validateValue, validateData, isRequired };\r\n"
"  }\n"
"\n"
"  function defineUnionShape(structure, env) {\r\n"
"    const {\r\n"
"      type,\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members, template },\r\n"
"      isIterator,\r\n"
"      hasPointer,\r\n"
"    } = structure;\r\n"
"    const { runtimeSafety } = env;\r\n"
"    const isTagged = (type === StructureType.TaggedUnion);\r\n"
"    const exclusion = (isTagged || (type === StructureType.BareUnion && runtimeSafety));\r\n"
"    const memberDescriptors = {};\r\n"
"    const memberInitializers = {};\r\n"
"    const memberValueGetters = {};\r\n"
"    const valueMembers = (exclusion) ? members.slice(0, -1) : members;\r\n"
"    const selectorMember = (exclusion) ? members[members.length - 1] : null;\r\n"
"    const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor(selectorMember, env) : {};\r\n"
"    const getActiveField = (isTagged)\r\n"
"    ? function() {\r\n"
"        const item = getSelector.call(this);\r\n"
"        return item[NAME];\r\n"
"      }\r\n"
"    : function() {\r\n"
"        const index = getSelector.call(this);\r\n"
"        return valueMembers[index].name;\r\n"
"      };\r\n"
"    const setActiveField = (isTagged)\r\n"
"    ? function(name) {\r\n"
"        const { constructor } = selectorMember.structure;\r\n"
"        setSelector.call(this, constructor[name]);\r\n"
"      }\r\n"
"    : function(name) {\r\n"
"        const index = valueMembers.findIndex(m => m.name === name);\r\n"
"        setSelector.call(this, index);\r\n"
"      };\r\n"
"    for (const member of valueMembers) {\r\n"
"      const { name } = member;\r\n"
"      const { get: getValue, set: setValue } = getDescriptor(member, env);\r\n"
"      const get = (exclusion)\r\n"
"      ? function() {\r\n"
"          const currentName = getActiveField.call(this);\r\n"
"          if (name !== currentName) {\r\n"
"            if (isTagged) {\r\n"
"              // tagged union allows inactive member to be queried\r\n"
"              return null;\r\n"
"            } else {\r\n"
"              // whereas bare union does not, since the condition is not detectable\r\n"
"              // when runtime safety is off\r\n"
"              throw new InactiveUnionProperty(structure, name, currentName);\r\n"
"            }\r\n"
"          }\r\n"
"          this[POINTER_VISITOR]?.(resetPointer);\r\n"
"          return getValue.call(this);\r\n"
"        }\r\n"
"      : getValue;\r\n"
"      const set = (exclusion && setValue)\r\n"
"      ? function(value) {\r\n"
"          const currentName = getActiveField.call(this);\r\n"
"          if (name !== currentName) {\r\n"
"            throw new InactiveUnionProperty(structure, name, currentName);\r\n"
"          }\r\n"
"          setValue.call(this, value);\r\n"
"        }\r\n"
"      : setValue;\r\n"
"      const init = (exclusion && setValue)\r\n"
"      ? function(value) {\r\n"
"          setActiveField.call(this, name);\r\n"
"          setValue.call(this, value);\r\n"
"          this[POINTER_VISITOR]?.(resetPointer);\r\n"
"        }\r\n"
"      : setValue;\r\n"
"      memberDescriptors[name] = { get, set, configurable: true, enumerable: true };\r\n"
"      memberInitializers[name] = init;\r\n"
"      memberValueGetters[name] = getValue;\r\n"
"    }\r\n"
"    const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);\r\n"
"    const memberKeys = Object.keys(memberDescriptors);\r\n"
"    const propApplier = createPropertyApplier(structure);\r\n"
"    const initializer = function(arg) {\r\n"
"      if (arg instanceof constructor) {\r\n"
"        /* WASM-ONLY-END */\r\n"
"        this[COPIER](arg);\r\n"
"        if (hasPointer) {\r\n"
"          this[POINTER_VISITOR](copyPointer, { vivificate: true, source: arg });\r\n"
"        }\r\n"
"      } else if (arg && typeof(arg) === 'object') {\r\n"
"        let found = 0;\r\n"
"        for (const key of memberKeys) {\r\n"
"          if (key in arg) {\r\n"
"            found++;\r\n"
"          }\r\n"
"        }\r\n"
"        if (found > 1) {\r\n"
"          throw new MultipleUnionInitializers(structure);\r\n"
"        }\r\n"
"        if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {\r\n"
"          throw new MissingUnionInitializer(structure, arg, exclusion);\r\n"
"        }\r\n"
"      } else if (arg !== undefined) {\r\n"
"        throw new InvalidInitializer(structure, 'object with a single property', arg);\r\n"
"      }\r\n"
"    };\r\n"
"    // non-tagged union as marked as not having pointers--if there're actually\r\n"
"    // members with pointers, we need to disable them\r\n"
"    const pointerMembers = members.filter(m => m.structure?.hasPointer);\r\n"
"    const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);\r\n"
"    const modifier = (hasInaccessiblePointer && !env.comptime)\r\n"
"    ? function() {\r\n"
"        // make pointer access throw\r\n"
"        this[POINTER_VISITOR](disablePointer, { vivificate: true });\r\n"
"      }\r\n"
"    : undefined;\r\n"
"    const constructor = structure.constructor = createConstructor(structure, { modifier, initializer }, env);\r\n"
"    const fieldDescriptor = (isTagged)\r\n"
"    ? {\r\n"
"        // for tagged union,  only the active field\r\n"
"        get() { return [ getActiveField.call(this) ] }\r\n"
"      }\r\n"
"    : {\r\n"
"        // for bare and extern union, all members are included\r\n"
"        value: valueMembers.map(m => m.name)\r\n"
"      };\r\n"
"    const isChildActive = (isTagged)\r\n"
"    ? function(child) {\r\n"
"        const name = getActiveField.call(this);\r\n"
"        const active = memberValueGetters[name].call(this);\r\n"
"        return child === active;\r\n"
"      }\r\n"
"    : never;\r\n"
"    const toPrimitive = (isTagged)\r\n"
"    ? function(hint) {\r\n"
"      switch (hint) {\r\n"
"        case 'string':\r\n"
"        case 'default':\r\n"
"          return getActiveField.call(this);\r\n"
"        default:\r\n"
"          return getSelector.call(this, 'number');\r\n"
"      }\r\n"
"    }\r\n"
"    : null;\r\n"
"    const getTagClass = function() { return selectorMember.structure.constructor };\r\n"
"    const getIterator = (isIterator) ? getIteratorIterator : getUnionIterator;\r\n"
"    const hasAnyPointer = hasPointer || hasInaccessiblePointer;\r\n"
"    const hasObject = !!members.find(m => m?.type === MemberType.Object);\r\n"
"    const instanceDescriptors = {\r\n"
"      $: { get: getSelf, set: initializer, configurable: true },\r\n"
"      dataView: getDataViewDescriptor(structure),\r\n"
"      base64: getBase64Descriptor(structure),\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      delete: { value: getDestructor(env) },\r\n"
"      ...memberDescriptors,\r\n"
"      [Symbol.iterator]: { value: getIterator },\r\n"
"      [Symbol.toPrimitive]: isTagged && { value: toPrimitive },\r\n"
"      [ENTRIES_GETTER]: { value: getUnionEntries },\r\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\r\n"
"      [TAG]: isTagged && { get: getSelector, configurable: true },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure, env) },\r\n"
"      [POINTER_VISITOR]: hasAnyPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },\r\n"
"      [PROP_GETTERS]: { value: memberValueGetters },\r\n"
"      [WRITE_DISABLER]: { value: makeReadOnly },\r\n"
"      [PROPS]: fieldDescriptor,\r\n"
"    };\r\n"
"    const staticDescriptors = {\r\n"
"      tag: isTagged && { get: getTagClass },\r\n"
"      [ALIGN]: { value: align },\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"      [TYPE]: { value: structure.type },\r\n"
"    };\r\n"
"    attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\r\n"
"    // replace regular setters with ones that change the active field\r\n"
"    const setters = constructor.prototype[PROP_SETTERS];\r\n"
"    for (const [ name, init ] of Object.entries(memberInitializers)) {\r\n"
"      if (init) {\r\n"
"        setters[name] = init;\r\n"
"      }\r\n"
"    }\r\n"
"  }\r\n"
"  function getUnionEntries(options) {\r\n"
"    return {\r\n"
"      [Symbol.iterator]: getUnionEntriesIterator.bind(this, options),\r\n"
"      length: this[PROPS].length,\r\n"
"    };\r\n"
"  }\r\n"
"\r\n"
"  function getUnionIterator(options) {\r\n"
"    const entries = getUnionEntries.call(this, options);\r\n"
"    return entries[Symbol.iterator]();\r\n"
"  }\r\n"
"\r\n"
"  function getUnionEntriesIterator(options) {\r\n"
"    const self = this;\r\n"
"    const props = this[PROPS];\r\n"
"    const getters = this[PROP_GETTERS];\r\n"
"    let index = 0;\r\n"
"    return {\r\n"
"      next() {\r\n"
"        let value, done;\r\n"
"        if (index < props.length) {\r\n"
"          const current = props[index++];\r\n"
"          // get value of prop with no check\r\n"
"          value = [ current, handleError(() => getters[current].call(self), options) ];\r\n"
"          done = false;\r\n"
"        } else {\r\n"
"          done = true;\r\n"
"        }\r\n"
"        return { value, done };\r\n"
"      },\r\n"
"    };\r\n"
"  }\n"
"\n"
"  function defineVariadicStruct(structure, env) {\r\n"
"    const {\r\n"
"      byteSize,\r\n"
"      align,\r\n"
"      instance: { members },\r\n"
"    } = structure;\r\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\r\n"
"    const argKeys = members.slice(1).map(m => m.name);\r\n"
"    const maxSlot = members.map(m => m.slot).sort().pop();\r\n"
"    const argCount = argKeys.length;\r\n"
"    const constructor = structure.constructor = function(args, name, offset) {\r\n"
"      if (args.length < argCount) {\r\n"
"        throw new ArgumentCountMismatch(name, `at least ${argCount - offset}`, args.length - offset);\r\n"
"      }\r\n"
"      // calculate the actual size of the struct based on arguments given\r\n"
"      let totalByteSize = byteSize;\r\n"
"      const varArgs = args.slice(argCount);\r\n"
"      const offsets = {};\r\n"
"      for (const [ index, arg ] of varArgs.entries()) {\r\n"
"        const dv = arg[MEMORY];\r\n"
"        let argAlign = arg.constructor[ALIGN];\r\n"
"        if (!dv || !argAlign) {\r\n"
"          const err = new InvalidVariadicArgument();\r\n"
"          throw adjustArgumentError(name, index - offset, argCount - offset, err);\r\n"
"        }\r\n"
"\r\n"
"        const offset = offsets[index] = (totalByteSize + argAlign - 1) & ~(argAlign - 1);\r\n"
"        totalByteSize = offset + dv.byteLength;\r\n"
"      }\r\n"
"      const attrs = new ArgAttributes(args.length);\r\n"
"      const dv = env.allocateMemory(totalByteSize);\r\n"
"      this[MEMORY] = dv;\r\n"
"      this[SLOTS] = {};\r\n"
"      for (const [ index, key ] of argKeys.entries()) {\r\n"
"        try {\r\n"
"          this[key] = args[index];\r\n"
"        } catch (err) {\r\n"
"          throw adjustArgumentError(name, index - offset, argCount - offset, err);\r\n"
"        }\r\n"
"      }\r\n"
"      // set attributes of retval and fixed args\r\n"
"      for (const [ index, { bitOffset, byteSize, type, structure: { align } } ] of members.entries()) {\r\n"
"        attrs.set(index, bitOffset / 8, byteSize, align, type);\r\n"
"      }\r\n"
"      // create additional child objects and copy arguments into them\r\n"
"      for (const [ index, arg ] of varArgs.entries()) {\r\n"
"        const slot = maxSlot + index + 1;\r\n"
"        const { byteLength } = arg[MEMORY];\r\n"
"        const offset = offsets[index];\r\n"
"        const childDV = env.obtainView(dv.buffer, offset, byteLength);\r\n"
"        const child = this[SLOTS][slot] = arg.constructor.call(PARENT, childDV);\r\n"
"        child.$ = arg;\r\n"
"        // set attributes\r\n"
"        attrs.set(1 + argCount + index, offset, byteLength, arg.constructor[ALIGN], arg.constructor[PRIMITIVE]);\r\n"
"      }\r\n"
"      this[ATTRIBUTES] = attrs;\r\n"
"    };\r\n"
"    const memberDescriptors = {};\r\n"
"    for (const member of members) {\r\n"
"      memberDescriptors[member.name] = getDescriptor(member, env);\r\n"
"    }\r\n"
"    const { slot: retvalSlot, type: retvalType } = members[0];\r\n"
"    const isChildMutable = (retvalType === MemberType.Object)\r\n"
"    ? function(object) {\r\n"
"        const child = this[VIVIFICATOR](retvalSlot);\r\n"
"        return object === child;\r\n"
"      }\r\n"
"    : function() { return false };\r\n"
"    const visitPointers = function(cb, options = {}) {\r\n"
"      const {\r\n"
"        vivificate = false,\r\n"
"        isActive = always,\r\n"
"        isMutable = always,\r\n"
"      } = options;\r\n"
"      const childOptions = {\r\n"
"        ...options,\r\n"
"        isActive,\r\n"
"        isMutable: (object) => isMutable(this) && isChildMutable.call(this, object),\r\n"
"      };\r\n"
"      if (vivificate && retvalType === MemberType.Object) {\r\n"
"        this[VIVIFICATOR](retvalSlot);\r\n"
"      }\r\n"
"      for (const child of Object.values(this[SLOTS])) {\r\n"
"        child?.[POINTER_VISITOR]?.(cb, childOptions);\r\n"
"      }\r\n"
"    };\r\n"
"    const ArgAttributes = function(length) {\r\n"
"      this[MEMORY] = env.allocateMemory((1 + length) * 8, 4);\r\n"
"      this.length = length;\r\n"
"      this.littleEndian = env.littleEndian;\r\n"
"    };\r\n"
"    const setAttributes = function(index, offset, size, align, type) {\r\n"
"      const dv = this[MEMORY];\r\n"
"      const le = env.littleEndian;\r\n"
"      dv.setUint16(index * 8, offset, le);\r\n"
"      dv.setUint16(index * 8 + 2, size, le);\r\n"
"      dv.setUint16(index * 8 + 4, align, le);\r\n"
"      dv.setUint8(index * 8 + 6, type == MemberType.Float);\r\n"
"      dv.setUint8(index * 8 + 7, type == MemberType.Int);\r\n"
"    };\r\n"
"    defineProperties(ArgAttributes.prototype, {\r\n"
"      set: { value: setAttributes },\r\n"
"      [COPIER]: { value: getMemoryCopier(4, true) },\r\n"
"      [ALIGN]: { value: 4 },\r\n"
"\r\n"
"    });\r\n"
"    defineProperties(constructor.prototype, {\r\n"
"      ...memberDescriptors,\r\n"
"      [COPIER]: { value: getMemoryCopier(undefined, true) },\r\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure, env) },\r\n"
"      [POINTER_VISITOR]: { value: visitPointers },\r\n"
"\r\n"
"    });\r\n"
"    defineProperties(constructor, {\r\n"
"      [SIZE]: { value: byteSize },\r\n"
"    });\r\n"
"    return constructor;\r\n"
"  }\n"
"\n"
"  const factories = Array(Object.values(StructureType).length);\r\n"
"\r\n"
"  function usePrimitive() {\r\n"
"    factories[StructureType.Primitive] = definePrimitive;\r\n"
"  }\r\n"
"\r\n"
"  function useArray() {\r\n"
"    factories[StructureType.Array] = defineArray;\r\n"
"  }\r\n"
"\r\n"
"  function useStruct() {\r\n"
"    factories[StructureType.Struct] = defineStructShape;\r\n"
"  }\r\n"
"\r\n"
"  function usePackedStruct() {\r\n"
"    factories[StructureType.PackedStruct] = defineStructShape;\r\n"
"  }\r\n"
"\r\n"
"  function useExternStruct() {\r\n"
"    factories[StructureType.ExternStruct] = defineStructShape;\r\n"
"  }\r\n"
"\r\n"
"  function useArgStruct() {\r\n"
"    factories[StructureType.ArgStruct] = defineArgStruct;\r\n"
"  }\r\n"
"\r\n"
"  function useVariadicStruct() {\r\n"
"    factories[StructureType.VariadicStruct] = defineVariadicStruct;\r\n"
"  }\r\n"
"\r\n"
"  function useExternUnion() {\r\n"
"    factories[StructureType.ExternUnion] = defineUnionShape;\r\n"
"  }\r\n"
"\r\n"
"  function useBareUnion() {\r\n"
"    factories[StructureType.BareUnion] = defineUnionShape;\r\n"
"  }\r\n"
"\r\n"
"  function useTaggedUnion() {\r\n"
"    factories[StructureType.TaggedUnion] = defineUnionShape;\r\n"
"  }\r\n"
"\r\n"
"  function useErrorUnion() {\r\n"
"    factories[StructureType.ErrorUnion] = defineErrorUnion;\r\n"
"  }\r\n"
"\r\n"
"  function useErrorSet() {\r\n"
"    factories[StructureType.ErrorSet] = defineErrorSet;\r\n"
"    useErrorSetTransform();\r\n"
"  }\r\n"
"\r\n"
"  function useEnum() {\r\n"
"    factories[StructureType.Enum] = defineEnumerationShape;\r\n"
"    useEnumerationTransform();\r\n"
"  }\r\n"
"\r\n"
"  function useOptional() {\r\n"
"    factories[StructureType.Optional] = defineOptional;\r\n"
"  }\r\n"
"\r\n"
"  function useSinglePointer() {\r\n"
"    factories[StructureType.SinglePointer] = definePointer;\r\n"
"    useUint();\r\n"
"  }\r\n"
"\r\n"
"  function useSlicePointer() {\r\n"
"    factories[StructureType.SlicePointer] = definePointer;\r\n"
"    useUint();\r\n"
"  }\r\n"
"\r\n"
"  function useMultiPointer() {\r\n"
"    factories[StructureType.MultiPointer] = definePointer;\r\n"
"    useUint();\r\n"
"  }\r\n"
"\r\n"
"  function useCPointer() {\r\n"
"    factories[StructureType.CPointer] = definePointer;\r\n"
"    useUint();\r\n"
"  }\r\n"
"\r\n"
"  function useSlice() {\r\n"
"    factories[StructureType.Slice] = defineSlice;\r\n"
"  }\r\n"
"\r\n"
"  function useVector() {\r\n"
"    factories[StructureType.Vector] = defineVector;\r\n"
"  }\r\n"
"\r\n"
"  function useOpaque() {\r\n"
"    factories[StructureType.Opaque] = defineOpaque;\r\n"
"  }\r\n"
"\r\n"
"  function getStructureFactory(type) {\r\n"
"    const f = factories[type];\r\n"
"\r\n"
"    return f;\r\n"
"  }\r\n"
"\r\n"
"  function findAllObjects(structures, SLOTS) {\r\n"
"    const list = [];\r\n"
"    const found = new Map();\r\n"
"    const find = (object) => {\r\n"
"      if (!object || found.get(object)) {\r\n"
"        return;\r\n"
"      }\r\n"
"      found.set(object, true);\r\n"
"      list.push(object);\r\n"
"      if (object[SLOTS]) {\r\n"
"        for (const child of Object.values(object[SLOTS])) {\r\n"
"          find(child);\r\n"
"        }\r\n"
"      }\r\n"
"    };\r\n"
"    for (const structure of structures) {\r\n"
"      find(structure.instance.template);\r\n"
"      find(structure.static.template);\r\n"
"    }\r\n"
"    return list;\r\n"
"  }\r\n"
"\r\n"
"  function useAllStructureTypes() {\r\n"
"    usePrimitive();\r\n"
"    useArray();\r\n"
"    useStruct();\r\n"
"    useExternStruct();\r\n"
"    usePackedStruct();\r\n"
"    useArgStruct();\r\n"
"    useVariadicStruct();\r\n"
"    useExternUnion();\r\n"
"    useBareUnion();\r\n"
"    useTaggedUnion();\r\n"
"    useErrorUnion();\r\n"
"    useErrorSet();\r\n"
"    useEnum();\r\n"
"    useOptional();\r\n"
"    useSinglePointer();\r\n"
"    useSlicePointer();\r\n"
"    useMultiPointer();\r\n"
"    useCPointer();\r\n"
"    useSlice();\r\n"
"    useVector();\r\n"
"    useOpaque();\r\n"
"  }\n"
"\n"
"  function addMethods(s, env) {\r\n"
"    const add = (target, { methods }, pushThis) => {\r\n"
"      const descriptors = {};\r\n"
"      const re = /^(get|set)\\s+([\\s\\S]+)/;\r\n"
"      for (const method of methods) {\r\n"
"        const f = env.createCaller(method, pushThis);\r\n"
"        const m = re.exec(f.name);\r\n"
"        if (m) {\r\n"
"          // getter/setter\r\n"
"          const type = m[1], propName = m[2];\r\n"
"          const argRequired = (type === 'get') ? 0 : 1;\r\n"
"          const argCount = getArgumentCount(method, pushThis);\r\n"
"          // need to match arg count, since instance methods also show up as static methods\r\n"
"          if (argCount === argRequired) {\r\n"
"            let descriptor = descriptors[propName];\r\n"
"            if (!descriptor) {\r\n"
"              descriptor = descriptors[propName] = { configurable: true, enumerable: true };\r\n"
"            }\r\n"
"            descriptor[type] = f;\r\n"
"          }\r\n"
"        } else {\r\n"
"          descriptors[f.name] = { value: f, configurable: true, writable: true };\r\n"
"        }\r\n"
"      }\r\n"
"      defineProperties(target, descriptors);\r\n"
"    };\r\n"
"    add(s.constructor, s.static, false);\r\n"
"    add(s.constructor.prototype, s.instance, true);\r\n"
"  }\r\n"
"\r\n"
"  function getArgumentCount(method, pushThis) {\r\n"
"    const { argStruct: { instance: { members } } } = method;\r\n"
"    return members.length - (pushThis ? 2 : 1);\r\n"
"  }\n"
"\n"
"  function addStaticMembers(structure, env) {\r\n"
"    const {\r\n"
"      type,\r\n"
"      constructor,\r\n"
"      static: { members, template },\r\n"
"    } = structure;\r\n"
"    const descriptors = {};\r\n"
"    for (const member of members) {\r\n"
"      descriptors[member.name] = getDescriptor(member, env);\r\n"
"    }\r\n"
"    defineProperties(constructor, {\r\n"
"      valueOf: { value: getValueOf },\r\n"
"      toJSON: { value: convertToJSON },\r\n"
"      ...descriptors,\r\n"
"      [Symbol.iterator]: { value: getStructIterator },\r\n"
"      [ENTRIES_GETTER]: { value: getStructEntries },\r\n"
"      // static variables are objects stored in the static template's slots\r\n"
"      [SLOTS]: template && { value: template[SLOTS] },\r\n"
"      // anyerror would have props already\r\n"
"      [PROPS]: !constructor[PROPS] && { value: members.map(m => m.name) },\r\n"
"    });\r\n"
"    if (type === StructureType.Enum) {\r\n"
"      for (const { name, slot } of members) {\r\n"
"        appendEnumeration(constructor, name, constructor[SLOTS][slot]);\r\n"
"      }\r\n"
"    } else if (type === StructureType.ErrorSet) {\r\n"
"      for (const { name, slot } of members) {\r\n"
"        appendErrorSet(constructor, name, constructor[SLOTS][slot]);\r\n"
"      }\r\n"
"    }\r\n"
"  }\n"
"\n"
"  class Environment {\r\n"
"    context;\r\n"
"    contextStack = [];\r\n"
"    consolePending = [];\r\n"
"    consoleTimeout = 0;\r\n"
"    viewMap = new WeakMap();\r\n"
"    emptyBuffer = new ArrayBuffer(0);\r\n"
"    abandoned = false;\r\n"
"    released = false;\r\n"
"    littleEndian = true;\r\n"
"    wordSize = 4;\r\n"
"    runtimeSafety = true;\r\n"
"    comptime = false;\r\n"
"    /* COMPTIME-ONLY */\r\n"
"    slots = {};\r\n"
"    structures = [];\r\n"
"    /* COMPTIME-ONLY-END */\r\n"
"    /* RUNTIME-ONLY */\r\n"
"    variables = [];\r\n"
"    /* RUNTIME-ONLY-END */\r\n"
"    imports;\r\n"
"    console = globalThis.console;\r\n"
"\r\n"
"\r\n"
"\r\n"
"    startContext() {\r\n"
"      if (this.context) {\r\n"
"        this.contextStack.push(this.context);\r\n"
"      }\r\n"
"      this.context = new CallContext();\r\n"
"    }\r\n"
"\r\n"
"    endContext() {\r\n"
"      this.context = this.contextStack.pop();\r\n"
"    }\r\n"
"\r\n"
"    allocateMemory(len, align = 0, fixed = false) {\r\n"
"      if (fixed) {\r\n"
"        return this.allocateFixedMemory(len, align);\r\n"
"      } else {\r\n"
"        return this.allocateRelocMemory(len, align);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    allocateFixedMemory(len, align) {\r\n"
"      const address = (len) ? this.allocateExternMemory(len, align) : 0;\r\n"
"      const dv = this.obtainFixedView(address, len);\r\n"
"      dv[FIXED].align = align;\r\n"
"      return dv;\r\n"
"    }\r\n"
"\r\n"
"    freeFixedMemory(address, len, align) {\r\n"
"      if (len) {\r\n"
"        this.freeExternMemory(address, len, align);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    obtainFixedView(address, len) {\r\n"
"      let dv;\r\n"
"      if (address && len) {\r\n"
"        dv = this.obtainExternView(address, len);\r\n"
"      } else {\r\n"
"        // pointer to nothing\r\n"
"        let entry = this.viewMap.get(this.emptyBuffer);\r\n"
"        if (!entry) {\r\n"
"          this.viewMap.set(this.emptyBuffer, entry = {});\r\n"
"        }\r\n"
"        const key = `${address}:0`;\r\n"
"        dv = entry[key];\r\n"
"        if (!dv) {\r\n"
"          dv = entry[key] = new DataView(this.emptyBuffer);\r\n"
"          dv[FIXED] = { address, len: 0 };\r\n"
"        }\r\n"
"      }\r\n"
"      return dv;\r\n"
"    }\r\n"
"\r\n"
"    releaseFixedView(dv) {\r\n"
"      const { address, len, align } = dv[FIXED];\r\n"
"      // only allocated memory would have align attached\r\n"
"      if (align !== undefined) {\r\n"
"        this.freeFixedMemory(address, len, align);\r\n"
"        dv[FIXED] = null;\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    allocateRelocMemory(len, align) {\r\n"
"      return this.obtainView(new ArrayBuffer(len), 0, len);\r\n"
"    }\r\n"
"\r\n"
"    registerMemory(dv, targetDV = null, targetAlign = undefined) {\r\n"
"      const { memoryList } = this.context;\r\n"
"      const address = this.getViewAddress(dv);\r\n"
"      const index = findMemoryIndex(memoryList, address);\r\n"
"      memoryList.splice(index, 0, { address, dv, len: dv.byteLength, targetDV, targetAlign });\r\n"
"      return address;\r\n"
"    }\r\n"
"\r\n"
"    unregisterMemory(address) {\r\n"
"      const { memoryList } = this.context;\r\n"
"      const index = findMemoryIndex(memoryList, address);\r\n"
"      const prev = memoryList[index - 1];\r\n"
"      if (prev?.address === address) {\r\n"
"        memoryList.splice(index - 1, 1);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    findMemory(address, count, size) {\r\n"
"      if (isInvalidAddress(address)) {\r\n"
"        if (!count) {\r\n"
"          address = 0;\r\n"
"        } else {\r\n"
"          return null;\r\n"
"        }\r\n"
"      } else if (!address && count) {\r\n"
"        return null;\r\n"
"      }\r\n"
"      let len = count * (size ?? 0);\r\n"
"      // check for null address (=== can't be used since address can be both number and bigint)\r\n"
"      if (this.context) {\r\n"
"        const { memoryList } = this.context;\r\n"
"        const index = findMemoryIndex(memoryList, address);\r\n"
"        const entry = memoryList[index - 1];\r\n"
"        if (entry?.address === address && entry.len === len) {\r\n"
"          return entry.targetDV ?? entry.dv;\r\n"
"        } else if (entry?.address <= address && address < add(entry.address, entry.len)) {\r\n"
"          const offset = Number(address - entry.address);\r\n"
"          const targetDV = entry.targetDV ?? entry.dv;\r\n"
"          const isOpaque = size === undefined;\r\n"
"          if (isOpaque) {\r\n"
"            len = targetDV.byteLength - offset;\r\n"
"          }\r\n"
"          const dv = this.obtainView(targetDV.buffer, targetDV.byteOffset + offset, len);\r\n"
"          if (isOpaque) {\r\n"
"            // opaque structure--need to save the alignment\r\n"
"            dv[ALIGN] = entry.targetAlign;\r\n"
"          }\r\n"
"          return dv;\r\n"
"        }\r\n"
"      }\r\n"
"      // not found in any of the buffers we've seen--assume it's fixed memory\r\n"
"      return this.obtainFixedView(address, len);\r\n"
"    }\r\n"
"\r\n"
"    getViewAddress(dv) {\r\n"
"      const fixed = dv[FIXED];\r\n"
"      if (fixed) {\r\n"
"        return fixed.address;\r\n"
"      } else {\r\n"
"        const address = this.getBufferAddress(dv.buffer);\r\n"
"        return add(address, dv.byteOffset);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    findViewAt(buffer, offset, len) {\r\n"
"      let entry = this.viewMap.get(buffer);\r\n"
"      let existing;\r\n"
"      if (entry) {\r\n"
"        if (entry instanceof DataView) {\r\n"
"          // only one view created thus far--see if that's the matching one\r\n"
"          if (entry.byteOffset === offset && entry.byteLength === len) {\r\n"
"            existing = entry;\r\n"
"          } else {\r\n"
"            // no, need to replace the entry with a hash keyed by `offset:len`\r\n"
"            const prev = entry;\r\n"
"            const prevKey = `${prev.byteOffset}:${prev.byteLength}`;\r\n"
"            entry = { [prevKey]: prev };\r\n"
"            this.viewMap.set(buffer, entry);\r\n"
"          }\r\n"
"        } else {\r\n"
"          existing = entry[`${offset}:${len}`];\r\n"
"        }\r\n"
"      }\r\n"
"      return { existing, entry };\r\n"
"    }\r\n"
"\r\n"
"    obtainView(buffer, offset, len) {\r\n"
"      const { existing, entry } = this.findViewAt(buffer, offset, len);\r\n"
"      let dv;\r\n"
"      if (existing) {\r\n"
"        return existing;\r\n"
"      } else if (entry) {\r\n"
"        dv = entry[`${offset}:${len}`] = new DataView(buffer, offset, len);\r\n"
"      } else {\r\n"
"        // just one view of this buffer for now\r\n"
"        this.viewMap.set(buffer, dv = new DataView(buffer, offset, len));\r\n"
"      }\r\n"
"      const fixed = buffer[FIXED];\r\n"
"      if (fixed) {\r\n"
"        // attach address to view of fixed buffer\r\n"
"        dv[FIXED] = { address: add(fixed.address, offset), len };\r\n"
"      }\r\n"
"      return dv;\r\n"
"    }\r\n"
"\r\n"
"    registerView(dv) {\r\n"
"      if (!dv[FIXED]) {\r\n"
"        const { buffer, byteOffset, byteLength } = dv;\r\n"
"        const { existing, entry } = this.findViewAt(buffer, byteOffset, byteLength);\r\n"
"        if (existing) {\r\n"
"          // return existing view instead of this one\r\n"
"          return existing;\r\n"
"        } else if (entry) {\r\n"
"          entry[`${byteOffset}:${byteLength}`] = dv;\r\n"
"        } else {\r\n"
"          this.viewMap.set(buffer, dv);\r\n"
"        }\r\n"
"      }\r\n"
"      return dv;\r\n"
"    }\r\n"
"\r\n"
"    captureView(address, len, copy) {\r\n"
"      if (copy) {\r\n"
"        // copy content into reloctable memory\r\n"
"        const dv = this.allocateRelocMemory(len, 0);\r\n"
"        if (len > 0) {\r\n"
"          this.copyBytes(dv, address, len);\r\n"
"        }\r\n"
"        return dv;\r\n"
"      } else {\r\n"
"        // link into fixed memory\r\n"
"        return this.obtainFixedView(address, len);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    castView(address, len, copy, structure) {\r\n"
"      const { constructor, hasPointer } = structure;\r\n"
"      const dv = this.captureView(address, len, copy);\r\n"
"      const object = constructor.call(ENVIRONMENT, dv);\r\n"
"      if (hasPointer) {\r\n"
"        // acquire targets of pointers\r\n"
"        this.updatePointerTargets(object);\r\n"
"      }\r\n"
"      if (copy) {\r\n"
"        object[WRITE_DISABLER]();\r\n"
"      }\r\n"
"      return object;\r\n"
"    }\r\n"
"\r\n"
"    /* COMPTIME-ONLY */\r\n"
"    readSlot(target, slot) {\r\n"
"      const slots = target ? target[SLOTS] : this.slots;\r\n"
"      return slots?.[slot];\r\n"
"    }\r\n"
"\r\n"
"    writeSlot(target, slot, value) {\r\n"
"      const slots = target ? target[SLOTS] : this.slots;\r\n"
"      if (slots) {\r\n"
"        slots[slot] = value;\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    createTemplate(dv) {\r\n"
"      return {\r\n"
"        [MEMORY]: dv,\r\n"
"        [SLOTS]: {}\r\n"
"      };\r\n"
"    }\r\n"
"\r\n"
"    beginStructure(def) {\r\n"
"      const {\r\n"
"        type,\r\n"
"        name,\r\n"
"        length,\r\n"
"        byteSize,\r\n"
"        align,\r\n"
"        isConst,\r\n"
"        isTuple,\r\n"
"        isIterator,\r\n"
"        hasPointer,\r\n"
"      } = def;\r\n"
"      return {\r\n"
"        constructor: null,\r\n"
"        typedArray: null,\r\n"
"        type,\r\n"
"        name,\r\n"
"        length,\r\n"
"        byteSize,\r\n"
"        align,\r\n"
"        isConst,\r\n"
"        isTuple,\r\n"
"        isIterator,\r\n"
"        hasPointer,\r\n"
"        instance: {\r\n"
"          members: [],\r\n"
"          methods: [],\r\n"
"          template: null,\r\n"
"        },\r\n"
"        static: {\r\n"
"          members: [],\r\n"
"          methods: [],\r\n"
"          template: null,\r\n"
"        },\r\n"
"      };\r\n"
"    }\r\n"
"\r\n"
"    attachMember(structure, member, isStatic = false) {\r\n"
"      const target = (isStatic) ? structure.static : structure.instance;\r\n"
"      target.members.push(member);\r\n"
"    }\r\n"
"\r\n"
"    attachMethod(structure, method, isStaticOnly = false) {\r\n"
"      structure.static.methods.push(method);\r\n"
"      if (!isStaticOnly) {\r\n"
"        structure.instance.methods.push(method);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    attachTemplate(structure, template, isStatic = false) {\r\n"
"      const target = (isStatic) ? structure.static : structure.instance;\r\n"
"      target.template = template;\r\n"
"    }\r\n"
"\r\n"
"    endStructure(structure) {\r\n"
"      this.structures.push(structure);\r\n"
"      this.finalizeStructure(structure);\r\n"
"    }\r\n"
"\r\n"
"    defineFactoryArgStruct() {\r\n"
"      useBool();\r\n"
"      useObject();\r\n"
"      useArgStruct();\r\n"
"      const options = this.beginStructure({\r\n"
"        type: StructureType.Struct,\r\n"
"        name: 'Options',\r\n"
"        byteSize: 2,\r\n"
"        hasPointer: false,\r\n"
"      });\r\n"
"      this.attachMember(options, {\r\n"
"        type: MemberType.Bool,\r\n"
"        name: 'omitFunctions',\r\n"
"        bitOffset: 0,\r\n"
"        bitSize: 1,\r\n"
"        byteSize: 1,\r\n"
"      });\r\n"
"      this.attachMember(options, {\r\n"
"        type: MemberType.Bool,\r\n"
"        name: 'omitVariables',\r\n"
"        bitOffset: 8,\r\n"
"        bitSize: 1,\r\n"
"        byteSize: 1,\r\n"
"      });\r\n"
"      this.finalizeShape(options);\r\n"
"      const structure = this.beginStructure({\r\n"
"        type: StructureType.ArgStruct,\r\n"
"        name: 'ArgFactory',\r\n"
"        byteSize: 2,\r\n"
"        hasPointer: false,\r\n"
"      });\r\n"
"      this.attachMember(structure, {\r\n"
"        type: MemberType.Void,\r\n"
"        name: 'retval',\r\n"
"        bitOffset: 0,\r\n"
"        bitSize: 0,\r\n"
"        byteSize: 0\r\n"
"      });\r\n"
"      this.attachMember(structure, {\r\n"
"        type: MemberType.Object,\r\n"
"        name: '0',\r\n"
"        bitOffset: 0,\r\n"
"        bitSize: 16,\r\n"
"        byteSize: 2,\r\n"
"        slot: 0,\r\n"
"        structure: options,\r\n"
"      });\r\n"
"      this.finalizeShape(structure);\r\n"
"      return structure.constructor;\r\n"
"    }\r\n"
"\r\n"
"    acquireStructures(options) {\r\n"
"      const {\r\n"
"        omitFunctions = false,\r\n"
"        omitVariables = isElectron(),\r\n"
"      } = options;\r\n"
"      resetGlobalErrorSet();\r\n"
"      const thunkId = this.getFactoryThunk();\r\n"
"      const ArgStruct = this.defineFactoryArgStruct();\r\n"
"      const args = new ArgStruct([ { omitFunctions, omitVariables } ]);\r\n"
"      this.comptime = true;\r\n"
"      this.invokeThunk(thunkId, args);\r\n"
"      this.comptime = false;\r\n"
"    }\r\n"
"\r\n"
"    getRootModule() {\r\n"
"      const root = this.structures[this.structures.length - 1];\r\n"
"      return root.constructor;\r\n"
"    }\r\n"
"\r\n"
"    hasMethods() {\r\n"
"      // all methods are static, so there's no need to check instance methods\r\n"
"      return !!this.structures.find(s => s.static.methods.length > 0);\r\n"
"    }\r\n"
"\r\n"
"    exportStructures() {\r\n"
"      this.acquireDefaultPointers();\r\n"
"      this.prepareObjectsForExport();\r\n"
"      const { structures, runtimeSafety, littleEndian } = this;\r\n"
"      return {\r\n"
"        structures,\r\n"
"        options: { runtimeSafety, littleEndian },\r\n"
"        keys: { MEMORY, SLOTS, CONST_TARGET },\r\n"
"      };\r\n"
"    }\r\n"
"\r\n"
"    prepareObjectsForExport() {\r\n"
"      const objects = findAllObjects(this.structures, SLOTS);\r\n"
"      const list = [];\r\n"
"      for (const object of objects) {\r\n"
"        if (object[MEMORY]?.[FIXED]) {\r\n"
"          // replace fixed memory\r\n"
"          const dv = object[MEMORY];\r\n"
"          const address = this.getViewAddress(dv);\r\n"
"          const offset = this.getMemoryOffset(address);\r\n"
"          const len = dv.byteLength;\r\n"
"          const relocDV = this.captureView(address, len, true);\r\n"
"          relocDV.reloc = offset;\r\n"
"          object[MEMORY] = relocDV;\r\n"
"          list.push({ offset, len, owner: object, replaced: false });\r\n"
"        }\r\n"
"      }\r\n"
"      // larger memory blocks come first\r\n"
"      list.sort((a, b) => b.len - a.len);\r\n"
"      for (const a of list) {\r\n"
"        if (!a.replaced) {\r\n"
"          for (const b of list) {\r\n"
"            if (a !== b && !b.replaced) {\r\n"
"              if (a.offset <= b.offset && b.offset < a.offset + a.len) {\r\n"
"                // B is inside A--replace it with a view of A's buffer\r\n"
"                const dv = a.owner[MEMORY];\r\n"
"                const pos = b.offset - a.offset + dv.byteOffset;\r\n"
"                const newDV = this.obtainView(dv.buffer, pos, b.len);\r\n"
"                newDV.reloc = b.offset;\r\n"
"                b.owner[MEMORY] = newDV;\r\n"
"                b.replaced = true;\r\n"
"              }\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    useStructures() {\r\n"
"      const module = this.getRootModule();\r\n"
"      // add fixed memory object to list so they can be unlinked\r\n"
"      const objects = findAllObjects(this.structures, SLOTS);\r\n"
"      for (const object of objects) {\r\n"
"        if (object[MEMORY]?.[FIXED]) {\r\n"
"          this.variables.push({ object });\r\n"
"        }\r\n"
"      }\r\n"
"      // clear comptime-only variables\r\n"
"      this.slots = {};\r\n"
"      this.structures = [];\r\n"
"      module.__zigar = this.getSpecialExports();\r\n"
"      return module;\r\n"
"    }\r\n"
"    /* COMPTIME-ONLY-END */\r\n"
"\r\n"
"    finalizeShape(structure) {\r\n"
"      const f = getStructureFactory(structure.type);\r\n"
"      const constructor = f(structure, this);\r\n"
"      if (typeof(constructor) === 'function') {\r\n"
"        defineProperties(constructor, {\r\n"
"          name: { value: structure.name, configurable: true },\r\n"
"        });\r\n"
"        if (!constructor.prototype.hasOwnProperty(Symbol.toStringTag)) {\r\n"
"          defineProperties(constructor.prototype, {\r\n"
"            [Symbol.toStringTag]: { value: structure.name, configurable: true },\r\n"
"          });\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    finalizeStructure(structure) {\r\n"
"      addStaticMembers(structure, this);\r\n"
"      addMethods(structure, this);\r\n"
"    }\r\n"
"\r\n"
"    createCaller(method, useThis) {\r\n"
"      const { name, argStruct, thunkId } = method;\r\n"
"      const { constructor } = argStruct;\r\n"
"      const self = this;\r\n"
"      let f;\r\n"
"      if (useThis) {\r\n"
"        f = function(...args) {\r\n"
"          return self.invokeThunk(thunkId, new constructor([ this, ...args ], name, 1));\r\n"
"        };\r\n"
"      } else {\r\n"
"        f = function(...args) {\r\n"
"          return self.invokeThunk(thunkId, new constructor(args, name, 0));\r\n"
"        };\r\n"
"      }\r\n"
"      Object.defineProperty(f, 'name', { value: name });\r\n"
"      return f;\r\n"
"    }\r\n"
"\r\n"
"    /* RUNTIME-ONLY */\r\n"
"    recreateStructures(structures, options) {\r\n"
"      Object.assign(this, options);\r\n"
"      const insertObjects = (dest, placeholders) => {\r\n"
"        for (const [ slot, placeholder ] of Object.entries(placeholders)) {\r\n"
"          dest[slot] = createObject(placeholder);\r\n"
"        }\r\n"
"        return dest;\r\n"
"      };\r\n"
"      const createObject = (placeholder) => {\r\n"
"        const { memory, structure, actual } = placeholder;\r\n"
"        if (memory) {\r\n"
"          if (actual) {\r\n"
"            return actual;\r\n"
"          } else {\r\n"
"            const { array, offset, length } = memory;\r\n"
"            const dv = this.obtainView(array.buffer, offset, length);\r\n"
"            const { constructor } = structure;\r\n"
"            const { reloc, const: isConst } = placeholder;\r\n"
"            const object = placeholder.actual = constructor.call(ENVIRONMENT, dv);\r\n"
"            if (isConst) {\r\n"
"              object[WRITE_DISABLER]?.();\r\n"
"            }\r\n"
"            if (placeholder.slots) {\r\n"
"              insertObjects(object[SLOTS], placeholder.slots);\r\n"
"            }\r\n"
"            if (reloc !== undefined) {\r\n"
"              // need to replace dataview with one pointing to fixed memory later,\r\n"
"              // when the VM is up and running\r\n"
"              this.variables.push({ reloc, object });\r\n"
"            }\r\n"
"            return object;\r\n"
"          }\r\n"
"        } else {\r\n"
"          return structure;\r\n"
"        }\r\n"
"      };\r\n"
"      resetGlobalErrorSet();\r\n"
"      const objectPlaceholders = new Map();\r\n"
"      for (const structure of structures) {\r\n"
"        // recreate the actual template using the provided placeholder\r\n"
"        for (const scope of [ structure.instance, structure.static ]) {\r\n"
"          if (scope.template) {\r\n"
"            const placeholder = scope.template;\r\n"
"            const template = scope.template = {};\r\n"
"            if (placeholder.memory) {\r\n"
"              const { array, offset, length } = placeholder.memory;\r\n"
"              template[MEMORY] = this.obtainView(array.buffer, offset, length);\r\n"
"            }\r\n"
"            if (placeholder.slots) {\r\n"
"              // defer creation of objects until shapes of structures are finalized\r\n"
"              const slots = template[SLOTS] = {};\r\n"
"              objectPlaceholders.set(slots, placeholder.slots);\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"        this.finalizeShape(structure);\r\n"
"      }\r\n"
"      // insert objects into template slots\r\n"
"      for (const [ slots, placeholders ] of objectPlaceholders) {\r\n"
"        insertObjects(slots, placeholders);\r\n"
"      }\r\n"
"      // add static members, methods, etc.\r\n"
"      for (const structure of structures) {\r\n"
"        this.finalizeStructure(structure);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    linkVariables(writeBack) {\r\n"
"      const pointers = [];\r\n"
"      for (const { object, reloc } of this.variables) {\r\n"
"        this.linkObject(object, reloc, writeBack);\r\n"
"        const getter = object[TARGET_GETTER];\r\n"
"        if (getter && object[SLOTS][0]) {\r\n"
"          pointers.push(object);\r\n"
"        }\r\n"
"      }\r\n"
"      // save locations of pointer targets\r\n"
"      for (const pointer of pointers) {\r\n"
"        const target = pointer[TARGET_GETTER]();\r\n"
"        const address = this.getViewAddress(target[MEMORY]);\r\n"
"        pointer[ADDRESS_SETTER](address);\r\n"
"        pointer[LENGTH_SETTER]?.(target.length);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    linkObject(object, reloc, writeBack) {\r\n"
"      if (object[MEMORY][FIXED]) {\r\n"
"        return;\r\n"
"      }\r\n"
"      const dv = object[MEMORY];\r\n"
"      const address = this.recreateAddress(reloc);\r\n"
"      const fixedDV = this.obtainFixedView(address, dv.byteLength);\r\n"
"      if (writeBack) {\r\n"
"        const dest = Object.create(object.constructor.prototype);\r\n"
"        dest[MEMORY] = fixedDV;\r\n"
"        dest[COPIER](object);\r\n"
"      }\r\n"
"      object[MEMORY] = fixedDV;\r\n"
"      const linkChildren = (object) => {\r\n"
"        if (object[SLOTS]) {\r\n"
"          for (const child of Object.values(object[SLOTS])) {\r\n"
"            if (child) {\r\n"
"              const childDV = child[MEMORY];\r\n"
"              if (childDV.buffer === dv.buffer) {\r\n"
"                const offset = childDV.byteOffset - dv.byteOffset;\r\n"
"                child[MEMORY] = this.obtainView(fixedDV.buffer, offset, childDV.byteLength);\r\n"
"                linkChildren(child);\r\n"
"              }\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"      };\r\n"
"      linkChildren(object);\r\n"
"    }\r\n"
"\r\n"
"    unlinkVariables() {\r\n"
"      for (const { object } of this.variables) {\r\n"
"        this.unlinkObject(object);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    unlinkObject(object) {\r\n"
"      if (!object[MEMORY][FIXED]) {\r\n"
"        return;\r\n"
"      }\r\n"
"      const dv = object[MEMORY];\r\n"
"      const relocDV = this.allocateMemory(dv.byteLength);\r\n"
"      const dest = Object.create(object.constructor.prototype);\r\n"
"      dest[MEMORY] = relocDV;\r\n"
"      dest[COPIER](object);\r\n"
"      object[MEMORY] = relocDV;\r\n"
"    }\r\n"
"\r\n"
"    releaseFunctions() {\r\n"
"      const throwError = () => { throw new Error(`Module was abandoned`) };\r\n"
"      for (const name of Object.keys(this.imports)) {\r\n"
"        if (this[name]) {\r\n"
"          this[name] = throwError;\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    getSpecialExports() {\r\n"
"      const check = (v) => {\r\n"
"        if (v === undefined) throw new Error('Not a Zig type');\r\n"
"        return v;\r\n"
"      };\r\n"
"      return {\r\n"
"        init: (...args) => this.init(...args),\r\n"
"        abandon: () => this.abandon(),\r\n"
"        released: () => this.released,\r\n"
"        connect: (c) => this.console = c,\r\n"
"        sizeOf: (T) => check(T[SIZE]),\r\n"
"        alignOf: (T) => check(T[ALIGN]),\r\n"
"        typeOf: (T) => getStructureName(check(T[TYPE])),\r\n"
"      };\r\n"
"    }\r\n"
"\r\n"
"    abandon() {\r\n"
"      if (!this.abandoned) {\r\n"
"        this.releaseFunctions();\r\n"
"        this.unlinkVariables();\r\n"
"        this.abandoned = true;\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    updatePointerAddresses(args) {\r\n"
"      // first, collect all the pointers\r\n"
"      const pointerMap = new Map();\r\n"
"      const bufferMap = new Map();\r\n"
"      const potentialClusters = [];\r\n"
"      const callback = function({ isActive }) {\r\n"
"        if (isActive(this)) {\r\n"
"          // bypass proxy\r\n"
"          const pointer = this[POINTER];\r\n"
"          if (!pointerMap.get(pointer)) {\r\n"
"            const target = pointer[SLOTS][0];\r\n"
"            if (target) {\r\n"
"              pointerMap.set(pointer, target);\r\n"
"              // only relocatable targets need updating\r\n"
"              const dv = target[MEMORY];\r\n"
"              if (!dv[FIXED]) {\r\n"
"                // see if the buffer is shared with other objects\r\n"
"                const other = bufferMap.get(dv.buffer);\r\n"
"                if (other) {\r\n"
"                  const array = Array.isArray(other) ? other : [ other ];\r\n"
"                  const index = findSortedIndex(array, dv.byteOffset, t => t[MEMORY].byteOffset);\r\n"
"                  array.splice(index, 0, target);\r\n"
"                  if (!Array.isArray(other)) {\r\n"
"                    bufferMap.set(dv.buffer, array);\r\n"
"                    potentialClusters.push(array);\r\n"
"                  }\r\n"
"                } else {\r\n"
"                  bufferMap.set(dv.buffer, target);\r\n"
"                }\r\n"
"                // scan pointers in target\r\n"
"                target[POINTER_VISITOR]?.(callback);\r\n"
"              }\r\n"
"            }\r\n"
"          }\r\n"
"        }\r\n"
"      };\r\n"
"      args[POINTER_VISITOR](callback);\r\n"
"      // find targets that overlap each other\r\n"
"      const clusters = this.findTargetClusters(potentialClusters);\r\n"
"      const clusterMap = new Map();\r\n"
"      for (const cluster of clusters) {\r\n"
"        for (const target of cluster.targets) {\r\n"
"          clusterMap.set(target, cluster);\r\n"
"        }\r\n"
"      }\r\n"
"      // process the pointers\r\n"
"      for (const [ pointer, target ] of pointerMap) {\r\n"
"        const cluster = clusterMap.get(target);\r\n"
"        const address = this.getTargetAddress(target, cluster) ?? this.getShadowAddress(target, cluster);\r\n"
"        // update the pointer\r\n"
"        pointer[ADDRESS_SETTER](address);\r\n"
"        pointer[LENGTH_SETTER]?.(target.length);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    findTargetClusters(potentialClusters) {\r\n"
"      const clusters = [];\r\n"
"      for (const targets of potentialClusters) {\r\n"
"        let prevTarget = null, prevStart = 0, prevEnd = 0;\r\n"
"        let currentCluster = null;\r\n"
"        for (const target of targets) {\r\n"
"          const dv = target[MEMORY];\r\n"
"          const { byteOffset: start, byteLength } = dv;\r\n"
"          const end = start + byteLength;\r\n"
"          let forward = true;\r\n"
"          if (prevTarget) {\r\n"
"            if (prevEnd > start) {\r\n"
"              // the previous target overlaps this one\r\n"
"              if (!currentCluster) {\r\n"
"                currentCluster = {\r\n"
"                  targets: [ prevTarget ],\r\n"
"                  start: prevStart,\r\n"
"                  end: prevEnd,\r\n"
"                  address: undefined,\r\n"
"                  misaligned: undefined,\r\n"
"                };\r\n"
"                clusters.push(currentCluster);\r\n"
"              }\r\n"
"              currentCluster.targets.push(target);\r\n"
"              if (end > prevEnd) {\r\n"
"                // set cluster end offset to include this one\r\n"
"                currentCluster.end = end;\r\n"
"              } else {\r\n"
"                // the previous target contains this one\r\n"
"                forward = false;\r\n"
"              }\r\n"
"            } else {\r\n"
"              currentCluster = null;\r\n"
"            }\r\n"
"          }\r\n"
"          if (forward) {\r\n"
"            prevTarget = target;\r\n"
"            prevStart = start;\r\n"
"            prevEnd = end;\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"      return clusters;\r\n"
"    }\r\n"
"\r\n"
"    createClusterShadow(cluster) {\r\n"
"      const { start, end, targets } = cluster;\r\n"
"      // look for largest align\r\n"
"      let maxAlign = 0, maxAlignOffset;\r\n"
"      for (const target of targets) {\r\n"
"        const dv = target[MEMORY];\r\n"
"        const offset = dv.byteOffset;\r\n"
"        const align = target.constructor[ALIGN] ?? dv[ALIGN];\r\n"
"        if (maxAlign === undefined || align > maxAlign) {\r\n"
"          maxAlign = align;\r\n"
"          maxAlignOffset = offset;\r\n"
"        }\r\n"
"      }\r\n"
"      // ensure the shadow buffer is large enough to accommodate necessary adjustments\r\n"
"      const len = end - start;\r\n"
"      const unalignedShadowDV = this.allocateShadowMemory(len + maxAlign, 1);\r\n"
"      const unalignedAddress = this.getViewAddress(unalignedShadowDV);\r\n"
"      const maxAlignAddress = getAlignedAddress(add(unalignedAddress, maxAlignOffset - start), maxAlign);\r\n"
"      const shadowAddress = add(maxAlignAddress, start - maxAlignOffset);\r\n"
"      const shadowOffset = unalignedShadowDV.byteOffset + Number(shadowAddress - unalignedAddress);\r\n"
"      const shadowDV = new DataView(unalignedShadowDV.buffer, shadowOffset, len);\r\n"
"      // make sure that other pointers are correctly aligned also\r\n"
"      for (const target of targets) {\r\n"
"        const dv = target[MEMORY];\r\n"
"        const offset = dv.byteOffset;\r\n"
"        if (offset !== maxAlignOffset) {\r\n"
"          const align = target.constructor[ALIGN] ?? dv[ALIGN];\r\n"
"          if (isMisaligned(add(shadowAddress, offset - start), align)) {\r\n"
"            throw new AlignmentConflict(align, maxAlign);\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"      // placeholder object type\r\n"
"      const prototype = {\r\n"
"        [COPIER]: getMemoryCopier(len)\r\n"
"      };\r\n"
"      const source = Object.create(prototype);\r\n"
"      const shadow = Object.create(prototype);\r\n"
"      source[MEMORY] = new DataView(targets[0][MEMORY].buffer, Number(start), len);\r\n"
"      shadow[MEMORY] = shadowDV;\r\n"
"      shadow[ATTRIBUTES] = {\r\n"
"        address: unalignedAddress,\r\n"
"        len: unalignedShadowDV.byteLength,\r\n"
"        align: 1,\r\n"
"      };\r\n"
"      return this.addShadow(shadow, source, 1);\r\n"
"    }\r\n"
"    /* RUNTIME-ONLY-END */\r\n"
"\r\n"
"    getShadowAddress(target, cluster) {\r\n"
"      if (cluster) {\r\n"
"        const dv = target[MEMORY];\r\n"
"        if (cluster.address === undefined) {\r\n"
"          const shadow = this.createClusterShadow(cluster);\r\n"
"          cluster.address = this.getViewAddress(shadow[MEMORY]);\r\n"
"        }\r\n"
"        return add(cluster.address, dv.byteOffset - cluster.start);\r\n"
"      } else {\r\n"
"        const shadow = this.createShadow(target);\r\n"
"        return this.getViewAddress(shadow[MEMORY]);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    createShadow(object) {\r\n"
"      const dv = object[MEMORY];\r\n"
"      // use the alignment of the structure; in the case of an opaque pointer's target,\r\n"
"      // try to the alignment specified when the memory was allocated\r\n"
"      const align = object.constructor[ALIGN] ?? dv[ALIGN];\r\n"
"      const shadow = Object.create(object.constructor.prototype);\r\n"
"      const shadowDV = shadow[MEMORY] = this.allocateShadowMemory(dv.byteLength, align);\r\n"
"      shadow[ATTRIBUTES] = {\r\n"
"        address: this.getViewAddress(shadowDV),\r\n"
"        len: shadowDV.byteLength,\r\n"
"        align,\r\n"
"      };\r\n"
"      return this.addShadow(shadow, object, align);\r\n"
"    }\r\n"
"\r\n"
"    addShadow(shadow, object, align) {\r\n"
"      let { shadowMap } = this.context;\r\n"
"      if (!shadowMap) {\r\n"
"        shadowMap = this.context.shadowMap = new Map();\r\n"
"      }\r\n"
"      shadowMap.set(shadow, object);\r\n"
"      this.registerMemory(shadow[MEMORY], object[MEMORY], align);\r\n"
"      return shadow;\r\n"
"    }\r\n"
"\r\n"
"    removeShadow(dv) {\r\n"
"      const { shadowMap } = this.context;\r\n"
"      if (shadowMap) {\r\n"
"        for (const [ shadow ] of shadowMap) {\r\n"
"          if (shadow[MEMORY] === dv) {\r\n"
"            shadowMap.delete(shadow);\r\n"
"            break;\r\n"
"          }\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    updateShadows() {\r\n"
"      const { shadowMap } = this.context;\r\n"
"      if (!shadowMap) {\r\n"
"        return;\r\n"
"      }\r\n"
"      for (const [ shadow, object ] of shadowMap) {\r\n"
"        shadow[COPIER](object);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    updateShadowTargets() {\r\n"
"      const { shadowMap } = this.context;\r\n"
"      if (!shadowMap) {\r\n"
"        return;\r\n"
"      }\r\n"
"      for (const [ shadow, object ] of shadowMap) {\r\n"
"        object[COPIER](shadow);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    releaseShadows() {\r\n"
"      const { shadowMap } = this.context;\r\n"
"      if (!shadowMap) {\r\n"
"        return;\r\n"
"      }\r\n"
"      for (const [ shadow ] of shadowMap) {\r\n"
"        const { address, len, align } = shadow[ATTRIBUTES];\r\n"
"        this.freeShadowMemory(address, len, align);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    updatePointerTargets(args) {\r\n"
"      const pointerMap = new Map();\r\n"
"      const callback = function({ isActive, isMutable }) {\r\n"
"        // bypass proxy\r\n"
"        const pointer = this[POINTER];\r\n"
"        if (!pointerMap.get(pointer)) {\r\n"
"          pointerMap.set(pointer, true);\r\n"
"          const writable = !pointer.constructor.const;\r\n"
"          const currentTarget = pointer[SLOTS][0];\r\n"
"          const newTarget = (!currentTarget || isMutable(this))\r\n"
"          ? pointer[TARGET_UPDATER](true, isActive(this))\r\n"
"          : currentTarget;\r\n"
"          // update targets of pointers in original target (which could have been altered)\r\n"
"          currentTarget?.[POINTER_VISITOR]?.(callback, { vivificate: true, isMutable: () => writable });\r\n"
"          if (newTarget !== currentTarget) {\r\n"
"            // acquire targets of pointers in new target\r\n"
"            newTarget?.[POINTER_VISITOR]?.(callback, { vivificate: true, isMutable: () => writable });\r\n"
"          }\r\n"
"        }\r\n"
"      };\r\n"
"      args[POINTER_VISITOR](callback, { vivificate: true });\r\n"
"    }\r\n"
"\r\n"
"    writeToConsole(dv) {\r\n"
"      const { console } = this;\r\n"
"      try {\r\n"
"        // make copy of array, in case incoming buffer is pointing to stack memory\r\n"
"        const array = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength).slice();\r\n"
"        // send text up to the last newline character\r\n"
"        const index = array.lastIndexOf(0x0a);\r\n"
"        if (index === -1) {\r\n"
"          this.consolePending.push(array);\r\n"
"        } else {\r\n"
"          const beginning = array.subarray(0, index);\r\n"
"          const remaining = array.subarray(index + 1);\r\n"
"          const list = [ ...this.consolePending, beginning ];\r\n"
"          console.log(decodeText(list));\r\n"
"          this.consolePending = (remaining.length > 0) ? [ remaining ] : [];\r\n"
"        }\r\n"
"        clearTimeout(this.consoleTimeout);\r\n"
"        if (this.consolePending.length > 0) {\r\n"
"          this.consoleTimeout = setTimeout(() => {\r\n"
"            console.log(decodeText(this.consolePending));\r\n"
"            this.consolePending = [];\r\n"
"          }, 250);\r\n"
"        }\r\n"
"        /* c8 ignore next 3 */\r\n"
"      } catch (err) {\r\n"
"        console.error(err);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    flushConsole() {\r\n"
"      if (this.consolePending.length > 0) {\r\n"
"        console.log(decodeText(this.consolePending));\r\n"
"        this.consolePending = [];\r\n"
"        clearTimeout(this.consoleTimeout);\r\n"
"      }\r\n"
"    }\r\n"
"\r\n"
"    /* COMPTIME-ONLY */\r\n"
"    acquireDefaultPointers() {\r\n"
"      for (const structure of this.structures) {\r\n"
"        const { constructor, hasPointer, instance: { template } } = structure;\r\n"
"        if (hasPointer && template && template[MEMORY]) {\r\n"
"          // create a placeholder for retrieving default pointers\r\n"
"          const placeholder = Object.create(constructor.prototype);\r\n"
"          placeholder[MEMORY] = template[MEMORY];\r\n"
"          placeholder[SLOTS] = template[SLOTS];\r\n"
"          this.updatePointerTargets(placeholder);\r\n"
"        }\r\n"
"      }\r\n"
"    }\r\n"
"    /* COMPTIME-ONLY-END */\r\n"
"  }\r\n"
"\r\n"
"  class CallContext {\r\n"
"    pointerProcessed = new Map();\r\n"
"    memoryList = [];\r\n"
"    shadowMap = null;\r\n"
"\r\n"
"  }\r\n"
"\r\n"
"  function findSortedIndex(array, value, cb) {\r\n"
"    let low = 0;\r\n"
"    let high = array.length;\r\n"
"    if (high === 0) {\r\n"
"      return 0;\r\n"
"    }\r\n"
"    while (low < high) {\r\n"
"      const mid = Math.floor((low + high) / 2);\r\n"
"      const value2 = cb(array[mid]);\r\n"
"      if (value2 <= value) {\r\n"
"        low = mid + 1;\r\n"
"      } else {\r\n"
"        high = mid;\r\n"
"      }\r\n"
"    }\r\n"
"    return high;\r\n"
"  }\r\n"
"\r\n"
"  function findMemoryIndex(array, address) {\r\n"
"    return findSortedIndex(array, address, m => m.address);\r\n"
"  }\r\n"
"\r\n"
"  function isMisaligned(address, align) {\r\n"
"    if (align === undefined) {\r\n"
"      return false;\r\n"
"    }\r\n"
"    if (typeof(address) === 'bigint') {\r\n"
"      address = Number(address & 0xFFFFFFFFn);\r\n"
"    }\r\n"
"    const mask = align - 1;\r\n"
"    return (address & mask) !== 0;\r\n"
"  }\r\n"
"\r\n"
"  function getAlignedAddress(address, align) {\r\n"
"    let mask;\r\n"
"    if (typeof(address) === 'bigint') {\r\n"
"      align = BigInt(align);\r\n"
"      mask = ~(align - 1n);\r\n"
"    } else {\r\n"
"      mask = ~(align - 1);\r\n"
"    }\r\n"
"    return (address & mask) + align;\r\n"
"  }\r\n"
"\r\n"
"  function add(address, len) {\r\n"
"    return address + ((typeof(address) === 'bigint') ? BigInt(len) : len);\r\n"
"  }\r\n"
"\r\n"
"  function isInvalidAddress(address) {\r\n"
"    if (typeof(address) === 'bigint') {\r\n"
"      return address === 0xaaaaaaaaaaaaaaaan;\r\n"
"    } else {\r\n"
"      return address === 0xaaaaaaaa;\r\n"
"    }\r\n"
"  }\r\n"
"\r\n"
"  function isElectron() {\r\n"
"    return typeof(process) === 'object'\r\n"
"        && typeof(process?.versions) === 'object'\r\n"
"        && !!process.versions?.electron;\r\n"
"  }\n"
"\n"
"  class NodeEnvironment extends Environment {\r\n"
"    // C code will patch in these functions:\r\n"
"    imports = {\r\n"
"      loadModule: null,\r\n"
"      getBufferAddress: null,\r\n"
"      allocateExternMemory: null,\r\n"
"      freeExternMemory: null,\r\n"
"      obtainExternBuffer: null,\r\n"
"      copyBytes: null,\r\n"
"      findSentinel: null,\r\n"
"      defineStructures: null,\r\n"
"      getFactoryThunk: null,\r\n"
"      runThunk: null,\r\n"
"      runVariadicThunk: null,\r\n"
"      getMemoryOffset: null,\r\n"
"      recreateAddress: null,\r\n"
"    };\r\n"
"    wordSize = [ 'arm64', 'ppc64', 'x64', 's390x' ].includes(process.arch) ? 8 : 4;\r\n"
"\r\n"
"    async init() {\r\n"
"      return;\r\n"
"    }\r\n"
"\r\n"
"    allocateRelocMemory(len, align) {\r\n"
"      // allocate extra memory for alignment purpose when align is larger than the default\r\n"
"      const extra = (align > this.wordSize * 2 && this.getBufferAddress) ? align : 0;\r\n"
"      const buffer = new ArrayBuffer(len + extra);\r\n"
"      let offset = 0;\r\n"
"      if (extra) {\r\n"
"        const address = this.getBufferAddress(buffer);\r\n"
"        const aligned = getAlignedAddress(address, align);\r\n"
"        offset = aligned - address;\r\n"
"      }\r\n"
"      return this.obtainView(buffer, Number(offset), len);\r\n"
"    }\r\n"
"\r\n"
"    allocateHostMemory(len, align) {\r\n"
"      const dv = this.allocateRelocMemory(len, align);\r\n"
"      this.registerMemory(dv);\r\n"
"      return dv;\r\n"
"    }\r\n"
"\r\n"
"    freeHostMemory(address, len, align) {\r\n"
"      // no freeing actually occurs--memory will await garbage collection\r\n"
"      this.unregisterMemory(address);\r\n"
"    }\r\n"
"\r\n"
"    allocateShadowMemory(len, align) {\r\n"
"      // Node can read into JavaScript memory space so we can keep shadows there\r\n"
"      return this.allocateRelocMemory(len, align);\r\n"
"    }\r\n"
"\r\n"
"    freeShadowMemory(address, len, align) {\r\n"
"      // nothing needs to happen\r\n"
"    }\r\n"
"\r\n"
"    obtainExternView(address, len) {\r\n"
"      const buffer = this.obtainExternBuffer(address, len);\r\n"
"      buffer[FIXED] = { address, len };\r\n"
"      return this.obtainView(buffer, 0, len);\r\n"
"    }\r\n"
"\r\n"
"    getTargetAddress(target, cluster) {\r\n"
"      const dv = target[MEMORY];\r\n"
"      if (cluster) {\r\n"
"        // pointer is pointing to buffer with overlapping views\r\n"
"        if (cluster.misaligned === undefined) {\r\n"
"          const address = this.getBufferAddress(dv.buffer);\r\n"
"          // ensure that all pointers are properly aligned\r\n"
"          for (const target of cluster.targets) {\r\n"
"            const offset = target[MEMORY].byteOffset;\r\n"
"            const align = target.constructor[ALIGN];\r\n"
"            const viewAddress = add(address, offset);\r\n"
"            if (isMisaligned(viewAddress, align)) {\r\n"
"              cluster.misaligned = true;\r\n"
"              break;\r\n"
"            }\r\n"
"          }\r\n"
"          if (cluster.misaligned === undefined)  {\r\n"
"            cluster.misaligned = false;\r\n"
"            cluster.address = address;\r\n"
"          }\r\n"
"        }\r\n"
"        if (!cluster.misaligned) {\r\n"
"          return add(cluster.address, dv.byteOffset);\r\n"
"        }\r\n"
"      } else {\r\n"
"        const align = target.constructor[ALIGN];\r\n"
"        const address = this.getViewAddress(dv);\r\n"
"        if (!isMisaligned(address, align)) {\r\n"
"          this.registerMemory(dv);\r\n"
"          return address;\r\n"
"        }\r\n"
"      }\r\n"
"      // need shadowing\r\n"
"    }\r\n"
"\r\n"
"    invokeThunk(thunkId, args) {\r\n"
"      let err;\r\n"
"      // create an object where information concerning pointers can be stored\r\n"
"      this.startContext();\r\n"
"      const attrs = args[ATTRIBUTES];\r\n"
"      if (args[POINTER_VISITOR]) {\r\n"
"        // copy addresses of garbage-collectible objects into memory\r\n"
"        this.updatePointerAddresses(args);\r\n"
"        this.updateShadows();\r\n"
"        err = (attrs)\r\n"
"        ? this.runVariadicThunk(thunkId, args[MEMORY], attrs[MEMORY])\r\n"
"        : this.runThunk(thunkId, args[MEMORY]);\r\n"
"        // create objects that pointers point to\r\n"
"        this.updateShadowTargets();\r\n"
"        this.updatePointerTargets(args);\r\n"
"        this.releaseShadows();\r\n"
"      } else {\r\n"
"        // don't need to do any of that if there're no pointers\r\n"
"        err = (attrs)\r\n"
"        ? this.runVariadicThunk(thunkId, args[MEMORY], attrs[MEMORY])\r\n"
"        : this.runThunk(thunkId, args[MEMORY]);\r\n"
"      }\r\n"
"      // restore the previous context if there's one\r\n"
"      this.endContext();\r\n"
"      if (!this.context) {\r\n"
"        this.flushConsole();\r\n"
"      }\r\n"
"      // errors returned by exported Zig functions are normally written into the\r\n"
"      // argument object and get thrown when we access its retval property (a zig error union)\r\n"
"      // error strings returned by the thunk are due to problems in the thunking process\r\n"
"      // (i.e. bugs in export.zig)\r\n"
"      if (err) {\r\n"
"        throw new ZigError(err);\r\n"
"      }\r\n"
"      return args.retval;\r\n"
"    }\r\n"
"  }\n"
"\n"
"  useAllMemberTypes();\r\n"
"  useAllStructureTypes();\r\n"
"  useAllExtendedTypes();\n"
"\n"
"  exports.Environment = NodeEnvironment;\n"
"\n"
"  return exports;\n"
"\n"
"})({}))"
