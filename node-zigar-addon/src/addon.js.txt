"((function (exports) {\n"
"  'use strict';\n"
"\n"
"  const MEMORY = Symbol('memory');\n"
"  const SLOTS = Symbol('slots');\n"
"  const PARENT = Symbol('parent');\n"
"  const NAME = Symbol('name');\n"
"  const TAG = Symbol('tag');\n"
"  const ITEMS = Symbol('items');\n"
"  const MESSAGES = Symbol('messages');\n"
"  const GETTER = Symbol('getter');\n"
"  const SETTER = Symbol('setter');\n"
"  const SETTERS = Symbol('setters');\n"
"  const ALL_KEYS = Symbol('allKeys');\n"
"  const LENGTH = Symbol('length');\n"
"  const PROXY = Symbol('proxy');\n"
"  const COMPAT = Symbol('compat');\n"
"  const SIZE = Symbol('size');\n"
"  const ALIGN = Symbol('align');\n"
"  const ARRAY = Symbol('array');\n"
"  const POINTER = Symbol('pointer');\n"
"  const CONST = Symbol('const');\n"
"  const CONST_PROTO = Symbol('constProto');\n"
"  const COPIER = Symbol('copier');\n"
"  const RESETTER = Symbol('resetter');\n"
"  const NORMALIZER = Symbol('normalizer');\n"
"  const VIVIFICATOR = Symbol('vivificator');\n"
"  const VISITOR = Symbol('visitor');\n"
"  const ENVIRONMENT = Symbol('environment');\n"
"  const ATTRIBUTES = Symbol('attributes');\n"
"\n"
"  function getDestructor(env) {\n"
"    return function() {\n"
"      const dv = this[MEMORY];\n"
"      this[MEMORY] = null;\n"
"      if (this[SLOTS]) {\n"
"        this[SLOTS] = {};\n"
"      }\n"
"      env.releaseFixedView(dv);\n"
"    };\n"
"  }\n"
"\n"
"  function getBitAlignFunction(bitPos, bitSize, toAligned) {\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const mask = (2 ** bitSize) - 1;\n"
"      if (toAligned) {\n"
"        // from single byte\n"
"        return function(dest, src, offset) {\n"
"          const n = src.getUint8(offset);\n"
"          const b = (n >> bitPos) & mask;\n"
"          dest.setUint8(0, b);\n"
"        };\n"
"      } else {\n"
"        // to single byte\n"
"        const destMask = 0xFF ^ (mask << bitPos);\n"
"        return function(dest, src, offset) {\n"
"          const n = src.getUint8(0);\n"
"          const d = dest.getUint8(offset);\n"
"          const b = (d & destMask) | ((n & mask) << bitPos);\n"
"          dest.setUint8(offset, b);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      const leadBits = 8 - bitPos;\n"
"      const leadMask = (2 ** leadBits) - 1;\n"
"      if (toAligned) {\n"
"        const trailBits = bitSize % 8;\n"
"        const trailMask = (2 ** trailBits) - 1;\n"
"        return function(dest, src, offset) {\n"
"          let i = offset, j = 0;\n"
"          let n = src.getUint8(i++), b;\n"
"          let bitBuf = (n >> bitPos) & leadMask;\n"
"          let bitCount = leadBits;\n"
"          let remaining = bitSize;\n"
"          do {\n"
"            if (remaining > bitCount) {\n"
"              n = src.getUint8(i++);\n"
"              bitBuf = bitBuf | (n << bitCount);\n"
"              //bitCount += 8;\n"
"            }\n"
"            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;\n"
"            dest.setUint8(j++, b);\n"
"            bitBuf >>= 8;\n"
"            //bitCount -= 8;\n"
"            remaining -= 8;\n"
"          } while (remaining > 0);\n"
"        }\n"
"      } else {\n"
"        const trailBits = (bitSize - leadBits) % 8;\n"
"        const trailMask = (2 ** trailBits) - 1;\n"
"        const destMask1 = 0xFF ^ (leadMask << bitPos);\n"
"        const destMask2 = 0xFF ^ trailMask;\n"
"        return function(dest, src, offset) {\n"
"          let i = 0, j = offset;\n"
"          // preserve bits ahead of bitPos\n"
"          let d = dest.getUint8(j), n, b;\n"
"          let bitBuf = d & destMask1;\n"
"          let bitCount = bitPos;\n"
"          let remaining = bitSize + bitCount;\n"
"          do {\n"
"            if (remaining > bitCount) {\n"
"              n = src.getUint8(i++);\n"
"              bitBuf = bitBuf | (n << bitCount);\n"
"              bitCount += 8;\n"
"            }\n"
"            if (remaining >= 8) {\n"
"              b = bitBuf & 0xFF;\n"
"            } else {\n"
"              // preserve bits at the destination sitting behind the trailing bits\n"
"              d = dest.getUint8(j);\n"
"              b = (d & destMask2) | (bitBuf & trailMask);\n"
"            }\n"
"            dest.setUint8(j++, b);\n"
"            bitBuf >>= 8;\n"
"            bitCount -= 8;\n"
"            remaining -= 8;\n"
"          } while (remaining > 0);\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function getMemoryCopier(size, multiple = false) {\n"
"    const copy = getCopyFunction(size, multiple);\n"
"    return function(target) {\n"
"      const src = target[MEMORY];\n"
"      const dest = this[MEMORY];\n"
"      copy(dest, src);\n"
"    };\n"
"  }\n"
"\n"
"  function getCopyFunction(size, multiple = false) {\n"
"    if (!multiple) {\n"
"      const copier = copiers[size];\n"
"      if (copier) {\n"
"        return copier;\n"
"      }\n"
"    }\n"
"    if (!(size & 0x07)) return copy8x;\n"
"    if (!(size & 0x03)) return copy4x;\n"
"    if (!(size & 0x01)) return copy2x;\n"
"    return copy1x;\n"
"  }\n"
"\n"
"  const copiers = {\n"
"    1: copy1,\n"
"    2: copy2,\n"
"    4: copy4,\n"
"    8: copy8,\n"
"    16: copy16,\n"
"    32: copy32,\n"
"  };\n"
"\n"
"  function copy1x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i++) {\n"
"      dest.setInt8(i, src.getInt8(i));\n"
"    }\n"
"  }\n"
"\n"
"  function copy2x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 2) {\n"
"      dest.setInt16(i, src.getInt16(i, true), true);\n"
"    }\n"
"  }\n"
"\n"
"  function copy4x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 4) {\n"
"      dest.setInt32(i, src.getInt32(i, true), true);\n"
"    }\n"
"  }\n"
"\n"
"  function copy8x(dest, src) {\n"
"    for (let i = 0, len = dest.byteLength; i < len; i += 8) {\n"
"      dest.setInt32(i, src.getInt32(i, true), true);\n"
"      dest.setInt32(i + 4, src.getInt32(i + 4, true), true);\n"
"    }\n"
"  }\n"
"\n"
"  function copy1(dest, src) {\n"
"    dest.setInt8(0, src.getInt8(0));\n"
"  }\n"
"\n"
"  function copy2(dest, src) {\n"
"    dest.setInt16(0, src.getInt16(0, true), true);\n"
"  }\n"
"\n"
"  function copy4(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"  }\n"
"\n"
"  function copy8(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\n"
"  }\n"
"\n"
"  function copy16(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\n"
"    dest.setInt32(8, src.getInt32(8, true), true);\n"
"    dest.setInt32(12, src.getInt32(12, true), true);\n"
"  }\n"
"\n"
"  function copy32(dest, src) {\n"
"    dest.setInt32(0, src.getInt32(0, true), true);\n"
"    dest.setInt32(4, src.getInt32(4, true), true);\n"
"    dest.setInt32(8, src.getInt32(8, true), true);\n"
"    dest.setInt32(12, src.getInt32(12, true), true);\n"
"    dest.setInt32(16, src.getInt32(16, true), true);\n"
"    dest.setInt32(20, src.getInt32(20, true), true);\n"
"    dest.setInt32(24, src.getInt32(24, true), true);\n"
"    dest.setInt32(28, src.getInt32(28, true), true);\n"
"  }\n"
"\n"
"  function getMemoryResetter(offset, size) {\n"
"    const reset = getResetFunction(size);\n"
"    return function() {\n"
"      const dest = this[MEMORY];\n"
"      reset(dest, offset, size);\n"
"    };\n"
"  }\n"
"\n"
"  function getResetFunction(size) {\n"
"    const resetter = resetters[size];\n"
"    if (resetter) {\n"
"      return resetter;\n"
"    }\n"
"    if (!(size & 0x07)) return reset8x;\n"
"    if (!(size & 0x03)) return reset4x;\n"
"    if (!(size & 0x01)) return reset2x;\n"
"    return reset1x;\n"
"  }\n"
"\n"
"  const resetters = {\n"
"    1: reset1,\n"
"    2: reset2,\n"
"    4: reset4,\n"
"    8: reset8,\n"
"    16: reset16,\n"
"    32: reset32,\n"
"  };\n"
"\n"
"  function reset1x(dest, offset, size) {\n"
"    for (let i = offset, limit = offset + size; i < limit; i++) {\n"
"      dest.setInt8(i, 0);\n"
"    }\n"
"  }\n"
"\n"
"  function reset2x(dest, offset, size) {\n"
"    for (let i = offset, limit = offset + size; i < limit; i += 2) {\n"
"      dest.setInt16(i, 0, true);\n"
"    }\n"
"  }\n"
"\n"
"  function reset4x(dest, offset, size) {\n"
"    for (let i = offset, limit = offset + size; i < limit; i += 4) {\n"
"      dest.setInt32(i, 0, true);\n"
"    }\n"
"  }\n"
"\n"
"  function reset8x(dest, offset, size) {\n"
"    for (let i = offset, limit = offset + size; i < limit; i += 8) {\n"
"      dest.setInt32(i, 0, true);\n"
"      dest.setInt32(i + 4, 0, true);\n"
"    }\n"
"  }\n"
"\n"
"  function reset1(dest, offset) {\n"
"    dest.setInt8(offset, 0);\n"
"  }\n"
"\n"
"  function reset2(dest, offset) {\n"
"    dest.setInt16(offset, 0, true);\n"
"  }\n"
"\n"
"  function reset4(dest, offset) {\n"
"    dest.setInt32(offset, 0, true);\n"
"  }\n"
"\n"
"  function reset8(dest, offset) {\n"
"    dest.setInt32(offset + 0, 0, true);\n"
"    dest.setInt32(offset + 4, 0, true);\n"
"  }\n"
"\n"
"  function reset16(dest, offset) {\n"
"    dest.setInt32(offset + 0, 0, true);\n"
"    dest.setInt32(offset + 4, 0, true);\n"
"    dest.setInt32(offset + 8, 0, true);\n"
"    dest.setInt32(offset + 12, 0, true);\n"
"  }\n"
"\n"
"  function reset32(dest, offset) {\n"
"    dest.setInt32(offset + 0, 0, true);\n"
"    dest.setInt32(offset + 4, 0, true);\n"
"    dest.setInt32(offset + 8, 0, true);\n"
"    dest.setInt32(offset + 12, 0, true);\n"
"    dest.setInt32(offset + 16, 0, true);\n"
"    dest.setInt32(offset + 20, 0, true);\n"
"    dest.setInt32(offset + 24, 0, true);\n"
"    dest.setInt32(offset + 28, 0, true);\n"
"  }\n"
"\n"
"  const decoders = {};\n"
"  const encoders = {};\n"
"\n"
"  function decodeText(arrays, encoding = 'utf-8') {\n"
"    let decoder = decoders[encoding];\n"
"    if (!decoder) {\n"
"      decoder = decoders[encoding] = new TextDecoder(encoding);\n"
"    }\n"
"    let array;\n"
"    if (Array.isArray(arrays)) {\n"
"      if (arrays.length === 1) {\n"
"        array = arrays[0];\n"
"      } else {\n"
"        let len = 0;\n"
"        for (const a of arrays) {\n"
"          len += a.length;\n"
"        }\n"
"        const { constructor } = arrays[0];\n"
"        array = new constructor(len);\n"
"        let offset = 0;\n"
"        for (const a of arrays) {\n"
"          array.set(a, offset);\n"
"          offset += a.length;\n"
"        }\n"
"      }\n"
"    } else {\n"
"      array = arrays;\n"
"    }\n"
"    return decoder.decode(array);\n"
"  }\n"
"\n"
"  function encodeText(text, encoding = 'utf-8') {\n"
"    switch (encoding) {\n"
"      case 'utf-16': {\n"
"        const { length } = text;\n"
"        const ta = new Uint16Array(length);\n"
"        for (let i = 0; i < length; i++) {\n"
"          ta[i] = text.charCodeAt(i);\n"
"        }\n"
"        return ta;\n"
"      }\n"
"      default: {\n"
"        let encoder = encoders[encoding];\n"
"        if (!encoder) {\n"
"          encoder = encoders[encoding] = new TextEncoder();\n"
"        }\n"
"        return encoder.encode(text);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function encodeBase64(dv) {\n"
"    /* NODE-ONLY */\n"
"    if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {\n"
"      return Buffer.from(dv.buffer, dv.byteOffset, dv.byteLength).toString('base64');\n"
"    }\n"
"    /* NODE-ONLY-END */\n"
"    const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);\n"
"    const bstr = String.fromCharCode.apply(null, ta);\n"
"    return btoa(bstr);\n"
"  }\n"
"\n"
"  function decodeBase64(str) {\n"
"    /* NODE-ONLY */\n"
"    if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {\n"
"      const b = Buffer.from(str, 'base64');\n"
"      return new DataView(b.buffer, b.byteOffset, b.byteLength);\n"
"    }\n"
"    /* NODE-ONLY-END */\n"
"    const bstr = atob(str);\n"
"    const ta = new Uint8Array(bstr.length);\n"
"    for (let i = 0; i < ta.byteLength; i++) {\n"
"      ta[i] = bstr.charCodeAt(i);\n"
"    }\n"
"    return new DataView(ta.buffer);  \n"
"  }\n"
"\n"
"  function getValueOf() {\n"
"    const map = new Map();\n"
"    return this[NORMALIZER](map, false);\n"
"  }\n"
"\n"
"  function convertToJSON() {\n"
"    const map = new Map();\n"
"    return this[NORMALIZER](map, true);\n"
"  }\n"
"\n"
"  function getDataViewAccessors(structure, handlers = {}) {\n"
"    return markAsSpecial({\n"
"      get() {\n"
"        return this[MEMORY];\n"
"      },\n"
"      set(dv) {\n"
"        checkDataView(dv);\n"
"        setDataView.call(this, dv, structure, true, handlers);\n"
"      },\n"
"    });\n"
"  }\n"
"\n"
"  function getBase64Accessors(structure, handlers = {}) {\n"
"    return markAsSpecial({\n"
"      get() {\n"
"        return encodeBase64(this.dataView);\n"
"      },\n"
"      set(str) {\n"
"        if (typeof(str) !== 'string') {\n"
"          throwTypeMismatch('string', str);\n"
"        }\n"
"        const dv = decodeBase64(str);\n"
"        setDataView.call(this, dv, structure, false, handlers);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getStringAccessors(structure, handlers = {}) {\n"
"    const { sentinel, instance: { members }} = structure;\n"
"    const { byteSize: charSize } = members[0];\n"
"    return markAsSpecial({\n"
"      get() {\n"
"        const dv = this.dataView;\n"
"        const TypedArray = (charSize === 1) ? Int8Array : Int16Array;\n"
"        const ta = new TypedArray(dv.buffer, dv.byteOffset, this.length);\n"
"        const s = decodeText(ta, `utf-${charSize * 8}`);\n"
"        return (sentinel?.value === undefined) ? s : s.slice(0, -1);\n"
"      },\n"
"      set(str) {\n"
"        if (typeof(str) !== 'string') {\n"
"          throwTypeMismatch('a string', str);\n"
"        }\n"
"        if (sentinel?.value !== undefined) {\n"
"          if (str.charCodeAt(str.length - 1) !== sentinel.value) {\n"
"            str = str + String.fromCharCode(sentinel.value);\n"
"          }\n"
"        }\n"
"        const ta = encodeText(str, `utf-${charSize * 8}`);\n"
"        const dv = new DataView(ta.buffer);   \n"
"        setDataView.call(this, dv, structure, false, handlers);\n"
"      },\n"
"    });\n"
"  }\n"
"\n"
"  function getTypedArrayAccessors(structure, handlers = {}) {\n"
"    const { typedArray } = structure;\n"
"    return markAsSpecial({\n"
"      get() {\n"
"        const dv = this.dataView;\n"
"        const length = dv.byteLength / typedArray.BYTES_PER_ELEMENT;\n"
"        return new typedArray(dv.buffer, dv.byteOffset, length);\n"
"      },\n"
"      set(ta) {\n"
"        if (!isTypedArray(ta, typedArray)) {\n"
"          throwTypeMismatch(typedArray.name, ta);\n"
"        }\n"
"        const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);\n"
"        setDataView.call(this, dv, structure, true, handlers);\n"
"      },\n"
"    });\n"
"  }\n"
"\n"
"  function markAsSpecial({ get, set }) {\n"
"    get.special = set.special = true;\n"
"    return { get, set };\n"
"  }\n"
"\n"
"  function definePointer(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members: [ member ] },\n"
"      isConst,\n"
"    } = structure;\n"
"    const {\n"
"      runtimeSafety = true,\n"
"    } = env;\n"
"    const { structure: targetStructure } = member;\n"
"    const { sentinel } = targetStructure;\n"
"    const isTargetSlice = (targetStructure.type === StructureType.Slice);\n"
"    const isTargetPointer = (targetStructure.type === StructureType.Pointer);\n"
"    const hasLength = isTargetSlice && !sentinel;  \n"
"    const addressSize = (hasLength) ? byteSize / 2 : byteSize;\n"
"    const { get: getAddress, set: setAddress } = getDescriptor({\n"
"      type: MemberType.Uint,\n"
"      bitOffset: 0,\n"
"      bitSize: addressSize * 8,\n"
"      byteSize: addressSize,\n"
"      structure: { byteSize: addressSize },\n"
"    }, env);\n"
"    const { get: getLength, set: setLength } = (hasLength) ? getDescriptor({\n"
"      type: MemberType.Uint,\n"
"      bitOffset: addressSize * 8,\n"
"      bitSize: addressSize * 8,\n"
"      byteSize: addressSize,\n"
"      structure: { name: 'usize', byteSize: addressSize },\n"
"    }, env) : {};\n"
"    const { get, set } = getDescriptor(member, env);\n"
"    const alternateCaster = function(arg, options) {\n"
"      const Target = targetStructure.constructor;\n"
"      if (isPointerOf(arg, Target)) {\n"
"        // const/non-const casting\n"
"        return new constructor(Target(arg['*'], { writable: !isConst }), options);\n"
"      } else if (this === ENVIRONMENT || this === PARENT) {\n"
"        // allow the runtime environment to cast to pointer\n"
"        return false;\n"
"      } else if (isTargetSlice) {\n"
"        // allow casting to slice through constructor of its pointer\n"
"        return new constructor(Target(arg), options);\n"
"      } else {\n"
"        throwNoCastingToPointer();\n"
"      }\n"
"    };\n"
"    const finalizer = function() {\n"
"      const handlers = (isTargetPointer) ? {} : proxyHandlers$1;\n"
"      const proxy = new Proxy(this, handlers);\n"
"      // hide the proxy so console wouldn't display a recursive structure\n"
"      Object.defineProperty(this, PROXY, { value: proxy });\n"
"      return proxy;\n"
"    };\n"
"    const initializer = function(arg) {\n"
"      const Target = targetStructure.constructor;\n"
"      if (isPointerOf(arg, Target)) {\n"
"        // initialize with the other pointer'structure target\n"
"        if (!isConst && arg.constructor.const) {\n"
"          throwConstantConstraint(structure, arg);\n"
"        }\n"
"        arg = arg[SLOTS][0];\n"
"      }\n"
"      if (arg instanceof Target) {\n"
"        if (isConst && !arg[CONST]) {\n"
"          // create read-only version\n"
"          arg = Target(arg, { writable: false });\n"
"        } else if (!isConst && arg[CONST]) {\n"
"          throwReadOnlyTarget(structure);\n"
"        }\n"
"      } else if (isCompatible(arg, Target)) {\n"
"        // autocast to target type\n"
"        const dv = getDataView(targetStructure, arg, env);\n"
"        arg = Target(dv, { writable: !isConst });\n"
"      } else if (isTargetSlice) {\n"
"        // autovivificate target object\n"
"        const autoObj = new Target(arg, { writable: !isConst });\n"
"        if (runtimeSafety) {\n"
"          // creation of a new slice using a typed array is probably\n"
"          // not what the user wants; it's more likely that the intention\n"
"          // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)\n"
"          if (targetStructure.typedArray && isBuffer(arg?.buffer)) {\n"
"            warnImplicitArrayCreation(targetStructure, arg);\n"
"          }\n"
"        }\n"
"        arg = autoObj;\n"
"      } else {\n"
"        throwInvalidPointerTarget(structure, arg);\n"
"      }\n"
"      if (env.inFixedMemory(this)) {\n"
"        // the pointer sits in fixed memory--apply the change immediately\n"
"        if (env.inFixedMemory(arg)) {\n"
"          const address = env.getViewAddress(arg[MEMORY]);\n"
"          setAddress.call(this, address);\n"
"          if (setLength) {\n"
"            setLength.call(this, arg.length);\n"
"          }\n"
"        } else {\n"
"          throwFixedMemoryTargetRequired();\n"
"        }\n"
"      }\n"
"      this[SLOTS][0] = arg;\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster, finalizer }, env);\n"
"    const addressSetter = (hasLength) \n"
"    ? function(address, length) {\n"
"        setAddress.call(this, address);\n"
"        setLength.call(this, length);\n"
"      }\n"
"    : setAddress;\n"
"    const addressGetter = (hasLength)\n"
"    ? function() {\n"
"      const address = getAddress.call(this);\n"
"      const length = getLength.call(this);\n"
"      return [ address, length ];\n"
"    } \n"
"    : (sentinel)\n"
"    ? function() {\n"
"      const address = getAddress.call(this);\n"
"      const length = (address) ? env.findSentinel(address, sentinel.bytes) + 1 : 0;\n"
"      return [ address, length ];\n"
"    }\n"
"    : function() {\n"
"      const address = getAddress.call(this);\n"
"      return [ address, 1 ];\n"
"    };\n"
"    const instanceDescriptors = {\n"
"      '*': { get, set },\n"
"      '$': { get: getProxy, set: initializer },\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      [GETTER]: { value: addressGetter },\n"
"      [SETTER]: { value: addressSetter },\n"
"      [VISITOR]: { value: visitPointer },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [VIVIFICATOR]: { value: throwNullPointer },\n"
"      [NORMALIZER]: { value: normalizePointer },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      child: { get: () => targetStructure.constructor },\n"
"      const: { value: isConst },\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function normalizePointer(map, forJSON) {\n"
"    const target = this['*'];\n"
"    return target[NORMALIZER]?.(map, forJSON) ?? target;\n"
"  }\n"
"\n"
"  function getProxy() {\n"
"    return this[PROXY];\n"
"  }\n"
"\n"
"  function copyPointer({ source }) {\n"
"    this[SLOTS][0] = source[SLOTS][0];\n"
"  }\n"
"\n"
"  function resetPointer({ isActive }) {\n"
"    if (this[SLOTS][0] && !isActive(this)) {\n"
"      this[SLOTS][0] = null;\n"
"    }\n"
"  }\n"
"\n"
"  function disablePointer() {\n"
"    Object.defineProperty(this[SLOTS], 0, {\n"
"      get: throwInaccessiblePointer,\n"
"      set: throwInaccessiblePointer,\n"
"      configurable: true\n"
"    });\n"
"  }\n"
"\n"
"  function visitPointer(fn, options = {}) {\n"
"    const {\n"
"      source,\n"
"      isActive = always,\n"
"      isMutable = always,\n"
"    } = options;\n"
"    fn.call(this, { source, isActive, isMutable });\n"
"  }\n"
"\n"
"  function isPointerOf(arg, Target) {\n"
"    return (arg?.constructor?.child === Target && arg['*']);\n"
"  }\n"
"\n"
"  const proxyHandlers$1 = {\n"
"    get(pointer, name) {\n"
"      if (name === POINTER) {\n"
"        return pointer;\n"
"      } else if (name in pointer) {\n"
"        return pointer[name];\n"
"      } else {\n"
"        return pointer['*'][name];\n"
"      }\n"
"    },\n"
"    set(pointer, name, value) {\n"
"      if (name in pointer) {\n"
"        pointer[name] = value;\n"
"      } else {\n"
"        pointer['*'][name] = value;\n"
"      }\n"
"      return true;\n"
"    },\n"
"    deleteProperty(pointer, name) {\n"
"      if (name in pointer) {\n"
"        delete pointer[name];\n"
"      } else {\n"
"        delete pointer['*'][name];\n"
"      }\n"
"      return true;\n"
"    },\n"
"    has(pointer, name) {\n"
"      if (name in pointer) {\n"
"        return true;\n"
"      } else {\n"
"        return name in pointer['*'];\n"
"      }\n"
"    },\n"
"  };\n"
"\n"
"  function always() {\n"
"    return true;\n"
"  }\n"
"\n"
"  function defineStructShape(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members },\n"
"      hasPointer,\n"
"    } = structure;  \n"
"    const memberDescriptors = {};\n"
"    for (const member of members) {\n"
"      const { get, set } = getDescriptor(member, env);\n"
"      memberDescriptors[member.name] = { get, set, configurable: true, enumerable: true };\n"
"      if (member.isRequired) {\n"
"        set.required = true;\n"
"      }\n"
"    }\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        this[COPIER](arg);\n"
"        if (hasPointer) {\n"
"          this[VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"        }\n"
"      } else if (arg && typeof(arg) === 'object') {\n"
"        propApplier.call(this, arg);\n"
"      } else if (arg !== undefined) {\n"
"        throwInvalidInitializer(structure, 'object', arg);\n"
"      }\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\n"
"    const memberNames = members.map(m => m.name);\n"
"    const interatorCreator = function() {\n"
"      const self = this;\n"
"      let index = 0;\n"
"      return {\n"
"        next() {\n"
"          let value, done;\n"
"          if (index < memberNames.length) {\n"
"            const name = memberNames[index];\n"
"            value = [ name, self[name] ];\n"
"            done = false;\n"
"            index++;\n"
"          } else {\n"
"            done = true;\n"
"          }\n"
"          return { value, done };\n"
"        },\n"
"      };\n"
"    };\n"
"    const instanceDescriptors = {\n"
"      $: { get: getSelf, set: initializer },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      ...memberDescriptors,\n"
"      [Symbol.iterator]: { value: interatorCreator },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },\n"
"      [VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, always) },\n"
"      [NORMALIZER]: { value: normalizeStruct },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function normalizeStruct(map, forJSON) {\n"
"    let object = map.get(this);\n"
"    if (!object) {\n"
"      object = {};\n"
"      map.set(this, object);\n"
"      for (const [ name, value ] of this) {      \n"
"        object[name] = value[NORMALIZER]?.(map, forJSON) ?? value;\n"
"      }\n"
"    }\n"
"    return object;\n"
"  }\n"
"\n"
"  function getChildVivificator$1(structure) {\n"
"    const { instance: { members } } = structure;\n"
"    const objectMembers = {};\n"
"    for (const member of members.filter(m => m.type === MemberType.Object)) {\n"
"      objectMembers[member.slot] = member;\n"
"    }\n"
"    return function vivificateChild(slot, writable = true) {\n"
"      const { bitOffset, byteSize, structure: { constructor } } = objectMembers[slot];\n"
"      const dv = this[MEMORY];\n"
"      const parentOffset = dv.byteOffset;\n"
"      const offset = parentOffset + (bitOffset >> 3);\n"
"      const childDV = new DataView(dv.buffer, offset, byteSize);\n"
"      const object = this[SLOTS][slot] = constructor.call(PARENT, childDV, { writable });\n"
"      return object;\n"
"    }\n"
"  }\n"
"\n"
"  function getPointerVisitor$1(structure, visitorOptions = {}) {\n"
"    const {\n"
"      isChildActive = always,\n"
"      isChildMutable = always,\n"
"    } = visitorOptions;\n"
"    const { instance: { members } } = structure;\n"
"    const pointerMembers = members.filter(m => m.structure.hasPointer);\n"
"    return function visitPointers(cb, options = {}) {\n"
"      const {\n"
"        source,\n"
"        vivificate = false,\n"
"        isActive = always,\n"
"        isMutable = always,\n"
"      } = options;\n"
"      const childOptions = {\n"
"        ...options,\n"
"        isActive: (object) => {\n"
"          // make sure parent object is active, then check whether the child is active\n"
"          return isActive(this) && isChildActive.call(this, object);\n"
"        },\n"
"        isMutable: (object) => {\n"
"          return isMutable(this) && isChildMutable.call(this, object);\n"
"        },\n"
"      };\n"
"      for (const { slot } of pointerMembers) {\n"
"        if (source) {\n"
"          // when src is a the struct's template, most slots will likely be empty,\n"
"          // since pointer fields aren't likely to have default values\n"
"          const srcChild = source[SLOTS]?.[slot];\n"
"          if (!srcChild) {\n"
"            continue;\n"
"          }\n"
"          childOptions.source = srcChild;\n"
"        }\n"
"        const child = this[SLOTS][slot] ?? (vivificate ? this[VIVIFICATOR](slot) : null);\n"
"        if (child) {\n"
"          child[VISITOR](cb, childOptions);\n"
"        }\n"
"      }\n"
"    };\n"
"  }\n"
"\n"
"  function defineArgStruct(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members },\n"
"      hasPointer,\n"
"    } = structure;\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const constructor = structure.constructor = function(args) {\n"
"      const dv = env.allocateMemory(byteSize, align);\n"
"      this[MEMORY] = dv;\n"
"      if (hasObject) {\n"
"        this[SLOTS] = {};\n"
"      }\n"
"      initializer.call(this, args);\n"
"    };\n"
"    const argNames = members.slice(0, -1).map(m => m.name);\n"
"    const argCount = argNames.length;\n"
"    const initializer = function(args) {\n"
"      if (args.length !== argCount) {\n"
"        throwArgumentCountMismatch(structure, args.length);\n"
"      }\n"
"      for (const [ index, name ] of argNames.entries()) {\n"
"        try {\n"
"          this[name] = args[index];\n"
"        } catch (err) {\n"
"          rethrowArgumentError(structure, index, err);\n"
"        }\n"
"      }\n"
"    };\n"
"    const memberDescriptors = {};\n"
"    for (const member of members) {\n"
"      memberDescriptors[member.name] = getDescriptor(member, env);\n"
"    }\n"
"    const isChildMutable = function(object) {\n"
"        return (object === this.retval);\n"
"    };\n"
"    defineProperties(constructor.prototype, {\n"
"      ...memberDescriptors,\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },\n"
"      [VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildMutable }) },\n"
"    });\n"
"    defineProperties(constructor, {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    });\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function defineArray(structure, env) {\n"
"    const {\n"
"      length,\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members: [ member ] },\n"
"      hasPointer,\n"
"    } = structure;\n"
"    const { get, set } = getDescriptor(member, env);\n"
"    const hasStringProp = canBeString(member);\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        this[COPIER](arg);\n"
"        if (hasPointer) {\n"
"          this[VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"        }\n"
"      } else {\n"
"        if (typeof(arg) === 'string' && hasStringProp) {\n"
"          arg = { string: arg };\n"
"        }\n"
"        if (arg?.[Symbol.iterator]) {\n"
"          let argLen = arg.length;\n"
"          if (typeof(argLen) !== 'number') {\n"
"            arg = [ ...arg ];\n"
"            argLen = arg.length;\n"
"          }\n"
"          if (argLen !== length) {\n"
"            throwArrayLengthMismatch(structure, this, arg);\n"
"          }\n"
"          let i = 0;\n"
"          for (const value of arg) {\n"
"            set.call(this, i++, value);\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            throwInvalidArrayInitializer(structure, arg);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throwInvalidArrayInitializer(structure, arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    const finalizer = createArrayProxy;\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, finalizer }, env);\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\n"
"    const hasObject = member.type === MemberType.Object;\n"
"    const instanceDescriptors = {\n"
"      $: { get: getProxy, set: initializer },\n"
"      length: { value: length },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      string: hasStringProp && getStringAccessors(structure),\n"
"      typedArray: typedArray && getTypedArrayAccessors(structure),\n"
"      get: { value: get },\n"
"      set: { value: set },\n"
"      entries: { value: getArrayEntries },\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      [Symbol.iterator]: { value: getArrayIterator },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator(structure) },\n"
"      [VISITOR]: hasPointer && { value: getPointerVisitor() },\n"
"      [NORMALIZER]: { value: normalizeArray },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      child: { get: () => member.structure.constructor },\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function createArrayProxy() {\n"
"    const proxy = new Proxy(this, proxyHandlers);\n"
"    // hide the proxy so console wouldn't display a recursive structure\n"
"    Object.defineProperty(this, PROXY, { value: proxy }); \n"
"    return proxy;\n"
"  }\n"
"\n"
"  function canBeString(member) {\n"
"    return member.type === MemberType.Uint && [ 8, 16 ].includes(member.bitSize);\n"
"  }\n"
"\n"
"  function normalizeArray(map, forJSON) {\n"
"    let array = map.get(this);\n"
"    if (!array) {\n"
"      array = [];\n"
"      map.set(this, array);\n"
"      for (const value of this) {      \n"
"        array.push(value[NORMALIZER]?.(map, forJSON) ?? value);\n"
"      }\n"
"    }\n"
"    return array;\n"
"  }\n"
"\n"
"  function getArrayIterator() {\n"
"    const self = this[ARRAY] ?? this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = self.get(index);\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getArrayEntriesIterator() {\n"
"    const self = this[ARRAY] ?? this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = [ index, self.get(index) ];\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getArrayEntries() {\n"
"    return {\n"
"      [Symbol.iterator]: getArrayEntriesIterator.bind(this),\n"
"      length: this.length,\n"
"    };\n"
"  }\n"
"\n"
"  function getChildVivificator(structure) {\n"
"    const { instance: { members: [ member ]} } = structure;\n"
"    const { byteSize, structure: elementStructure } = member;\n"
"    return function getChild(index, writable = true) {\n"
"      const { constructor } = elementStructure;\n"
"      const dv = this[MEMORY];\n"
"      const parentOffset = dv.byteOffset;\n"
"      const offset = parentOffset + byteSize * index;\n"
"      const childDV = new DataView(dv.buffer, offset, byteSize);\n"
"      const object = this[SLOTS][index] = constructor.call(PARENT, childDV, { writable });\n"
"      return object;\n"
"    };\n"
"  }\n"
"\n"
"  function getPointerVisitor(structure) {\n"
"    return function visitPointers(cb, options = {}) {\n"
"      const {\n"
"        source,\n"
"        vivificate = false,\n"
"        isActive = always,\n"
"        isMutable = always,\n"
"      } = options;\n"
"      const childOptions = {\n"
"        ...options,\n"
"        isActive: () => isActive(this),\n"
"        isMutable: () => isMutable(this),\n"
"      };\n"
"      for (let i = 0, len = this.length; i < len; i++) {\n"
"        // no need to check for empty slots, since that isn't possible\n"
"        if (source) {\n"
"          childOptions.source = source?.[SLOTS][i];\n"
"        }\n"
"        const child = this[SLOTS][i] ?? (vivificate ? this[VIVIFICATOR](i) : null);\n"
"        if (child) {\n"
"          child[VISITOR](cb, childOptions);\n"
"        }\n"
"      }\n"
"    };\n"
"  }\n"
"\n"
"  const proxyHandlers = {\n"
"    get(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return array.get(index);\n"
"      } else {\n"
"        switch (name) {\n"
"          case 'get':\n"
"            if (!array[GETTER]) {\n"
"              array[GETTER] = array.get.bind(array);\n"
"            }\n"
"            return array[GETTER];\n"
"          case 'set':\n"
"            if (!array[SETTER]) {\n"
"              array[SETTER] = array.set.bind(array);\n"
"            }\n"
"            return array[SETTER];\n"
"          case ARRAY:\n"
"            return array;\n"
"          default:\n"
"            return array[name];\n"
"        }\n"
"      }\n"
"    },\n"
"    set(array, name, value) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        array.set(index, value);\n"
"      } else {\n"
"        switch (name) {\n"
"          case 'get':\n"
"            array[GETTER] = value;\n"
"            break;\n"
"          case 'set':\n"
"            array[SETTER] = value;\n"
"            break;\n"
"          default:\n"
"            array[name] = value;\n"
"        }\n"
"      }\n"
"      return true;\n"
"    },\n"
"    deleteProperty(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return false;\n"
"      } else {\n"
"        switch (name) {\n"
"          case 'get':\n"
"            delete array[GETTER];\n"
"            break;\n"
"          case 'set':\n"
"            delete array[SETTER];\n"
"            break;\n"
"          default:\n"
"            delete array[name];\n"
"        }\n"
"        return true;\n"
"      }\n"
"    },\n"
"    has(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return (index >= 0 && index < array.length);\n"
"      } else {\n"
"        return array[name];\n"
"      }\n"
"    },\n"
"    ownKeys(array) {\n"
"      const keys = [];\n"
"      for (let i = 0, len = array.length; i < len; i++) {\n"
"        keys.push(`${i}`);\n"
"      }\n"
"      keys.push('length', PROXY);\n"
"      return keys;\n"
"    },\n"
"    getOwnPropertyDescriptor(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        if (index >= 0 && index < array.length) {\n"
"          return { value: array.get(index), enumerable: true, writable: true, configurable: true };\n"
"        }\n"
"      } else {\n"
"        return Object.getOwnPropertyDescriptor(array, name);\n"
"      }\n"
"    },\n"
"  };\n"
"\n"
"  function defineEnumerationShape(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"    } = structure;\n"
"    const { get: getIndex } = getDescriptor(member, env);\n"
"    // get the enum descriptor instead of the int/uint descriptor\n"
"    const { get, set } = getDescriptor({ ...member, type: MemberType.EnumerationItem, structure }, env);\n"
"    const expected = [ 'string', 'number', 'tagged union' ];\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg && typeof(arg) === 'object') {\n"
"        if (propApplier.call(this, arg) === 0) {\n"
"          throwInvalidInitializer(structure, expected, arg);\n"
"        }\n"
"      } else if (arg !== undefined) {\n"
"        set.call(this, arg);\n"
"      }\n"
"    };\n"
"    const alternateCaster = function(arg) {\n"
"      if (typeof(arg)  === 'string') {\n"
"        return constructor[arg];\n"
"      } else if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {\n"
"        return constructor[ITEMS][arg];\n"
"      } else if (arg?.[TAG] instanceof constructor) {\n"
"        // a tagged union, return the active tag\n"
"        return arg[TAG];\n"
"      } else if (!getDataView(structure, arg, env)) {\n"
"        throwInvalidInitializer(structure, expected, arg);\n"
"      } else {\n"
"        return false;\n"
"      }\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster }, env);\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\n"
"    const instanceDescriptors = {\n"
"      $: { get, set },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      typedArray: typedArray && getTypedArrayAccessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      [Symbol.toPrimitive]: { value: getIndex },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [NORMALIZER]: { value: normalizeEnumerationItem },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"      [ITEMS]: { value: {} },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"  function normalizeEnumerationItem(map, forJSON) {\n"
"    const item = this.$;\n"
"    return item[NAME];\n"
"  }\n"
"\n"
"  let currentErrorSets;\n"
"\n"
"  function defineErrorSet(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members: [ member ] },\n"
"    } = structure;\n"
"    const { get: getIndex } = getDescriptor(member, env);\n"
"    // get the error descriptor instead of the int/uint descriptor\n"
"    const { get, set } = getDescriptor({ ...member, type: MemberType.Error, structure }, env);\n"
"    const expected = [ 'string', 'number' ];\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg && typeof(arg) === 'object') {\n"
"        try {\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            throwInvalidInitializer(structure, expected, arg);\n"
"          } \n"
"        } catch (err) {\n"
"          const { error } = arg;\n"
"          if (typeof(error) === 'string') {\n"
"            set.call(this, error);\n"
"          } else {\n"
"            throw err;\n"
"          }\n"
"        }\n"
"      } else if (arg !== undefined) {\n"
"        set.call(this, arg);\n"
"      }\n"
"    };\n"
"    const alternateCaster = function(arg) {\n"
"      if (typeof(arg) === 'number' || typeof(arg) === 'string') {\n"
"        return constructor[ITEMS][arg];\n"
"      } else if (!getDataView(structure, arg, env)) {\n"
"        throwInvalidInitializer(structure, expected, arg);\n"
"      } else {\n"
"        return false;\n"
"      }\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, alternateCaster }, env);\n"
"    Object.setPrototypeOf(constructor.prototype, Error.prototype);\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\n"
"    const getMessage = function() {\n"
"      const index = getIndex.call(this);\n"
"      return constructor[MESSAGES][index];\n"
"    };\n"
"    const toStringTag = function() { return 'Error' };\n"
"    const instanceDescriptors = {\n"
"      $: { get, set },\n"
"      index: { get: getIndex },\n"
"      message: { get: getMessage },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      typedArray: typedArray && getTypedArrayAccessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      // ensure that libraries that rely on the string tag for type detection will\n"
"      // correctly identify the object as an error\n"
"      [Symbol.toStringTag]: { get: toStringTag },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [NORMALIZER]: { value: normalizeError },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"      [ITEMS]: { value: {} },\n"
"      [MESSAGES]: { value: {} },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"  function normalizeError(map, forJSON) {\n"
"    const err = this.$;\n"
"    if (forJSON) {\n"
"      const { message } = err;\n"
"      return { error: message };\n"
"    } else {\n"
"      return err;\n"
"    }\n"
"  }\n"
"\n"
"  function initializeErrorSets() {\n"
"    currentErrorSets = {};\n"
"  }\n"
"\n"
"  function getCurrentErrorSets() {\n"
"    return currentErrorSets;\n"
"  }\n"
"\n"
"  function defineErrorUnion(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members },\n"
"      hasPointer,\n"
"    } = structure;\n"
"    const { get: getValue, set: setValue } = getDescriptor(members[0], env);\n"
"    const { get: getError, set: setError } = getDescriptor(members[1], env);\n"
"    const get = function() {\n"
"      const error = getError.call(this);\n"
"      if (error) {\n"
"        throw error;\n"
"      } else {\n"
"        return getValue.call(this);\n"
"      }\n"
"    };\n"
"    const isChildActive = function() {\n"
"      return !getError.call(this);\n"
"    };\n"
"    const clearValue = function() {\n"
"      this[RESETTER]();\n"
"      this[VISITOR]?.(resetPointer);\n"
"    };\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        this[COPIER](arg);\n"
"        if (hasPointer) {\n"
"          if (isChildActive.call(this)) {\n"
"            this[VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"          }\n"
"        }\n"
"      } else if (arg instanceof Error) {\n"
"        setError.call(this, arg);\n"
"        clearValue.call(this);\n"
"      } else if (arg !== undefined) {\n"
"        try {\n"
"          // call setValue() first, in case it throws\n"
"          setValue.call(this, arg);\n"
"          setError.call(this, null);\n"
"        } catch (err) {\n"
"          if (arg && typeof(arg) === 'object') {\n"
"            try {\n"
"              if (propApplier.call(this, arg) === 0) {\n"
"                throw err;\n"
"              }\n"
"            } catch (err) {\n"
"              const { error } = arg;\n"
"              if (typeof(error) === 'string') {\n"
"                setError.call(this, error);\n"
"                clearValue.call(this);\n"
"              } else {\n"
"                throw err;\n"
"              }   \n"
"            }                   \n"
"          } else {\n"
"            throw err;\n"
"          }\n"
"        }\n"
"      }\n"
"    };  \n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\n"
"    const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];\n"
"    const instanceDescriptors = {\n"
"      '$': { get, set: initializer },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [RESETTER]: { value: getMemoryResetter(valueBitOffset / 8, valueByteSize) },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },\n"
"      [VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },\n"
"      [NORMALIZER]: { value: normalizeErrorUnion },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function normalizeErrorUnion(map, forJSON) {\n"
"    try {\n"
"      const value = this.$;\n"
"      return value[NORMALIZER]?.(map, forJSON) ?? value;\n"
"    } catch (err) {\n"
"      if (forJSON) {\n"
"        return { error: err.message };\n"
"      } else {\n"
"        throw err;\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineOptional(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members },\n"
"      hasPointer,\n"
"    } = structure;\n"
"    const { get: getValue, set: setValue } = getDescriptor(members[0], env);\n"
"    const { get: getPresent, set: setPresent } = getDescriptor(members[1], env);\n"
"    const hasPresentFlag = !(members[0].bitSize > 0 && members[0].bitOffset === members[1].bitOffset);  \n"
"    const get = function() {\n"
"      const present = getPresent.call(this);\n"
"      if (present) {\n"
"        return getValue.call(this);\n"
"      } else {\n"
"        this[VISITOR]?.(resetPointer);\n"
"        return null;\n"
"      }\n"
"    };\n"
"    const isChildActive = getPresent;\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        this[COPIER](arg);\n"
"        if (hasPointer) {\n"
"          // don't bother copying pointers when it's empty\n"
"          if (isChildActive.call(arg)) {\n"
"            this[VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"          }\n"
"        }      \n"
"      } else if (arg !== null) {\n"
"        // call setValue() first, in case it throws\n"
"        setValue.call(this, arg);\n"
"        if (hasPresentFlag || !env.inFixedMemory(this)) {\n"
"          // since setValue() wouldn't write address into memory when the pointer is in \n"
"          // relocatable memory, we need to use setPresent() in order to write something \n"
"          // non-zero there so that we know the field is populated\n"
"          setPresent.call(this, true);\n"
"        }\n"
"      } else {      \n"
"        setPresent.call(this, false);\n"
"        this[RESETTER]?.();\n"
"        // clear references so objects can be garbage-collected\n"
"        this[VISITOR]?.(resetPointer);\n"
"      }\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\n"
"    const { bitOffset: valueBitOffset, byteSize: valueByteSize } = members[0];\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const instanceDescriptors = {\n"
"      $: { get, set: initializer },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      // no need to reset the value when it's a pointer, since setPresent() would null out memory used by the pointer\n"
"      [RESETTER]: !hasPointer && { value: getMemoryResetter(valueBitOffset / 8, valueByteSize) },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },\n"
"      [VISITOR]: hasPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },\n"
"      [NORMALIZER]: { value: normalizeOptional },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function normalizeOptional(map, forJSON) {\n"
"    const value = this.$;\n"
"    return value?.[NORMALIZER]?.(map, forJSON) ?? value;\n"
"  }\n"
"\n"
"  function defineSlice(structure, env) {\n"
"    const {\n"
"      align,\n"
"      instance: {\n"
"        members: [ member ],\n"
"      },\n"
"      hasPointer,\n"
"    } = structure;\n"
"    const { get, set } = getDescriptor(member, env);\n"
"    const { byteSize: elementSize, structure: elementStructure } = member;\n"
"    const sentinel = getSentinel(structure, env);\n"
"    if (sentinel) {\n"
"      // zero-terminated strings aren't expected to be commonly used\n"
"      // so we're not putting this prop into the standard structure\n"
"      structure.sentinel = sentinel;\n"
"    }\n"
"    const hasStringProp = canBeString(member);\n"
"    const shapeDefiner = function(dv, length, fixed = false) {\n"
"      if (!dv) {\n"
"        dv = env.allocateMemory(length * elementSize, align, fixed);\n"
"      }\n"
"      this[MEMORY] = dv;\n"
"      this[LENGTH] = length;\n"
"    };\n"
"    const shapeChecker = function(arg, length) {\n"
"      if (length !== this[LENGTH]) {\n"
"        throwArrayLengthMismatch(structure, this, arg);\n"
"      }\n"
"    };\n"
"    // the initializer behave differently depending on whether it's called by the\n"
"    // constructor or by a member setter (i.e. after object's shape has been established)\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg, fixed = false) {\n"
"      if (arg instanceof constructor) {\n"
"        if (!this[MEMORY]) {\n"
"          shapeDefiner.call(this, null, arg.length, fixed);\n"
"        } else {\n"
"          shapeChecker.call(this, arg, arg.length);\n"
"        }\n"
"        this[COPIER](arg);\n"
"        if (hasPointer) {\n"
"          this[VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"        }\n"
"      } else if (typeof(arg) === 'string' && hasStringProp) {\n"
"        initializer.call(this, { string: arg }, fixed);\n"
"      } else if (arg?.[Symbol.iterator]) {\n"
"        let argLen = arg.length;\n"
"        if (typeof(argLen) !== 'number') {\n"
"          arg = [ ...arg ];\n"
"          argLen = arg.length;\n"
"        }\n"
"        if (!this[MEMORY]) {\n"
"          shapeDefiner.call(this, null, argLen, fixed);\n"
"        } else {\n"
"          shapeChecker.call(this, arg, argLen);\n"
"        }\n"
"        let i = 0;\n"
"        for (const value of arg) {\n"
"          sentinel?.validateValue(value, i, argLen);\n"
"          set.call(this, i++, value);\n"
"        }\n"
"      } else if (typeof(arg) === 'number') {\n"
"        if (!this[MEMORY] && arg >= 0 && isFinite(arg)) {\n"
"          shapeDefiner.call(this, null, arg);\n"
"        } else {\n"
"          throwInvalidArrayInitializer(structure, arg, !this[MEMORY]);\n"
"        }\n"
"      } else if (arg && typeof(arg) === 'object') {\n"
"        if (propApplier.call(this, arg) === 0) {\n"
"          throwInvalidArrayInitializer(structure, arg);\n"
"        }\n"
"      } else if (arg !== undefined) {\n"
"        throwInvalidArrayInitializer(structure, arg);\n"
"      }\n"
"    };\n"
"    const finalizer = createArrayProxy;\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer, shapeDefiner, finalizer }, env);\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\n"
"    const hasObject = member.type === MemberType.Object;\n"
"    const shapeHandlers = { shapeDefiner };\n"
"    const instanceDescriptors = {\n"
"      $: { get: getProxy, set: initializer },\n"
"      length: { get: getLength },\n"
"      dataView: getDataViewAccessors(structure, shapeHandlers),\n"
"      base64: getBase64Accessors(structure, shapeHandlers),\n"
"      string: hasStringProp && getStringAccessors(structure, shapeHandlers),\n"
"      typedArray: typedArray && getTypedArrayAccessors(structure, shapeHandlers),\n"
"      get: { value: get },\n"
"      set: { value: set },\n"
"      entries: { value: getArrayEntries },\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      [Symbol.iterator]: { value: getArrayIterator },\n"
"      [COPIER]: { value: getMemoryCopier(elementSize, true) },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator(structure) },\n"
"      [VISITOR]: hasPointer && { value: getPointerVisitor() },\n"
"      [NORMALIZER]: { value: normalizeArray },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      child: { get: () => elementStructure.constructor },\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: elementSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function getLength() {\n"
"    return this[LENGTH];\n"
"  }\n"
"\n"
"  function getSentinel(structure, env) {\n"
"    const {\n"
"      runtimeSafety = true,\n"
"    } = env;\n"
"    const {\n"
"      byteSize,\n"
"      instance: { members: [ member, sentinel ], template },\n"
"    } = structure;\n"
"    if (!sentinel) {\n"
"      return;\n"
"    }\n"
"    const { get: getSentinelValue } = getDescriptor(sentinel, env);\n"
"    const value = getSentinelValue.call(template, 0);\n"
"    const { get } = getDescriptor(member, env);\n"
"    const validateValue = (runtimeSafety) ? function(v, i, l) {\n"
"      if (v === value && i !== l - 1) {\n"
"        throwMisplacedSentinel(structure, v, i, l);\n"
"      } else if (v !== value && i === l - 1) {\n"
"        throwMissingSentinel(structure, value, i);\n"
"      }\n"
"    } : function(v, i, l) {\n"
"      if (v !== value && i === l - 1) {\n"
"        throwMissingSentinel(structure, value, l);\n"
"      }\n"
"    };\n"
"    const validateData = (runtimeSafety) ? function(source, len) {\n"
"      for (let i = 0; i < len; i++) {\n"
"        const v = get.call(source, i);\n"
"        if (v === value && i !== len - 1) {\n"
"          throwMisplacedSentinel(structure, value, i, len);\n"
"        } else if (v !== value && i === len - 1) {\n"
"          throwMissingSentinel(structure, value, len);\n"
"        }\n"
"      }\n"
"    } : function(source, len) {\n"
"      if (len * byteSize === source[MEMORY].byteLength) {\n"
"        const i = len - 1;\n"
"        const v = get.call(source, i);\n"
"        if (v !== value) {\n"
"          throwMissingSentinel(structure, value, len);\n"
"        }\n"
"      }\n"
"    };\n"
"    const bytes = template[MEMORY];\n"
"    return { value, bytes, validateValue, validateData };\n"
"  }\n"
"\n"
"  function defineUnionShape(structure, env) {\n"
"    const {\n"
"      type,\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members, template },\n"
"      hasPointer,\n"
"    } = structure;\n"
"    const { runtimeSafety } = env;\n"
"    const isTagged = (type === StructureType.TaggedUnion);\n"
"    const exclusion = (isTagged || (type === StructureType.BareUnion && runtimeSafety));\n"
"    const memberDescriptors = {};\n"
"    const memberInitializers = {};\n"
"    const memberValueGetters = {};\n"
"    const valueMembers = (exclusion) ? members.slice(0, -1) : members;\n"
"    const selectorMember = (exclusion) ? members[members.length - 1] : null;  \n"
"    const { get: getSelector, set: setSelector } = (exclusion) ? getDescriptor(selectorMember, env) : {};\n"
"    const getActiveField = (isTagged)\n"
"    ? function() {\n"
"        const item = getSelector.call(this);\n"
"        return item[NAME];\n"
"      }\n"
"    : function() {\n"
"        const index = getSelector.call(this);\n"
"        return valueMembers[index].name;\n"
"      };\n"
"    const setActiveField = (isTagged)\n"
"    ? function(name) {\n"
"        const { constructor } = selectorMember.structure;\n"
"        setSelector.call(this, constructor[name]);\n"
"      }\n"
"    : function(name) {\n"
"        const index = valueMembers.findIndex(m => m.name === name);\n"
"        setSelector.call(this, index);\n"
"      };\n"
"    for (const member of valueMembers) {\n"
"      const { name } = member;\n"
"      const { get: getValue, set: setValue } = getDescriptor(member, env);\n"
"      const get = (exclusion)\n"
"      ? function() {\n"
"          const currentName = getActiveField.call(this);\n"
"          if (name !== currentName) {\n"
"            if (isTagged) {\n"
"              // tagged union allows inactive member to be queried\n"
"              return null;\n"
"            } else {\n"
"              // whereas bare union does not, since the condition is not detectable \n"
"              // when runtime safety is off\n"
"              throwInactiveUnionProperty(structure, name, currentName);\n"
"            }\n"
"          }\n"
"          this[VISITOR]?.(resetPointer);\n"
"          return getValue.call(this);\n"
"        }\n"
"      : getValue;\n"
"      const set = (exclusion) \n"
"      ? function(value) {\n"
"          const currentName = getActiveField.call(this);\n"
"          if (name !== currentName) {\n"
"            throwInactiveUnionProperty(structure, name, currentName);\n"
"          }\n"
"          setValue.call(this, value);\n"
"        }\n"
"      : setValue;\n"
"      const init = (exclusion)\n"
"      ? function(value) {\n"
"          setActiveField.call(this, name);\n"
"          setValue.call(this, value);\n"
"          this[VISITOR]?.(resetPointer);\n"
"        }\n"
"      : setValue;\n"
"      memberDescriptors[name] = { get, set, configurable: true, enumerable: true };\n"
"      memberInitializers[name] = init;\n"
"      memberValueGetters[name] = getValue;\n"
"    }\n"
"    const hasDefaultMember = !!valueMembers.find(m => !m.isRequired);\n"
"    const memberKeys = Object.keys(memberDescriptors);\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        /* WASM-ONLY-END */\n"
"        this[COPIER](arg);\n"
"        if (hasPointer) {\n"
"          this[VISITOR](copyPointer, { vivificate: true, source: arg });\n"
"        }\n"
"      } else if (arg && typeof(arg) === 'object') {\n"
"        let found = 0;\n"
"        for (const key of memberKeys) {\n"
"          if (key in arg) {\n"
"            found++;\n"
"          }\n"
"        }\n"
"        if (found > 1) {\n"
"          throwMultipleUnionInitializers(structure);\n"
"        }\n"
"        if (propApplier.call(this, arg) === 0 && !hasDefaultMember) {\n"
"          throwMissingUnionInitializer(structure, arg, exclusion);\n"
"        }\n"
"      } else if (arg !== undefined) {\n"
"        throwInvalidInitializer(structure, 'object with a single property', arg);\n"
"      }\n"
"    };\n"
"    // non-tagged union as marked as not having pointers--if there're actually\n"
"    // members with pointers, we need to disable them\n"
"    const pointerMembers = members.filter(m => m.structure.hasPointer);\n"
"    const hasInaccessiblePointer = !hasPointer && (pointerMembers.length > 0);\n"
"    const modifier = (hasInaccessiblePointer) \n"
"    ? function() {\n"
"        // make pointer access throw\n"
"        this[VISITOR](disablePointer, { vivificate: true });\n"
"      }\n"
"    : undefined;\n"
"    const constructor = structure.constructor = createConstructor(structure, { modifier, initializer }, env);\n"
"    // for bare and extern union, all members will be included \n"
"    // tagged union meanwhile will only give the entity for the active field\n"
"    const memberNames = (isTagged) ? [ '' ] : valueMembers.map(m => m.name);\n"
"    const interatorCreator = function() {\n"
"      const self = this;\n"
"      let index = 0;\n"
"      if (isTagged) {\n"
"        memberNames[0] = getActiveField.call(this);\n"
"      }\n"
"      return {\n"
"        next() {\n"
"          let value, done;\n"
"          if (index < memberNames.length) {\n"
"            const name = memberNames[index];\n"
"            // get value of field with no check\n"
"            const get = memberValueGetters[name];\n"
"            value = [ name, get.call(self) ];\n"
"            done = false;\n"
"            index++;\n"
"          } else {\n"
"            done = true;\n"
"          }\n"
"          return { value, done };\n"
"        },\n"
"      };\n"
"    };\n"
"    const isChildActive = (isTagged)\n"
"    ? function(child) {\n"
"        const name = getActiveField.call(this);\n"
"        const active = memberValueGetters[name].call(this);\n"
"        return child === active;\n"
"      }\n"
"    : always;\n"
"    const hasAnyPointer = hasPointer || hasInaccessiblePointer;\n"
"    const hasObject = !!members.find(m => m.type === MemberType.Object);\n"
"    const instanceDescriptors = {\n"
"      $: { get: getSelf, set: initializer, configurable: true },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      delete: { value: getDestructor(env) },\n"
"      ...memberDescriptors,\n"
"      [Symbol.iterator]: { value: interatorCreator },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [TAG]: isTagged && { get: getSelector, configurable: true },\n"
"      [VIVIFICATOR]: hasObject && { value: getChildVivificator$1(structure) },\n"
"      [VISITOR]: hasAnyPointer && { value: getPointerVisitor$1(structure, { isChildActive }) },\n"
"      [NORMALIZER]: { value: normalizeStruct },\n"
"    };  \n"
"    const staticDescriptors = {\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"    // replace regular setters with ones that change the active field\n"
"    const setters = constructor.prototype[SETTERS];\n"
"    for (const [ name, init ] of Object.entries(memberInitializers)) {\n"
"      setters[name] = init;\n"
"    }\n"
"  }\n"
"\n"
"  function defineVector(structure, env) {\n"
"    const {\n"
"      length,\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members: [ member ] },\n"
"    } = structure;\n"
"    const { bitSize: elementBitSize, structure: elementStructure } = member;\n"
"    const elementDescriptors = {};\n"
"    for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {\n"
"      const { get, set } = getDescriptor({ ...member, bitOffset }, env);\n"
"      elementDescriptors[i] = { get, set, configurable: true };\n"
"    }\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        this[COPIER](arg);\n"
"      } else if (arg?.[Symbol.iterator]) {\n"
"        let argLen = arg.length;\n"
"        if (typeof(argLen) !== 'number') {\n"
"          arg = [ ...arg ];\n"
"          argLen = arg.length;\n"
"        }\n"
"        if (argLen !== length) {\n"
"          throwArrayLengthMismatch(structure, this, arg);\n"
"        }\n"
"        let i = 0;\n"
"        for (const value of arg) {\n"
"          this[SETTERS][i++].call(this, value);\n"
"        }\n"
"      } else if (arg && typeof(arg) === 'object') {\n"
"        if (propApplier.call(this, arg) === 0) {\n"
"          throwInvalidArrayInitializer(structure, arg);\n"
"        }\n"
"      } else if (arg !== undefined) {\n"
"        throwInvalidArrayInitializer(structure, arg);\n"
"      }\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\n"
"    const instanceDescriptors = {\n"
"      ...elementDescriptors,\n"
"      $: { get: getSelf, set: initializer },\n"
"      length: { value: length },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      typedArray: typedArray && getTypedArrayAccessors(structure),\n"
"      valueOf: { value: getValueOf },\n"
"      toJSON: { value: convertToJSON },\n"
"      entries: { value: createVectorEntries },\n"
"      delete: { value: getDestructor(structure) },\n"
"      [Symbol.iterator]: { value: getVectorIterator },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"      [NORMALIZER]: { value: normalizeVector },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      child: { get: () => elementStructure.constructor },\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"\n"
"  function normalizeVector(map, forJSON) {\n"
"    let array = map.get(this);\n"
"    if (!array) {\n"
"      array = [ ...this ];\n"
"      map.set(this, array);\n"
"    }\n"
"    return array;\n"
"  }\n"
"\n"
"  function getVectorIterator() {\n"
"    const self = this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = self[index];\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getVectorEntriesIterator() {\n"
"    const self = this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          value = [ index, self[index] ];\n"
"          done = false;\n"
"          index++;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function createVectorEntries() {\n"
"    return {\n"
"      [Symbol.iterator]: getVectorEntriesIterator.bind(this),\n"
"      length: this.length,\n"
"    };\n"
"  }\n"
"\n"
"  const StructureType = {\n"
"    Primitive: 0,\n"
"    Array: 1,\n"
"    Struct: 2,\n"
"    ArgStruct: 3,\n"
"    ExternUnion: 4,\n"
"    BareUnion: 5,\n"
"    TaggedUnion: 6,\n"
"    ErrorUnion: 7,\n"
"    ErrorSet: 8,\n"
"    Enumeration: 9,\n"
"    Optional: 10,\n"
"    Pointer: 11,\n"
"    Slice: 12,\n"
"    Vector: 13,\n"
"    Opaque: 14,\n"
"    Function: 15,\n"
"  };\n"
"\n"
"  const factories$1 = Array(Object.values(StructureType).length);\n"
"\n"
"  function usePrimitive() {\n"
"    factories$1[StructureType.Primitive] = definePrimitive;\n"
"  }\n"
"\n"
"  function useArray() {\n"
"    factories$1[StructureType.Array] = defineArray;\n"
"  }\n"
"\n"
"  function useStruct() {\n"
"    factories$1[StructureType.Struct] = defineStructShape;\n"
"  }\n"
"\n"
"  function useExternUnion() {\n"
"    factories$1[StructureType.ExternUnion] = defineUnionShape;\n"
"  }\n"
"\n"
"  function useBareUnion() {\n"
"    factories$1[StructureType.BareUnion] = defineUnionShape;\n"
"  }\n"
"\n"
"  function useTaggedUnion() {\n"
"    factories$1[StructureType.TaggedUnion] = defineUnionShape;\n"
"  }\n"
"\n"
"  function useErrorUnion() {\n"
"    factories$1[StructureType.ErrorUnion] = defineErrorUnion;\n"
"  }\n"
"\n"
"  function useErrorSet() {\n"
"    factories$1[StructureType.ErrorSet] = defineErrorSet;\n"
"  }\n"
"\n"
"  function useEnumeration() {\n"
"    factories$1[StructureType.Enumeration] = defineEnumerationShape;\n"
"  }\n"
"\n"
"  function useOptional() {\n"
"    factories$1[StructureType.Optional] = defineOptional;\n"
"  }\n"
"\n"
"  function usePointer() {\n"
"    factories$1[StructureType.Pointer] = definePointer;\n"
"  }\n"
"\n"
"  function useSlice() {\n"
"    factories$1[StructureType.Slice] = defineSlice;\n"
"  }\n"
"\n"
"  function useVector() {\n"
"    factories$1[StructureType.Vector] = defineVector;\n"
"  }\n"
"\n"
"  function useOpaque() {\n"
"    factories$1[StructureType.Opaque] = defineStructShape;\n"
"  }\n"
"\n"
"  function useArgStruct() {\n"
"    factories$1[StructureType.ArgStruct] = defineArgStruct;\n"
"  }\n"
"\n"
"  function getStructureName(structure, full = false) {\n"
"    let r = structure.name;\n"
"    if (!full) {\n"
"      r = r.replace(/{.*}/, '');\n"
"      if (!r.endsWith('.enum_literal)')) {\n"
"        r = r.replace(/[^\\.\\s]*?\\./g, '');\n"
"      }\n"
"    }\n"
"    return r;\n"
"  }\n"
"\n"
"  function getStructureFactory(type) {\n"
"    const f = factories$1[type];\n"
"    return f;\n"
"  }\n"
"\n"
"  function defineProperties(object, descriptors) {\n"
"    for (const [ name, descriptor ] of Object.entries(descriptors)) {\n"
"      if (descriptor) {\n"
"        const { \n"
"          set,\n"
"          get,\n"
"          value,\n"
"          enumerable,\n"
"          configurable = true,\n"
"          writable = true,\n"
"        } = descriptor;\n"
"        Object.defineProperty(object, name, (get) \n"
"          ? { get, set, configurable, enumerable } \n"
"          : { value, configurable, enumerable, writable }\n"
"        );\n"
"      }\n"
"    }\n"
"    for (const symbol of Object.getOwnPropertySymbols(descriptors)) {\n"
"      const descriptor = descriptors[symbol];\n"
"      if (descriptor) {\n"
"        Object.defineProperty(object, symbol, descriptor);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function attachDescriptors(constructor, instanceDescriptors, staticDescriptors) {\n"
"    // create prototype for read-only objects\n"
"    const prototypeRO = {};\n"
"    Object.setPrototypeOf(prototypeRO, constructor.prototype);\n"
"    const instanceDescriptorsRO = {};\n"
"    const setters = {};\n"
"    for (const [ name, descriptor ] of Object.entries(instanceDescriptors)) {\n"
"      if (descriptor?.set) {\n"
"        instanceDescriptorsRO[name] = { ...descriptor, set: throwReadOnly };\n"
"        // save the setters so we can initialize read-only objects\n"
"        if (name !== '$') {\n"
"          setters[name] = descriptor.set;\n"
"        }\n"
"      } else if (name === 'set') {\n"
"        instanceDescriptorsRO[name] = { value: throwReadOnly, configurable: true, writable: true };\n"
"      }\n"
"    }\n"
"    const vivificate = instanceDescriptors[VIVIFICATOR]?.value;\n"
"    const vivificateDescriptor = { \n"
"      // vivificate child objects as read-only too\n"
"      value: function(slot) { \n"
"        return vivificate.call(this, slot, false);\n"
"      }\n"
"    };\n"
"    defineProperties(constructor.prototype, { \n"
"      [CONST]: { value: false },\n"
"      [ALL_KEYS]: { value: Object.keys(setters) },\n"
"      [SETTERS]: { value: setters },\n"
"      ...instanceDescriptors,\n"
"    });\n"
"    defineProperties(constructor, {\n"
"      [CONST_PROTO]: { value: prototypeRO },\n"
"      ...staticDescriptors,\n"
"    }); \n"
"    defineProperties(prototypeRO, { \n"
"      constructor: { value: constructor, configurable: true },\n"
"      [CONST]: { value: true },\n"
"      [VIVIFICATOR]: vivificate && vivificateDescriptor,\n"
"      ...instanceDescriptorsRO,\n"
"    });\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function createConstructor(structure, handlers, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members, template },\n"
"    } = structure;\n"
"    const {\n"
"      modifier,\n"
"      initializer,\n"
"      finalizer,\n"
"      alternateCaster,\n"
"      shapeDefiner,\n"
"    } = handlers;\n"
"    const hasSlots = needSlots(members);\n"
"    // comptime fields are stored in the instance template's slots\n"
"    const comptimeFieldSlots = members.filter(m => m.type === MemberType.Comptime).map(m => m.slot);\n"
"    const cache = new ObjectCache();\n"
"    const constructor = function(arg, options = {}) {\n"
"      const {\n"
"        writable = true,\n"
"        fixed = false,\n"
"      } = options;\n"
"      const creating = this instanceof constructor;\n"
"      let self, dv;\n"
"      if (creating) {\n"
"        if (arguments.length === 0) {\n"
"          throwNoInitializer(structure);\n"
"        }\n"
"        self = (writable) ? this : Object.create(constructor[CONST_PROTO]);\n"
"        if (hasSlots) {\n"
"          self[SLOTS] = {};\n"
"        }\n"
"        if (shapeDefiner) {\n"
"          // provided by defineSlice(); the slice is different from other structures as it does not have \n"
"          // a fixed size; memory is allocated by the slice initializer based on the argument given\n"
"          initializer.call(self, arg, fixed);\n"
"          dv = self[MEMORY]; \n"
"        } else {\n"
"          self[MEMORY] = dv = env.allocateMemory(byteSize, align, fixed);\n"
"        }\n"
"      } else {\n"
"        if (alternateCaster) {\n"
"          self = alternateCaster.call(this, arg, options);\n"
"          if (self !== false) {\n"
"            return self;\n"
"          }\n"
"        }\n"
"        dv = requireDataView(structure, arg, env);\n"
"        if (self = cache.find(dv, writable)) {\n"
"          return self;\n"
"        }\n"
"        self = Object.create(writable ? constructor.prototype : constructor[CONST_PROTO]);\n"
"        if (hasSlots) {\n"
"          self[SLOTS] = {};\n"
"        }\n"
"        if (shapeDefiner) {\n"
"          setDataView.call(self, dv, structure, false, { shapeDefiner });\n"
"        } else {\n"
"          self[MEMORY] = dv;\n"
"        }\n"
"      }\n"
"      if (comptimeFieldSlots.length > 0 && template?.[SLOTS]) {\n"
"        for (const slot of comptimeFieldSlots) {\n"
"          self[SLOTS][slot] = template[SLOTS][slot];\n"
"        }\n"
"      }\n"
"      if (modifier) {\n"
"        modifier.call(self);\n"
"      }\n"
"      if (creating && !shapeDefiner) {\n"
"        initializer.call(self, arg);\n"
"      }\n"
"      if (finalizer) {\n"
"        self = finalizer.call(self);\n"
"      }\n"
"      return cache.save(dv, writable, self); \n"
"    };\n"
"    return constructor;\n"
"  }\n"
"\n"
"  function createPropertyApplier(structure) {\n"
"    const { instance: { template } } = structure;  \n"
"    return function(arg) {\n"
"      const argKeys = Object.keys(arg);\n"
"      const setters = this[SETTERS];\n"
"      const allKeys = this[ALL_KEYS];\n"
"      // don't accept unknown props\n"
"      for (const key of argKeys) {\n"
"        if (!(key in setters)) {\n"
"          throwNoProperty(structure, key);\n"
"        }\n"
"      }\n"
"      // checking each name so that we would see inenumerable initializers as well\n"
"      let normalCount = 0;\n"
"      let normalFound = 0;\n"
"      let normalMissing = 0;\n"
"      let specialFound = 0;\n"
"      for (const key of allKeys) {\n"
"        const set = setters[key];\n"
"        if (set.special) {\n"
"          if (key in arg) {\n"
"            specialFound++;\n"
"          }\n"
"        } else {\n"
"          normalCount++;\n"
"          if (key in arg) {\n"
"            normalFound++;\n"
"          } else if (set.required) {\n"
"            normalMissing++;\n"
"          }\n"
"        }\n"
"      }\n"
"      if (normalMissing !== 0 && specialFound === 0) {\n"
"        const missing = allKeys.filter(k => setters[k].required && !(k in arg));\n"
"        throwMissingInitializers(structure, missing);\n"
"      }\n"
"      if (specialFound + normalFound > argKeys.length) {\n"
"        // some props aren't enumerable\n"
"        for (const key of allKeys) {\n"
"          if (key in arg) {\n"
"            if (!argKeys.includes(key)) {\n"
"              argKeys.push(key);\n"
"            }\n"
"          }\n"
"        }\n"
"      }\n"
"      // apply default values unless all properties are initialized\n"
"      if (normalFound < normalCount && specialFound === 0) {\n"
"        if (template) {\n"
"          if (template[MEMORY]) {\n"
"            this[COPIER](template);\n"
"          }\n"
"          this[VISITOR]?.(copyPointer, { vivificate: true, source: template });\n"
"        }\n"
"      }\n"
"      for (const key of argKeys) {\n"
"        const set = setters[key];\n"
"        set.call(this, arg[key]);\n"
"      }\n"
"      return argKeys.length;\n"
"    };\n"
"  }\n"
"\n"
"  function needSlots(members) {\n"
"    for (const { type } of members) {\n"
"      switch (type) {\n"
"        case MemberType.Object:\n"
"        case MemberType.Comptime:\n"
"        case MemberType.Type:\n"
"        case MemberType.Literal:\n"
"          return true;\n"
"      }\n"
"    }\n"
"    return false;\n"
"  }\n"
"\n"
"  function getSelf() {\n"
"    return this;\n"
"  }\n"
"\n"
"  function findAllObjects(structures, SLOTS) {\n"
"    const list = [];\n"
"    const found = new Map();\n"
"    const find = (object) => {\n"
"      if (!object || found.get(object)) {\n"
"        return;\n"
"      }\n"
"      found.set(object, true);\n"
"      list.push(object);\n"
"      if (object[SLOTS]) {\n"
"        for (const child of Object.values(object[SLOTS])) {\n"
"          find(child);         \n"
"        }\n"
"      }\n"
"    };\n"
"    for (const structure of structures) {\n"
"      find(structure.instance.template);\n"
"      find(structure.static.template);\n"
"    }\n"
"    return list;\n"
"  }\n"
"\n"
"  function useAllStructureTypes() {\n"
"    usePrimitive();\n"
"    useArray();\n"
"    useStruct();\n"
"    useArgStruct();\n"
"    useExternUnion();\n"
"    useBareUnion();\n"
"    useTaggedUnion();\n"
"    useErrorUnion();\n"
"    useErrorSet();\n"
"    useEnumeration();\n"
"    useOptional();\n"
"    usePointer();\n"
"    useSlice();\n"
"    useVector();\n"
"    useOpaque();\n"
"  }\n"
"\n"
"  class ObjectCache {\n"
"    [0] = null;\n"
"    [1] = null;\n"
"\n"
"    find(dv, writable) {\n"
"      const key = (writable) ? 0 : 1;\n"
"      const map = this[key];\n"
"      return map?.get(dv);\n"
"    }\n"
"\n"
"    save(dv, writable, object) {\n"
"      const key = (writable) ? 0 : 1;\n"
"      let map = this[key];    \n"
"      if (!map) {\n"
"        map = this[key] = new WeakMap();\n"
"      }\n"
"      map.set(dv, object);\n"
"      return object;\n"
"    }\n"
"  }\n"
"\n"
"  function definePrimitive(structure, env) {\n"
"    const {\n"
"      byteSize,\n"
"      align,\n"
"      instance: { members: [ member ] },\n"
"    } = structure;\n"
"    const { get, set } = getDescriptor(member, env);\n"
"    const propApplier = createPropertyApplier(structure);\n"
"    const initializer = function(arg) {\n"
"      if (arg instanceof constructor) {\n"
"        this[COPIER](arg);\n"
"      } else {\n"
"        if (arg && typeof(arg) === 'object') {\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            const type = getPrimitiveType(member);\n"
"            throwInvalidInitializer(structure, type, arg);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          set.call(this, arg);\n"
"        }\n"
"      }\n"
"    };\n"
"    const constructor = structure.constructor = createConstructor(structure, { initializer }, env);\n"
"    const typedArray = structure.typedArray = getTypedArrayClass(member);\n"
"    const instanceDescriptors = {\n"
"      $: { get, set },\n"
"      dataView: getDataViewAccessors(structure),\n"
"      base64: getBase64Accessors(structure),\n"
"      typedArray: typedArray && getTypedArrayAccessors(structure),\n"
"      valueOf: { value: get },\n"
"      toJSON: { value: get },\n"
"      delete: { value: getDestructor(env) },\n"
"      [Symbol.toPrimitive]: { value: get },\n"
"      [COPIER]: { value: getMemoryCopier(byteSize) },\n"
"    };\n"
"    const staticDescriptors = {\n"
"      [COMPAT]: { value: getCompatibleTags(structure) },\n"
"      [ALIGN]: { value: align },\n"
"      [SIZE]: { value: byteSize },\n"
"    };\n"
"    return attachDescriptors(constructor, instanceDescriptors, staticDescriptors);\n"
"  }\n"
"  function getIntRange(member) {\n"
"    const { type, bitSize } = member;\n"
"    const signed = (type === MemberType.Int);\n"
"    let magBits = (signed) ? bitSize - 1 : bitSize;\n"
"    if (bitSize <= 32) {\n"
"      const max = 2 ** magBits - 1;\n"
"      const min = (signed) ? -(2 ** magBits) : 0;\n"
"      return { min, max };\n"
"    } else {\n"
"      magBits = BigInt(magBits);\n"
"      const max = 2n ** magBits - 1n;\n"
"      const min = (signed) ? -(2n ** magBits) : 0n;\n"
"      return { min, max };\n"
"    }\n"
"  }\n"
"\n"
"  function getPrimitiveClass({ type, bitSize }) {\n"
"    if (type === MemberType.Int || type === MemberType.Uint) {\n"
"      if (bitSize <= 32) {\n"
"        return Number;\n"
"      } else {\n"
"        return BigInt;\n"
"      }\n"
"    } else if (type === MemberType.Float) {\n"
"      return Number;\n"
"    } else if (type === MemberType.Bool) {\n"
"      return Boolean;\n"
"    }\n"
"  }\n"
"\n"
"  function getPrimitiveType(member) {\n"
"    const Primitive = getPrimitiveClass(member);\n"
"    if (Primitive) {\n"
"      return typeof(Primitive(0));\n"
"    }\n"
"  }\n"
"\n"
"  function throwNoInitializer(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);\n"
"  }\n"
"\n"
"  function throwBufferSizeMismatch(structure, dv, target = null) {\n"
"    const { type, byteSize } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const actual = dv.byteLength;\n"
"    const s = (byteSize > 1) ? 's' : '';\n"
"    if (type === StructureType.Slice && !target) {\n"
"      throw new TypeError(`${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`);\n"
"    } else {\n"
"      const total = (type === StructureType.Slice) ? target.length * byteSize : byteSize;\n"
"      throw new TypeError(`${name} has ${total} byte${s}, received ${actual}`);\n"
"    }\n"
"  }\n"
"\n"
"  function throwBufferExpected(structure) {\n"
"    const { type, byteSize, typedArray } = structure;\n"
"    const s = (byteSize > 1) ? 's' : '';\n"
"    const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle);\n"
"    if (typedArray) {\n"
"      acceptable.push(addArticle(typedArray.name));\n"
"    }\n"
"    if (type === StructureType.Slice) {\n"
"      throw new TypeError(`Expecting ${formatList(acceptable)} that can accommodate items ${byteSize} byte${s} in length`);\n"
"    } else {\n"
"      throw new TypeError(`Expecting ${formatList(acceptable)} that is ${byteSize} byte${s} in length`);\n"
"    }\n"
"  }\n"
"\n"
"  function throwEnumExpected(structure, arg) {\n"
"    const name = getStructureName(structure);\n"
"    if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {\n"
"      throw new TypeError(`Value given does not correspond to an item of enum ${name}: ${arg}`);\n"
"    } else {\n"
"      throw new TypeError(`Enum item of the type ${name} expected, received ${arg}`);\n"
"    }\n"
"  }\n"
"\n"
"  function throwErrorExpected(structure, arg) {\n"
"    const name = getStructureName(structure);\n"
"    const type = typeof(arg);\n"
"    if (type === 'string' || type === 'number') {\n"
"      throw new TypeError(`Error ${type} does not corresponds to any error in error set ${name}: ${arg}`);\n"
"    } else {\n"
"      throw new TypeError(`Error of the type ${name} expected, received ${arg}`);\n"
"    }\n"
"  }\n"
"\n"
"  function throwNotInErrorSet(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Error given is not a part of error set ${name}`);\n"
"  }\n"
"\n"
"  function throwMultipleUnionInitializers(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Only one property of ${name} can be given a value`);\n"
"  }\n"
"\n"
"  function throwInactiveUnionProperty(structure, name, currentName) {\n"
"    throw new TypeError(`Accessing property ${name} when ${currentName} is active`);\n"
"  }\n"
"\n"
"  function throwMissingUnionInitializer(structure, arg, exclusion) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);\n"
"    throw new TypeError(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);\n"
"  }\n"
"\n"
"  function throwInvalidInitializer(structure, expected, arg) {\n"
"    const name = getStructureName(structure);\n"
"    const acceptable = [];\n"
"    if (Array.isArray(expected)) {\n"
"      for (const type of expected) {\n"
"        acceptable.push(addArticle(type));\n"
"      }\n"
"    } else {\n"
"      acceptable.push(addArticle(expected));\n"
"    }\n"
"    const received = getDescription(arg);\n"
"    throw new TypeError(`${name} expects ${formatList(acceptable)} as argument, received ${received}`);\n"
"  }\n"
"\n"
"  function throwInvalidArrayInitializer(structure, arg, shapeless = false) {\n"
"    const { instance: { members: [ member ] }, type, typedArray } = structure;\n"
"    const acceptable = [];\n"
"    const primitive = getPrimitiveType(member);\n"
"    if (primitive) {\n"
"      acceptable.push(`array of ${primitive}s`);\n"
"    } else if (member.type === MemberType.EnumerationItem) {\n"
"      acceptable.push(`array of enum items`);\n"
"    } else {\n"
"      acceptable.push(`array of objects`);\n"
"    }\n"
"    if (typedArray) {\n"
"      acceptable.push(typedArray.name);\n"
"    }\n"
"    if (type === StructureType.Slice && shapeless) {\n"
"      acceptable.push(`length`);\n"
"    }\n"
"    throwInvalidInitializer(structure, acceptable.join(' or '), arg);\n"
"  }\n"
"\n"
"  function throwArrayLengthMismatch(structure, target, arg) {\n"
"    const { length, instance: { members: [ member ] } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const { structure: { constructor: elementConstructor} } = member;\n"
"    const { length: argLength, constructor: argConstructor } = arg;\n"
"    // get length from object whech it's a slice\n"
"    const actualLength = target?.length ?? length;\n"
"    const s = (actualLength > 1) ? 's' : '';\n"
"    let received;\n"
"    if (argConstructor === elementConstructor) {\n"
"      received = `only a single one`;\n"
"    } else if (argConstructor.child === elementConstructor) {\n"
"      received = `a slice/array that has ${argLength}`;\n"
"    } else {\n"
"      received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;\n"
"    }\n"
"    throw new TypeError(`${name} has ${actualLength} element${s}, received ${received}`);\n"
"  }\n"
"\n"
"  function throwMissingInitializers(structure, missing) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`Missing initializers for ${name}: ${missing.join(', ')}`);\n"
"  }\n"
"\n"
"  function throwNoProperty(structure, propName) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} does not have a property with that name: ${propName}`);\n"
"  }\n"
"\n"
"  function throwArgumentCountMismatch(structure, actual) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    const argCount = members.length - 1;\n"
"    const s = (argCount > 1) ? 's' : '';\n"
"    throw new Error(`${name} expects ${argCount} argument${s}, received ${actual}`);\n"
"  }\n"
"\n"
"  function rethrowArgumentError(structure, index, err) {\n"
"    const { instance: { members } } = structure;\n"
"    const name = getStructureName(structure);\n"
"    // Zig currently does not provide the argument name\n"
"    const argName = `args[${index}]`;\n"
"    const argCount = members.length - 1;\n"
"    const prefix = (index !== 0) ? '..., ' : '';\n"
"    const suffix = (index !== argCount - 1) ? ', ...' : '';\n"
"    const argLabel = prefix + argName + suffix;\n"
"    const newError = new err.constructor(`${name}(${argLabel}): ${err.message}`);\n"
"    newError.stack = err.stack;\n"
"    throw newError;\n"
"  }\n"
"\n"
"  function throwNoCastingToPointer(structure) {\n"
"    throw new TypeError(`Non-slice pointers can only be created with the help of the new operator`);\n"
"  }\n"
"\n"
"  function throwConstantConstraint(structure, pointer) {\n"
"    const name1 = getStructureName(structure);\n"
"    const { constructor: { name: name2 } } = pointer;\n"
"    throw new TypeError(`Conversion of ${name2} to ${name1} requires an explicit cast`);\n"
"  }\n"
"\n"
"  function throwMisplacedSentinel(structure, value, index, length) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);\n"
"  }\n"
"\n"
"  function throwMissingSentinel(structure, value, length) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} expects the sentinel value ${value} at ${length - 1}`);\n"
"  }\n"
"\n"
"  function throwAlignmentConflict(align1, align2) {\n"
"    throw new TypeError(`Cannot simultaneously align memory to ${align2}-byte and ${align1}-byte boundary`);\n"
"  }\n"
"\n"
"  function throwTypeMismatch(expected, arg) {\n"
"    const received = getDescription(arg);\n"
"    throw new TypeError(`Expected ${addArticle(expected)}, received ${received}`)\n"
"  }\n"
"\n"
"  function throwInaccessiblePointer() {\n"
"    throw new TypeError(`Pointers within an untagged union are not accessible`);\n"
"  }\n"
"\n"
"  function throwNullPointer() {\n"
"    throw new TypeError(`Null pointer`);\n"
"  }\n"
"\n"
"  function throwInvalidPointerTarget(structure, arg) {\n"
"    const name = getStructureName(structure);\n"
"    let target;\n"
"    if (arg != null) {\n"
"      const type = typeof(arg);\n"
"      const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;\n"
"      const a = article(noun);\n"
"      target = `${a} ${noun}`;\n"
"    } else {\n"
"      target = arg + '';\n"
"    }\n"
"    throw new TypeError(`${name} cannot point to ${target}`)\n"
"  }\n"
"\n"
"  function throwFixedMemoryTargetRequired(structure, arg) {\n"
"    throw new TypeError(`Pointers in fixed memory cannot point to garbage-collected object`);\n"
"  }\n"
"\n"
"\n"
"  function throwOverflow(member, value) {\n"
"    const typeName = getTypeName(member);\n"
"    throw new TypeError(`${typeName} cannot represent the value given: ${value}`);\n"
"  }\n"
"\n"
"  function throwOutOfBound(member, index) {\n"
"    const { name } = member;\n"
"    throw new RangeError(`Index exceeds the size of ${name ?? 'array'}: ${index}`);\n"
"  }\n"
"\n"
"  function rethrowRangeError(member, index, err) {\n"
"    if (err instanceof RangeError) {\n"
"      throwOutOfBound(member, index);\n"
"    } else {\n"
"      throw err;\n"
"    }\n"
"  }\n"
"\n"
"  function throwNotNull(member) {\n"
"    const { name } = member;\n"
"    throw new TypeError(`Property ${name} can only be null`);\n"
"  }\n"
"\n"
"  function throwNotUndefined(member) {\n"
"    const { name } = member;\n"
"    throw new RangeError(`Property ${name} can only be undefined`);\n"
"  }\n"
"\n"
"  function throwReadOnly() {\n"
"    throw new TypeError(`Unable to modify read-only object`);\n"
"  }\n"
"\n"
"  function throwReadOnlyTarget(structure) {\n"
"    const name = getStructureName(structure);\n"
"    throw new TypeError(`${name} cannot point to a read-only object`);\n"
"  }\n"
"\n"
"  function throwZigError(name) {\n"
"    throw new Error(decamelizeErrorName(name));\n"
"  }\n"
"\n"
"  function warnImplicitArrayCreation(structure, arg) {\n"
"    const created = addArticle(structure.typedArray.name);\n"
"    const source = addArticle(arg.constructor.name);\n"
"    console.warn(`Implicitly creating ${created} from ${source}`);\n"
"  }\n"
"\n"
"  function decamelizeErrorName(name) {\n"
"    // use a try block in case Unicode regex fails\n"
"    try {\n"
"      const lc = name.replace(/(\\p{Uppercase}+)(\\p{Lowercase}*)/gu, (m0, m1, m2) => {\n"
"        if (m1.length === 1) {\n"
"          return ` ${m1.toLocaleLowerCase()}${m2}`;\n"
"        } else {\n"
"          if (m2) {\n"
"            const acronym = m1.substring(0, m1.length - 1);\n"
"            const letter = m1.charAt(m1.length - 1).toLocaleLowerCase();\n"
"            return ` ${acronym} ${letter}${m2}`;\n"
"          } else {\n"
"            return ` ${m1}`;\n"
"          }\n"
"        }\n"
"      }).trimStart();\n"
"      return lc.charAt(0).toLocaleUpperCase() + lc.substring(1);\n"
"      /* c8 ignore next 3 */\n"
"    } catch (err) {\n"
"      return name;\n"
"    }\n"
"  }\n"
"\n"
"  function getDescription(arg) {\n"
"    const type = typeof(arg);\n"
"    let s;\n"
"    if (type === 'object') {\n"
"      s = (arg) ? Object.prototype.toString.call(arg) : 'null';\n"
"    } else {\n"
"      s = type;\n"
"    }\n"
"    return addArticle(s);\n"
"  }\n"
"\n"
"  function addArticle(noun) {\n"
"    return `${article(noun)} ${noun}`;\n"
"  }\n"
"\n"
"  function article(noun) {\n"
"    return /^\\W*[aeiou]/i.test(noun) ? 'an' : 'a';\n"
"  }\n"
"\n"
"  function formatList(list, conj = 'or') {\n"
"    const sep = ` ${conj} `;\n"
"    if (list.length > 2) {\n"
"      return list.slice(0, -1).join(', ') + sep + list[list.length - 1];\n"
"    } else {\n"
"      return list.join(sep);\n"
"    }\n"
"  }\n"
"\n"
"  function getDataViewBoolAccessor(access, member) {\n"
"    return cacheMethod(access, member, () => {\n"
"      const { byteSize } = member;\n"
"      if (byteSize === undefined) {\n"
"        return undefined;\n"
"      }\n"
"      const typeName = getTypeName({ type: MemberType.Int, bitSize: byteSize * 8 });\n"
"      if (access === 'get') {\n"
"        const get = DataView.prototype[`get${typeName}`];\n"
"        return function(offset, littleEndian) {\n"
"          return !!get.call(this, offset, littleEndian);\n"
"        };\n"
"      } else {\n"
"        const set = DataView.prototype[`set${typeName}`];\n"
"        const T = (byteSize > 4) ? 1n : 1;\n"
"        const F = (byteSize > 4) ? 0n : 0;\n"
"        return function(offset, value, littleEndian) {\n"
"          set.call(this, offset, value ? T : F, littleEndian);\n"
"        };\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewBoolAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, () => {\n"
"      if (isByteAligned(member)) {\n"
"        return getDataViewBoolAccessor(access, member);\n"
"      }\n"
"      const { bitOffset } = member;\n"
"      const bitPos = bitOffset & 0x07;\n"
"      const mask = 1 << bitPos;\n"
"      const get = DataView.prototype.getInt8;\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = get.call(this, offset);\n"
"          return !!(n & mask);\n"
"        };\n"
"      } else {\n"
"        const set = DataView.prototype.setInt8;\n"
"        return function(offset, value) {\n"
"          const n = get.call(this, offset);\n"
"          const b = (value) ? n | mask : n & ~mask;\n"
"          set.call(this, offset, b);\n"
"        };\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewBuiltInAccessor(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      return DataView.prototype[name];\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewIntAccessor(access, member) {\n"
"    return getDataViewBuiltInAccessor(access, member);\n"
"  }\n"
"\n"
"  function getDataViewIntAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      if (DataView.prototype[name]) {\n"
"        return DataView.prototype[name];\n"
"      }\n"
"      if (isByteAligned(member)) {\n"
"        return defineAlignedIntAccessor(access, member)\n"
"      } else {\n"
"        return defineUnalignedIntAccessor(access, member);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewUintAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      if (DataView.prototype[name]) {\n"
"        return DataView.prototype[name];\n"
"      }\n"
"      if (isByteAligned(member)) {\n"
"        return defineAlignedUintAccessor(access, member)\n"
"      } else {\n"
"        return defineUnalignedUintAccessor(access, member);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataViewFloatAccessorEx(access, member) {\n"
"    return cacheMethod(access, member, (name) => {\n"
"      if (DataView.prototype[name]) {\n"
"        return DataView.prototype[name];\n"
"      }\n"
"      if (isByteAligned(member)) {\n"
"        return defineAlignedFloatAccessor(access, member)\n"
"      } else {\n"
"        return defineUnalignedFloatAccessor(access, member);\n"
"      }\n"
"    });\n"
"  }\n"
"\n"
"  function getDataView(structure, arg, env) {\n"
"    const { type, byteSize, typedArray } = structure;\n"
"    let dv;\n"
"    // not using instanceof just in case we're getting objects created in other contexts\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    if (tag === 'DataView') {\n"
"      dv = arg;\n"
"    } else if (tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {\n"
"      dv = env.obtainView(arg, 0, arg.byteLength);\n"
"    } else if (typedArray && tag === typedArray.name || (tag === 'Uint8ClampedArray' && typedArray === Uint8Array)) {\n"
"      dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);\n"
"    } else if (tag === 'Uint8Array' && typeof(Buffer) === 'function' && arg instanceof Buffer) {\n"
"      dv = env.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);\n"
"    } else {\n"
"      const memory = arg?.[MEMORY];\n"
"      if (memory) {\n"
"        const { constructor, instance: { members: [ member ] } } = structure;\n"
"        if (arg instanceof constructor) {\n"
"          return memory;\n"
"        } else if (type === StructureType.Array || type === StructureType.Slice || type === StructureType.Vector) {\n"
"          const { byteSize: elementSize, structure: { constructor: Child } } = member;\n"
"          const number = findElements(arg, Child);\n"
"          if (number !== undefined) {\n"
"            if (type === StructureType.Slice || number * elementSize === byteSize) {\n"
"              return memory;\n"
"            } else {\n"
"              throwArrayLengthMismatch(structure, null, arg);\n"
"            }\n"
"          } \n"
"        }\n"
"      }\n"
"    }\n"
"    if (dv) {\n"
"      checkDataViewSize(dv, structure);\n"
"    }\n"
"    return dv;\n"
"  }\n"
"\n"
"  function checkDataView(dv) {\n"
"    if (dv?.[Symbol.toStringTag] !== 'DataView') {\n"
"      throwTypeMismatch('a DataView', dv);\n"
"    }\n"
"    return dv;\n"
"  }\n"
"\n"
"  function checkDataViewSize(dv, structure) {\n"
"    const { byteSize, type } = structure;\n"
"    const multiple = type === StructureType.Slice;\n"
"    if (multiple ? dv.byteLength % byteSize !== 0 : dv.byteLength !== byteSize) {\n"
"      throwBufferSizeMismatch(structure, dv);\n"
"    }\n"
"  }\n"
"\n"
"  function setDataView(dv, structure, copy, handlers) {\n"
"    const { byteSize, type, sentinel } = structure;\n"
"    const multiple = type === StructureType.Slice;\n"
"    if (!this[MEMORY]) {\n"
"      const { shapeDefiner } = handlers;\n"
"      checkDataViewSize(dv, structure);\n"
"      const len = dv.byteLength / byteSize;\n"
"      const source = { [MEMORY]: dv };\n"
"      sentinel?.validateData(source, len);\n"
"      shapeDefiner.call(this, copy ? null : dv, len);\n"
"      if (copy) {\n"
"        this[COPIER](source);\n"
"      }  \n"
"    } else {\n"
"      const byteLength = multiple ? byteSize * this.length : byteSize;\n"
"      if (dv.byteLength !== byteLength) {\n"
"        throwBufferSizeMismatch(structure, dv, this);\n"
"      }\n"
"      const source = { [MEMORY]: dv };\n"
"      sentinel?.validateData(source, this.length);\n"
"      this[COPIER](source); \n"
"    }\n"
"  }\n"
"\n"
"  function findElements(arg, Child) {\n"
"    // casting to a array/slice\n"
"    const { constructor: Arg } = arg;\n"
"    if (Arg === Child) {\n"
"      // matching object\n"
"      return 1;\n"
"    } else if (Arg.child === Child) {\n"
"      // matching slice/array\n"
"      return arg.length;\n"
"    }\n"
"  }\n"
"\n"
"  function requireDataView(structure, arg, env) {\n"
"    const dv = getDataView(structure, arg, env);\n"
"    if (!dv) {\n"
"      throwBufferExpected(structure);\n"
"    }\n"
"    return dv;\n"
"  }\n"
"\n"
"  function getTypedArrayClass(member) {\n"
"    const { type: memberType, byteSize } = member;\n"
"    if (memberType === MemberType.Int) {\n"
"      switch (byteSize) {\n"
"        case 1: return Int8Array;\n"
"        case 2: return Int16Array;\n"
"        case 4: return Int32Array;\n"
"        case 8: return BigInt64Array;\n"
"      }\n"
"    } else if (memberType === MemberType.Uint) {\n"
"      switch (byteSize) {\n"
"        case 1: return Uint8Array;\n"
"        case 2: return Uint16Array;\n"
"        case 4: return Uint32Array;\n"
"        case 8: return BigUint64Array;\n"
"      }\n"
"    } else if (memberType === MemberType.Float) {\n"
"      switch (byteSize) {\n"
"        case 4: return Float32Array;\n"
"        case 8: return Float64Array;\n"
"      }\n"
"    }\n"
"    return null;\n"
"  }\n"
"\n"
"  function isTypedArray(arg, TypedArray) {\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    return (!!TypedArray && tag === TypedArray.name);\n"
"  }\n"
"\n"
"  function isCompatible(arg, constructor) {\n"
"    const tags = constructor[COMPAT];\n"
"    if (tags) {\n"
"      const tag = arg?.[Symbol.toStringTag];\n"
"      if (tags.includes(tag)) {\n"
"        return true;\n"
"      }\n"
"    }\n"
"    if (constructor.child) {\n"
"      if (findElements(arg, constructor.child) !== undefined) {\n"
"        return true;\n"
"      }\n"
"    }\n"
"    return false;\n"
"  }\n"
"\n"
"  function getCompatibleTags(structure) {\n"
"    const { typedArray } = structure;\n"
"    const tags = [];\n"
"    if (typedArray) {\n"
"      tags.push(typedArray.name);\n"
"      tags.push('DataView');\n"
"      if (typedArray === Uint8Array || typedArray === Int8Array) {\n"
"        tags.push('Uint8ClampedArray');\n"
"        tags.push('ArrayBuffer');\n"
"        tags.push('SharedArrayBuffer');\n"
"      }\n"
"    }\n"
"    return tags;\n"
"  }\n"
"\n"
"  function isBuffer(arg, typedArray) {\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    if (tag === 'DataView' || tag === 'ArrayBuffer' || tag === 'SharedArrayBuffer') {\n"
"      return true;\n"
"    } else if (typedArray && tag === typedArray.name) {\n"
"      return true;\n"
"    } else {\n"
"      return false;\n"
"    }\n"
"  }\n"
"\n"
"  function getTypeName(member) {\n"
"    const { type, bitSize, byteSize, structure } = member;\n"
"    if (structure?.name === 'usize') {\n"
"      return 'USize';\n"
"    } else if (structure?.name === 'isize') {\n"
"      return 'ISize';\n"
"    } else if (type === MemberType.Int) {\n"
"      return `${bitSize <= 32 ? '' : 'Big' }Int${bitSize}`;\n"
"    } else if (type === MemberType.Uint) {\n"
"      return `${bitSize <= 32 ? '' : 'Big' }Uint${bitSize}`;\n"
"    } else if (type === MemberType.Float) {\n"
"      return `Float${bitSize}`;\n"
"    } else if (type === MemberType.Bool) {\n"
"      const boolSize = (byteSize !== undefined) ? byteSize * 8 : 1;\n"
"      return `Bool${boolSize}`;\n"
"    } else if (type === MemberType.Void) {\n"
"      return `Null`;\n"
"    }\n"
"  }\n"
"\n"
"  function getBigIntAccessors(bitSize) {\n"
"    const getWord = DataView.prototype.getBigUint64;\n"
"    const setWord = DataView.prototype.setBigUint64;\n"
"    const wordCount = Math.ceil(bitSize / 64);\n"
"    return {\n"
"      get: function(offset, littleEndian) {\n"
"        let n = 0n;\n"
"        if (littleEndian) {\n"
"          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\n"
"            const w = getWord.call(this, j, littleEndian);\n"
"            n = (n << 64n) | w;\n"
"          }\n"
"        } else {\n"
"          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\n"
"            const w = getWord.call(this, j, littleEndian);\n"
"            n = (n << 64n) | w;\n"
"          }\n"
"        }\n"
"        return n;\n"
"      },\n"
"      set: function(offset, value, littleEndian) {\n"
"        let n = value;\n"
"        const mask = 0xFFFFFFFFFFFFFFFFn;\n"
"        if (littleEndian) {\n"
"          for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\n"
"            const w = n & mask;\n"
"            setWord.call(this, j, w, littleEndian);\n"
"            n >>= 64n;\n"
"          }\n"
"        } else {\n"
"          n <<= BigInt(wordCount * 64 - bitSize);\n"
"          for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\n"
"            const w = n & mask;\n"
"            setWord.call(this, j, w, littleEndian);\n"
"            n >>= 64n;\n"
"          }\n"
"        }\n"
"        return n;\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function defineAlignedIntAccessor(access, member) {\n"
"    const { bitSize, byteSize } = member;\n"
"    if (bitSize < 64) {\n"
"      // actual number of bits needed when stored aligned\n"
"      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });\n"
"      const get = DataView.prototype[`get${typeName}`];\n"
"      const set = DataView.prototype[`set${typeName}`];\n"
"      const signMask = (bitSize <= 32) ? 2 ** (bitSize - 1) : 2n ** BigInt(bitSize - 1);\n"
"      const valueMask = (bitSize <= 32) ? signMask - 1 : signMask - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return (n & valueMask) - (n & signMask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      // larger than 64 bits\n"
"      const { get, set } = getBigIntAccessors(bitSize);\n"
"      const signMask = 2n ** BigInt(bitSize - 1);\n"
"      const valueMask = signMask - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return (n & valueMask) - (n & signMask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineAlignedUintAccessor(access, member) {\n"
"    const { bitSize, byteSize } = member;\n"
"    if (bitSize < 64) {\n"
"      // actual number of bits needed when stored aligned\n"
"      const typeName = getTypeName({ ...member, bitSize: byteSize * 8 });\n"
"      const get = DataView.prototype[`get${typeName}`];\n"
"      const set = DataView.prototype[`set${typeName}`];\n"
"      const valueMask = (bitSize <= 32) ? (2 ** bitSize) - 1 : (2n ** BigInt(bitSize)) - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return n & valueMask;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      // larger than 64 bits\n"
"      const { get, set } = getBigIntAccessors(bitSize);\n"
"      const valueMask = (2n ** BigInt(bitSize)) - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          return n & valueMask;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = value & valueMask;\n"
"          set.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineUnalignedIntAccessor(access, member) {\n"
"    const { bitSize, bitOffset } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const set = DataView.prototype.setUint8;\n"
"      const get = DataView.prototype.getUint8;\n"
"      // sub-8-bit numbers have real use cases\n"
"      const signMask = 2 ** (bitSize - 1);\n"
"      const valueMask = signMask - 1;\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = get.call(this, offset);\n"
"          const s = n >>> bitPos;\n"
"          return (s & valueMask) - (s & signMask);\n"
"        };\n"
"      } else {\n"
"        const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);\n"
"        return function(offset, value) {\n"
"          let b = get.call(this, offset);\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          b = (b & outsideMask) | (n << bitPos);\n"
"          set.call(this, offset, b);\n"
"        };\n"
"      }\n"
"    }\n"
"    return defineUnalignedAccessorUsing(access, member, getDataViewIntAccessorEx);\n"
"  }\n"
"\n"
"  function defineUnalignedUintAccessor(access, member) {\n"
"    const { bitSize, bitOffset } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const set = DataView.prototype.setUint8;\n"
"      const get = DataView.prototype.getUint8;\n"
"      const valueMask = (2 ** bitSize - 1);\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = get.call(this, offset);\n"
"          const s = n >>> bitPos;\n"
"          return s & valueMask;\n"
"        };\n"
"      } else {\n"
"        const outsideMask = 0xFF ^ (valueMask << bitPos);\n"
"        return function(offset, value) {\n"
"          const n = get.call(this, offset);\n"
"          const b = (n & outsideMask) | ((value & valueMask) << bitPos);\n"
"          set.call(this, offset, b);\n"
"        };\n"
"      }\n"
"    }\n"
"    return defineUnalignedAccessorUsing(access, member, getDataViewUintAccessorEx);\n"
"  }\n"
"\n"
"  function defineAlignedFloatAccessor(access, member) {\n"
"    const { bitSize } = member;\n"
"    if (bitSize === 16) {\n"
"      const buf = new DataView(new ArrayBuffer(4));\n"
"      const set = DataView.prototype.setUint16;\n"
"      const get = DataView.prototype.getUint16;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >>> 15;\n"
"          const exp = (n & 0x7C00) >> 10;\n"
"          const frac = n & 0x03FF;\n"
"          if (exp === 0) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x1F) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);\n"
"          buf.setUint32(0, n32, littleEndian);\n"
"          return buf.getFloat32(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat32(0, value, littleEndian);\n"
"          const n = buf.getUint32(0, littleEndian);\n"
"          const sign = n >>> 31;\n"
"          const exp = (n & 0x7F800000) >> 23;\n"
"          const frac = n & 0x007FFFFF;\n"
"          const exp16 = (exp - 127 + 15);\n"
"          let n16;\n"
"          if (exp === 0) {\n"
"            n16 = sign << 15;\n"
"          } else if (exp === 0xFF) {\n"
"            n16 = sign << 15 | 0x1F << 10 | (frac ? 1 : 0);\n"
"          } else if (exp16 >= 31) {\n"
"            n16 = sign << 15 | 0x1F << 10;\n"
"          } else {\n"
"            n16 = sign << 15 | exp16 << 10 | (frac >> 13);\n"
"          }\n"
"          set.call(this, offset, n16, littleEndian);\n"
"        }\n"
"      }\n"
"    } else if (bitSize === 80) {\n"
"      const buf = new DataView(new ArrayBuffer(8));\n"
"      const setWord = DataView.prototype.setBigUint64;\n"
"      const getWord = DataView.prototype.getBigUint64;\n"
"      const get = function(offset, littleEndian) {\n"
"        const w1 = getWord.call(this, offset, littleEndian);\n"
"        const w2 = getWord.call(this, offset + 8, littleEndian);\n"
"        return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;\n"
"      };\n"
"      const set = function(offset, value, littleEndian) {\n"
"        const w1 = value & 0xFFFFFFFFFFFFFFFFn;\n"
"        const w2 = value >> 64n;\n"
"        setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);\n"
"        setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);\n"
"      };\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >> 79n;\n"
"          const exp = (n & 0x7FFF0000000000000000n) >> 64n;\n"
"          const frac = n & 0x00007FFFFFFFFFFFFFFFn;\n"
"          if (exp === 0n) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x7FFFn) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const exp64 = exp - 16383n + 1023n;\n"
"          if (exp64 >= 2047n) {\n"
"            return (sign) ? -Infinity : Infinity;\n"
"          }\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);\n"
"          buf.setBigUint64(0, n64, littleEndian);\n"
"          return buf.getFloat64(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat64(0, value, littleEndian);\n"
"          const n = buf.getBigUint64(0, littleEndian);\n"
"          const sign = n >> 63n;\n"
"          const exp = (n & 0x7FF0000000000000n) >> 52n;\n"
"          const frac = n & 0x000FFFFFFFFFFFFFn;\n"
"          let n80;\n"
"          if (exp === 0n) {\n"
"            n80 = sign << 79n | (frac << 11n);\n"
"          } else if (exp === 0x07FFn) {\n"
"            n80 = sign << 79n | 0x7FFFn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;\n"
"            //                                                 ^ bit 61                       ^ bit 63\n"
"          } else {\n"
"            n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;\n"
"          }\n"
"          set.call(this, offset, n80, littleEndian);\n"
"        }\n"
"      }\n"
"    } else if (bitSize === 128) {\n"
"      const buf = new DataView(new ArrayBuffer(8));\n"
"      const getWord = DataView.prototype.getBigUint64;\n"
"      const setWord = DataView.prototype.setBigUint64;\n"
"      const get = function(offset, littleEndian) {\n"
"        const w1 = getWord.call(this, offset, littleEndian);\n"
"        const w2 = getWord.call(this, offset + 8, littleEndian);\n"
"        return (littleEndian) ? w1 | w2 << 64n : w1 << 64n | w2;\n"
"      };\n"
"      const set = function(offset, value, littleEndian) {\n"
"        const w1 = value & 0xFFFFFFFFFFFFFFFFn;\n"
"        const w2 = value >> 64n;\n"
"        setWord.call(this, offset + (littleEndian ? 0 : 8), w1, littleEndian);\n"
"        setWord.call(this, offset + (littleEndian ? 8 : 0), w2, littleEndian);\n"
"      };\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >> 127n;\n"
"          const exp = (n & 0x7FFF0000000000000000000000000000n) >> 112n;\n"
"          const frac = n & 0x0000FFFFFFFFFFFFFFFFFFFFFFFFFFFFn;\n"
"          if (exp === 0n) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x7FFFn) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const exp64 = exp - 16383n + 1023n;\n"
"          if (exp64 >= 2047n) {\n"
"            return (sign) ? -Infinity : Infinity;\n"
"          }\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);\n"
"          buf.setBigUint64(0, n64, littleEndian);\n"
"          return buf.getFloat64(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat64(0, value, littleEndian);\n"
"          const n = buf.getBigUint64(0, littleEndian);\n"
"          const sign = n >> 63n;\n"
"          const exp = (n & 0x7FF0000000000000n) >> 52n;\n"
"          const frac = n & 0x000FFFFFFFFFFFFFn;\n"
"          let n128;\n"
"          if (exp === 0n) {\n"
"            n128 = sign << 127n | (frac << 60n);\n"
"          } else if (exp === 0x07FFn) {\n"
"            n128 = sign << 127n | 0x7FFFn << 112n | (frac ? 1n : 0n);\n"
"          } else {\n"
"            n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);\n"
"          }\n"
"          set.call(this, offset, n128, littleEndian);\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function defineUnalignedFloatAccessor(access, member) {\n"
"    return defineUnalignedAccessorUsing(access, member, getDataViewFloatAccessorEx);\n"
"  }\n"
"\n"
"  function defineUnalignedAccessorUsing(access, member, getDataViewAccessor) {\n"
"    // pathological usage scenario--handle it anyway by copying the bitSize into a\n"
"    // temporary buffer, bit-aligning the data\n"
"    const { bitSize, bitOffset } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;\n"
"    const buf = new DataView(new ArrayBuffer(byteSize));\n"
"    if (access === 'get') {\n"
"      const getAligned = getDataViewAccessor('get', { ...member, byteSize });\n"
"      const copyBits = getBitAlignFunction(bitPos, bitSize, true);\n"
"      return function(offset, littleEndian) {\n"
"        copyBits(buf, this, offset);\n"
"        return getAligned.call(buf, 0, littleEndian);\n"
"      };\n"
"    } else {\n"
"      const setAligned = getDataViewAccessor('set', { ...member, byteSize });\n"
"      const applyBits = getBitAlignFunction(bitPos, bitSize, false);\n"
"      return function(offset, value, littleEndian) {\n"
"        setAligned.call(buf, 0, value, littleEndian);\n"
"        applyBits(this, buf, offset);\n"
"      };\n"
"    }\n"
"  }\n"
"\n"
"  function cacheMethod(access, member, cb) {\n"
"    const { type, bitOffset, bitSize } = member;\n"
"    const bitPos = bitOffset & 0x07;\n"
"    const typeName = getTypeName(member);\n"
"    const suffix = isByteAligned(member) ? `` : `Bit${bitPos}`;\n"
"    const name = `${access}${typeName}${suffix}`;\n"
"    let fn = methodCache[name];\n"
"    if (!fn) {\n"
"      // usize and isize can return/accept number or bigint\n"
"      if ((type === MemberType.Int && typeName === 'ISize')\n"
"       || (type === MemberType.Uint && typeName === 'USize')) {\n"
"        if (bitSize === 64) {\n"
"          const realTypeName = (type === MemberType.Int) ? 'BigInt64' : 'BigUint64';\n"
"          const realName = `${access}${realTypeName}`;\n"
"          if (access === 'get') {\n"
"            const get = cb(realName);\n"
"            const min = BigInt(Number.MIN_SAFE_INTEGER);\n"
"            const max = BigInt(Number.MAX_SAFE_INTEGER);\n"
"            fn = function(offset, littleEndian) {\n"
"              const value = get.call(this, offset, littleEndian);\n"
"              if (min <= value && value <= max) {\n"
"                return Number(value);\n"
"              } else {\n"
"                return value;\n"
"              }\n"
"            };\n"
"          } else {\n"
"            const set = cb(realName);\n"
"            fn = function(offset, value, littleEndian) {\n"
"              // automatically convert number to bigint\n"
"              if (typeof(value) === 'number') {\n"
"                value = BigInt(value);\n"
"              }\n"
"              set.call(this, offset, value, littleEndian);\n"
"            };\n"
"          }\n"
"        } else if (bitSize === 32) {\n"
"          const realTypeName = (type === MemberType.Int) ? 'Int32' : 'Uint32';\n"
"          const realName = `${access}${realTypeName}`;\n"
"          if (access === 'get') {\n"
"            fn = cb(realName);\n"
"          } else {\n"
"            const set = cb(realName);\n"
"            fn = function(offset, value, littleEndian) {\n"
"              if (typeof(value) === 'bigint') {\n"
"                value = Number(value);\n"
"              }\n"
"              set.call(this, offset, value, littleEndian);\n"
"            };\n"
"          }\n"
"        }\n"
"      } else {\n"
"        fn = cb(name);\n"
"      }\n"
"      if (fn && fn.name !== name) {\n"
"        Object.defineProperty(fn, 'name', { value: name, configurable: true, writable: false });\n"
"      }\n"
"      methodCache[name] = fn;\n"
"    }\n"
"    return fn;\n"
"  }\n"
"\n"
"  const methodCache = {};\n"
"\n"
"  const MemberType = {\n"
"    Void: 0,\n"
"    Bool: 1,\n"
"    Int: 2,\n"
"    Uint: 3,\n"
"    Float: 4,\n"
"    EnumerationItem: 5,\n"
"    Error: 6,\n"
"    Object: 7,\n"
"    Type: 8,\n"
"    Comptime: 9,\n"
"    Static: 10,\n"
"    Literal: 11,\n"
"    Null: 12,\n"
"  };\n"
"\n"
"  const factories = Array(Object.values(MemberType).length);\n"
"\n"
"  function useVoid() {\n"
"    factories[MemberType.Void] = getVoidDescriptor;\n"
"  }\n"
"\n"
"  function useBool() {\n"
"    factories[MemberType.Bool] = getBoolDescriptor;\n"
"  }\n"
"\n"
"  function useBoolEx() {\n"
"    factories[MemberType.Bool] = getBoolDescriptorEx;\n"
"  }\n"
"\n"
"  function useIntEx() {\n"
"    factories[MemberType.Int] = getIntDescriptorEx;\n"
"  }\n"
"\n"
"  function useUintEx() {\n"
"    factories[MemberType.Uint] = getUintDescriptorEx;\n"
"  }\n"
"\n"
"  function useFloatEx() {\n"
"    factories[MemberType.Float] = getFloatDescriptorEx;\n"
"  }\n"
"\n"
"  function useEnumerationItemEx() {\n"
"    factories[MemberType.EnumerationItem] = getEnumerationItemDescriptorEx;\n"
"  }\n"
"\n"
"  function useError() {\n"
"    factories[MemberType.Error] = getErrorDescriptor;\n"
"  }\n"
"\n"
"  function useObject() {\n"
"    factories[MemberType.Object] = getObjectDescriptor;\n"
"  }\n"
"\n"
"  function useType() {\n"
"    factories[MemberType.Type] = getTypeDescriptor;\n"
"  }\n"
"\n"
"  function useComptime() {\n"
"    factories[MemberType.Comptime] = getComptimeDescriptor;\n"
"  }\n"
"\n"
"  function useStatic() {\n"
"    factories[MemberType.Static] = getStaticDescriptor;\n"
"  }\n"
"\n"
"  function useLiteral() {\n"
"    factories[MemberType.Literal] = getLiteralDescriptor;\n"
"  }\n"
"\n"
"  function useNull() {\n"
"    factories[MemberType.Null] = getNullDescriptor;\n"
"  }\n"
"\n"
"  function isByteAligned({ bitOffset, bitSize, byteSize }) {\n"
"    return byteSize !== undefined || (!(bitOffset & 0x07) && !(bitSize & 0x07)) || bitSize === 0;\n"
"  }\n"
"\n"
"  function getDescriptor(member, env) {\n"
"    const f = factories[member.type];\n"
"    return f(member, env);\n"
"  }\n"
"\n"
"  function getVoidDescriptor(member, env) {\n"
"    const { runtimeSafety } = env;\n"
"    return {\n"
"      get: function() {\n"
"        return undefined;\n"
"      },\n"
"      set: (runtimeSafety)\n"
"      ? function(value) {\n"
"          if (value !== undefined) {\n"
"            throwNotUndefined(member);\n"
"          }\n"
"        }\n"
"      : function() {},\n"
"    }\n"
"  }\n"
"\n"
"  function getNullDescriptor(member, env) {\n"
"    const { runtimeSafety } = env;\n"
"    return {\n"
"      get: function() {\n"
"        return null;\n"
"      },\n"
"      set: (runtimeSafety)\n"
"      ? function(value) {\n"
"          if (value !== null) {\n"
"            throwNotNull(member);\n"
"          }\n"
"        }\n"
"      : function() {},\n"
"    }\n"
"  }\n"
"\n"
"  function getBoolDescriptor(member, env) {\n"
"    return getDescriptorUsing(member, env, getDataViewBoolAccessor)\n"
"  }\n"
"\n"
"  function getBoolDescriptorEx(member, env) {\n"
"    return getDescriptorUsing(member, env, getDataViewBoolAccessorEx)\n"
"  }\n"
"\n"
"  function getIntDescriptorEx(member, env) {\n"
"    const getDataViewAccessor = addRuntimeCheck(env, getDataViewIntAccessorEx);\n"
"    return getDescriptorUsing(member, env, getDataViewAccessor)\n"
"  }\n"
"\n"
"  function getUintDescriptorEx(member, env) {\n"
"    const getDataViewAccessor = addRuntimeCheck(env, getDataViewUintAccessorEx);\n"
"    return getDescriptorUsing(member, env, getDataViewAccessor)\n"
"  }\n"
"\n"
"  function addRuntimeCheck(env, getDataViewAccessor) {\n"
"    return function (access, member) {\n"
"      const {\n"
"        runtimeSafety = true,\n"
"      } = env;\n"
"      const accessor = getDataViewAccessor(access, member);\n"
"      if (runtimeSafety && access === 'set') {\n"
"        const { min, max } = getIntRange(member);\n"
"        return function(offset, value, littleEndian) {\n"
"          if (value < min || value > max) {\n"
"            throwOverflow(member, value);\n"
"          }\n"
"          accessor.call(this, offset, value, littleEndian);\n"
"        };\n"
"      }\n"
"      return accessor;\n"
"    };\n"
"  }\n"
"\n"
"  function getFloatDescriptorEx(member, env) {\n"
"    return getDescriptorUsing(member, env, getDataViewFloatAccessorEx)\n"
"  }\n"
"\n"
"  function getEnumerationItemDescriptorEx(member, env) {\n"
"    const getDataViewAccessor = addEnumerationLookup(getDataViewIntAccessorEx);\n"
"    return getDescriptorUsing(member, env, getDataViewAccessor) ;\n"
"  }\n"
"\n"
"  function addEnumerationLookup(getDataViewIntAccessor) {\n"
"    return function(access, member) {\n"
"      // no point in using non-standard int accessor to read enum values unless they aren't byte-aligned\n"
"      const { structure } = member;\n"
"      const [ intMember ] = structure.instance.members;\n"
"      const accessor = getDataViewIntAccessor(access, intMember);\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const { constructor } = structure;\n"
"          const value = accessor.call(this, offset, littleEndian);\n"
"          // the enumeration constructor returns the object for the int value\n"
"          const object = constructor(value);\n"
"          if (!object) {\n"
"            throwEnumExpected(structure, value);\n"
"          }\n"
"          return object;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const { constructor } = structure;\n"
"          let item;\n"
"          if (value instanceof constructor) {\n"
"            item = value;\n"
"          } else {\n"
"            item = constructor(value);\n"
"          }\n"
"          if (!item) {\n"
"            throwEnumExpected(structure, value);\n"
"          }\n"
"          accessor.call(this, offset, item[Symbol.toPrimitive](), littleEndian);\n"
"        };\n"
"      }\n"
"    };\n"
"  }\n"
"\n"
"  function getErrorDescriptor(member, env) {\n"
"    const getDataViewAccessor = addErrorLookup(getDataViewIntAccessor);\n"
"    return getDescriptorUsing(member, env, getDataViewAccessor) ;\n"
"  }\n"
"\n"
"  function addErrorLookup(getDataViewIntAccessor) {\n"
"    return function(access, member) {\n"
"      // no point in using non-standard int accessor to read enum values unless they aren't byte-aligned\n"
"      const { structure } = member;\n"
"      const [ intMember ] = structure.instance.members;\n"
"      const acceptAny = structure.name === 'anyerror';\n"
"      const accessor = getDataViewIntAccessor(access, intMember);\n"
"      const allErrors = getCurrentErrorSets();\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const { constructor } = structure;\n"
"          const index = accessor.call(this, offset, littleEndian);\n"
"          if (index) {\n"
"            const object = acceptAny ? allErrors[index] : constructor(index);\n"
"            if (!object) {\n"
"              throwErrorExpected(structure, index);\n"
"            }\n"
"            return object;\n"
"          }\n"
"        };\n"
"      } else {\n"
"        const Primitive = getPrimitiveClass(intMember);\n"
"        const zero = Primitive(0);\n"
"        return function(offset, value, littleEndian) {\n"
"          const { constructor } = structure;\n"
"          let object;\n"
"          if (value instanceof Error) {\n"
"            if (acceptAny ? value.hasOwnProperty('index') : value instanceof constructor) {\n"
"              object = value;\n"
"            } else {\n"
"              throwNotInErrorSet(structure);\n"
"            }\n"
"          } else if (value !== null) {\n"
"            object = acceptAny ? allErrors[value] : constructor(value);\n"
"            if (!object) {\n"
"              throwErrorExpected(structure, value);\n"
"            } \n"
"          }  \n"
"          accessor.call(this, offset, object?.index ?? zero, littleEndian);\n"
"        };\n"
"      }\n"
"    };\n"
"  }\n"
"\n"
"  function isValueExpected(structure) {\n"
"    switch (structure.type) {\n"
"      case StructureType.Primitive:\n"
"      case StructureType.ErrorUnion:\n"
"      case StructureType.Optional:\n"
"      case StructureType.Enumeration:\n"
"      case StructureType.ErrorSet:\n"
"        return true;\n"
"      default:\n"
"        return false;\n"
"    }\n"
"  }\n"
"\n"
"  function getValue(slot) {\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);\n"
"    return object.$;\n"
"  }\n"
"\n"
"  function getObject(slot) {\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);\n"
"    return object;\n"
"  }\n"
"\n"
"  function setValue(slot, value) {\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATOR](slot);\n"
"    object.$ = value;\n"
"  }\n"
"\n"
"  function bindSlot(slot, { get, set }) {\n"
"    if (slot !== undefined) {\n"
"      return { \n"
"        get: function() {\n"
"          return get.call(this, slot);\n"
"        },\n"
"        set: (set) \n"
"        ? function(arg) {\n"
"            return set.call(this, slot, arg);\n"
"          } \n"
"        : undefined,\n"
"      };\n"
"    } else {\n"
"      // array accessors\n"
"      return { get, set };\n"
"    }\n"
"  }\n"
"\n"
"  function getObjectDescriptor(member, env) {\n"
"    const { structure, slot } = member;\n"
"    return bindSlot(slot, {\n"
"      get: isValueExpected(structure) ? getValue : getObject,\n"
"      set: setValue,\n"
"    });\n"
"  }\n"
"\n"
"  function getType(slot) {\n"
"    // unsupported types will have undefined structure\n"
"    const structure = this[SLOTS][slot];\n"
"    return structure?.constructor;\n"
"  }\n"
"\n"
"  function getTypeDescriptor(member, env) {\n"
"    const { slot } = member;\n"
"    return bindSlot(slot, { get: getType });\n"
"  }\n"
"\n"
"  function getComptimeDescriptor(member, env) {\n"
"    const { slot, structure } = member;\n"
"    return bindSlot(slot, {\n"
"      get: isValueExpected(structure) ? getValue : getObject,\n"
"    });\n"
"  }\n"
"\n"
"  function getStaticDescriptor(member, env) {\n"
"    const { slot, structure } = member;\n"
"    return bindSlot(slot, {\n"
"      get: isValueExpected(structure) ? getValue : getObject,\n"
"      set: setValue,\n"
"    });\n"
"  }\n"
"\n"
"  function getLiteral(slot) {\n"
"    const object = this[SLOTS][slot];\n"
"    return object.string;\n"
"  }\n"
"\n"
"  function getLiteralDescriptor(member, env) {\n"
"    const { slot } = member;\n"
"    return bindSlot(slot, { get: getLiteral });\n"
"  }\n"
"\n"
"  function getDescriptorUsing(member, env, getDataViewAccessor) {\n"
"    const {\n"
"      littleEndian = true,\n"
"    } = env;\n"
"    const { bitOffset, byteSize } = member;\n"
"    const getter = getDataViewAccessor('get', member);\n"
"    const setter = getDataViewAccessor('set', member);\n"
"    if (bitOffset !== undefined) {\n"
"      const offset = bitOffset >> 3;\n"
"      return {\n"
"        get: function getValue() {\n"
"            return getter.call(this[MEMORY], offset, littleEndian);\n"
"        },\n"
"        set: function setValue(value) {\n"
"          return setter.call(this[MEMORY], offset, value, littleEndian);\n"
"        }\n"
"      }\n"
"    } else {\n"
"      return {\n"
"        get: function getElement(index) {\n"
"          try {\n"
"            return getter.call(this[MEMORY], index * byteSize, littleEndian);\n"
"          } catch (err) {\n"
"              rethrowRangeError(member, index, err);\n"
"          }\n"
"        },\n"
"        set: function setElement(index, value) {\n"
"            return setter.call(this[MEMORY], index * byteSize, value, littleEndian);\n"
"        },\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function useAllMemberTypes() {\n"
"    useVoid();\n"
"    useNull();\n"
"    useBoolEx();\n"
"    useIntEx();\n"
"    useUintEx();\n"
"    useFloatEx();\n"
"    useEnumerationItemEx();\n"
"    useError();\n"
"    useObject();\n"
"    useType();\n"
"    useComptime();\n"
"    useStatic();\n"
"    useLiteral();\n"
"  }\n"
"\n"
"  function addMethods(s, env) {\n"
"    const add = (target, { methods }, pushThis) => {\n"
"      const descriptors = {};\n"
"      const re = /^(get|set)\\s+([\\s\\S]+)/;\n"
"      for (const method of methods) {\n"
"        const f = env.createCaller(method, pushThis);\n"
"        const m = re.exec(f.name);\n"
"        if (m) {\n"
"          // getter/setter\n"
"          const type = m[1], propName = m[2];\n"
"          const argRequired = (type === 'get') ? 0 : 1;\n"
"          const argCount = getArgumentCount(method, pushThis);\n"
"          // need to match arg count, since instance methods also show up as static methods\n"
"          if (argCount === argRequired) {\n"
"            let descriptor = descriptors[propName];\n"
"            if (!descriptor) {\n"
"              descriptor = descriptors[propName] = { configurable: true, enumerable: true };\n"
"            }\n"
"            descriptor[type] = f; \n"
"          }\n"
"        } else {\n"
"          descriptors[f.name] = { value: f, configurable: true, writable: true };\n"
"        }\n"
"      }\n"
"      defineProperties(target, descriptors);\n"
"    };\n"
"    add(s.constructor, s.static, false);\n"
"    add(s.constructor.prototype, s.instance, true);\n"
"  }\n"
"\n"
"  function getArgumentCount(method, pushThis) {\n"
"    const { argStruct: { instance: { members } } } = method;  \n"
"    return members.length - (pushThis ? 2 : 1);\n"
"  }\n"
"\n"
"  function addStaticMembers(structure, env) {\n"
"    const {\n"
"      type,\n"
"      constructor,\n"
"      static: { members, template },\n"
"    } = structure;\n"
"    if (members.length === 0) {\n"
"      return;\n"
"    }\n"
"    const descriptors = {};\n"
"    for (const member of members) {\n"
"      descriptors[member.name] = getDescriptor(member, env);\n"
"    }\n"
"    defineProperties(constructor, {\n"
"      ...descriptors,\n"
"      // static variables are objects stored in the static template's slots\n"
"      [SLOTS]: { value: template[SLOTS] },\n"
"    });\n"
"    if (type === StructureType.Enumeration) {\n"
"      const enums = constructor[ITEMS];\n"
"      for (const { name, slot } of members) {\n"
"        // place item in hash to facilitate lookup, \n"
"        const item = constructor[SLOTS][slot];\n"
"        if (item instanceof constructor) {\n"
"          const index = item[Symbol.toPrimitive]();\n"
"          enums[index] = item;\n"
"          // attach name to item so tagged union code can quickly find it\n"
"          defineProperties(item, { [NAME]: { value: name } });  \n"
"        }      \n"
"      }\n"
"    } else if (type === StructureType.ErrorSet) {\n"
"      const allErrors = getCurrentErrorSets();\n"
"      const errors = constructor[ITEMS];\n"
"      const messages = constructor[MESSAGES];\n"
"      for (const { name, slot } of members) {\n"
"        let error = constructor[SLOTS][slot];\n"
"        const { index } = error;\n"
"        const previous = allErrors[index];\n"
"        if (previous) {\n"
"          if (!(previous instanceof constructor)) {\n"
"            // error already exists in a previously defined set\n"
"            // see if we should make that set a subclass or superclass of this one\n"
"            const otherSet = previous.constructor;\n"
"            const otherErrors = Object.values(otherSet[SLOTS]);\n"
"            const errorIndices = Object.values(constructor[SLOTS]).map(e => e.index);\n"
"            if (otherErrors.every(e => errorIndices.includes(e.index))) {\n"
"              // this set contains the all errors of the other one, so it's a superclass\n"
"              Object.setPrototypeOf(otherSet.prototype, constructor.prototype);\n"
"            } else {\n"
"              // make this set a subclass of the other\n"
"              Object.setPrototypeOf(constructor.prototype, otherSet.prototype);\n"
"              for (const otherError of otherErrors) {\n"
"                if (errorIndices.includes(otherError.index)) {\n"
"                  // this set should be this error object's class\n"
"                  Object.setPrototypeOf(otherError, constructor.prototype);\n"
"                }\n"
"              }\n"
"            }\n"
"          }\n"
"          error = constructor[SLOTS][slot] = previous;       \n"
"        } else {\n"
"          // set error message\n"
"          const message = decamelizeErrorName(name);\n"
"          messages[error.index] = message;\n"
"          // add to hash\n"
"          allErrors[index] = error;\n"
"          allErrors[message] = error;\n"
"          allErrors[`${error}`] = error;\n"
"        }\n"
"        errors[index] = error;\n"
"        errors[error.message] = error;\n"
"        errors[`${error}`] = error;\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  class Environment {\n"
"    context;\n"
"    contextStack = [];\n"
"    consolePending = [];\n"
"    consoleTimeout = 0;\n"
"    viewMap = new WeakMap();\n"
"    initPromise;\n"
"    abandoned = false;\n"
"    released = false;\n"
"    littleEndian = true;\n"
"    runtimeSafety = true;\n"
"    /* COMPTIME-ONLY */\n"
"    slots = {};\n"
"    structures = [];\n"
"    /* COMPTIME-ONLY-END */\n"
"    /* RUNTIME-ONLY */\n"
"    variables = [];\n"
"    /* RUNTIME-ONLY-END */\n"
"    imports;\n"
"\n"
"    /*\n"
"    Functions to be defined in subclass:\n"
"\n"
"    getBufferAddress(buffer: ArrayBuffer): bigint|number {\n"
"      // return a buffer's address\n"
"    }\n"
"    allocateRelocMemory(len: number, align: number): DataView {\n"
"      // allocate memory and remember its address\n"
"    }\n"
"    allocateShadowMemory(len: number, align: number): DataView {\n"
"      // allocate memory for shadowing objects\n"
"    }\n"
"    freeRelocMemory(address: bigint|number, len: number, align: number): void {\n"
"      // free previously allocated memory\n"
"    }\n"
"    freeShadowMemory(address: bigint|number, len: number, align: number): void {\n"
"      // free memory allocated for shadow\n"
"    }\n"
"    allocateFixedMemory(len: number, align: number): DataView {\n"
"      // allocate fixed memory and keep a reference to it\n"
"    }\n"
"    freeFixedMemory(address: bigint|number, len: number, align: number): void {\n"
"      // free previously allocated fixed memory return the reference\n"
"    }\n"
"    obtainFixedView(address: bigint|number, len: number): DataView {\n"
"      // obtain a data view of memory at given address\n"
"    }\n"
"    releaseFixedView(dv: DataView): void {\n"
"      // release allocated memory stored in data view, doing nothing if data view \n"
"      // does not contain fixed memory or if memory is static\n"
"    }\n"
"    inFixedMemory(object: object): boolean {\n"
"      // return true/false depending on whether object is in fixed memory\n"
"    }\n"
"    copyBytes(dst: DataView, address: bigint|number, len: number): void {\n"
"      // copy memory at given address into destination view\n"
"    }\n"
"    findSentinel(address: bigint|number, bytes: DataView): number {\n"
"      // return offset where sentinel value is found\n"
"    }\n"
"    getMemoryOffset(address: bigint|number) number {\n"
"      // return offset of address relative to start of module memory\n"
"    }\n"
"    recreateAddress(reloc: number) number {\n"
"      // recreate address of memory belonging to module\n"
"    }\n"
"\n"
"    getTargetAddress(target: object, cluster: object|undefined) {\n"
"      // return the address of target's buffer if correctly aligned\n"
"    }\n"
"    */\n"
"\n"
"    startContext() {\n"
"      if (this.context) {\n"
"        this.contextStack.push(this.context);\n"
"      }\n"
"      this.context = new CallContext();\n"
"    }\n"
"\n"
"    endContext() {\n"
"      this.context = this.contextStack.pop();\n"
"    }\n"
"\n"
"    allocateMemory(len, align = 0, fixed = false) {\n"
"      if (fixed) {\n"
"        return this.allocateFixedMemory(len, align);\n"
"      } else {\n"
"        return this.obtainView(new ArrayBuffer(len), 0, len);\n"
"      }\n"
"    }\n"
"\n"
"    registerMemory(dv, targetDV = null) {\n"
"      const { memoryList } = this.context;\n"
"      const address = this.getViewAddress(dv);\n"
"      const index = findMemoryIndex(memoryList, address);\n"
"      memoryList.splice(index, 0, { address, dv, len: dv.byteLength, targetDV });\n"
"      return address;\n"
"    }\n"
"\n"
"    unregisterMemory(address) {\n"
"      const { memoryList } = this.context;\n"
"      const index = findMemoryIndex(memoryList, address);\n"
"      const prev = memoryList[index - 1];\n"
"      if (prev?.address === address) {\n"
"        memoryList.splice(index - 1, 1);\n"
"      }\n"
"    }\n"
"\n"
"    findMemory(address, len) {\n"
"      // check for null address (=== can't be used since address can be both number and bigint)\n"
"      if (this.context) {\n"
"        const { memoryList, shadowMap } = this.context;\n"
"        const index = findMemoryIndex(memoryList, address);\n"
"        const prev = memoryList[index - 1];\n"
"        if (prev?.address === address && prev.len === len) {\n"
"          return prev.targetDV ?? prev.dv;\n"
"        } else if (prev?.address <= address && address < add(prev.address, prev.len)) {\n"
"          const offset = Number(address - prev.address) + prev.dv.byteOffset;\n"
"          const dv = prev.targetDV ?? prev.dv;\n"
"          return this.obtainView(dv.buffer, dv.byteOffset + offset, len);\n"
"        }\n"
"      }\n"
"      // not found in any of the buffers we've seen--assume it's fixed memory\n"
"      return this.obtainFixedView(address, len);\n"
"    }\n"
"\n"
"    getViewAddress(dv) {\n"
"      const address = this.getBufferAddress(dv.buffer);\n"
"      return add(address, dv.byteOffset);\n"
"    }\n"
"\n"
"    obtainView(buffer, offset, len) {\n"
"      let entry = this.viewMap.get(buffer);\n"
"      if (!entry) {\n"
"        const dv = new DataView(buffer, offset, len);\n"
"        this.viewMap.set(buffer, dv);\n"
"        return dv;\n"
"      } \n"
"      if (entry instanceof DataView) {\n"
"        // only one view created thus far--see if that's the matching one \n"
"        if (entry.byteOffset === offset && entry.byteLength === len) {\n"
"          return entry;\n"
"        } else {\n"
"          // no, need to replace the entry with a hash keyed by `offset:len`\n"
"          const dv = entry;\n"
"          const key = `${dv.byteOffset}:${dv.byteLength}`;\n"
"          entry = { [key]: dv };\n"
"          this.viewMap.set(buffer, entry);\n"
"        }\n"
"      }\n"
"      const key = `${offset}:${len}`;\n"
"      let dv = entry[key];\n"
"      if (!dv) {\n"
"        dv = entry[key] = new DataView(buffer, offset, len);\n"
"      }\n"
"      return dv;\n"
"    }\n"
"\n"
"    captureView(address, len, copy) {\n"
"      if (copy) {\n"
"        const dv = this.allocateMemory(len);\n"
"        if (len > 0) {\n"
"          this.copyBytes(dv, address, len);\n"
"        }\n"
"        return dv;\n"
"      } else {\n"
"        return this.obtainFixedView(address, len);\n"
"      }\n"
"    }\n"
"\n"
"    castView(structure, dv, writable) {\n"
"      const { constructor, hasPointer } = structure;\n"
"      const object = constructor.call(ENVIRONMENT, dv, { writable });\n"
"      if (hasPointer) {\n"
"        // acquire targets of pointers\n"
"        this.acquirePointerTargets(object);\n"
"      }\n"
"      return object;\n"
"    }\n"
"\n"
"    /* COMPTIME-ONLY */\n"
"    readSlot(target, slot) {\n"
"      const slots = target ? target[SLOTS] : this.slots;\n"
"      return slots?.[slot];\n"
"    }\n"
"\n"
"    writeSlot(target, slot, value) {\n"
"      const slots = target ? target[SLOTS] : this.slots;\n"
"      if (slots) {\n"
"        slots[slot] = value;\n"
"      }\n"
"    }\n"
"\n"
"    createTemplate(dv) {\n"
"      return {\n"
"        [MEMORY]: dv,\n"
"        [SLOTS]: {}\n"
"      };\n"
"    }\n"
"\n"
"    beginStructure(def) {\n"
"      const {\n"
"        type,\n"
"        name,\n"
"        length,\n"
"        byteSize,\n"
"        align,\n"
"        isConst,\n"
"        hasPointer,\n"
"      } = def;\n"
"      return {\n"
"        constructor: null,\n"
"        typedArray: null,\n"
"        type,\n"
"        name,\n"
"        length,\n"
"        byteSize,\n"
"        align,\n"
"        isConst,\n"
"        hasPointer,\n"
"        instance: {\n"
"          members: [],\n"
"          methods: [],\n"
"          template: null,\n"
"        },\n"
"        static: {\n"
"          members: [],\n"
"          methods: [],\n"
"          template: null,\n"
"        },\n"
"      };\n"
"    }\n"
"\n"
"    attachMember(structure, member, isStatic = false) {\n"
"      const target = (isStatic) ? structure.static : structure.instance;\n"
"      target.members.push(member);\n"
"    }\n"
"\n"
"    attachMethod(structure, method, isStaticOnly = false) {\n"
"      structure.static.methods.push(method);\n"
"      if (!isStaticOnly) {\n"
"        structure.instance.methods.push(method);\n"
"      }\n"
"    }\n"
"\n"
"    attachTemplate(structure, template, isStatic = false) {\n"
"      const target = (isStatic) ? structure.static : structure.instance;\n"
"      target.template = template;\n"
"    }\n"
"\n"
"    endStructure(structure) {\n"
"      this.structures.push(structure);\n"
"      this.finalizeStructure(structure);\n"
"      for (const structure of this.structures) {\n"
"        this.acquireDefaultPointers(structure);\n"
"      }\n"
"    }\n"
"\n"
"    defineFactoryArgStruct() {\n"
"      useBool();\n"
"      useObject();\n"
"      useArgStruct();\n"
"      const options = this.beginStructure({\n"
"        type: StructureType.Struct,\n"
"        name: 'Options',\n"
"        byteSize: 1,\n"
"        hasPointer: false,\n"
"      });\n"
"      this.attachMember(options, {\n"
"        type: MemberType.Bool,\n"
"        name: 'omitFunctions',\n"
"        bitOffset: 0,\n"
"        bitSize: 1,\n"
"        byteSize: 1,      \n"
"      });\n"
"      this.finalizeShape(options);\n"
"      const structure = this.beginStructure({\n"
"        type: StructureType.ArgStruct,\n"
"        name: 'factory',\n"
"        byteSize: 1,\n"
"        hasPointer: false,\n"
"      });\n"
"      this.attachMember(structure, {\n"
"        type: MemberType.Object,\n"
"        name: '0',\n"
"        bitOffset: 0,\n"
"        bitSize: 1,\n"
"        byteSize: 1,\n"
"        slot: 0,\n"
"        structure: options,\n"
"      });\n"
"      this.attachMember(structure, {\n"
"        type: MemberType.Void,\n"
"        name: 'retval',\n"
"        bitOffset: 8,\n"
"        bitSize: 0,\n"
"        byteSize: 0\n"
"      });\n"
"      this.finalizeShape(structure);\n"
"      return structure.constructor;\n"
"    }\n"
"\n"
"    acquireStructures(options) {\n"
"      initializeErrorSets();\n"
"      const thunkId = this.getFactoryThunk();\n"
"      const ArgStruct = this.defineFactoryArgStruct();\n"
"      const args = new ArgStruct([ options ]);\n"
"      this.invokeThunk(thunkId, args);\n"
"    }\n"
"\n"
"    getRootModule() {\n"
"      const root = this.structures[this.structures.length - 1];\n"
"      return root.constructor;\n"
"    }\n"
"\n"
"    exportStructures() {\n"
"      this.prepareObjectsForExport();\n"
"      const { structures } = this;\n"
"      return { structures, keys: { MEMORY, SLOTS, CONST } };\n"
"    }\n"
"\n"
"    prepareObjectsForExport() {\n"
"      const objects = findAllObjects(this.structures, SLOTS);    \n"
"      const list = [];\n"
"      for (const object of objects) {\n"
"        if (object[MEMORY]) {\n"
"          let dv = object[MEMORY];\n"
"          if (this.inFixedMemory(object)) {\n"
"            // replace fixed memory\n"
"            const address = this.getViewAddress(dv);\n"
"            const offset = this.getMemoryOffset(address);\n"
"            const len = dv.byteLength;\n"
"            const relocDV = this.captureView(address, len, true);\n"
"            relocDV.reloc = offset;\n"
"            object[MEMORY] = relocDV;\n"
"            list.push({ offset, len, owner: object, replaced: false });\n"
"          }\n"
"        }\n"
"      }\n"
"      // larger memory blocks come first\n"
"      list.sort((a, b) => b.len - a.len);\n"
"      for (const a of list) {\n"
"        for (const b of list) {\n"
"          if (a !== b && !a.replaced) {\n"
"            if (a.offset <= b.offset && b.offset + b.len <= a.offset + a.len) {\n"
"              // B is inside A--replace it with a view of A's buffer\n"
"              const dv = a.owner[MEMORY];\n"
"              const pos = b.offset - a.offset + dv.byteOffset;\n"
"              const newDV = this.obtainView(dv.buffer, pos, b.len);\n"
"              newDV.reloc = b.offset;\n"
"              b.owner[MEMORY] = newDV;\n"
"              b.replaced = true;\n"
"            }\n"
"          }\n"
"        }\n"
"      }\n"
"    }\n"
"    /* COMPTIME-ONLY-END */\n"
"\n"
"    finalizeShape(structure) {\n"
"      const f = getStructureFactory(structure.type);\n"
"      const constructor = f(structure, this);\n"
"      if (typeof(constructor) === 'function') {\n"
"        const name = getStructureName(structure);\n"
"        defineProperties(constructor, {\n"
"          name: { value: name, configurable: true },\n"
"        });\n"
"        if (!constructor.prototype.hasOwnProperty(Symbol.toStringTag)) {\n"
"          defineProperties(constructor.prototype, {\n"
"            [Symbol.toStringTag]: { value: structure.name, configurable: true },\n"
"          });\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    finalizeStructure(structure) {\n"
"      addStaticMembers(structure, this);\n"
"      addMethods(structure, this);\n"
"    }\n"
"\n"
"    createCaller(method, useThis) {\n"
"      const { name, argStruct, thunkId } = method;\n"
"      const { constructor } = argStruct;\n"
"      const self = this;\n"
"      let f;\n"
"      if (useThis) {\n"
"        f = function(...args) {\n"
"          return self.invokeThunk(thunkId, new constructor([ this, ...args ]));\n"
"        };\n"
"      } else {\n"
"        f = function(...args) {\n"
"          return self.invokeThunk(thunkId, new constructor(args));\n"
"        };\n"
"      }\n"
"      Object.defineProperty(f, 'name', { value: name });\n"
"      return f;\n"
"    }\n"
"\n"
"    /* RUNTIME-ONLY */\n"
"    recreateStructures(structures) {\n"
"      const insertObjects = (dest, placeholders) => {\n"
"        for (const [ slot, placeholder ] of Object.entries(placeholders)) {\n"
"          dest[slot] = placeholder ? createObject(placeholder) : null;\n"
"        }\n"
"        return dest;\n"
"      };\n"
"      const createObject = (placeholder) => {\n"
"        if (placeholder.memory) {\n"
"          const { array, offset, length } = placeholder.memory;\n"
"          const dv = this.obtainView(array.buffer, offset, length);\n"
"          const { constructor } = placeholder.structure;\n"
"          const { reloc, const: isConst } = placeholder;\n"
"          const writable = reloc !== undefined && isConst !== true;\n"
"          const object = constructor.call(ENVIRONMENT, dv, { writable });\n"
"          if (placeholder.slots) {\n"
"            insertObjects(object[SLOTS], placeholder.slots);\n"
"          }\n"
"          if (reloc !== undefined) {\n"
"            // need to replace dataview with one pointing to fixed memory later,\n"
"            // when the VM is up and running\n"
"            this.variables.push({ reloc, object });\n"
"          }\n"
"          return object;  \n"
"        } else {\n"
"          return placeholder.structure;\n"
"        }\n"
"      };\n"
"      initializeErrorSets();\n"
"      const objectPlaceholders = new Map();\n"
"      for (const structure of structures) {\n"
"        // recreate the actual template using the provided placeholder\n"
"        for (const scope of [ structure.instance, structure.static ]) {\n"
"          if (scope.template) {\n"
"            const placeholder = scope.template;\n"
"            const template = scope.template = {};\n"
"            if (placeholder.memory) {\n"
"              const { array, offset, length } = placeholder.memory;\n"
"              template[MEMORY] = this.obtainView(array.buffer, offset, length);\n"
"            }\n"
"            if (placeholder.slots) {\n"
"              // defer creation of objects until shapes of structures are finalized\n"
"              const slots = template[SLOTS] = {};\n"
"              objectPlaceholders.set(slots, placeholder.slots); \n"
"            }   \n"
"          }\n"
"        }\n"
"        this.finalizeShape(structure);\n"
"      }\n"
"      // insert objects into template slots\n"
"      for (const [ slots, placeholders ] of objectPlaceholders) {\n"
"        insertObjects(slots, placeholders);\n"
"      }\n"
"      // add static members, methods, etc.\n"
"      for (const structure of structures) {\n"
"        this.finalizeStructure(structure);\n"
"      }\n"
"    }\n"
"\n"
"    linkVariables(writeBack) {\n"
"      for (const { object, reloc } of this.variables) {\n"
"        this.linkObject(object, reloc, writeBack);\n"
"      }\n"
"    }\n"
"\n"
"    linkObject(object, reloc, writeBack) {\n"
"      if (this.inFixedMemory(object)) {\n"
"        return;\n"
"      }\n"
"      const dv = object[MEMORY];\n"
"      if (dv.byteLength !== 0) {\n"
"        const address = this.recreateAddress(reloc);\n"
"        const fixedDV = this.obtainFixedView(address, dv.byteLength);\n"
"        if (writeBack) {\n"
"          const dest = Object.create(object.constructor.prototype);\n"
"          dest[MEMORY] = fixedDV;\n"
"          dest[COPIER](object);\n"
"        }\n"
"        object[MEMORY] = fixedDV;\n"
"      }\n"
"    }\n"
"\n"
"    unlinkVariables() {\n"
"      for (const { object } of this.variables) {\n"
"        this.unlinkObject(object);\n"
"      }\n"
"    }\n"
"\n"
"    unlinkObject(object) {\n"
"      if (!this.inFixedMemory(object)) {\n"
"        return;\n"
"      }\n"
"      const dv = object[MEMORY];\n"
"      const relocDV = this.allocateMemory(dv.byteLength);\n"
"      const dest = Object.create(object.constructor.prototype);\n"
"      dest[MEMORY] = relocDV;\n"
"      dest[COPIER](object);\n"
"      object[MEMORY] = relocDV;\n"
"    }\n"
"\n"
"    releaseFunctions() {\n"
"      const throwError = function() {\n"
"        throw new Error(`Module was abandoned`);\n"
"      };\n"
"      for (const name of Object.keys(this.imports)) {\n"
"        if (this[name]) {\n"
"          this[name] = throwError;\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    getControlObject() {\n"
"      return {\n"
"        init: () => this.initPromise ?? Promise.resolve(),\n"
"        abandon: () => this.abandon(),\n"
"        released: () => this.released,\n"
"      }\n"
"    }\n"
"\n"
"    abandon() {\n"
"      if (!this.abandoned) {\n"
"        this.releaseFunctions();\n"
"        this.unlinkVariables();\n"
"        this.abandoned = true;\n"
"      }\n"
"    }\n"
"\n"
"    writeToConsole(dv) {\n"
"      try {\n"
"        // make copy of array, in case incoming buffer is pointing to stack memory\n"
"        const array = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength).slice();\n"
"        // send text up to the last newline character\n"
"        const index = array.lastIndexOf(0x0a);\n"
"        if (index === -1) {\n"
"          this.consolePending.push(array);\n"
"        } else {\n"
"          const beginning = array.subarray(0, index);\n"
"          const remaining = array.subarray(index + 1);\n"
"          const list = [ ...this.consolePending, beginning ];\n"
"          console.log(decodeText(list));\n"
"          this.consolePending = (remaining.length > 0) ? [ remaining ] : [];\n"
"        }\n"
"        clearTimeout(this.consoleTimeout);\n"
"        if (this.consolePending.length > 0) {\n"
"          this.consoleTimeout = setTimeout(() => {\n"
"            console.log(decodeText(this.consolePending));\n"
"            this.consolePending = [];\n"
"          }, 250);\n"
"        }\n"
"        /* c8 ignore next 3 */\n"
"      } catch (err) {\n"
"        console.error(err);\n"
"      }\n"
"    }\n"
"\n"
"    flushConsole() {\n"
"      if (this.consolePending.length > 0) {\n"
"        console.log(decodeText(this.consolePending));\n"
"        this.consolePending = [];\n"
"        clearTimeout(this.consoleTimeout);\n"
"      }\n"
"    }\n"
"\n"
"    updatePointerAddresses(args) {\n"
"      // first, collect all the pointers\n"
"      const pointerMap = new Map();\n"
"      const bufferMap = new Map();\n"
"      const potentialClusters = [];\n"
"      const env = this;\n"
"      const callback = function({ isActive }) {\n"
"        if (!isActive(this)) {\n"
"          return;\n"
"        }\n"
"        // bypass proxy\n"
"        const pointer = this[POINTER];\n"
"        if (pointerMap.get(pointer)) {\n"
"          return;\n"
"        }\n"
"        const target = pointer[SLOTS][0];\n"
"        if (target) {\n"
"          pointerMap.set(pointer, target);\n"
"          if (!env.inFixedMemory(target)) {\n"
"            // see if the buffer is shared with other objects\n"
"            const dv = target[MEMORY];\n"
"            const other = bufferMap.get(dv.buffer);\n"
"            if (other) {\n"
"              const array = Array.isArray(other) ? other : [ other ];\n"
"              const index = findSortedIndex(array, dv.byteOffset, t => t[MEMORY].byteOffset);\n"
"              array.splice(index, 0, target);\n"
"              if (!Array.isArray(other)) {\n"
"                bufferMap.set(dv.buffer, array);\n"
"                potentialClusters.push(array);\n"
"              }\n"
"            } else {\n"
"              bufferMap.set(dv.buffer, target);\n"
"            }\n"
"            // scan pointers in target\n"
"            target[VISITOR]?.(callback);\n"
"          }\n"
"        }\n"
"      };\n"
"      args[VISITOR](callback);\n"
"      // find targets that overlap each other\n"
"      const clusters = this.findTargetClusters(potentialClusters);\n"
"      const clusterMap = new Map();\n"
"      for (const cluster of clusters) {\n"
"        for (const target of cluster.targets) {\n"
"          clusterMap.set(target, cluster);\n"
"        }\n"
"      }\n"
"      // process the pointers\n"
"      for (const [ pointer, target ] of pointerMap) {\n"
"        const cluster = clusterMap.get(target);\n"
"        let address = this.getTargetAddress(target, cluster);\n"
"        if (address === false) {\n"
"          // need to shadow the object\n"
"          address = this.getShadowAddress(target, cluster);\n"
"        }\n"
"        // update the pointer\n"
"        pointer[SETTER](address, target.length);\n"
"      }\n"
"    }\n"
"\n"
"    findTargetClusters(potentialClusters) {\n"
"      const clusters = [];\n"
"      for (const targets of potentialClusters) {\n"
"        let prevTarget = null, prevStart = 0, prevEnd = 0;\n"
"        let currentCluster = null;\n"
"        for (const target of targets) {\n"
"          const dv = target[MEMORY];\n"
"          const { byteOffset: start, byteLength } = dv;\n"
"          const end = start + byteLength;\n"
"          let forward = true;\n"
"          if (prevTarget) {\n"
"            if (prevEnd > start) {\n"
"              // the previous target overlaps this one\n"
"              if (!currentCluster) {\n"
"                currentCluster = {\n"
"                  targets: [ prevTarget ],\n"
"                  start: prevStart,\n"
"                  end: prevEnd,\n"
"                  address: undefined,\n"
"                  misaligned: undefined,\n"
"                };\n"
"                clusters.push(currentCluster);\n"
"              }\n"
"              currentCluster.targets.push(target);\n"
"              if (end > prevEnd) {\n"
"                // set cluster end offset to include this one\n"
"                currentCluster.end = end;\n"
"              } else {\n"
"                // the previous target contains this one\n"
"                forward = false;\n"
"              }\n"
"            } else {\n"
"              currentCluster = null;\n"
"            }\n"
"          }\n"
"          if (forward) {\n"
"            prevTarget = target;\n"
"            prevStart = start;\n"
"            prevEnd = end;\n"
"          }\n"
"        }\n"
"      }\n"
"      return clusters;\n"
"    }\n"
"\n"
"    createClusterShadow(cluster) {\n"
"      const { start, end, targets } = cluster;\n"
"      // look for largest align\n"
"      let maxAlign = 0, maxAlignOffset;\n"
"      for (const target of targets) {\n"
"        const offset = target[MEMORY].byteOffset;\n"
"        const align = target.constructor[ALIGN];\n"
"        if (maxAlign === undefined || align > maxAlign) {\n"
"          maxAlign = align;\n"
"          maxAlignOffset = offset;\n"
"        }\n"
"      }\n"
"      // ensure the shadow buffer is large enough to accommodate necessary adjustments\n"
"      const len = end - start;\n"
"      const unalignedShadowDV = this.allocateShadowMemory(len + maxAlign, 1);\n"
"      const unalignedAddress = this.getViewAddress(unalignedShadowDV);\n"
"      const maxAlignAddress = getAlignedAddress(add(unalignedAddress, maxAlignOffset), maxAlign);\n"
"      const shadowAddress = subtract(maxAlignAddress, maxAlignOffset);\n"
"      const shadowOffset = unalignedShadowDV.byteOffset + Number(shadowAddress - unalignedAddress);\n"
"      const shadowDV = new DataView(unalignedShadowDV.buffer, shadowOffset, len);\n"
"      // make sure that other pointers are correctly aligned also\n"
"      for (const target of targets) {\n"
"        const offset = target[MEMORY].byteOffset;\n"
"        if (offset !== maxAlignOffset) {\n"
"          const align = target.constructor[ALIGN];\n"
"          if (isMisaligned(add(shadowAddress, offset), align)) {\n"
"            throwAlignmentConflict(align, maxAlign);\n"
"          }\n"
"        }\n"
"      }\n"
"      // placeholder object type\n"
"      const prototype = {\n"
"        [COPIER]: getMemoryCopier(len)\n"
"      };\n"
"      const source = Object.create(prototype);\n"
"      const shadow = Object.create(prototype);\n"
"      source[MEMORY] = new DataView(targets[0][MEMORY].buffer, Number(start), len);\n"
"      shadow[MEMORY] = shadowDV;\n"
"      shadow[ATTRIBUTES] = {\n"
"        address: unalignedAddress,\n"
"        len: unalignedShadowDV.byteLength,\n"
"        align: 1,\n"
"      };\n"
"      return this.addShadow(shadow, source);\n"
"    }\n"
"    /* RUNTIME-ONLY-END */\n"
"\n"
"    getShadowAddress(target, cluster) {\n"
"      if (cluster) {\n"
"        const dv = target[MEMORY];\n"
"        if (cluster.address === undefined) {\n"
"          const shadow = this.createClusterShadow(cluster);\n"
"          cluster.address = this.getViewAddress(shadow[MEMORY]);\n"
"        }\n"
"        return add(cluster.address, dv.byteOffset);\n"
"      } else {\n"
"        const shadow = this.createShadow(target);\n"
"        return this.getViewAddress(shadow[MEMORY]);\n"
"      }\n"
"    }\n"
"\n"
"    createShadow(object) {\n"
"      const dv = object[MEMORY];\n"
"      const align = object.constructor[ALIGN];\n"
"      const shadow = Object.create(object.constructor.prototype);\n"
"      const shadowDV = shadow[MEMORY] = this.allocateShadowMemory(dv.byteLength, align);\n"
"      shadow[ATTRIBUTES] = {\n"
"        address: this.getViewAddress(shadowDV),\n"
"        len: shadowDV.byteLength,\n"
"        align: align,\n"
"      };\n"
"      return this.addShadow(shadow, object);\n"
"    }\n"
"\n"
"    addShadow(shadow, object) {\n"
"      let { shadowMap } = this.context;\n"
"      if (!shadowMap) {\n"
"        shadowMap = this.context.shadowMap = new Map();\n"
"      }\n"
"      shadowMap.set(shadow, object);\n"
"      this.registerMemory(shadow[MEMORY], object[MEMORY]);\n"
"      return shadow;\n"
"    }\n"
"\n"
"    removeShadow(dv) {\n"
"      const { shadowMap } = this.context;\n"
"      if (shadowMap) {\n"
"        for (const [ shadow ] of shadowMap) {\n"
"          if (shadow[MEMORY] === dv) {\n"
"            shadowMap.delete(shadow);\n"
"            break;\n"
"          }\n"
"        }\n"
"      }\n"
"    }\n"
"\n"
"    updateShadows() {\n"
"      const { shadowMap } = this.context;\n"
"      if (!shadowMap) {\n"
"        return;\n"
"      }\n"
"      for (const [ shadow, object ] of shadowMap) {\n"
"        shadow[COPIER](object);\n"
"      }\n"
"    }\n"
"\n"
"    updateShadowTargets() {\n"
"      const { shadowMap } = this.context;\n"
"      if (!shadowMap) {\n"
"        return;\n"
"      }\n"
"      for (const [ shadow, object ] of shadowMap) {\n"
"        object[COPIER](shadow);\n"
"      }\n"
"    }\n"
"\n"
"    releaseShadows() {\n"
"      const { shadowMap } = this.context;\n"
"      if (!shadowMap) {\n"
"        return;\n"
"      }\n"
"      for (const [ shadow ] of shadowMap) {\n"
"        const { address, len, align } = shadow[ATTRIBUTES];\n"
"        this.freeShadowMemory(address, len, align);\n"
"      }\n"
"    }\n"
"\n"
"    acquirePointerTargets(args) {\n"
"      const env = this;\n"
"      const pointerMap = new Map();\n"
"      const callback = function({ isActive, isMutable }) {\n"
"        const pointer = this[POINTER];\n"
"        if (pointerMap.get(pointer)) {\n"
"          return;\n"
"        } else {\n"
"          pointerMap.set(pointer, true);\n"
"        }\n"
"        const writable = !pointer.constructor.const;\n"
"        const currentTarget = pointer[SLOTS][0];\n"
"        let newTarget = null;\n"
"        if (isActive(this)) {\n"
"          const Target = pointer.constructor.child;\n"
"          if (!currentTarget || isMutable(this)) {\n"
"            // obtain address (and possibly length) from memory\n"
"            const [ address, length ] = pointer[GETTER]();\n"
"            // get view of memory that pointer points to\n"
"            const byteLength = length * Target[SIZE];\n"
"            const dv = env.findMemory(address, byteLength);\n"
"            // create the target\n"
"            newTarget = Target.call(ENVIRONMENT, dv, { writable });\n"
"\n"
"          } else {\n"
"            newTarget = currentTarget;\n"
"          }\n"
"        }\n"
"        // acquire objects pointed to by pointers in target\n"
"        currentTarget?.[VISITOR]?.(callback, { vivificate: true, isMutable: () => writable });\n"
"        if (newTarget !== currentTarget) {\n"
"          newTarget?.[VISITOR]?.(callback, { vivificate: true, isMutable: () => writable });\n"
"          pointer[SLOTS][0] = newTarget;\n"
"        }\n"
"      };\n"
"      args[VISITOR](callback, { vivificate: true });\n"
"    }\n"
"\n"
"    /* COMPTIME-ONLY */\n"
"    acquireDefaultPointers(structure) {\n"
"      const { constructor, hasPointer, instance: { template } } = structure;\n"
"      if (hasPointer && template && template[MEMORY]) {\n"
"        // create a placeholder for retrieving default pointers\n"
"        const placeholder = Object.create(constructor.prototype);\n"
"        placeholder[MEMORY] = template[MEMORY];\n"
"        placeholder[SLOTS] = template[SLOTS];\n"
"        this.acquirePointerTargets(placeholder);\n"
"      }\n"
"    }\n"
"    /* COMPTIME-ONLY-END */\n"
"  }\n"
"\n"
"  class CallContext {\n"
"    pointerProcessed = new Map();\n"
"    memoryList = [];\n"
"    shadowMap = null;\n"
"  }\n"
"\n"
"  function findSortedIndex(array, value, cb) {\n"
"    let low = 0;\n"
"    let high = array.length;\n"
"    if (high === 0) {\n"
"      return 0;\n"
"    }\n"
"    while (low < high) {\n"
"      const mid = Math.floor((low + high) / 2);\n"
"      const value2 = cb(array[mid]);\n"
"      if (value2 <= value) {\n"
"        low = mid + 1;\n"
"      } else {\n"
"        high = mid;\n"
"      }\n"
"    }\n"
"    return high;\n"
"  }\n"
"\n"
"  function findMemoryIndex(array, address) {\n"
"    return findSortedIndex(array, address, m => m.address);\n"
"  }\n"
"\n"
"  function isMisaligned(address, align) {\n"
"    if (typeof(address) === 'bigint') {\n"
"      address = Number(address & 0xFFFFFFFFn);\n"
"    }\n"
"    const mask = align - 1;\n"
"    return (address & mask) !== 0;\n"
"  }\n"
"\n"
"  function getAlignedAddress(address, align) {\n"
"    let mask;\n"
"    if (typeof(address) === 'bigint') {\n"
"      align = BigInt(align);\n"
"      mask = ~(align - 1n);\n"
"    } else {\n"
"      mask = ~(align - 1);\n"
"    }\n"
"    return (address & mask) + align;\n"
"  }\n"
"\n"
"  function add(address, len) {\n"
"    return address + ((typeof(address) === 'bigint') ? BigInt(len) : len);\n"
"  }\n"
"\n"
"  function subtract(address, len) {\n"
"    return address - ((typeof(address) === 'bigint') ? BigInt(len) : len);\n"
"  }\n"
"\n"
"  class NodeEnvironment extends Environment {\n"
"    // C code will patch in these functions:\n"
"    imports = {\n"
"      extractBufferAddress: null,\n"
"      allocateExternMemory: null,\n"
"      freeExternMemory: null,\n"
"      obtainExternBuffer: null,\n"
"      copyBytes: null,\n"
"      findSentinel: null,\n"
"      defineStructures: null,\n"
"      runThunk: null,\n"
"      getMemoryOffset: null,\n"
"      recreateAddress: null,\n"
"    };\n"
"    // use a weak map to store the addresses of shared buffer, so that Zig code can free the \n"
"    // underlying memory without causing a crash; basically, we don't want to ask V8 to return\n"
"    // the buffer's backing store if there's a chance that the memory is no longer there\n"
"    addressMap = new WeakMap();\n"
"\n"
"    getBufferAddress(buffer) {\n"
"      let address = this.addressMap.get(buffer);\n"
"      if (address === undefined) {\n"
"        address = this.extractBufferAddress(buffer);\n"
"      }\n"
"      return address;\n"
"    }\n"
"\n"
"    allocateRelocMemory(len, align) {\n"
"      const dv = this.createAlignedBuffer(len, align);\n"
"      this.registerMemory(dv);\n"
"      return dv;\n"
"    }\n"
"\n"
"    freeRelocMemory(address, len, align) {\n"
"      this.unregisterMemory(address);\n"
"    }\n"
"\n"
"    allocateShadowMemory(len, align) {\n"
"      return this.createAlignedBuffer(len, align);\n"
"    }\n"
"\n"
"    freeShadowMemory(address, len, align) {\n"
"      // nothing needs to happen\n"
"    }\n"
"\n"
"    allocateFixedMemory(len, align) {\n"
"      if (len === 0) {\n"
"        return this.obtainView(new ArrayBuffer(0));\n"
"      }\n"
"      const buffer = this.allocateExternMemory(len, align);\n"
"      const address = this.extractBufferAddress(buffer);\n"
"      this.addressMap.set(buffer, address);\n"
"      const dv = this.obtainView(buffer, 0, len);\n"
"      dv[ALIGN] = align;\n"
"      return dv;\n"
"    }\n"
"\n"
"    freeFixedMemory(address, len, align) {\n"
"      if (len === 0) {\n"
"        return;\n"
"      }\n"
"      this.freeExternMemory(address, len, align);\n"
"    }\n"
"\n"
"    obtainFixedView(address, len) {\n"
"      if (len === 0) {\n"
"        return this.obtainView(new ArrayBuffer(0));\n"
"      }\n"
"      const buffer = this.obtainExternBuffer(address, len);\n"
"      this.addressMap.set(buffer, address);\n"
"      return this.obtainView(buffer, 0, len);\n"
"    }\n"
"\n"
"    releaseFixedView(dv) {\n"
"      const address = this.addressMap.get(dv.buffer);\n"
"      const len = dv.byteLength;\n"
"      const align = dv[ALIGN];\n"
"      if (address !== undefined && align !== undefined) {\n"
"        this.freeFixedMemory(address, len, align);\n"
"        this.addressMap.delete(dv.buffer);\n"
"      }\n"
"    }\n"
"\n"
"    inFixedMemory(object) {\n"
"      return this.addressMap.has(object[MEMORY].buffer);\n"
"    }\n"
"\n"
"    getTargetAddress(target, cluster) {\n"
"      const dv = target[MEMORY];\n"
"      if (cluster) {\n"
"        // pointer is pointing to buffer with overlapping views\n"
"        if (cluster.misaligned === undefined) {\n"
"          const address = this.getBufferAddress(dv.buffer);\n"
"          // ensure that all pointers are properly aligned\n"
"          for (const target of cluster.targets) {\n"
"            const offset = target[MEMORY].byteOffset;\n"
"            const align = target.constructor[ALIGN];\n"
"            const viewAddress = add(address, offset);\n"
"            if (isMisaligned(viewAddress, align)) {\n"
"              cluster.misaligned = true;\n"
"              break;\n"
"            }\n"
"          }\n"
"          if (cluster.misaligned === undefined)  {\n"
"            cluster.misaligned = false;\n"
"            cluster.address = address;\n"
"          }\n"
"        }\n"
"        return (cluster.misaligned) ? false : add(cluster.address, dv.byteOffset);\n"
"      } else {\n"
"        const align = target.constructor[ALIGN];\n"
"        const address = this.getViewAddress(dv);\n"
"        if (isMisaligned(address, align)) {\n"
"          return false;\n"
"        }\n"
"        this.registerMemory(dv);\n"
"        return address;\n"
"      }\n"
"    }\n"
"\n"
"    createAlignedBuffer(len, align) {\n"
"      // allocate extra memory for alignment purpose when align is larger than the default\n"
"      const extra = (align > 16) ? align : 0;\n"
"      const buffer = new ArrayBuffer(len + extra);\n"
"      let offset = 0;\n"
"      if (extra) {\n"
"        const address = this.getBufferAddress(buffer);\n"
"        const aligned = getAlignedAddress(address, align);\n"
"        offset = aligned - address;\n"
"      }\n"
"      return this.obtainView(buffer, Number(offset), len);\n"
"    }\n"
"\n"
"    invokeThunk(thunkId, args) {\n"
"      let err;\n"
"      // create an object where information concerning pointers can be stored\n"
"      this.startContext();\n"
"      if (args[VISITOR]) {\n"
"        // copy addresses of garbage-collectible objects into memory\n"
"        this.updatePointerAddresses(args);\n"
"        this.updateShadows();\n"
"        err = this.runThunk(thunkId, args[MEMORY]);\n"
"        // create objects that pointers point to\n"
"        this.updateShadowTargets();\n"
"        this.acquirePointerTargets(args);\n"
"        this.releaseShadows();\n"
"      } else {\n"
"        // don't need to do any of that if there're no pointers\n"
"        err = this.runThunk(thunkId, args[MEMORY]);\n"
"      }\n"
"      // restore the previous context if there's one\n"
"      this.endContext();\n"
"      if (!this.context) {\n"
"        this.flushConsole();\n"
"      }\n"
"      // errors returned by exported Zig functions are normally written into the\n"
"      // argument object and get thrown when we access its retval property (a zig error union)\n"
"      // error strings returned by the thunk are due to problems in the thunking process\n"
"      // (i.e. bugs in export.zig)\n"
"      if (err) {\n"
"        throwZigError(err);\n"
"      }\n"
"      return args.retval;\n"
"    }\n"
"  }\n"
"\n"
"  useAllMemberTypes();\n"
"  useAllStructureTypes();\n"
"\n"
"  exports.Environment = NodeEnvironment;\n"
"\n"
"  return exports;\n"
"\n"
"})({}))"
