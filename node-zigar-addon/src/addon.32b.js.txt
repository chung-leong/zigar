"((function (exports) {\n"
"  'use strict';\n"
"\n"
"  const StructureType = {\n"
"    Primitive: 0,\n"
"    Array: 1,\n"
"    Struct: 2,\n"
"    Union: 3,\n"
"    ErrorUnion: 4,\n"
"    ErrorSet: 5,\n"
"    Enum: 6,\n"
"    Optional: 7,\n"
"    Pointer: 8,\n"
"    Slice: 9,\n"
"    Vector: 10,\n"
"    Opaque: 11,\n"
"    ArgStruct: 12,\n"
"    VariadicStruct: 13,\n"
"    Function: 14,\n"
"  };\n"
"  const structureNames = Object.keys(StructureType);\n"
"  const StructureFlag = {\n"
"    HasValue:         0x0001,\n"
"    HasObject:        0x0002,\n"
"    HasPointer:       0x0004,\n"
"    HasSlot:          0x0008,\n"
"  };\n"
"  const PrimitiveFlag = {\n"
"    IsSize:           0x0010,\n"
"  };\n"
"  const ArrayFlag = {\n"
"    HasSentinel:      0x0010,\n"
"    IsString:         0x0020,\n"
"    IsTypedArray:     0x0040,\n"
"    IsClampedArray:   0x0080,\n"
"  };\n"
"  const StructFlag = {\n"
"    IsExtern:         0x0010,\n"
"    IsPacked:         0x0020,\n"
"    IsIterator:       0x0040,\n"
"    IsTuple:          0x0080,\n"
"\n"
"    IsAllocator:      0x0100,\n"
"    IsPromise:        0x0200,\n"
"    IsAbortSignal:    0x0400,\n"
"  };\n"
"  const UnionFlag = {\n"
"    HasSelector:      0x0010,\n"
"    HasTag:           0x0020,\n"
"    HasInaccessible:  0x0040,\n"
"    IsExtern:         0x0080,\n"
"\n"
"    IsPacked:         0x0100,\n"
"    IsIterator:       0x0200,\n"
"  };\n"
"  const EnumFlag = {\n"
"    IsOpenEnded:      0x0010,\n"
"    IsIterator:       0x0020,\n"
"  };\n"
"  const OptionalFlag = {\n"
"    HasSelector:      0x0010,\n"
"  };\n"
"  const PointerFlag = {\n"
"    HasLength:        0x0010,\n"
"    IsMultiple:       0x0020,\n"
"    IsSingle:         0x0040,\n"
"    IsConst:          0x0080,\n"
"\n"
"    IsNullable:       0x0100,\n"
"  };\n"
"  const SliceFlag = {\n"
"    HasSentinel:      0x0010,\n"
"    IsString:         0x0020,\n"
"    IsTypedArray:     0x0040,\n"
"    IsClampedArray:   0x0080,\n"
"\n"
"    IsOpaque:         0x0100,\n"
"  };\n"
"  const ErrorSetFlag = {\n"
"    IsGlobal:         0x0010,\n"
"  };\n"
"  const OpaqueFlag = {\n"
"    IsIterator:       0x0010,\n"
"  };\n"
"  const VectorFlag = {\n"
"    IsTypedArray:     0x0010,\n"
"    IsClampedArray:   0x0020,\n"
"  };\n"
"  const ArgStructFlag = {\n"
"    HasOptions:       0x0010,\n"
"    IsThrowing:       0x0020,\n"
"    IsAsync:          0x0040,\n"
"  };\n"
"\n"
"  const MemberType = {\n"
"    Void: 0,\n"
"    Bool: 1,\n"
"    Int: 2,\n"
"    Uint: 3,\n"
"    Float: 4,\n"
"    Object: 5,\n"
"    Type: 6,\n"
"    Literal: 7,\n"
"    Null: 8,\n"
"    Undefined: 9,\n"
"    Unsupported: 10,\n"
"  };\n"
"  const memberNames = Object.keys(MemberType);\n"
"  const MemberFlag = {\n"
"    IsRequired:       0x0001,\n"
"    IsReadOnly:       0x0002,\n"
"    IsPartOfSet:      0x0004,\n"
"    IsSelector:       0x0008,\n"
"    IsMethod:         0x0010,\n"
"    IsSentinel:       0x0020,\n"
"    IsBackingInt:     0x0040,\n"
"  };\n"
"\n"
"  const ExportFlag = {\n"
"    OmitMethods:      0x0001,\n"
"    OmitVariables:    0x0002,\n"
"  };\n"
"\n"
"  const CallResult = {\n"
"    OK: 0,\n"
"    Failure: 1,\n"
"    Deadlock: 2,\n"
"    Disabled: 3,\n"
"  };\n"
"\n"
"  const Action = {\n"
"    Call: 0,\n"
"    Release: 1,\n"
"  };\n"
"\n"
"  const ModuleAttribute = {\n"
"    LittleEndian:     0x0001,\n"
"    RuntimeSafety:    0x0002,\n"
"    LibC:             0x0004,\n"
"  };\n"
"\n"
"  const MEMORY = Symbol('memory');\n"
"  const SLOTS = Symbol('slots');\n"
"  const PARENT = Symbol('parent');\n"
"  const ZIG = Symbol('zig');\n"
"  const NAME = Symbol('name');\n"
"  const TYPE = Symbol('type');\n"
"  const FLAGS = Symbol('flags');\n"
"  const CLASS = Symbol('class');\n"
"  const TAG = Symbol('tag');\n"
"  const PROPS = Symbol('props');\n"
"  const POINTER = Symbol('pointer');\n"
"  const SENTINEL = Symbol('sentinel');\n"
"  const ARRAY = Symbol('array');\n"
"  const TARGET = Symbol('target');\n"
"  const ENTRIES = Symbol('entries');\n"
"  const MAX_LENGTH = Symbol('maxLength');\n"
"  const KEYS = Symbol('keys');\n"
"  const ADDRESS = Symbol('address');\n"
"  const LENGTH = Symbol('length');\n"
"  const LAST_ADDRESS = Symbol('lastAddress');\n"
"  const LAST_LENGTH = Symbol('lastLength');\n"
"  const PROXY = Symbol('proxy');\n"
"  const CACHE = Symbol('cache');\n"
"  const SIZE = Symbol('size');\n"
"  const BIT_SIZE = Symbol('bitSize');\n"
"  const ALIGN = Symbol('align');\n"
"  const CONST_TARGET = Symbol('constTarget');\n"
"  const CONST_PROXY = Symbol('constProxy');\n"
"  const ENVIRONMENT = Symbol('environment');\n"
"  const ATTRIBUTES = Symbol('attributes');\n"
"  const PRIMITIVE = Symbol('primitive');\n"
"  const GETTERS = Symbol('getters');\n"
"  const SETTERS = Symbol('setters');\n"
"  const TYPED_ARRAY = Symbol('typedArray');\n"
"  const THROWING = Symbol('throwing');\n"
"  const PROMISE = Symbol('promise');\n"
"  const CONTEXT = Symbol('context');\n"
"  const FALLBACK = Symbol('fallback');\n"
"\n"
"  const UPDATE = Symbol('update');\n"
"  const RESET = Symbol('resetter');\n"
"  const VIVIFICATE = Symbol('vivificate');\n"
"  const VISIT = Symbol('visit');\n"
"  const COPY = Symbol('copy');\n"
"  const SHAPE = Symbol('shape');\n"
"  const MODIFY = Symbol('modify');\n"
"  const INITIALIZE = Symbol('initialize');\n"
"  const FINALIZE = Symbol('finalize');\n"
"  const CAST = Symbol('cast');\n"
"\n"
"  function defineProperty(object, name, descriptor) {\n"
"    if (descriptor) {\n"
"      const {\n"
"        set,\n"
"        get,\n"
"        value,\n"
"        enumerable,\n"
"        configurable = true,\n"
"        writable = true,\n"
"      } = descriptor;\n"
"      Object.defineProperty(object, name, (get || set)\n"
"        ? { get, set, configurable, enumerable }\n"
"        : { value, configurable, enumerable, writable }\n"
"      );\n"
"    }\n"
"    return object;\n"
"  }\n"
"\n"
"  function defineProperties(object, descriptors) {\n"
"    for (const [ name, descriptor ] of Object.entries(descriptors)) {\n"
"      defineProperty(object, name, descriptor);\n"
"    }\n"
"    for (const symbol of Object.getOwnPropertySymbols(descriptors)) {\n"
"      const descriptor = descriptors[symbol];\n"
"      defineProperty(object, symbol, descriptor);\n"
"    }\n"
"    return object;\n"
"  }\n"
"\n"
"  function defineValue(value) {\n"
"    return (value !== undefined) ? { value } : undefined;\n"
"  }\n"
"\n"
"  function getPrimitiveName({ type, bitSize }) {\n"
"    switch (type) {\n"
"      case MemberType.Bool: return 'boolean';\n"
"      case MemberType.Int:\n"
"      case MemberType.Uint:\n"
"        if (bitSize > 32) {\n"
"          return 'bigint';\n"
"        }\n"
"      case MemberType.Float: return 'number';\n"
"    }\n"
"  }\n"
"\n"
"  function decodeText(arrays, encoding = 'utf-8') {\n"
"    const decoder = decoders[encoding] ??= new TextDecoder(encoding);\n"
"    let array;\n"
"    if (Array.isArray(arrays)) {\n"
"      if (arrays.length === 1) {\n"
"        array = arrays[0];\n"
"      } else {\n"
"        let len = 0;\n"
"        for (const a of arrays) {\n"
"          len += a.length;\n"
"        }\n"
"        const { constructor } = arrays[0];\n"
"        array = new constructor(len);\n"
"        let offset = 0;\n"
"        for (const a of arrays) {\n"
"          array.set(a, offset);\n"
"          offset += a.length;\n"
"        }\n"
"      }\n"
"    } else {\n"
"      array = arrays;\n"
"    }\n"
"    return decoder.decode(array);\n"
"  }\n"
"\n"
"  function encodeText(text, encoding = 'utf-8') {\n"
"    switch (encoding) {\n"
"      case 'utf-16': {\n"
"        const { length } = text;\n"
"        const ta = new Uint16Array(length);\n"
"        for (let i = 0; i < length; i++) {\n"
"          ta[i] = text.charCodeAt(i);\n"
"        }\n"
"        return ta;\n"
"      }\n"
"      default: {\n"
"        const encoder = encoders[encoding] ??= new TextEncoder();\n"
"        return encoder.encode(text);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function encodeBase64(dv) {\n"
"    {\n"
"      if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {\n"
"        return Buffer.from(dv.buffer, dv.byteOffset, dv.byteLength).toString('base64');\n"
"      }\n"
"    }\n"
"    const ta = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength);\n"
"    const bstr = String.fromCharCode.apply(null, ta);\n"
"    return btoa(bstr);\n"
"  }\n"
"\n"
"  function decodeBase64(str) {\n"
"    {\n"
"      if (typeof(Buffer) === 'function' && Buffer.prototype instanceof Uint8Array) {\n"
"        const b = Buffer.from(str, 'base64');\n"
"        return new DataView(b.buffer, b.byteOffset, b.byteLength);\n"
"      }\n"
"    }\n"
"    const bstr = atob(str);\n"
"    const ta = new Uint8Array(bstr.length);\n"
"    for (let i = 0; i < ta.byteLength; i++) {\n"
"      ta[i] = bstr.charCodeAt(i);\n"
"    }\n"
"    return new DataView(ta.buffer);\n"
"  }\n"
"\n"
"  const decoders = {};\n"
"  const encoders = {};\n"
"\n"
"  function findSortedIndex(array, value, cb) {\n"
"    let low = 0;\n"
"    let high = array.length;\n"
"    if (high === 0) {\n"
"      return 0;\n"
"    }\n"
"    while (low < high) {\n"
"      const mid = Math.floor((low + high) / 2);\n"
"      const value2 = cb(array[mid]);\n"
"      if (value2 <= value) {\n"
"        low = mid + 1;\n"
"      } else {\n"
"        high = mid;\n"
"      }\n"
"    }\n"
"    return high;\n"
"  }\n"
"\n"
"  const isMisaligned = function(address, align) {\n"
"      return (align) ? !!(address & (align - 1)) : false;\n"
"    }\n"
"    /* c8 ignore next */\n"
"  ;\n"
"\n"
"  const alignForward = function(address, align) {\n"
"      return (address + (align - 1)) & ~(align - 1);\n"
"    }\n"
"    /* c8 ignore next */\n"
"  ;\n"
"\n"
"  const usizeMin = 0;\n"
"  const usizeMax = 0xFFFF_FFFF;\n"
"  const usizeInvalid = -1;\n"
"\n"
"  const usize = function(arg) {\n"
"      return Number(arg);\n"
"    }\n"
"    /* c8 ignore next */\n"
"  ;\n"
"\n"
"  const isInvalidAddress = function(address) {\n"
"      return address === 0xaaaaaaaa;\n"
"    }\n"
"    /* c8 ignore next */\n"
"  ;\n"
"\n"
"  const adjustAddress = function(address, addend) {\n"
"      return address + addend;\n"
"    }\n"
"    /* c8 ignore next */\n"
"  ;\n"
"\n"
"  function transformIterable(arg) {\n"
"    if (typeof(arg.length) === 'number') {\n"
"      // it's an array of sort\n"
"      return arg;\n"
"    }\n"
"    const iterator = arg[Symbol.iterator]();\n"
"    const first = iterator.next();\n"
"    const length = first.value?.length;\n"
"    if (typeof(length) === 'number' && Object.keys(first.value).join() === 'length') {\n"
"      // return generator with length attached\n"
"      return Object.assign((function*() {\n"
"        let result;\n"
"        while (!(result = iterator.next()).done) {\n"
"          yield result.value;\n"
"        }\n"
"      })(), { length });\n"
"    } else {\n"
"      const array = [];\n"
"      let result = first;\n"
"      while (!result.done) {\n"
"        array.push(result.value);\n"
"        result = iterator.next();\n"
"      }\n"
"      return array;\n"
"    }\n"
"  }\n"
"\n"
"  function findElements(arg, Child) {\n"
"    // casting to a array/slice\n"
"    const { constructor: Arg } = arg;\n"
"    if (Arg === Child) {\n"
"      // matching object\n"
"      return 1;\n"
"    } else if (Arg.child === Child) {\n"
"      // matching slice/array\n"
"      return arg.length;\n"
"    }\n"
"  }\n"
"\n"
"  function findObjects(structures, SLOTS) {\n"
"    const list = [];\n"
"    const found = new Map();\n"
"    const find = (object) => {\n"
"      if (!object || found.get(object)) {\n"
"        return;\n"
"      }\n"
"      found.set(object, true);\n"
"      list.push(object);\n"
"      if (object[SLOTS]) {\n"
"        for (const child of Object.values(object[SLOTS])) {\n"
"          find(child);\n"
"        }\n"
"      }\n"
"    };\n"
"    for (const structure of structures) {\n"
"      find(structure.instance.template);\n"
"      find(structure.static.template);\n"
"    }\n"
"    return list;\n"
"  }\n"
"\n"
"  function markAsSpecial({ get, set }) {\n"
"    get.special = set.special = true;\n"
"    return { get, set };\n"
"  }\n"
"\n"
"  function getSelf() {\n"
"    return this;\n"
"  }\n"
"\n"
"  function getProxy() {\n"
"    return this[PROXY];\n"
"  }\n"
"\n"
"  function toString() {\n"
"    return String(this);\n"
"  }\n"
"\n"
"  function always() {\n"
"    return true;\n"
"  }\n"
"\n"
"  function never() {\n"
"    return false;\n"
"  }\n"
"\n"
"  function empty() {}\n"
"\n"
"  class ObjectCache {\n"
"    map = new WeakMap();\n"
"\n"
"    find(dv) {\n"
"      return this.map.get(dv);\n"
"    }\n"
"\n"
"    save(dv, object) {\n"
"      this.map.set(dv, object);\n"
"      return object;\n"
"    }\n"
"  }\n"
"\n"
"  class CallContext {\n"
"    memoryList = [];\n"
"    shadowMap = null;\n"
"    id = usizeMin;\n"
"    async = false;\n"
"  }\n"
"\n"
"  const cls = {\n"
"    name: '',\n"
"    mixins: [],\n"
"    constructor: null,\n"
"  };\n"
"\n"
"  function mixin(object) {\n"
"    if (!cls.constructor) {\n"
"      cls.mixins.push(object);\n"
"    }\n"
"    return object;\n"
"  }\n"
"\n"
"  function defineEnvironment() {\n"
"    if (!cls.constructor) {\n"
"      cls.constructor = defineClass(cls.name, cls.mixins);\n"
"      cls.name = '';\n"
"      cls.mixins = [];\n"
"    }\n"
"    return cls.constructor;\n"
"  }\n"
"\n"
"  function defineClass(name, mixins) {\n"
"    const props = {};\n"
"    const constructor = function() {\n"
"      for (const [ name, object ] of Object.entries(props)) {\n"
"        this[name] = structuredClone(object);\n"
"      }\n"
"    };\n"
"    const { prototype } = constructor;\n"
"    defineProperty(constructor, 'name', defineValue(name));\n"
"    for (const mixin of mixins) {\n"
"      for (let [ name, object ] of Object.entries(mixin)) {\n"
"        if (typeof(object) === 'function') {\n"
"          if (process.env.MIXIN === 'track') {\n"
"            props.mixinUsage = new Map();\n"
"            const f = function(...args) {\n"
"              this.mixinUsage.set(mixin, true);\n"
"              return object.call(this, ...args);\n"
"            };\n"
"            defineProperty(prototype, name, defineValue(f));\n"
"          } else {\n"
"            defineProperty(prototype, name, defineValue(object));\n"
"          }\n"
"        } else {\n"
"          let current = props[name];\n"
"          if (current !== undefined) {\n"
"            if (current?.constructor === Object) {\n"
"              object = Object.assign({ ...current }, object);\n"
"            } else if (current !== object) {\n"
"              throw new Error(`Duplicate property: ${name}`);\n"
"            }\n"
"          }\n"
"          props[name] = object;\n"
"        }\n"
"      }\n"
"    }\n"
"    return constructor;\n"
"  }\n"
"\n"
"  // handle retrieval of accessors\n"
"\n"
"  mixin({\n"
"    accessorCache: new Map(),\n"
"\n"
"    getAccessor(access, member) {\n"
"      const { type, bitSize, bitOffset, byteSize } = member;\n"
"      const names = [];\n"
"      const unaligned = (byteSize === undefined) && (bitSize & 0x07 || bitOffset & 0x07);\n"
"      if (unaligned) {\n"
"        names.push('Unaligned');\n"
"      }\n"
"      let name = memberNames[type];\n"
"      if (bitSize > 32 && (type === MemberType.Int || type === MemberType.Uint)) {\n"
"        if (bitSize <= 64) {\n"
"          name = `Big${name}`;\n"
"        } else {\n"
"          name = `Jumbo${name}`;\n"
"        }\n"
"      }\n"
"      names.push(name, `${(type === MemberType.Bool && byteSize) ? byteSize * 8 : bitSize}`);\n"
"      if (unaligned) {\n"
"        names.push(`@${bitOffset}`);\n"
"      }\n"
"      const accessorName = access + names.join('');\n"
"      // see if it's a built-in method of DataView\n"
"      let accessor = DataView.prototype[accessorName];\n"
"      {\n"
"        if (accessor && this.usingBufferFallback()) {\n"
"          const thisEnv = this;\n"
"          const normal = accessor;\n"
"          const getAddress = function(offset) {\n"
"            const { buffer, byteOffset, byteLength } = this;\n"
"            const base = buffer[FALLBACK];\n"
"            if (base) {\n"
"              if (offset < 0 || (offset + bitSize / 8) > byteLength) {\n"
"                throw new RangeError('Offset is outside the bounds of the DataView');\n"
"              }\n"
"              return base + usize(byteOffset + offset);\n"
"            }\n"
"          };\n"
"          accessor = (access === 'get')\n"
"          ? function(offset, littleEndian) {\n"
"              const address = getAddress.call(this, offset);\n"
"              if (address !== undefined) {\n"
"                return thisEnv.getNumericValue(type, bitSize, address);\n"
"              } else {\n"
"                return normal.call(this, offset, littleEndian);\n"
"              }\n"
"            }\n"
"          : function(offset, value, littleEndian) {\n"
"              const address = getAddress.call(this, offset);\n"
"              if (address !== undefined) {\n"
"                return thisEnv.setNumericValue(type, bitSize, address, value);\n"
"              } else {\n"
"                return normal.call(this, offset, value, littleEndian);\n"
"              }\n"
"            };\n"
"        }\n"
"      }\n"
"      if (accessor) {\n"
"        return accessor;\n"
"      }\n"
"      // check cache\n"
"      accessor = this.accessorCache.get(accessorName);\n"
"      if (accessor) {\n"
"        return accessor;\n"
"      }\n"
"      while (names.length > 0) {\n"
"        const handlerName = `getAccessor${names.join('')}`;\n"
"        if (accessor = this[handlerName]?.(access, member)) {\n"
"          break;\n"
"        }\n"
"        names.pop();\n"
"      }\n"
"      /* c8 ignore start */\n"
"      if (!accessor) {\n"
"        throw new Error(`No accessor available: ${accessorName}`);\n"
"      }\n"
"      /* c8 ignore end */\n"
"      defineProperty(accessor, 'name', defineValue(accessorName));\n"
"      this.accessorCache.set(accessorName, accessor);\n"
"      return accessor;\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        getNumericValue: null,\n"
"        setNumericValue: null,\n"
"      },\n"
"    } ),\n"
"  });\n"
"\n"
"  mixin({\n"
"    getAccessorBigInt(access, member) {\n"
"      const { bitSize } = member;\n"
"      const signMask = 2n ** BigInt(bitSize - 1);\n"
"      const valueMask = signMask - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = this.getBigUint64(offset, littleEndian);\n"
"          return (n & valueMask) - (n & signMask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          this.setBigUint64(offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    getAccessorBigUint(access, member) {\n"
"      const { bitSize } = member;\n"
"      const valueMask = (2n ** BigInt(bitSize)) - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = this.getBigInt64(offset, littleEndian);\n"
"          return n & valueMask;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = value & valueMask;\n"
"          this.setBigUint64(offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  // handles bools, including implicit ones in optional pointers, where an address\n"
"  // of zero would be treated as boolean false\n"
"\n"
"  mixin({\n"
"    getAccessorBool(access, member) {\n"
"      const { byteSize } = member;\n"
"      const bitSize = byteSize * 8;\n"
"      const f = this.getAccessor(access, { type: MemberType.Uint, bitSize, byteSize });\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          return !!f.call(this, offset, littleEndian);\n"
"        }\n"
"      } else {\n"
"        const zero = (bitSize <= 32) ? 0 : 0n;\n"
"        const one = (bitSize <= 32) ? 1 : 1n;\n"
"        return function(offset, value, littleEndian) {\n"
"          f.call(this, offset, value ? one : zero, littleEndian);\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handles f128\n"
"\n"
"  mixin({\n"
"    getAccessorFloat128(access, member) {\n"
"      const { byteSize } = member;\n"
"      const buf = new DataView(new ArrayBuffer(8));\n"
"      const get = function(offset, littleEndian) {\n"
"        const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));\n"
"        const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));\n"
"        const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));\n"
"        const w4 = BigInt(this.getUint32(offset + (littleEndian ? 12 : byteSize - 16), littleEndian));\n"
"        return w1 | w2 << 32n | w3 << 64n | w4 << 96n;\n"
"      };\n"
"      const set = function(offset, value, littleEndian) {\n"
"        const w1 = value & 0xffff_ffffn;\n"
"        const w2 = (value >> 32n) & 0xffff_ffffn;\n"
"        const w3 = (value >> 64n) & 0xffff_ffffn;\n"
"        const w4 = (value >> 96n) & 0xffff_ffffn;\n"
"        this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);\n"
"        this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);\n"
"        this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);\n"
"        this.setUint32(offset + (littleEndian ? 12 : byteSize - 16), Number(w4), littleEndian);\n"
"      };\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >> 127n;\n"
"          const exp = (n & 0x7fff_0000_0000_0000_0000_0000_0000_0000n) >> 112n;\n"
"          const frac = n & 0x0000_ffff_ffff_ffff_ffff_ffff_ffff_ffffn;\n"
"          if (exp === 0n) {\n"
"            const value = (frac) ? Number.MIN_VALUE : 0;\n"
"            return (sign) ? -value : value;\n"
"          } else if (exp === 0x7fffn) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const exp64 = exp - 16383n + 1023n;\n"
"          if (exp64 >= 2047n) {\n"
"            const value = Infinity;\n"
"            return (sign) ? -value : value;\n"
"          }\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 60n) + BigInt((frac & (2n**60n - 1n)) >= 2n**59n);\n"
"          buf.setBigUint64(0, n64, littleEndian);\n"
"          return buf.getFloat64(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat64(0, value, littleEndian);\n"
"          const n = buf.getBigUint64(0, littleEndian);\n"
"          const sign = n >> 63n;\n"
"          const exp = (n & 0x7ff0_0000_0000_0000n) >> 52n;\n"
"          const frac = n & 0x000f_ffff_ffff_ffffn;\n"
"          let n128;\n"
"          if (exp === 0n) {\n"
"            n128 = sign << 127n | (frac << 60n);\n"
"          } else if (exp === 0x07ffn) {\n"
"            n128 = sign << 127n | 0x7fffn << 112n | (frac ? 1n : 0n);\n"
"          } else {\n"
"            n128 = sign << 127n | (exp - 1023n + 16383n) << 112n | (frac << 60n);\n"
"          }\n"
"          set.call(this, offset, n128, littleEndian);\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handles f16\n"
"\n"
"  mixin({\n"
"    getAccessorFloat16(access, member) {\n"
"      const buf = new DataView(new ArrayBuffer(4));\n"
"      const set = DataView.prototype.setUint16;\n"
"      const get = DataView.prototype.getUint16;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >>> 15;\n"
"          const exp = (n & 0x7c00) >> 10;\n"
"          const frac = n & 0x03ff;\n"
"          if (exp === 0) {\n"
"            return (sign) ? -0 : 0;\n"
"          } else if (exp === 0x1f) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const n32 = (sign << 31) | ((exp - 15 + 127) << 23) | (frac << 13);\n"
"          buf.setUint32(0, n32, littleEndian);\n"
"          return buf.getFloat32(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat32(0, value, littleEndian);\n"
"          const n = buf.getUint32(0, littleEndian);\n"
"          const sign = n >>> 31;\n"
"          const exp = (n & 0x7f80_0000) >> 23;\n"
"          const frac = n & 0x007f_ffff;\n"
"          const exp16 = (exp - 127 + 15);\n"
"          let n16;\n"
"          if (exp === 0) {\n"
"            n16 = sign << 15;\n"
"          } else if (exp === 0xff) {\n"
"            n16 = sign << 15 | 0x1f << 10 | (frac ? 1 : 0);\n"
"          } else if (exp16 >= 31) {\n"
"            n16 = sign << 15 | 0x1f << 10;\n"
"          } else {\n"
"            n16 = sign << 15 | exp16 << 10 | (frac >> 13);\n"
"          }\n"
"          set.call(this, offset, n16, littleEndian);\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handles f80\n"
"\n"
"  mixin({\n"
"    getAccessorFloat80(access, member) {\n"
"      const { byteSize } = member;\n"
"      const buf = new DataView(new ArrayBuffer(8));\n"
"      const get = function(offset, littleEndian) {\n"
"        const w1 = BigInt(this.getUint32(offset + (littleEndian ? 0 : byteSize - 4), littleEndian));\n"
"        const w2 = BigInt(this.getUint32(offset + (littleEndian ? 4 : byteSize - 8), littleEndian));\n"
"        const w3 = BigInt(this.getUint32(offset + (littleEndian ? 8 : byteSize - 12), littleEndian));\n"
"        return w1 | w2 << 32n | w3 << 64n;\n"
"      };\n"
"      const set = function(offset, value, littleEndian) {\n"
"        const w1 = value & 0xffff_ffffn;\n"
"        const w2 = (value >> 32n) & 0xffff_ffffn;\n"
"        const w3 = (value >> 64n) & 0xffff_ffffn;\n"
"        this.setUint32(offset + (littleEndian ? 0 : byteSize - 4), Number(w1), littleEndian);\n"
"        this.setUint32(offset + (littleEndian ? 4 : byteSize - 8), Number(w2), littleEndian);\n"
"        this.setUint32(offset + (littleEndian ? 8 : byteSize - 12), Number(w3), littleEndian);\n"
"      };\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = get.call(this, offset, littleEndian);\n"
"          const sign = n >> 79n;\n"
"          const exp = (n & 0x7fff_0000_0000_0000_0000n) >> 64n;\n"
"          const frac = n & 0x0000_7fff_ffff_ffff_ffffn;\n"
"          if (exp === 0n) {\n"
"            const value = (frac) ? Number.MIN_VALUE : 0;\n"
"            return (sign) ? -value : value;\n"
"          } else if (exp === 0x7fffn) {\n"
"            if (!frac) {\n"
"              return (sign) ? -Infinity : Infinity;\n"
"            } else {\n"
"              return NaN;\n"
"            }\n"
"          }\n"
"          const exp64 = exp - 16383n + 1023n;\n"
"          if (exp64 >= 2047n) {\n"
"            const value = Infinity;\n"
"            return (sign) ? -value : value;\n"
"          }\n"
"          const n64 = (sign << 63n) | (exp64 << 52n) | (frac >> 11n) + BigInt((frac & (2n**11n - 1n)) >= 2n**10n);\n"
"          buf.setBigUint64(0, n64, littleEndian);\n"
"          return buf.getFloat64(0, littleEndian);\n"
"        }\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          buf.setFloat64(0, value, littleEndian);\n"
"          const n = buf.getBigUint64(0, littleEndian);\n"
"          const sign = n >> 63n;\n"
"          const exp = (n & 0x7ff0_0000_0000_0000n) >> 52n;\n"
"          const frac = n & 0x000f_ffff_ffff_ffffn;\n"
"          let n80;\n"
"          if (exp === 0n) {\n"
"            n80 = sign << 79n | (frac << 11n);\n"
"          } else if (exp === 0x07ffn) {\n"
"            n80 = sign << 79n | 0x7fffn << 64n | (frac ? 0x00002000000000000000n : 0n) | 0x00008000000000000000n;\n"
"            //                                                 ^ bit 61                       ^ bit 63\n"
"          } else {\n"
"            n80 = sign << 79n | (exp - 1023n + 16383n) << 64n | (frac << 11n) | 0x00008000000000000000n;\n"
"          }\n"
"          set.call(this, offset, n80, littleEndian);\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handle non-standard ints 32-bit or smaller\n"
"\n"
"  mixin({\n"
"    getAccessorInt(access, member) {\n"
"      const { bitSize, byteSize } = member;\n"
"      if (byteSize) {\n"
"        const f = this.getAccessor(access, { type: MemberType.Uint, bitSize: byteSize * 8, byteSize });\n"
"        const signMask = 2 ** (bitSize - 1);\n"
"        const valueMask = signMask - 1;\n"
"        if (access === 'get') {\n"
"          return function(offset, littleEndian) {\n"
"            const n = f.call(this, offset, littleEndian);\n"
"            return (n & valueMask) - (n & signMask);\n"
"          };\n"
"        } else {\n"
"          return function(offset, value, littleEndian) {\n"
"            const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"            f.call(this, offset, n, littleEndian);\n"
"          };\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  mixin({\n"
"    getAccessorJumboInt(access, member) {\n"
"      const { bitSize } = member;\n"
"      const f = this.getJumboAccessor(access, bitSize);\n"
"      const signMask = 2n ** BigInt(bitSize - 1);\n"
"      const valueMask = signMask - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = f.call(this, offset, littleEndian);\n"
"          return (n & valueMask) - (n & signMask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"          f.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    getAccessorJumboUint(access, member) {\n"
"      const { bitSize } = member;\n"
"      const f = this.getJumboAccessor(access, bitSize);\n"
"      const valueMask = (2n ** BigInt(bitSize)) - 1n;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          const n = f.call(this, offset, littleEndian);\n"
"          return n & valueMask;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          const n = value & valueMask;\n"
"          f.call(this, offset, n, littleEndian);\n"
"        };\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    getJumboAccessor(access, bitSize) {\n"
"      const wordCount = (bitSize + 63) >> 6;\n"
"      if (access === 'get') {\n"
"        return function(offset, littleEndian) {\n"
"          let n = 0n;\n"
"          if (littleEndian) {\n"
"            for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\n"
"              const w = this.getBigUint64(j, littleEndian);\n"
"              n = (n << 64n) | w;\n"
"            }\n"
"          } else {\n"
"            for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\n"
"              const w = this.getBigUint64(j, littleEndian);\n"
"              n = (n << 64n) | w;\n"
"            }\n"
"          }\n"
"          return n;\n"
"        };\n"
"      } else {\n"
"        return function(offset, value, littleEndian) {\n"
"          let n = value;\n"
"          const mask = 0xffff_ffff_ffff_ffffn;\n"
"          if (littleEndian) {\n"
"            for (let i = 0, j = offset; i < wordCount; i++, j += 8) {\n"
"              const w = n & mask;\n"
"              this.setBigUint64(j, w, littleEndian);\n"
"              n >>= 64n;\n"
"            }\n"
"          } else {\n"
"            for (let i = 0, j = offset + (wordCount - 1) * 8; i < wordCount; i++, j -= 8) {\n"
"              const w = n & mask;\n"
"              this.setBigUint64(j, w, littleEndian);\n"
"              n >>= 64n;\n"
"            }\n"
"          }\n"
"        };\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handle non-standard uints 32-bit or smaller\n"
"\n"
"  mixin({\n"
"    getAccessorUint(access, member) {\n"
"      const { bitSize, byteSize } = member;\n"
"      if (byteSize) {\n"
"        const f = this.getAccessor(access, { ...member, bitSize: byteSize * 8 });\n"
"        const valueMask = (2 ** bitSize) - 1;\n"
"        if (access === 'get') {\n"
"          return function(offset, littleEndian) {\n"
"            const n = f.call(this, offset, littleEndian);\n"
"            return n & valueMask;\n"
"          };\n"
"        } else {\n"
"          return function(offset, value, littleEndian) {\n"
"            const n = value & valueMask;\n"
"            f.call(this, offset, n, littleEndian);\n"
"          };\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handle bools in packed structs\n"
"\n"
"  mixin({\n"
"    getAccessorUnalignedBool1(access, member) {\n"
"      const { bitOffset } = member;\n"
"      const bitPos = bitOffset & 0x07;\n"
"      const mask = 1 << bitPos;\n"
"      if (access === 'get') {\n"
"        return function(offset) {\n"
"          const n = this.getInt8(offset);\n"
"          return !!(n & mask);\n"
"        };\n"
"      } else {\n"
"        return function(offset, value) {\n"
"          const n = this.getInt8(offset);\n"
"          const b = (value) ? n | mask : n & ~mask;\n"
"          this.setInt8(offset, b);\n"
"        };\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  // handle ints 7-bit or smaller in packed structs that are stored in a single byte\n"
"  // other unaligned ints are handled by the mixin \"unaligned\"\n"
"\n"
"  mixin({\n"
"    getAccessorUnalignedInt(access, member) {\n"
"      const { bitSize, bitOffset } = member;\n"
"      const bitPos = bitOffset & 0x07;\n"
"      if (bitPos + bitSize <= 8) {\n"
"        const signMask = 2 ** (bitSize - 1);\n"
"        const valueMask = signMask - 1;\n"
"        if (access === 'get') {\n"
"          return function(offset) {\n"
"            const n = this.getUint8(offset);\n"
"            const s = n >>> bitPos;\n"
"            return (s & valueMask) - (s & signMask);\n"
"          };\n"
"        } else {\n"
"          const outsideMask = 0xFF ^ ((valueMask | signMask) << bitPos);\n"
"          return function(offset, value) {\n"
"            let b = this.getUint8(offset);\n"
"            const n = (value < 0) ? signMask | (value & valueMask) : value & valueMask;\n"
"            b = (b & outsideMask) | (n << bitPos);\n"
"            this.setUint8(offset, b);\n"
"          };\n"
"        }\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  // handle uints 7-bit or smaller in packed structs that are stored in a single byte\n"
"  // other unaligned ints are handled by the mixin \"unaligned\"\n"
"\n"
"  mixin({\n"
"    getAccessorUnalignedUint(access, member) {\n"
"      const { bitSize, bitOffset } = member;\n"
"      const bitPos = bitOffset & 0x07;\n"
"      if (bitPos + bitSize <= 8) {\n"
"        const valueMask = (2 ** bitSize - 1);\n"
"        if (access === 'get') {\n"
"          return function(offset) {\n"
"            const n = this.getUint8(offset);\n"
"            const s = n >>> bitPos;\n"
"            return s & valueMask;\n"
"          };\n"
"        } else {\n"
"          const outsideMask = 0xFF ^ (valueMask << bitPos);\n"
"          return function(offset, value) {\n"
"            const n = this.getUint8(offset);\n"
"            const b = (n & outsideMask) | ((value & valueMask) << bitPos);\n"
"            this.setUint8(offset, b);\n"
"          };\n"
"        }\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  // handle unaligned ints and floats by copying the bits into a\n"
"  // temporary buffer, aligning them\n"
"\n"
"  mixin({\n"
"    getAccessorUnaligned(access, member) {\n"
"      const { bitSize, bitOffset } = member;\n"
"      const bitPos = bitOffset & 0x07;\n"
"      const byteSize = [ 1, 2, 4, 8 ].find(b => b * 8 >= bitSize) ?? Math.ceil(bitSize / 64) * 64;\n"
"      const buf = new DataView(new ArrayBuffer(byteSize));\n"
"      if (access === 'get') {\n"
"        const getAligned = this.getAccessor('get', { ...member, byteSize });\n"
"        const copyBits = getBitAlignFunction(bitPos, bitSize, true);\n"
"        return function(offset, littleEndian) {\n"
"          copyBits(buf, this, offset);\n"
"          return getAligned.call(buf, 0, littleEndian);\n"
"        };\n"
"      } else {\n"
"        const setAligned = this.getAccessor('set', { ...member, byteSize });\n"
"        const applyBits = getBitAlignFunction(bitPos, bitSize, false);\n"
"        return function(offset, value, littleEndian) {\n"
"          setAligned.call(buf, 0, value, littleEndian);\n"
"          applyBits(this, buf, offset);\n"
"        };\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  function getBitAlignFunction(bitPos, bitSize, toAligned) {\n"
"    if (bitPos + bitSize <= 8) {\n"
"      const mask = (2 ** bitSize) - 1;\n"
"      if (toAligned) {\n"
"        // from single byte\n"
"        return function(dest, src, offset) {\n"
"          const n = src.getUint8(offset);\n"
"          const b = (n >> bitPos) & mask;\n"
"          dest.setUint8(0, b);\n"
"        };\n"
"      } else {\n"
"        // to single byte\n"
"        const destMask = 0xFF ^ (mask << bitPos);\n"
"        return function(dest, src, offset) {\n"
"          const n = src.getUint8(0);\n"
"          const d = dest.getUint8(offset);\n"
"          const b = (d & destMask) | ((n & mask) << bitPos);\n"
"          dest.setUint8(offset, b);\n"
"        };\n"
"      }\n"
"    } else {\n"
"      const leadBits = 8 - bitPos;\n"
"      const leadMask = (2 ** leadBits) - 1;\n"
"      if (toAligned) {\n"
"        const trailBits = bitSize % 8;\n"
"        const trailMask = (2 ** trailBits) - 1;\n"
"        return function(dest, src, offset) {\n"
"          let i = offset, j = 0;\n"
"          let n = src.getUint8(i++), b;\n"
"          let bitBuf = (n >> bitPos) & leadMask;\n"
"          let bitCount = leadBits;\n"
"          let remaining = bitSize;\n"
"          do {\n"
"            if (remaining > bitCount) {\n"
"              n = src.getUint8(i++);\n"
"              bitBuf = bitBuf | (n << bitCount);\n"
"              //bitCount += 8;\n"
"            }\n"
"            b = (remaining >= 8) ? bitBuf & 0xFF : bitBuf & trailMask;\n"
"            dest.setUint8(j++, b);\n"
"            bitBuf >>= 8;\n"
"            //bitCount -= 8;\n"
"            remaining -= 8;\n"
"          } while (remaining > 0);\n"
"        }\n"
"      } else {\n"
"        const trailBits = (bitSize - leadBits) % 8;\n"
"        const trailMask = (2 ** trailBits) - 1;\n"
"        const destMask1 = 0xFF ^ (leadMask << bitPos);\n"
"        const destMask2 = 0xFF ^ trailMask;\n"
"        return function(dest, src, offset) {\n"
"          let i = 0, j = offset;\n"
"          // preserve bits ahead of bitPos\n"
"          let d = dest.getUint8(j), n, b;\n"
"          let bitBuf = d & destMask1;\n"
"          let bitCount = bitPos;\n"
"          let remaining = bitSize + bitCount;\n"
"          do {\n"
"            if (remaining > bitCount) {\n"
"              n = src.getUint8(i++);\n"
"              bitBuf = bitBuf | (n << bitCount);\n"
"              bitCount += 8;\n"
"            }\n"
"            if (remaining >= 8) {\n"
"              b = bitBuf & 0xFF;\n"
"            } else {\n"
"              // preserve bits at the destination sitting behind the trailing bits\n"
"              d = dest.getUint8(j);\n"
"              b = (d & destMask2) | (bitBuf & trailMask);\n"
"            }\n"
"            dest.setUint8(j++, b);\n"
"            bitBuf >>= 8;\n"
"            bitCount -= 8;\n"
"            remaining -= 8;\n"
"          } while (remaining > 0);\n"
"        }\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  mixin({\n"
"    createSignalArray(args, structure, signal) {\n"
"      const { constructor: { child: Int32 } } = structure.instance.members[0].structure;\n"
"      const ta = new Int32Array([ signal?.aborted ? 1 : 0 ]);\n"
"      const int32 = Int32(ta);\n"
"      if (signal) {\n"
"        signal.addEventListener('abort', () => {\n"
"          {\n"
"            // node has direct access on the other hand\n"
"            Atomics.store(ta, 0, 1);\n"
"          }\n"
"        }, { once: true });\n"
"      }\n"
"      return int32;\n"
"    },\n"
"  });\n"
"\n"
"  class InvalidIntConversion extends SyntaxError {\n"
"    constructor(arg) {\n"
"      super(`Cannot convert ${arg} to an Int`);\n"
"    }\n"
"  }\n"
"\n"
"  class Unsupported extends TypeError {\n"
"    constructor() {\n"
"      super(`Unsupported`);\n"
"    }\n"
"  }\n"
"\n"
"  class NoInitializer extends TypeError {\n"
"    constructor(structure) {\n"
"      const { name } = structure;\n"
"      super(`An initializer must be provided to the constructor of ${name}, even when the intended value is undefined`);\n"
"    }\n"
"  }\n"
"\n"
"  class BufferSizeMismatch extends TypeError {\n"
"    constructor(structure, dv, target = null) {\n"
"      const { name, type, byteSize } = structure;\n"
"      const actual = dv.byteLength;\n"
"      const s = (byteSize !== 1) ? 's' : '';\n"
"      let msg;\n"
"      if (type === StructureType.Slice && !target) {\n"
"        msg = `${name} has elements that are ${byteSize} byte${s} in length, received ${actual}`;\n"
"      } else {\n"
"        const total = (type === StructureType.Slice) ? target.length * byteSize : byteSize;\n"
"        msg = `${name} has ${total} byte${s}, received ${actual}`;\n"
"      }\n"
"      super(msg);\n"
"    }\n"
"  }\n"
"\n"
"  class BufferExpected extends TypeError {\n"
"    constructor(structure) {\n"
"      const { type, byteSize, typedArray } = structure;\n"
"      const s = (byteSize !== 1) ? 's' : '';\n"
"      const acceptable = [ 'ArrayBuffer', 'DataView' ].map(addArticle);\n"
"      if (typedArray) {\n"
"        acceptable.push(addArticle(typedArray.name));\n"
"      }\n"
"      let msg;\n"
"      if (type === StructureType.Slice) {\n"
"        msg = `Expecting ${formatList(acceptable)} that can accommodate items ${byteSize} byte${s} in length`;\n"
"      } else {\n"
"        msg = `Expecting ${formatList(acceptable)} that is ${byteSize} byte${s} in length`;\n"
"      }\n"
"      super(msg);\n"
"    }\n"
"  }\n"
"\n"
"  class EnumExpected extends TypeError {\n"
"    constructor(structure, arg) {\n"
"      const { name } = structure;\n"
"      let msg;\n"
"      if (typeof(arg) === 'number' || typeof(arg) === 'bigint') {\n"
"        msg = `Value given does not correspond to an item of enum ${name}: ${arg}`;\n"
"      } else {\n"
"        msg = `Enum item of the type ${name} expected, received ${arg}`;\n"
"      }\n"
"      super(msg);\n"
"    }\n"
"  }\n"
"\n"
"  class ErrorExpected extends TypeError {\n"
"    constructor(structure, arg) {\n"
"      const { name } = structure;\n"
"      const type = typeof(arg);\n"
"      let msg;\n"
"      if (type === 'string' || type === 'number' || isErrorJSON(arg)) {\n"
"        if (isErrorJSON(arg)) {\n"
"          arg = `{ error: ${JSON.stringify(arg.error)} }`;\n"
"        }\n"
"        msg = `Error ${type} does not corresponds to any error in error set ${name}: ${arg}`;\n"
"      } else {\n"
"        msg = `Error of the type ${name} expected, received ${arg}`;\n"
"      }\n"
"      super(msg);\n"
"    }\n"
"  }\n"
"\n"
"  class NotInErrorSet extends TypeError {\n"
"    constructor(structure) {\n"
"      const { name } = structure;\n"
"      super(`Error given is not a part of error set ${name}`);\n"
"    }\n"
"  }\n"
"\n"
"  class MultipleUnionInitializers extends TypeError {\n"
"    constructor(structure) {\n"
"      const { name } = structure;\n"
"      super(`Only one property of ${name} can be given a value`);\n"
"    }\n"
"  }\n"
"\n"
"  class InactiveUnionProperty extends TypeError {\n"
"    constructor(structure, name, currentName) {\n"
"      super(`Accessing property ${name} when ${currentName} is active`);\n"
"    }\n"
"  }\n"
"\n"
"  class MissingUnionInitializer extends TypeError {\n"
"    constructor(structure, arg, exclusion) {\n"
"      const { name, instance: { members } } = structure;\n"
"      const missing = members.slice(0, exclusion ? -1 : undefined).map(m => m.name);\n"
"      super(`${name} needs an initializer for one of its union properties: ${missing.join(', ')}`);\n"
"    }\n"
"  }\n"
"\n"
"  class InvalidInitializer extends TypeError {\n"
"    constructor(structure, expected, arg) {\n"
"      const { name } = structure;\n"
"      const acceptable = [];\n"
"      if (Array.isArray(expected)) {\n"
"        for (const type of expected) {\n"
"          acceptable.push(addArticle(type));\n"
"        }\n"
"      } else {\n"
"        acceptable.push(addArticle(expected));\n"
"      }\n"
"      const received = getDescription(arg);\n"
"      super(`${name} expects ${formatList(acceptable)} as argument, received ${received}`);\n"
"    }\n"
"  }\n"
"\n"
"  class InvalidArrayInitializer extends InvalidInitializer {\n"
"    constructor(structure, arg, shapeless = false) {\n"
"      const { instance: { members: [ member ] }, type, constructor } = structure;\n"
"      const acceptable = [];\n"
"      const primitive = getPrimitiveName(member);\n"
"      if (primitive) {\n"
"        let object;\n"
"        switch (member.structure?.type) {\n"
"          case StructureType.Enum: object = 'enum item'; break;\n"
"          case StructureType.ErrorSet: object = 'error'; break;\n"
"          default: object = primitive;\n"
"        }\n"
"        acceptable.push(`array of ${object}s`);\n"
"      } else {\n"
"        acceptable.push(`array of objects`);\n"
"      }\n"
"      if (constructor[TYPED_ARRAY]) {\n"
"        acceptable.push(constructor[TYPED_ARRAY].name);\n"
"      }\n"
"      if (type === StructureType.Slice && shapeless) {\n"
"        acceptable.push(`length`);\n"
"      }\n"
"      super(structure, acceptable.join(' or '), arg);\n"
"    }\n"
"  }\n"
"\n"
"  class ArrayLengthMismatch extends TypeError {\n"
"    constructor(structure, target, arg) {\n"
"      const { name, length, instance: { members: [ member ] } } = structure;\n"
"      const { structure: { constructor: elementConstructor} } = member;\n"
"      const { length: argLength, constructor: argConstructor } = arg;\n"
"      // get length from object whech it's a slice\n"
"      const actualLength = target?.length ?? length;\n"
"      const s = (actualLength !== 1) ? 's' : '';\n"
"      let received;\n"
"      if (argConstructor === elementConstructor) {\n"
"        received = `only a single one`;\n"
"      } else if (argConstructor.child === elementConstructor) {\n"
"        received = `a slice/array that has ${argLength}`;\n"
"      } else {\n"
"        received = `${argLength} initializer${argLength > 1 ? 's' : ''}`;\n"
"      }\n"
"      super(`${name} has ${actualLength} element${s}, received ${received}`);\n"
"    }\n"
"  }\n"
"\n"
"  class InvalidSliceLength extends TypeError {\n"
"    constructor(length, max) {\n"
"      if (length < 0) {\n"
"        super(`Length of slice cannot be negative`);\n"
"      } else {\n"
"        super(`Length of slice can be ${max} or less, received ${length}`);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  class MissingInitializers extends TypeError {\n"
"    constructor(structure, missing) {\n"
"      const { name } = structure;\n"
"      super(`Missing initializers for ${name}: ${missing.join(', ')}`);\n"
"    }\n"
"  }\n"
"\n"
"  class NoProperty extends TypeError {\n"
"    constructor(structure, propName) {\n"
"      const { name, instance: { members } } = structure;\n"
"      const member = members.find(m => m.name === propName);\n"
"      let msg;\n"
"      if (member) {\n"
"        msg = `Comptime value cannot be changed: ${propName}`;\n"
"      } else {\n"
"        msg = `${name} does not have a property with that name: ${propName}`;\n"
"      }\n"
"      super(msg);\n"
"    }\n"
"  }\n"
"\n"
"  class ArgumentCountMismatch extends Error {\n"
"    constructor(expected, actual, variadic = false) {\n"
"      super();\n"
"      this.fnName = 'fn';\n"
"      this.argIndex = expected;\n"
"      this.argCount = actual;\n"
"      this.variadic = variadic;\n"
"    }\n"
"\n"
"    get message() {\n"
"      const s = (this.argIndex !== 1) ? 's' : '';\n"
"      let count = this.argIndex;\n"
"      if (this.variadic) {\n"
"        count = `at least ${count}`;\n"
"      }\n"
"      return `${this.fnName}(): Expecting ${count} argument${s}, received ${this.argCount}`;\n"
"    }\n"
"  }\n"
"\n"
"  class UndefinedArgument extends Error {\n"
"    constructor() {\n"
"      super(`Undefined argument`);\n"
"    }\n"
"  }\n"
"\n"
"  class NoCastingToPointer extends TypeError {\n"
"    constructor() {\n"
"      super(`Non-slice pointers can only be created with the help of the new operator`);\n"
"    }\n"
"  }\n"
"\n"
"  class NoCastingToFunction extends TypeError {\n"
"    constructor() {\n"
"      super(`Casting to function is not allowed`);\n"
"    }\n"
"  }\n"
"\n"
"  class ConstantConstraint extends TypeError {\n"
"    constructor(structure, pointer) {\n"
"      const { name: target } = structure;\n"
"      const { constructor: { name } } = pointer;\n"
"      super(`Conversion of ${name} to ${target} requires an explicit cast`);\n"
"    }\n"
"  }\n"
"\n"
"  class MisplacedSentinel extends TypeError {\n"
"    constructor(structure, value, index, length) {\n"
"      const { name } = structure;\n"
"      super(`${name} expects the sentinel value ${value} at ${length - 1}, found at ${index}`);\n"
"    }\n"
"  }\n"
"\n"
"  class MissingSentinel extends TypeError {\n"
"    constructor(structure, value, length) {\n"
"      const { name } = structure;\n"
"      super(`${name} expects the sentinel value ${value} at ${length - 1}`);\n"
"    }\n"
"  }\n"
"\n"
"  class AlignmentConflict extends TypeError {\n"
"    constructor(align1, align2) {\n"
"      super(`Unable to simultaneously align memory to ${align2}-byte and ${align1}-byte boundary`);\n"
"    }\n"
"  }\n"
"\n"
"  class TypeMismatch extends TypeError {\n"
"    constructor(expected, arg) {\n"
"      const received = getDescription(arg);\n"
"      super(`Expected ${addArticle(expected)}, received ${received}`);\n"
"    }\n"
"  }\n"
"\n"
"  class InaccessiblePointer extends TypeError {\n"
"    constructor() {\n"
"      super(`Pointers within an untagged union are not accessible`);\n"
"    }\n"
"  }\n"
"\n"
"  class NullPointer extends TypeError {\n"
"    constructor() {\n"
"      super(`Null pointer`);\n"
"    }\n"
"  }\n"
"\n"
"  class PreviouslyFreed extends TypeError {\n"
"    constructor(arg) {\n"
"      super(`Object has been freed already: ${arg.constructor.name}`);\n"
"    }\n"
"  }\n"
"\n"
"  class InvalidPointerTarget extends TypeError {\n"
"    constructor(structure, arg) {\n"
"      const { name } = structure;\n"
"      let target;\n"
"      if (arg != null) {\n"
"        const type = typeof(arg);\n"
"        const noun = (type === 'object' && arg.constructor !== Object) ? `${arg.constructor.name} object`: type;\n"
"        const a = article(noun);\n"
"        target = `${a} ${noun}`;\n"
"      } else {\n"
"        target = arg + '';\n"
"      }\n"
"      super(`${name} cannot point to ${target}`);\n"
"    }\n"
"  }\n"
"\n"
"  class ZigMemoryTargetRequired extends TypeError {\n"
"    constructor(structure, arg) {\n"
"      super(`Pointers in Zig memory cannot point to garbage-collected object`);\n"
"    }\n"
"  }\n"
"\n"
"  class Overflow extends TypeError {\n"
"    constructor(member, value) {\n"
"      const { type, bitSize } = member;\n"
"      const name = (bitSize > 32 ? 'Big' : '') + memberNames[type] + bitSize;\n"
"      super(`${name} cannot represent the value given: ${value}`);\n"
"    }\n"
"  }\n"
"\n"
"  class OutOfBound extends RangeError {\n"
"    constructor(member, index) {\n"
"      const { name } = member;\n"
"      super(`Index exceeds the size of ${name ?? 'array'}: ${index}`);\n"
"    }\n"
"  }\n"
"\n"
"  class NotUndefined extends TypeError {\n"
"    constructor(member) {\n"
"      const { name } = member;\n"
"      const rvalue = (name !== undefined) ? `Property ${name}` : `Element`;\n"
"      super(`${rvalue} can only be undefined`);\n"
"    }\n"
"  }\n"
"\n"
"  class NotOnByteBoundary extends TypeError {\n"
"    constructor(member) {\n"
"      const { name, structure: { name: struct } } = member;\n"
"      super(`Unable to create ${struct} as it is not situated on a byte boundary: ${name}`);\n"
"    }\n"
"  }\n"
"\n"
"  class ReadOnly extends TypeError {\n"
"    constructor() {\n"
"      super(`Unable to modify read-only object`);\n"
"    }\n"
"  }\n"
"\n"
"  class ReadOnlyTarget extends TypeError {\n"
"    constructor(structure) {\n"
"      const { name } = structure;\n"
"      super(`${name} cannot point to a read-only object`);\n"
"    }\n"
"  }\n"
"\n"
"  class AccessingOpaque extends TypeError {\n"
"    constructor(structure) {\n"
"      const { name } = structure;\n"
"      super(`Unable to access opaque structure ${name}`);\n"
"    }\n"
"  }\n"
"\n"
"  class CreatingOpaque extends TypeError {\n"
"    constructor(structure) {\n"
"      const { name } = structure;\n"
"      super(`Unable to create instance of ${name}, as it is opaque`);\n"
"    }\n"
"  }\n"
"\n"
"  class InvalidVariadicArgument extends TypeError {\n"
"    constructor() {\n"
"      super(`Arguments passed to variadic function must be casted to a Zig type`);\n"
"    }\n"
"  }\n"
"\n"
"  class ZigError extends Error {\n"
"    constructor(message) {\n"
"      super(message ?? 'Error encountered in Zig code');\n"
"    }\n"
"  }\n"
"\n"
"  function adjustArgumentError(argIndex, argCount) {\n"
"    const { message } = this;\n"
"    defineProperties(this, {\n"
"      fnName: defineValue('fn'),\n"
"      argIndex: defineValue(argIndex),\n"
"      argCount: defineValue(argCount),\n"
"      message: {\n"
"        get() {\n"
"          const { fnName, argIndex, argCount } = this;\n"
"          const argName = `args[${argIndex}]`;\n"
"          const prefix = (argIndex !== 0) ? '..., ' : '';\n"
"          const suffix = (argIndex !== argCount - 1) ? ', ...' : '';\n"
"          const argLabel = prefix + argName + suffix;\n"
"          return `${fnName}(${argLabel}): ${message}`;\n"
"        },\n"
"      }\n"
"    });\n"
"    return this;\n"
"  }\n"
"\n"
"  function replaceRangeError(member, index, err) {\n"
"    if (err instanceof RangeError && !(err instanceof OutOfBound)) {\n"
"      err = new OutOfBound(member, index);\n"
"    }\n"
"    return err;\n"
"  }\n"
"\n"
"  function throwReadOnly() {\n"
"    throw new ReadOnly();\n"
"  }\n"
"\n"
"  function warnImplicitArrayCreation(structure, arg) {\n"
"    const created = addArticle(structure.constructor[TYPED_ARRAY].name);\n"
"    const source = addArticle(arg.constructor.name);\n"
"    console.warn(`Implicitly creating ${created} from ${source}`);\n"
"  }\n"
"\n"
"  function deanimalizeErrorName(name) {\n"
"    // deal with snake_case first\n"
"    let s = name.replace(/_/g, ' ');\n"
"    // then camelCase, using a try block in case Unicode regex fails\n"
"    try {\n"
"      s = s.replace(/(\\p{Uppercase}+)(\\p{Lowercase}*)/gu, (m0, m1, m2) => {\n"
"        if (m1.length === 1) {\n"
"          return ` ${m1.toLocaleLowerCase()}${m2}`;\n"
"        } else {\n"
"          if (m2) {\n"
"            return m0;\n"
"          } else {\n"
"            return ` ${m1}`;\n"
"          }\n"
"        }\n"
"      }).trimStart();\n"
"      /* c8 ignore next 2 */\n"
"    } catch (err) {\n"
"    }\n"
"    return s.charAt(0).toLocaleUpperCase() + s.substring(1);\n"
"  }\n"
"\n"
"  function isErrorJSON(arg) {\n"
"    return typeof(arg) === 'object' && typeof(arg.error) === 'string' && Object.keys(arg).length === 1  ;\n"
"  }\n"
"\n"
"  function getDescription(arg) {\n"
"    const type = typeof(arg);\n"
"    let s;\n"
"    if (type === 'object') {\n"
"      s = (arg) ? Object.prototype.toString.call(arg) : 'null';\n"
"    } else {\n"
"      s = type;\n"
"    }\n"
"    return addArticle(s);\n"
"  }\n"
"\n"
"  function addArticle(noun) {\n"
"    return `${article(noun)} ${noun}`;\n"
"  }\n"
"\n"
"  function article(noun) {\n"
"    return /^\\W*[aeiou]/i.test(noun) ? 'an' : 'a';\n"
"  }\n"
"\n"
"  function formatList(list, conj = 'or') {\n"
"    const sep = ` ${conj} `;\n"
"    if (list.length > 2) {\n"
"      return list.slice(0, -1).join(', ') + sep + list[list.length - 1];\n"
"    } else {\n"
"      return list.join(sep);\n"
"    }\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineAlloc() {\n"
"      return {\n"
"        value(len, align = 1) {\n"
"          const ptrAlign = 31 - Math.clz32(align);\n"
"          const { vtable: { alloc }, ptr } = this;\n"
"          const slicePtr = alloc(ptr, len, ptrAlign, 0);\n"
"          // alloc returns a [*]u8, which has a initial length of 1\n"
"          slicePtr.length = len;\n"
"          const dv = slicePtr['*'][MEMORY];\n"
"          // attach alignment so we can find it again\n"
"          dv[ZIG].align = align;\n"
"          return dv;\n"
"        }\n"
"      };\n"
"    },\n"
"    defineFree() {\n"
"      return {\n"
"        value(arg) {\n"
"          const { dv, align } = getMemory(arg);\n"
"          const zig = dv?.[ZIG];\n"
"          if (!zig) {\n"
"            throw new TypeMismatch('object containing allocated Zig memory', arg);\n"
"          }\n"
"          const { address } = zig;\n"
"          if (!address || address === usizeInvalid) {\n"
"            throw new PreviouslyFreed(arg);\n"
"          }\n"
"          const ptrAlign = 31 - Math.clz32(align);\n"
"          const { vtable: { free }, ptr } = this;\n"
"          free(ptr, dv, ptrAlign, 0);\n"
"          zig.address = usizeInvalid;\n"
"        }\n"
"      };\n"
"    },\n"
"    defineDupe() {\n"
"      const copy = this.getCopyFunction();\n"
"      return {\n"
"        value(arg) {\n"
"          const { dv: src, align, constructor } = getMemory(arg);\n"
"          if (!src) {\n"
"            throw new TypeMismatch('string, DataView, typed array, or Zig object', arg);\n"
"          }\n"
"          const dest = this.alloc(src.byteLength, align);\n"
"          copy(dest, src);\n"
"          return (constructor) ? constructor(dest) : dest;\n"
"        }\n"
"      };\n"
"    }\n"
"  });\n"
"\n"
"  function getMemory(arg) {\n"
"    let dv, align = 1, constructor = null;\n"
"    if (arg instanceof DataView) {\n"
"      dv = arg;\n"
"      const fixedMemoryAlign = dv?.[ZIG]?.align;\n"
"      if (fixedMemoryAlign) {\n"
"        align = fixedMemoryAlign;\n"
"      }\n"
"    } else if (arg instanceof ArrayBuffer) {\n"
"      dv = new DataView(arg);\n"
"    } else if (arg) {\n"
"      if (arg[MEMORY]) {\n"
"        if (arg.constructor[TYPE] === StructureType.Pointer) {\n"
"          arg = arg['*'];\n"
"        }\n"
"        dv = arg[MEMORY];\n"
"        constructor = arg.constructor;\n"
"        align = constructor[ALIGN];\n"
"      } else {\n"
"        if (typeof(arg) === 'string') {\n"
"          arg = encodeText(arg);\n"
"        }\n"
"        const { buffer, byteOffset, byteLength, BYTES_PER_ELEMENT } = arg;\n"
"        if (buffer && byteOffset !== undefined && byteLength !== undefined) {\n"
"          dv = new DataView(buffer, byteOffset, byteLength);\n"
"          align = BYTES_PER_ELEMENT;\n"
"        }\n"
"      }\n"
"    }\n"
"    return { dv, align, constructor };\n"
"  }\n"
"\n"
"  mixin({\n"
"    variables: [],\n"
"\n"
"    getSpecialExports() {\n"
"      const check = (v) => {\n"
"        if (v === undefined) throw new Error('Not a Zig type');\n"
"        return v;\n"
"      };\n"
"      return {\n"
"        init: (...args) => this.initialize?.(...args),\n"
"        abandon: () => this.abandonModule?.(),\n"
"        released: () => this.released,\n"
"        connect: (console) => this.consoleObject = console,\n"
"        sizeOf: (T) => check(T?.[SIZE]),\n"
"        alignOf: (T) => check(T?.[ALIGN]),\n"
"        typeOf: (T) => structureNames[check(T?.[TYPE])]?.toLowerCase(),\n"
"      };\n"
"    },\n"
"    recreateStructures(structures, settings) {\n"
"      Object.assign(this, settings);\n"
"      const insertObjects = (dest, placeholders) => {\n"
"        for (const [ slot, placeholder ] of Object.entries(placeholders)) {\n"
"          dest[slot] = createObject(placeholder);\n"
"        }\n"
"        return dest;\n"
"      };\n"
"      const createObject = (placeholder) => {\n"
"        const { memory, structure, actual } = placeholder;\n"
"        if (memory) {\n"
"          if (actual) {\n"
"            return actual;\n"
"          } else {\n"
"            const { array, offset, length } = memory;\n"
"            const dv = this.obtainView(array.buffer, offset, length);\n"
"            const { reloc, const: isConst } = placeholder;\n"
"            const constructor = structure?.constructor;\n"
"            const object = placeholder.actual = constructor.call(ENVIRONMENT, dv);\n"
"            if (isConst) {\n"
"              this.makeReadOnly(object);\n"
"            }\n"
"            if (placeholder.slots) {\n"
"              insertObjects(object[SLOTS], placeholder.slots);\n"
"            }\n"
"            if (reloc !== undefined) {\n"
"              // need to replace dataview with one pointing to Zig memory later,\n"
"              // when the VM is up and running\n"
"              this.variables.push({ reloc, object });\n"
"            }\n"
"            return object;\n"
"          }\n"
"        } else {\n"
"          return structure;\n"
"        }\n"
"      };\n"
"      this.resetGlobalErrorSet?.();\n"
"      const objectPlaceholders = new Map();\n"
"      for (const structure of structures) {\n"
"        // recreate the actual template using the provided placeholder\n"
"        for (const scope of [ structure.instance, structure.static ]) {\n"
"          if (scope.template) {\n"
"            const { slots, memory, reloc } = scope.template;\n"
"            const object = scope.template = {};\n"
"            if (memory) {\n"
"              const { array, offset, length } = memory;\n"
"              object[MEMORY] = this.obtainView(array.buffer, offset, length);\n"
"              if (reloc) {\n"
"                this.variables.push({ reloc, object });\n"
"              }\n"
"            }\n"
"            if (slots) {\n"
"              // defer creation of objects until shapes of structures are finalized\n"
"              const realSlots = object[SLOTS] = {};\n"
"              objectPlaceholders.set(realSlots, slots);\n"
"            }\n"
"          }\n"
"        }\n"
"        this.defineStructure(structure);\n"
"      }\n"
"      // insert objects into template slots\n"
"      for (const [ slots, placeholders ] of objectPlaceholders) {\n"
"        insertObjects(slots, placeholders);\n"
"      }\n"
"      // add static members, methods, etc.\n"
"      for (const structure of structures) {\n"
"        this.finalizeStructure(structure);\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    jsFunctionThunkMap: new Map(),\n"
"    jsFunctionCallerMap: new Map(),\n"
"    jsFunctionControllerMap: new Map(),\n"
"    jsFunctionIdMap: null,\n"
"    jsFunctionNextId: 1,\n"
"\n"
"    getFunctionId(fn) {\n"
"      if (!this.jsFunctionIdMap) {\n"
"        this.jsFunctionIdMap = new WeakMap();\n"
"      }\n"
"      let id = this.jsFunctionIdMap.get(fn);\n"
"      if (id === undefined) {\n"
"        id = this.jsFunctionNextId++;\n"
"        this.jsFunctionIdMap.set(fn, id);\n"
"      }\n"
"      return id;\n"
"    },\n"
"    getFunctionThunk(fn, jsThunkController) {\n"
"      const id = this.getFunctionId(fn);\n"
"      let dv = this.jsFunctionThunkMap.get(id);\n"
"      if (dv === undefined) {\n"
"        const controllerAddress = this.getViewAddress(jsThunkController[MEMORY]);\n"
"        const thunkAddress = this.createJsThunk(controllerAddress, id);\n"
"        if (!thunkAddress) {\n"
"          throw new Error('Unable to create function thunk');\n"
"        }\n"
"        dv = this.obtainZigView(thunkAddress, 0);\n"
"        this.jsFunctionThunkMap.set(id, dv);\n"
"        this.jsFunctionControllerMap.set(id, jsThunkController);\n"
"      }\n"
"      return dv;\n"
"    },\n"
"    createInboundCaller(fn, ArgStruct) {\n"
"      const handler = (dv, futexHandle) => {\n"
"        let result = CallResult.OK;\n"
"        let awaiting = false;\n"
"        try {\n"
"          const argStruct = ArgStruct(dv);\n"
"          const onError = (err) => {\n"
"            if (ArgStruct[THROWING] && err instanceof Error) {\n"
"              // see if the error is part of the error set of the error union returned by function\n"
"              try {\n"
"                argStruct.retval = err;\n"
"                return;\n"
"              } catch (_) {\n"
"              }\n"
"            }\n"
"            console.error(err);\n"
"            result = CallResult.Failure;\n"
"          };\n"
"          const onReturn = (value) => {\n"
"            argStruct.retval = value;\n"
"          };\n"
"          try {\n"
"            const retval = fn(...argStruct);\n"
"            if (retval?.[Symbol.toStringTag] === 'Promise') {\n"
"              if (futexHandle) {\n"
"                retval.then(onReturn, onError).then(() => {\n"
"                  this.finalizeAsyncCall(futexHandle, result);\n"
"                });\n"
"                awaiting = true;\n"
"                result = CallResult.OK;\n"
"              } else {\n"
"                result = CallResult.Deadlock;\n"
"              }\n"
"            } else {\n"
"              onReturn(retval);\n"
"            }\n"
"          } catch (err) {\n"
"            onError(err);\n"
"          }\n"
"        } catch(err) {\n"
"          console.error(err);\n"
"          result = CallResult.Failure;\n"
"        }\n"
"        if (futexHandle && !awaiting) {\n"
"          this.finalizeAsyncCall(futexHandle, result);\n"
"        }\n"
"        return result;\n"
"      };\n"
"      const id = this.getFunctionId(fn);\n"
"      this.jsFunctionCallerMap.set(id, handler);\n"
"      return function(...args) {\n"
"        return fn(...args);\n"
"      };\n"
"    },\n"
"    defineArgIterator(members) {\n"
"      const allocatorTotal = members.filter(({ structure: s }) => {\n"
"        return (s.type === StructureType.Struct) && (s.flags & StructFlag.IsAllocator);\n"
"      }).length;\n"
"      return {\n"
"        value() {\n"
"          let options;\n"
"          let allocatorCount = 0, callbackCount = 0, signalCount = 0;\n"
"          const args = [];\n"
"          for (const [ srcIndex, { structure } ] of members.entries()) {\n"
"            // error unions will throw on access, in which case we pass the error as the argument\n"
"            try {\n"
"              const arg = this[srcIndex];\n"
"              let optName, opt;\n"
"              if (structure.type === StructureType.Struct) {\n"
"                if (structure.flags & StructFlag.IsAllocator) {\n"
"                  optName = (allocatorTotal === 1) ? `allocator` : `allocator${++allocatorCount}`;\n"
"                  opt = arg;\n"
"                } else if (structure.flags & StructFlag.IsPromise) {\n"
"                  optName = (++callbackCount === 1) ? 'callback' : '';\n"
"                  opt = arg.callback['*'];\n"
"                } else if (structure.flags & StructFlag.IsAbortSignal) {\n"
"                  optName = (++signalCount === 1) ? 'signal' : '';\n"
"                  const target = arg.ptr[SLOTS][0];\n"
"                  const dv = target[MEMORY];\n"
"                  opt = Int32Array(dv.buffer, 0, 1);\n"
"                }\n"
"              }\n"
"              if (optName !== undefined) {\n"
"                if (optName) {\n"
"                  options ??= {};\n"
"                  options[optName] = opt;\n"
"                }\n"
"              } else {\n"
"                // just a regular argument\n"
"                args.push(arg);\n"
"              }\n"
"            } catch (err) {\n"
"              args.push(err);\n"
"            }\n"
"          }\n"
"          if (options) {\n"
"            args.push(options);\n"
"          }\n"
"          return args[Symbol.iterator]();\n"
"        }\n"
"      };\n"
"    },\n"
"    performJsAction(action, id, argAddress, argSize, futexHandle = 0) {\n"
"      if (action === Action.Call) {\n"
"        const dv = this.obtainZigView(argAddress, argSize);\n"
"        {\n"
"          if (id) {\n"
"            return this.runFunction(id, dv, futexHandle);\n"
"          } else {\n"
"            const result = this.writeToConsole(dv) ? CallResult.OK : CallResult.Failure;\n"
"            if (futexHandle) {\n"
"              this.finalizeAsyncCall(futexHandle, result);\n"
"            }\n"
"            return result;\n"
"          }\n"
"        }\n"
"      } else if (action === Action.Release) {\n"
"        return this.releaseFunction(id);\n"
"      }\n"
"    },\n"
"    runFunction(id, dv, futexHandle) {\n"
"      const caller = this.jsFunctionCallerMap.get(id);\n"
"      if (!caller) {\n"
"        return CallResult.Failure;\n"
"      }\n"
"      return caller(dv, futexHandle);\n"
"    },\n"
"    releaseFunction(id) {\n"
"      const thunk = this.jsFunctionThunkMap.get(id);\n"
"      const controller = this.jsFunctionControllerMap.get(id);\n"
"      if (thunk && controller) {\n"
"        const controllerAddress = this.getViewAddress(controller[MEMORY]);\n"
"        const thunkAddress = this.getViewAddress(thunk);\n"
"        const id = this.destroyJsThunk(controllerAddress, thunkAddress);\n"
"        this.releaseZigView(thunk);\n"
"        if (id) {\n"
"          this.jsFunctionThunkMap.delete(id);\n"
"          this.jsFunctionCallerMap.delete(id);\n"
"          this.jsFunctionControllerMap.delete(id);\n"
"        }\n"
"      }\n"
"    },\n"
"    ...({\n"
"      exports: {\n"
"        performJsAction: null,\n"
"      },\n"
"      imports: {\n"
"        createJsThunk: null,\n"
"        destroyJsThunk: null,\n"
"        finalizeAsyncCall: null,\n"
"      },\n"
"    /* c8 ignore next */\n"
"    } ),\n"
"  });\n"
"\n"
"  mixin({\n"
"    createOutboundCaller(thunk, ArgStruct) {\n"
"      const thisEnv = this;\n"
"      const self = function (...args) {\n"
"        try {\n"
"          const argStruct = new ArgStruct(args);\n"
"          thisEnv.invokeThunk(thunk, self, argStruct);\n"
"          return argStruct[PROMISE] ?? argStruct.retval;\n"
"        } catch (err) {\n"
"          if ('fnName' in err) {\n"
"            err.fnName = self.name;\n"
"          }\n"
"          throw err;\n"
"        }\n"
"      };\n"
"      return self;\n"
"    },\n"
"    copyArguments(dest, src, members, options) {\n"
"      let srcIndex = 0;\n"
"      let allocatorCount = 0;\n"
"      for (const [ destIndex, { type, structure } ] of members.entries()) {\n"
"        let arg, callback, signal;\n"
"        if (structure.type === StructureType.Struct) {\n"
"          if (structure.flags & StructFlag.IsAllocator) {\n"
"            // use programmer-supplied allocator if found in options object, handling rare scenarios\n"
"            // where a function uses multiple allocators\n"
"            const allocator = (++allocatorCount === 1)\n"
"            ? options?.['allocator'] ?? options?.['allocator1']\n"
"            : options?.[`allocator${allocatorCount}`];\n"
"            // otherwise use default allocator which allocates relocatable memory from JS engine\n"
"            arg = allocator ?? this.createDefaultAllocator(dest, structure);\n"
"          } else if (structure.flags & StructFlag.IsPromise) {\n"
"            // invoke programmer-supplied callback if there's one, otherwise a function that\n"
"            // resolves/rejects a promise attached to the argument struct\n"
"            if (!callback) {\n"
"              callback = { callback: this.createCallback(dest, structure, options?.['callback']) };\n"
"            }\n"
"            arg = callback;\n"
"          } else if (structure.flags & StructFlag.IsAbortSignal) {\n"
"            // create an Int32Array with one element, hooking it up to the programmer-supplied\n"
"            // AbortSignal object if found\n"
"            if (!signal) {\n"
"              signal = { ptr: this.createSignalArray(dest, structure, options?.['signal']) };\n"
"            }\n"
"            arg = signal;\n"
"          }\n"
"        }\n"
"        if (arg === undefined) {\n"
"          // just a regular argument\n"
"          arg = src[srcIndex++];\n"
"          // only void has the value of undefined\n"
"          if (arg === undefined && type !== MemberType.Void) {\n"
"            throw new UndefinedArgument();\n"
"          }\n"
"        }\n"
"        try {\n"
"          dest[destIndex] = arg;\n"
"        } catch (err) {\n"
"          throw adjustArgumentError.call(err, destIndex, src.length);\n"
"        }\n"
"      }\n"
"    },\n"
"    invokeThunk(thunk, fn, args) {\n"
"      const context = args[CONTEXT];\n"
"      const attrs = args[ATTRIBUTES];\n"
"      const thunkAddress = this.getViewAddress(thunk[MEMORY]);\n"
"      const fnAddress = this.getViewAddress(fn[MEMORY]);\n"
"      const hasPointers = VISIT in args;\n"
"      if (hasPointers) {\n"
"        this.updatePointerAddresses(context, args);\n"
"      }\n"
"      // return address of shadow for argumnet struct\n"
"      const argAddress = this.getViewAddress(args[MEMORY]);\n"
"      // get address of attributes if function variadic\n"
"      const attrAddress = (attrs) ? this.getViewAddress(attrs[MEMORY]) : 0;\n"
"      this.updateShadows(context);\n"
"      const success = (attrs)\n"
"      ? this.runVariadicThunk(thunkAddress, fnAddress, argAddress, attrAddress, attrs.length)\n"
"      : this.runThunk(thunkAddress, fnAddress, argAddress);\n"
"      if (!success) {\n"
"        throw new ZigError();\n"
"      }\n"
"      const finalize = () => {\n"
"        // create objects that pointers point to\n"
"        this.updateShadowTargets(context);\n"
"        if (hasPointers) {\n"
"          this.updatePointerTargets(context, args);\n"
"        }\n"
"        this.releaseShadows(context);\n"
"        this.releaseCallContext?.(context);\n"
"        if (this.libc) {\n"
"          this.flushStdout?.();\n"
"        }\n"
"        this.flushConsole?.();\n"
"      };\n"
"      if (FINALIZE in args) {\n"
"        // async function--finalization happens when callback is invoked\n"
"        args[FINALIZE] = finalize;\n"
"      } else {\n"
"        finalize();\n"
"      }\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        runThunk: null,\n"
"        runVariadicThunk: null,\n"
"      },\n"
"    /* c8 ignore next */\n"
"    } ),\n"
"    ...(process.env.MIXIN === 'track' ? {\n"
"      usingPromise: false,\n"
"      usingAbortSignal: false,\n"
"      usingDefaultAllocator: false,\n"
"\n"
"      detectArgumentFeatures(argMembers) {\n"
"        for (const { structure: { flags } } of argMembers) {\n"
"          if (flags & StructFlag.IsAllocator) {\n"
"            this.usingDefaultAllocator = true;\n"
"          } else if (flags & StructFlag.IsPromise) {\n"
"            this.usingPromise = true;\n"
"          } else if (flags & StructFlag.IsAbortSignal) {\n"
"            this.usingAbortSignal = true;\n"
"          }\n"
"        }\n"
"      }\n"
"    /* c8 ignore next */\n"
"    } : undefined),\n"
"  });\n"
"\n"
"  mixin({\n"
"    copiers: null,\n"
"    resetters: null,\n"
"\n"
"    defineCopier(size, multiple) {\n"
"      const copy = this.getCopyFunction(size, multiple);\n"
"      return {\n"
"        value(target) {\n"
"          const src = target[MEMORY];\n"
"          const dest = this[MEMORY];\n"
"          copy(dest, src);\n"
"        },\n"
"      };\n"
"    },\n"
"    defineResetter(offset, size) {\n"
"      const reset = this.getResetFunction(size);\n"
"      return {\n"
"        value() {\n"
"          const dest = this[MEMORY];\n"
"          reset(dest, offset, size);\n"
"        }\n"
"      };\n"
"    },\n"
"    getCopyFunction(size, multiple = false) {\n"
"      if (!this.copiers) {\n"
"        this.copiers = this.defineCopiers();\n"
"      }\n"
"      const f = !multiple ? this.copiers[size] : undefined;\n"
"      return f ?? this.copiers.any;\n"
"    },\n"
"    getResetFunction(size) {\n"
"      if (!this.resetters) {\n"
"        this.resetters = this.defineResetters();\n"
"      }\n"
"      return this.resetters[size] ?? this.resetters.any;\n"
"    },\n"
"    defineCopiers() {\n"
"      const int8 = { type: MemberType.Int, bitSize: 8, byteSize: 1 };\n"
"      const int16 = { type: MemberType.Int, bitSize: 16, byteSize: 2 };\n"
"      const int32 = { type: MemberType.Int, bitSize: 32, byteSize: 4 };\n"
"      const getInt8 = this.getAccessor('get', int8);\n"
"      const setInt8 = this.getAccessor('set', int8);\n"
"      const getInt16 = this.getAccessor('get', int16);\n"
"      const setInt16 = this.getAccessor('set', int16);\n"
"      const getInt32 = this.getAccessor('get', int32);\n"
"      const setInt32 = this.getAccessor('set', int32);\n"
"\n"
"      return {\n"
"        0: empty,\n"
"        1: function(dest, src) {\n"
"          setInt8.call(dest, 0, getInt8.call(src, 0));\n"
"        },\n"
"        2: function(dest, src) {\n"
"          setInt16.call(dest, 0, getInt16.call(src, 0, true), true);\n"
"\n"
"        },\n"
"        4: function(dest, src) {\n"
"          setInt32.call(dest, 0, getInt32.call(src, 0, true), true);\n"
"        },\n"
"        8: function(dest, src) {\n"
"          setInt32.call(dest, 0, getInt32.call(src, 0, true), true);\n"
"          setInt32.call(dest, 4, getInt32.call(src, 4, true), true);\n"
"        },\n"
"        16: function(dest, src) {\n"
"          setInt32.call(dest, 0, getInt32.call(src, 0, true), true);\n"
"          setInt32.call(dest, 4, getInt32.call(src, 4, true), true);\n"
"          setInt32.call(dest, 8, getInt32.call(src, 8, true), true);\n"
"          setInt32.call(dest, 12, getInt32.call(src, 12, true), true);\n"
"        },\n"
"        'any': function(dest, src) {\n"
"          let i = 0, len = dest.byteLength;\n"
"          while (i + 4 <= len) {\n"
"            setInt32.call(dest, i, getInt32.call(src, i, true), true);\n"
"            i += 4;\n"
"          }\n"
"          while (i + 1 <= len) {\n"
"            setInt8.call(dest, i, getInt8.call(src, i));\n"
"            i++;\n"
"          }\n"
"        },\n"
"      }\n"
"    },\n"
"    defineResetters() {\n"
"      const int8 = { type: MemberType.Int, bitSize: 8, byteSize: 1 };\n"
"      const int16 = { type: MemberType.Int, bitSize: 16, byteSize: 2 };\n"
"      const int32 = { type: MemberType.Int, bitSize: 32, byteSize: 4 };\n"
"      const setInt8 = this.getAccessor('set', int8);\n"
"      const setInt16 = this.getAccessor('set', int16);\n"
"      const setInt32 = this.getAccessor('set', int32);\n"
"      return {\n"
"        0: empty,\n"
"        1: function(dest, offset) {\n"
"          setInt8.call(dest, offset, 0);\n"
"        },\n"
"        2: function(dest, offset) {\n"
"          setInt16.call(dest, offset, 0, true);\n"
"\n"
"        },\n"
"        4: function(dest, offset) {\n"
"          setInt32.call(dest, offset, 0, true);\n"
"        },\n"
"        8: function(dest, offset) {\n"
"          setInt32.call(dest, offset + 0, 0, true);\n"
"          setInt32.call(dest, offset + 4, 0, true);\n"
"        },\n"
"        16: function(dest, offset) {\n"
"          setInt32.call(dest, offset + 0, 0, true);\n"
"          setInt32.call(dest, offset + 4, 0, true);\n"
"          setInt32.call(dest, offset + 8, 0, true);\n"
"          setInt32.call(dest, offset + 12, 0, true);\n"
"        },\n"
"        any: function(dest, offset, len) {\n"
"          let i = offset;\n"
"          while (i + 4 <= len) {\n"
"            setInt32.call(dest, i, 0, true);\n"
"            i += 4;\n"
"          }\n"
"          while (i + 1 <= len) {\n"
"            setInt8.call(dest, i, 0);\n"
"            i++;\n"
"          }\n"
"        },\n"
"      };\n"
"    }\n"
"  });\n"
"\n"
"  mixin({\n"
"    nextContextId: usizeMax,\n"
"    contextMap: new Map(),\n"
"    allocatorVTable: null,\n"
"\n"
"    createDefaultAllocator(args, structure) {\n"
"      const { constructor: Allocator } = structure;\n"
"      let vtable = this.allocatorVTable;\n"
"      if (!vtable) {\n"
"        // create vtable in Zig memory\n"
"        const { VTable, noResize } = Allocator;\n"
"        const dv = this.allocateZigMemory(VTable[SIZE], VTable[ALIGN]);\n"
"        vtable = this.allocatorVTable = VTable(dv);\n"
"        vtable.alloc = (ptr, len, ptrAlign) => {\n"
"          const contextId = this.getViewAddress(ptr['*'][MEMORY]);\n"
"          const context = this.contextMap.get(contextId);\n"
"          if (context) {\n"
"            return this.allocateHostMemory(context, len, 1 << ptrAlign);\n"
"          } else {\n"
"            return null;\n"
"          }\n"
"        };\n"
"        vtable.resize = noResize;\n"
"        vtable.free = (ptr, buf, ptrAlign) => {\n"
"          const contextId = this.getViewAddress(ptr['*'][MEMORY]);\n"
"          const context = this.contextMap.get(contextId);\n"
"          if (context) {\n"
"            const address = this.getViewAddress(buf['*'][MEMORY]);\n"
"            const len = buf.length;\n"
"            this.freeHostMemory(context, address, len, 1 << ptrAlign);\n"
"          }\n"
"        };\n"
"      }\n"
"      const context = args[CONTEXT];\n"
"      const contextId = context.id = this.nextContextId--;\n"
"      // storing context id in a fake pointer\n"
"      const ptr = this.obtainZigView(contextId, 0);\n"
"      this.contextMap.set(contextId, context);\n"
"      return new Allocator({ ptr, vtable });\n"
"    },\n"
"    allocateHostMemory(context, len, align) {\n"
"      const dv = this.allocateJSMemory(len, align);\n"
"      // for WebAssembly, we need to allocate Zig memory that backs the JS memory\n"
"      // for Node, we create another DataView on the same buffer and pretend that it's zig\n"
"      // memory\n"
"      const shadowDV = this.createShadowView(dv);\n"
"      const copier = empty;\n"
"      const constructor = { [ALIGN]: align };\n"
"      const object = { constructor, [MEMORY]: dv, [COPY]: copier };\n"
"      const shadow = { constructor, [MEMORY]: shadowDV, [COPY]: copier };\n"
"      this.addShadow(context, shadow, object, align);\n"
"      return shadowDV;\n"
"    },\n"
"    freeHostMemory(context, address, len, align) {\n"
"      const shadowDV = this.unregisterMemory(context, address);\n"
"      if (shadowDV) {\n"
"        this.removeShadow(context, shadowDV);\n"
"        this.freeShadowMemory(shadowDV);\n"
"      }\n"
"    },\n"
"    releaseCallContext(context) {\n"
"      if (!context.retained) {\n"
"        this.contextMap.delete(context.id);\n"
"      }\n"
"    },\n"
"    freeDefaultAllocator() {\n"
"      if (this.allocatorVTable) {\n"
"        const dv = this.allocatorVTable[MEMORY];\n"
"        this.allocatorVTable = null;\n"
"        this.freeZigMemory(dv);\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    addIntConversion(getAccessor) {\n"
"      return function (access, member) {\n"
"        const accessor = getAccessor.call(this, access, member);\n"
"        const { flags, bitSize } = member;\n"
"        if (access === 'set') {\n"
"          return (bitSize > 32)\n"
"          ? function(offset, value, littleEndian) {\n"
"              accessor.call(this, offset, BigInt(value), littleEndian);\n"
"            }\n"
"          : function(offset, value, littleEndian) {\n"
"            const number = Number(value);\n"
"            if (!isFinite(number)) {\n"
"              throw new InvalidIntConversion(value)\n"
"            }\n"
"            accessor.call(this, offset, number, littleEndian);\n"
"          };\n"
"        } else {\n"
"          const { flags: structureFlags } = member.structure;\n"
"          if ((structureFlags & PrimitiveFlag.IsSize) && bitSize > 32) {\n"
"            const max = BigInt(Number.MAX_SAFE_INTEGER);\n"
"            const min = BigInt(Number.MIN_SAFE_INTEGER);\n"
"            return function(offset, littleEndian) {\n"
"              const bigint = accessor.call(this, offset, littleEndian);\n"
"              return (min <= bigint && bigint <= max) ? Number(bigint) : bigint;\n"
"            };\n"
"          }\n"
"        }\n"
"        return accessor;\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    emptyBuffer: new ArrayBuffer(0),\n"
"    emptyBufferMap: new Map,\n"
"\n"
"    getShadowAddress(context, target, cluster) {\n"
"      if (cluster) {\n"
"        const dv = target[MEMORY];\n"
"        if (cluster.address === undefined) {\n"
"          const shadow = this.createClusterShadow(context, cluster);\n"
"          cluster.address = this.getViewAddress(shadow[MEMORY]);\n"
"        }\n"
"        return adjustAddress(cluster.address, dv.byteOffset - cluster.start);\n"
"      } else {\n"
"        const shadow = this.createShadow(context, target);\n"
"        return this.getViewAddress(shadow[MEMORY]);\n"
"      }\n"
"    },\n"
"    createShadow(context, object) {\n"
"      const dv = object[MEMORY];\n"
"      // use the alignment of the structure; in the case of an opaque pointer's target,\n"
"      // try to the alignment specified when the memory was allocated\n"
"      const align = object.constructor[ALIGN] ?? dv[ALIGN];\n"
"      const shadow = Object.create(object.constructor.prototype);\n"
"      shadow[MEMORY] = this.allocateShadowMemory(dv.byteLength, align);\n"
"      return this.addShadow(context, shadow, object, align);\n"
"    },\n"
"    addShadow(context, shadow, object, align) {\n"
"      const shadowMap = context.shadowMap ??= new Map();\n"
"      shadowMap.set(shadow, object);\n"
"      this.registerMemory(context, shadow[MEMORY], object[MEMORY], align);\n"
"      return shadow;\n"
"    },\n"
"    findShadow(context, object) {\n"
"      const { shadowMap } = context;\n"
"      for (const [ shadow, shadowObject ] of shadowMap) {\n"
"        if (object === shadowObject) {\n"
"          return shadow;\n"
"        }\n"
"      }\n"
"    },\n"
"    removeShadow(context, dv) {\n"
"      const { shadowMap } = context;\n"
"      if (shadowMap) {\n"
"        for (const [ shadow ] of shadowMap) {\n"
"          if (shadow[MEMORY] === dv) {\n"
"            shadowMap.delete(shadow);\n"
"            break;\n"
"          }\n"
"        }\n"
"      }\n"
"    },\n"
"    createClusterShadow(context, cluster) {\n"
"      const { start, end, targets } = cluster;\n"
"      // look for largest align\n"
"      let maxAlign = 0, maxAlignOffset;\n"
"      for (const target of targets) {\n"
"        const dv = target[MEMORY];\n"
"        const offset = dv.byteOffset;\n"
"        const align = target.constructor[ALIGN] ?? dv[ALIGN];\n"
"        if (maxAlign === undefined || align > maxAlign) {\n"
"          maxAlign = align;\n"
"          maxAlignOffset = offset;\n"
"        }\n"
"      }\n"
"      // ensure the shadow buffer is large enough to accommodate necessary adjustments\n"
"      const len = end - start;\n"
"      const unalignedShadowDV = this.allocateShadowMemory(len + maxAlign, 1);\n"
"      const unalignedAddress = this.getViewAddress(unalignedShadowDV);\n"
"      const maxAlignAddress = alignForward(adjustAddress(unalignedAddress, maxAlignOffset - start), maxAlign);\n"
"      const shadowAddress = adjustAddress(maxAlignAddress, start - maxAlignOffset);\n"
"      const shadowOffset = unalignedShadowDV.byteOffset + Number(shadowAddress - unalignedAddress);\n"
"      const shadowDV = new DataView(unalignedShadowDV.buffer, shadowOffset, len);\n"
"      // make sure that other pointers are correctly aligned also\n"
"      for (const target of targets) {\n"
"        const dv = target[MEMORY];\n"
"        const offset = dv.byteOffset;\n"
"        if (offset !== maxAlignOffset) {\n"
"          const align = target.constructor[ALIGN] ?? dv[ALIGN];\n"
"          if (isMisaligned(adjustAddress(shadowAddress, offset - start), align)) {\n"
"            throw new AlignmentConflict(align, maxAlign);\n"
"          }\n"
"        }\n"
"      }\n"
"      // placeholder object type\n"
"      const prototype = defineProperty({}, COPY, this.defineCopier(len));\n"
"      const source = Object.create(prototype);\n"
"      const shadow = Object.create(prototype);\n"
"      source[MEMORY] = new DataView(targets[0][MEMORY].buffer, Number(start), len);\n"
"      shadow[MEMORY] = shadowDV;\n"
"      return this.addShadow(context, shadow, source, 1);\n"
"    },\n"
"    updateShadows(context) {\n"
"      const { shadowMap } = context;\n"
"      if (shadowMap) {\n"
"        for (const [ shadow, object ] of shadowMap) {\n"
"          shadow[COPY](object);\n"
"        }\n"
"      }\n"
"    },\n"
"    updateShadowTargets(context) {\n"
"      const { shadowMap } = context;\n"
"      if (shadowMap) {\n"
"        for (const [ shadow, object ] of shadowMap) {\n"
"          object[COPY](shadow);\n"
"        }\n"
"      }\n"
"    },\n"
"    releaseShadows(context) {\n"
"      const { shadowMap } = context;\n"
"      if (!shadowMap) {\n"
"        return;\n"
"      }\n"
"      for (const [ shadow ] of shadowMap) {\n"
"        this.freeShadowMemory(shadow[MEMORY]);\n"
"      }\n"
"    },\n"
"    registerMemory(context, dv, targetDV = null, targetAlign = undefined) {\n"
"      const { memoryList } = context;\n"
"      const address = this.getViewAddress(dv);\n"
"      const index = findMemoryIndex(memoryList, address);\n"
"      memoryList.splice(index, 0, { address, dv, len: dv.byteLength, targetDV, targetAlign });\n"
"      return address;\n"
"    },\n"
"    unregisterMemory(context, address) {\n"
"      const { memoryList } = context;\n"
"      const index = findMemoryIndex(memoryList, address);\n"
"      const entry = memoryList[index - 1];\n"
"      if (entry?.address === address) {\n"
"        memoryList.splice(index - 1, 1);\n"
"        return entry.dv;\n"
"      }\n"
"    },\n"
"    findMemory(context, address, count, size) {\n"
"      if (isInvalidAddress(address)) {\n"
"        if (!count) {\n"
"          address = 0;\n"
"        } else {\n"
"          return null;\n"
"        }\n"
"      } else if (!address && count) {\n"
"        return null;\n"
"      }\n"
"      let len = count * (size ?? 0);\n"
"      // check for null address (=== can't be used since address can be both number and bigint)\n"
"      if (context) {\n"
"        // see if the address points to the call context; if so, we need to retain the context\n"
"        // because a copy of the allocator is stored in a returned structure\n"
"        if (size === undefined && context.id === address) {\n"
"          context.retained = true;\n"
"        }\n"
"        const { memoryList } = context;\n"
"        const index = findMemoryIndex(memoryList, address);\n"
"        const entry = memoryList[index - 1];\n"
"        if (entry?.address === address && entry.len === len) {\n"
"          return entry.targetDV ?? entry.dv;\n"
"        } else if (entry?.address <= address && address < adjustAddress(entry.address, entry.len)) {\n"
"          const offset = Number(address - entry.address);\n"
"          const targetDV = entry.targetDV ?? entry.dv;\n"
"          const isOpaque = size === undefined;\n"
"          if (isOpaque) {\n"
"            len = targetDV.byteLength - offset;\n"
"          }\n"
"          const dv = this.obtainView(targetDV.buffer, targetDV.byteOffset + offset, len);\n"
"          if (isOpaque) {\n"
"            // opaque structure--need to save the alignment\n"
"            dv[ALIGN] = entry.targetAlign;\n"
"          }\n"
"          return dv;\n"
"        }\n"
"      }\n"
"      // not found in any of the buffers we've seen--assume it's Zig memory\n"
"      return this.obtainZigView(address, len);\n"
"    },\n"
"    allocateZigMemory(len, align, type = MemoryType.Normal) {\n"
"      const address = (len) ? this.allocateExternMemory(type, len, align) : 0;\n"
"      const dv = this.obtainZigView(address, len);\n"
"      dv[ZIG].align = align;\n"
"      dv[ZIG].type = type;\n"
"      return dv;\n"
"    },\n"
"    freeZigMemory(dv) {\n"
"      const { address, unalignedAddress, len, align, type } = dv[ZIG];\n"
"      if (len) {\n"
"        this.freeExternMemory(type, unalignedAddress ?? address, len, align);\n"
"      }\n"
"    },\n"
"    obtainZigView(address, len) {\n"
"      let dv;\n"
"      if (address && len) {\n"
"        dv = this.obtainExternView(address, len);\n"
"      } else {\n"
"        // pointer to nothing\n"
"        dv = this.emptyBufferMap.get(address);\n"
"        if (!dv) {\n"
"          dv = new DataView(this.emptyBuffer);\n"
"          dv[ZIG] = { address, len: 0 };\n"
"          this.emptyBufferMap.set(address, dv);\n"
"        }\n"
"      }\n"
"      return dv;\n"
"    },\n"
"    releaseZigView(dv) {\n"
"      const zig = dv[ZIG];\n"
"      const address = zig?.address;\n"
"      if (address && address !== usizeInvalid) {\n"
"        // set address to invalid to avoid double free\n"
"        zig.address = usizeInvalid;\n"
"        if (!zig.len) {\n"
"          // remove view from empty buffer map\n"
"          this.emptyBufferMap.delete(address);\n"
"        }\n"
"      }\n"
"    },\n"
"    getViewAddress(dv) {\n"
"      const zig = dv[ZIG];\n"
"      if (zig) {\n"
"        return zig.address;\n"
"      } else {\n"
"        const address = this.getBufferAddress(dv.buffer);\n"
"        return adjustAddress(address, dv.byteOffset);\n"
"      }\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        allocateExternMemory: null,\n"
"        freeExternMemory: null,\n"
"        getBufferAddress: null,\n"
"        copyExternBytes: null,\n"
"        obtainExternBuffer: null,\n"
"      },\n"
"      exports: {\n"
"        getViewAddress: null,\n"
"      },\n"
"\n"
"      allocateShadowMemory(len, align) {\n"
"        // Node can read into JavaScript memory space so we can keep shadows there\n"
"        return this.allocateJSMemory(len, align);\n"
"      },\n"
"      freeShadowMemory(dv) {\n"
"        // nothing needs to happen\n"
"      },\n"
"      createShadowView(dv) {\n"
"        // create a fake zig view for bypassing pointer check\n"
"        const address = this.getViewAddress(dv);\n"
"        const len = dv.byteLength;\n"
"        const shadowDV = new DataView(dv.buffer, dv.byteOffset, len);\n"
"        shadowDV[ZIG] = { address, len };\n"
"        return shadowDV;\n"
"      },\n"
"      obtainExternView(address, len) {\n"
"        const buffer = this.obtainExternBuffer(address, len, FALLBACK);\n"
"        buffer[ZIG] = { address, len };\n"
"        return this.obtainView(buffer, 0, len);\n"
"      },\n"
"      getTargetAddress(context, target, cluster) {\n"
"        const dv = target[MEMORY];\n"
"        if (cluster) {\n"
"          // pointer is pointing to buffer with overlapping views\n"
"          if (cluster.misaligned === undefined) {\n"
"            const address = this.getBufferAddress(dv.buffer);\n"
"            // ensure that all pointers are properly aligned\n"
"            for (const target of cluster.targets) {\n"
"              const offset = target[MEMORY].byteOffset;\n"
"              const align = target.constructor[ALIGN];\n"
"              const viewAddress = adjustAddress(address, offset);\n"
"              if (isMisaligned(viewAddress, align)) {\n"
"                cluster.misaligned = true;\n"
"                break;\n"
"              }\n"
"            }\n"
"            if (cluster.misaligned === undefined)  {\n"
"              cluster.misaligned = false;\n"
"              cluster.address = address;\n"
"            }\n"
"          }\n"
"          if (!cluster.misaligned) {\n"
"            return adjustAddress(cluster.address, dv.byteOffset);\n"
"          }\n"
"        } else {\n"
"          const align = target.constructor[ALIGN];\n"
"          const address = this.getViewAddress(dv);\n"
"          if (!isMisaligned(address, align)) {\n"
"            this.registerMemory(context, dv);\n"
"            return address;\n"
"          }\n"
"        }\n"
"        // need shadowing\n"
"      },\n"
"      /* c8 ignore next */\n"
"    } ),\n"
"  });\n"
"\n"
"  function findMemoryIndex(array, address) {\n"
"    return findSortedIndex(array, address, m => m.address);\n"
"  }\n"
"\n"
"  const MemoryType = {\n"
"    Normal: 0,\n"
"    Scratch: 1,\n"
"  };\n"
"\n"
"  mixin({\n"
"    released: false,\n"
"    abandoned: false,\n"
"\n"
"    releaseFunctions() {\n"
"      const throwError = () => { throw new Error(`Module was abandoned`) };\n"
"      for (const name of Object.keys(this.imports)) {\n"
"        if (this[name]) {\n"
"          this[name] = throwError;\n"
"        }\n"
"      }\n"
"    },\n"
"    abandonModule() {\n"
"      if (!this.abandoned) {\n"
"        this.freeDefaultAllocator?.();\n"
"        this.releaseFunctions();\n"
"        this.unlinkVariables?.();\n"
"        this.abandoned = true;\n"
"      }\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        loadModule: null,\n"
"      },\n"
"\n"
"      exportFunctions() {\n"
"        const imports = {};\n"
"        for (const [ name, alias ] of Object.entries(this.exports)) {\n"
"          const fn = this[alias ?? name];\n"
"          if (fn) {\n"
"            imports[name] = fn.bind(this);\n"
"          }\n"
"        }\n"
"        return imports;\n"
"      },\n"
"      importFunctions(exports) {\n"
"        for (const [ name, alias ] of Object.entries(this.imports)) {\n"
"          const fn = exports[alias ?? /* c8 ignore next */ name];\n"
"          if (fn) {\n"
"            this[name] = fn;\n"
"          }\n"
"        }\n"
"      },\n"
"    /* c8 ignore next */\n"
"    } )\n"
"  });\n"
"\n"
"  mixin({\n"
"    linkVariables(writeBack) {\n"
"      const pointers = [];\n"
"      for (const { object, reloc } of this.variables) {\n"
"        this.linkObject(object, reloc, writeBack);\n"
"        if (TARGET in object && object[SLOTS][0]) {\n"
"          pointers.push(object);\n"
"        }\n"
"      }\n"
"      // save locations of pointer targets\n"
"      for (const pointer of pointers) {\n"
"        const target = pointer[TARGET];\n"
"        const address = this.getViewAddress(target[MEMORY]);\n"
"        pointer[ADDRESS] = address;\n"
"        if (LENGTH in pointer) {\n"
"          pointer[LENGTH] = target.length;\n"
"        }\n"
"      }\n"
"    },\n"
"    linkObject(object, reloc, writeBack) {\n"
"      if (object[MEMORY][ZIG]) {\n"
"        return;\n"
"      }\n"
"      const dv = object[MEMORY];\n"
"      const address = this.recreateAddress(reloc);\n"
"      const length = dv.byteLength;\n"
"      const zigDV = this.obtainZigView(address, length);\n"
"      if (writeBack && length > 0) {\n"
"        const dest = Object.create(object.constructor.prototype);\n"
"        dest[MEMORY] = zigDV;\n"
"        dest[COPY](object);\n"
"      }\n"
"      object[MEMORY] = zigDV;\n"
"      const linkChildren = (object) => {\n"
"        if (object[SLOTS]) {\n"
"          for (const child of Object.values(object[SLOTS])) {\n"
"            if (child) {\n"
"              const childDV = child[MEMORY];\n"
"              if (childDV.buffer === dv.buffer) {\n"
"                const offset = childDV.byteOffset - dv.byteOffset;\n"
"                child[MEMORY] = this.obtainView(zigDV.buffer, offset, childDV.byteLength);\n"
"                linkChildren(child);\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"      };\n"
"      linkChildren(object);\n"
"    },\n"
"    unlinkVariables() {\n"
"      for (const { object } of this.variables) {\n"
"        this.unlinkObject(object);\n"
"      }\n"
"    },\n"
"    unlinkObject(object) {\n"
"      if (!object[MEMORY][ZIG]) {\n"
"        return;\n"
"      }\n"
"      const dv = object[MEMORY];\n"
"      const relocDV = this.allocateMemory(dv.byteLength);\n"
"      if (object[COPY]) {\n"
"        const dest = Object.create(object.constructor.prototype);\n"
"        dest[MEMORY] = relocDV;\n"
"        dest[COPY](object);\n"
"      }\n"
"      object[MEMORY] = relocDV;\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        recreateAddress: null,\n"
"      },\n"
"      /* c8 ignore start */\n"
"    } ),\n"
"      ...(process.env.MIXIN === 'track' ? {\n"
"      useObjectLinkage() {\n"
"        // empty function used for mixin tracking\n"
"      },\n"
"    } : undefined),\n"
"      /* c8 ignore end */\n"
"    });\n"
"\n"
"  mixin({\n"
"    updatePointerAddresses(context, args) {\n"
"      // first, collect all the pointers\n"
"      const pointerMap = new Map();\n"
"      const bufferMap = new Map();\n"
"      const potentialClusters = [];\n"
"      const callback = function({ isActive }) {\n"
"        if (isActive(this)) {\n"
"          // bypass proxy\n"
"          const pointer = this[POINTER];\n"
"          if (!pointerMap.get(pointer)) {\n"
"            const target = pointer[SLOTS][0];\n"
"            if (target) {\n"
"              pointerMap.set(pointer, target);\n"
"              // only relocatable targets need updating\n"
"              const dv = target[MEMORY];\n"
"              if (!dv[ZIG]) {\n"
"                // see if the buffer is shared with other objects\n"
"                const other = bufferMap.get(dv.buffer);\n"
"                if (other) {\n"
"                  const array = Array.isArray(other) ? other : [ other ];\n"
"                  const index = findSortedIndex(array, dv.byteOffset, t => t[MEMORY].byteOffset);\n"
"                  array.splice(index, 0, target);\n"
"                  if (!Array.isArray(other)) {\n"
"                    bufferMap.set(dv.buffer, array);\n"
"                    potentialClusters.push(array);\n"
"                  }\n"
"                } else {\n"
"                  bufferMap.set(dv.buffer, target);\n"
"                }\n"
"                // scan pointers in target\n"
"                target[VISIT]?.(callback);\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"      };\n"
"      args[VISIT](callback);\n"
"      // find targets that overlap each other\n"
"      const clusters = this.findTargetClusters(potentialClusters);\n"
"      const clusterMap = new Map();\n"
"      for (const cluster of clusters) {\n"
"        for (const target of cluster.targets) {\n"
"          clusterMap.set(target, cluster);\n"
"        }\n"
"      }\n"
"      // process the pointers\n"
"      for (const [ pointer, target ] of pointerMap) {\n"
"        if (!pointer[MEMORY][ZIG]) {\n"
"          const cluster = clusterMap.get(target);\n"
"          const address = this.getTargetAddress(context, target, cluster)\n"
"                       ?? this.getShadowAddress(context, target, cluster);\n"
"          // update the pointer\n"
"          pointer[ADDRESS] = address;\n"
"          if (LENGTH in pointer) {\n"
"            pointer[LENGTH] = target.length;\n"
"          }\n"
"        }\n"
"      }\n"
"    },\n"
"    updatePointerTargets(context, args) {\n"
"      const pointerMap = new Map();\n"
"      const callback = function({ isActive, isMutable }) {\n"
"        // bypass proxy\n"
"        const pointer = this[POINTER] /* c8 ignore next */ ?? this;\n"
"        if (!pointerMap.get(pointer)) {\n"
"          pointerMap.set(pointer, true);\n"
"          const writable = !pointer.constructor.const;\n"
"          const currentTarget = pointer[SLOTS][0];\n"
"          const newTarget = (!currentTarget || isMutable(this))\n"
"          ? pointer[UPDATE](context, true, isActive(this))\n"
"          : currentTarget;\n"
"          // update targets of pointers in original target if it's in relocatable memory\n"
"          // pointers in Zig memory are updated on access so we don't need to do it here\n"
"          // (and they should never point to reloctable memory)\n"
"          if (currentTarget && !currentTarget[MEMORY][ZIG]) {\n"
"            currentTarget[VISIT]?.(callback, { vivificate: true, isMutable: () => writable });\n"
"          }\n"
"          if (newTarget !== currentTarget) {\n"
"            if (newTarget && !newTarget[MEMORY][ZIG]) {\n"
"              // acquire targets of pointers in new target\n"
"              newTarget?.[VISIT]?.(callback, { vivificate: true, isMutable: () => writable });\n"
"            }\n"
"          }\n"
"        }\n"
"      };\n"
"      args[VISIT](callback, { vivificate: true });\n"
"    },\n"
"    findTargetClusters(potentialClusters) {\n"
"      const clusters = [];\n"
"      for (const targets of potentialClusters) {\n"
"        let prevTarget = null, prevStart = 0, prevEnd = 0;\n"
"        let currentCluster = null;\n"
"        for (const target of targets) {\n"
"          const dv = target[MEMORY];\n"
"          const { byteOffset: start, byteLength } = dv;\n"
"          const end = start + byteLength;\n"
"          let forward = true;\n"
"          if (prevTarget) {\n"
"            if (prevEnd > start) {\n"
"              // the previous target overlaps this one\n"
"              if (!currentCluster) {\n"
"                currentCluster = {\n"
"                  targets: [ prevTarget ],\n"
"                  start: prevStart,\n"
"                  end: prevEnd,\n"
"                  address: undefined,\n"
"                  misaligned: undefined,\n"
"                };\n"
"                clusters.push(currentCluster);\n"
"              }\n"
"              currentCluster.targets.push(target);\n"
"              if (end > prevEnd) {\n"
"                // set cluster end offset to include this one\n"
"                currentCluster.end = end;\n"
"              } else {\n"
"                // the previous target contains this one\n"
"                forward = false;\n"
"              }\n"
"            } else {\n"
"              currentCluster = null;\n"
"            }\n"
"          }\n"
"          if (forward) {\n"
"            prevTarget = target;\n"
"            prevStart = start;\n"
"            prevEnd = end;\n"
"          }\n"
"        }\n"
"      }\n"
"      return clusters;\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    createCallback(args, structure, callback) {\n"
"      if (callback) {\n"
"        if (typeof(callback) !== 'function') {\n"
"          throw new TypeMismatch('function', callback);\n"
"        }\n"
"      } else {\n"
"        let resolve, reject;\n"
"        args[PROMISE] = new Promise((...args) => {\n"
"          resolve = args[0];\n"
"          reject = args[1];\n"
"        });\n"
"        callback = (result) => {\n"
"          if (result?.[MEMORY]?.[ZIG]) {\n"
"            // the memory in the result object is stack memory, which will go bad after the function\n"
"            // returns; we need to copy the content into JavaScript memory\n"
"            result = new result.constructor(result);\n"
"          }\n"
"          const f = (result instanceof Error) ? reject : resolve;\n"
"          f(result);\n"
"        };\n"
"      }\n"
"      return (result) => {\n"
"        if (!(result instanceof Error)) {\n"
"          args[FINALIZE]();\n"
"        }\n"
"        return callback(result);\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    addRuntimeCheck(getAccessor) {\n"
"      return function (access, member) {\n"
"        const accessor = getAccessor.call(this, access, member);\n"
"        if (access === 'set') {\n"
"          const { min, max } = getIntRange(member);\n"
"          return function(offset, value, littleEndian) {\n"
"            if (value < min || value > max) {\n"
"              throw new Overflow(member, value);\n"
"            }\n"
"            accessor.call(this, offset, value, littleEndian);\n"
"          };\n"
"        }\n"
"        return accessor;\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  function getIntRange(member) {\n"
"    const { type, bitSize } = member;\n"
"    const signed = (type === MemberType.Int);\n"
"    let magBits = (signed) ? bitSize - 1 : bitSize;\n"
"    if (bitSize <= 32) {\n"
"      const max = 2 ** magBits - 1;\n"
"      const min = (signed) ? -(2 ** magBits) : 0;\n"
"      return { min, max };\n"
"    } else {\n"
"      magBits = BigInt(magBits);\n"
"      const max = 2n ** magBits - 1n;\n"
"      const min = (signed) ? -(2n ** magBits) : 0n;\n"
"      return { min, max };\n"
"    }\n"
"  }\n"
"\n"
"  mixin({\n"
"    consoleObject: null,\n"
"    consolePending: [],\n"
"    consoleTimeout: 0,\n"
"\n"
"    writeToConsole(dv) {\n"
"      try {\n"
"        // make copy of array, in case incoming buffer is pointing to stack memory\n"
"        const array = new Uint8Array(dv.buffer, dv.byteOffset, dv.byteLength).slice();\n"
"        // send text up to the last newline character\n"
"        const index = array.lastIndexOf(0x0a);\n"
"        if (index === -1) {\n"
"          this.consolePending.push(array);\n"
"        } else {\n"
"          const beginning = array.subarray(0, index);\n"
"          const remaining = array.subarray(index + 1);\n"
"          this.writeToConsoleNow([ ...this.consolePending, beginning ]);\n"
"          this.consolePending.splice(0);\n"
"          if (remaining.length > 0) {\n"
"            this.consolePending.push(remaining);\n"
"          }\n"
"        }\n"
"        clearTimeout(this.consoleTimeout);\n"
"        this.consoleTimeout = 0;\n"
"        if (this.consolePending.length > 0) {\n"
"          this.consoleTimeout = setTimeout(() => {\n"
"            this.writeToConsoleNow(this.consolePending);\n"
"            this.consolePending.splice(0);\n"
"          }, 250);\n"
"        }\n"
"        return true;\n"
"        /* c8 ignore next 4 */\n"
"      } catch (err) {\n"
"        console.error(err);\n"
"        return false;\n"
"      }\n"
"    },\n"
"    writeToConsoleNow(array) {\n"
"      const c = this.consoleObject ?? globalThis.console;\n"
"      c.log?.call?.(c, decodeText(array));\n"
"    },\n"
"    flushConsole() {\n"
"      if (this.consolePending.length > 0) {\n"
"        this.writeToConsoleNow(this.consolePending);\n"
"        this.consolePending.splice(0);\n"
"        clearTimeout(this.consoleTimeout);\n"
"      }\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        flushStdout: null,\n"
"      },\n"
"      /* c8 ignore next */\n"
"    } ),\n"
"  });\n"
"\n"
"  mixin({\n"
"    comptime: false,\n"
"    slots: {},\n"
"    structures: [],\n"
"    structureCounters: {\n"
"      struct: 0,\n"
"      union: 0,\n"
"      errorSet: 0,\n"
"      enum: 0,\n"
"      opaque: 0,\n"
"    },\n"
"    littleEndian: true,\n"
"    runtimeSafety: false,\n"
"    libc: false,\n"
"\n"
"    readSlot(target, slot) {\n"
"      const slots = target ? target[SLOTS] : this.slots;\n"
"      return slots?.[slot];\n"
"    },\n"
"    writeSlot(target, slot, value) {\n"
"      const slots = target ? target[SLOTS] : this.slots;\n"
"      if (slots) {\n"
"        slots[slot] = value;\n"
"      }\n"
"    },\n"
"    createTemplate(dv) {\n"
"      return {\n"
"        [MEMORY]: dv,\n"
"        [SLOTS]: {}\n"
"      };\n"
"    },\n"
"    beginStructure(def) {\n"
"      const {\n"
"        type,\n"
"        name,\n"
"        length,\n"
"        byteSize,\n"
"        align,\n"
"        flags,\n"
"      } = def;\n"
"      return {\n"
"        constructor: null,\n"
"        type,\n"
"        flags,\n"
"        name,\n"
"        length,\n"
"        byteSize,\n"
"        align,\n"
"        instance: {\n"
"          members: [],\n"
"          template: null,\n"
"        },\n"
"        static: {\n"
"          members: [],\n"
"          template: null,\n"
"        },\n"
"      };\n"
"    },\n"
"    attachMember(structure, member, isStatic = false) {\n"
"      const target = (isStatic) ? structure.static : structure.instance;\n"
"      target.members.push(member);\n"
"    },\n"
"    attachTemplate(structure, template, isStatic = false) {\n"
"      const target = (isStatic) ? structure.static : structure.instance;\n"
"      target.template = template;\n"
"    },\n"
"    endStructure(structure) {\n"
"      if (!structure.name) {\n"
"        this.inferTypeName(structure);\n"
"      }\n"
"      this.structures.push(structure);\n"
"      this.finalizeStructure(structure);\n"
"    },\n"
"    captureView(address, len, copy) {\n"
"      if (copy) {\n"
"        // copy content into JavaScript memory\n"
"        const dv = this.allocateJSMemory(len, 0);\n"
"        if (len > 0) {\n"
"          this.copyExternBytes(dv, address, len);\n"
"        }\n"
"        return dv;\n"
"      } else {\n"
"        // link into Zig memory\n"
"        return this.obtainZigView(address, len);\n"
"      }\n"
"    },\n"
"    castView(address, len, copy, structure) {\n"
"      const { constructor, flags } = structure;\n"
"      const dv = this.captureView(address, len, copy);\n"
"      const object = constructor.call(ENVIRONMENT, dv);\n"
"      if (flags & StructureFlag.HasPointer) {\n"
"        // acquire targets of pointers\n"
"        this.updatePointerTargets(null, object);\n"
"      }\n"
"      if (copy && len > 0) {\n"
"        this.makeReadOnly?.(object);\n"
"      }\n"
"      return object;\n"
"    },\n"
"    acquireDefaultPointers() {\n"
"      for (const structure of this.structures) {\n"
"        const { constructor, flags, instance: { template } } = structure;\n"
"        if (flags & StructureFlag.HasPointer && template && template[MEMORY]) {\n"
"          // create a placeholder for retrieving default pointers\n"
"          const placeholder = Object.create(constructor.prototype);\n"
"          placeholder[MEMORY] = template[MEMORY];\n"
"          placeholder[SLOTS] = template[SLOTS];\n"
"          this.updatePointerTargets(null, placeholder);\n"
"        }\n"
"      }\n"
"    },\n"
"    acquireStructures(options) {\n"
"      const attrs = this.getModuleAttributes();\n"
"      this.littleEndian = !!(attrs & ModuleAttribute.LittleEndian);\n"
"      this.runtimeSafety = !!(attrs & ModuleAttribute.RuntimeSafety);\n"
"      this.libc = !!(attrs & ModuleAttribute.LibC);\n"
"      const thunkAddress = this.getFactoryThunk();\n"
"      const thunk = { [MEMORY]: this.obtainZigView(thunkAddress, 0) };\n"
"      const { littleEndian } = this;\n"
"      const FactoryArg = function(options) {\n"
"        const {\n"
"          omitFunctions = false,\n"
"          omitVariables = false,\n"
"        } = options;\n"
"        const dv = new DataView(new ArrayBuffer(4));\n"
"        let flags = 0;\n"
"        if (omitFunctions) {\n"
"          flags |= ExportFlag.OmitMethods;\n"
"        }\n"
"        if (omitVariables) {\n"
"          flags |= ExportFlag.OmitVariables;\n"
"        }\n"
"        dv.setUint32(0, flags, littleEndian);\n"
"        this[MEMORY] = dv;\n"
"        this[CONTEXT] = new CallContext();\n"
"      };\n"
"      defineProperty(FactoryArg.prototype, COPY, this.defineCopier(4));\n"
"      const args = new FactoryArg(options);\n"
"      this.comptime = true;\n"
"      this.invokeThunk(thunk, thunk, args);\n"
"      this.comptime = false;\n"
"    },\n"
"    getRootModule() {\n"
"      const root = this.structures[this.structures.length - 1];\n"
"      return root.constructor;\n"
"    },\n"
"    hasMethods() {\n"
"      return !!this.structures.find(s => s.type === StructureType.Function);\n"
"    },\n"
"    exportStructures() {\n"
"      this.acquireDefaultPointers();\n"
"      this.prepareObjectsForExport();\n"
"      const { structures, runtimeSafety, littleEndian, libc } = this;\n"
"      return {\n"
"        structures,\n"
"        settings: { runtimeSafety, littleEndian, libc },\n"
"        keys: { MEMORY, SLOTS, CONST_TARGET },\n"
"      };\n"
"    },\n"
"    prepareObjectsForExport() {\n"
"      const objects = findObjects(this.structures, SLOTS);\n"
"      const list = [];\n"
"      for (const object of objects) {\n"
"        if (object[MEMORY]?.[ZIG]) {\n"
"          // replace Zig memory\n"
"          const dv = object[MEMORY];\n"
"          const address = this.getViewAddress(dv);\n"
"          const offset = this.getMemoryOffset(address);\n"
"          const len = dv.byteLength;\n"
"          const relocDV = this.captureView(address, len, true);\n"
"          relocDV.reloc = offset;\n"
"          object[MEMORY] = relocDV;\n"
"          list.push({ offset, len, owner: object, replaced: false });\n"
"        }\n"
"      }\n"
"      // larger memory blocks come first\n"
"      list.sort((a, b) => b.len - a.len);\n"
"      for (const a of list) {\n"
"        if (!a.replaced) {\n"
"          for (const b of list) {\n"
"            if (a !== b && !b.replaced) {\n"
"              if (a.offset <= b.offset && b.offset < a.offset + a.len) {\n"
"                // B is inside A--replace it with a view of A's buffer\n"
"                const dv = a.owner[MEMORY];\n"
"                const pos = b.offset - a.offset + dv.byteOffset;\n"
"                const newDV = this.obtainView(dv.buffer, pos, b.len);\n"
"                newDV.reloc = b.offset;\n"
"                b.owner[MEMORY] = newDV;\n"
"                b.replaced = true;\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"      }\n"
"      if (process.env.MIXIN === 'track') {\n"
"        if (list.length > 0) {\n"
"          // mixin \"features/object-linkage\" is used when there are objects linked to Zig memory\n"
"          this.useObjectLinkage();\n"
"        }\n"
"      }\n"
"    },\n"
"    useStructures() {\n"
"      const module = this.getRootModule();\n"
"      // add Zig memory object to list so they can be unlinked\n"
"      const objects = findObjects(this.structures, SLOTS);\n"
"      for (const object of objects) {\n"
"        if (object[MEMORY]?.[ZIG]) {\n"
"          this.variables.push({ object });\n"
"        }\n"
"      }\n"
"      // clear comptime-only variables\n"
"      this.slots = {};\n"
"      this.structures = [];\n"
"      module.__zigar = this.getSpecialExports();\n"
"      return module;\n"
"    },\n"
"    inferTypeName(s) {\n"
"      const handlerName = `get${structureNames[s.type]}Name`;\n"
"      const handler = this[handlerName];\n"
"      s.name = handler.call(this, s);\n"
"    },\n"
"    getPrimitiveName(s) {\n"
"      const { instance: { members: [ member ] }, static: { template }, flags } = s;\n"
"      switch (member.type) {\n"
"        case MemberType.Bool:\n"
"          return `bool`;\n"
"        case MemberType.Int:\n"
"          return (flags & PrimitiveFlag.IsSize) ? `isize` : `i${member.bitSize}`;\n"
"        case MemberType.Uint:\n"
"          return (flags & PrimitiveFlag.IsSize) ? `usize` : `u${member.bitSize}`;\n"
"        case MemberType.Float:\n"
"          return `f${member.bitSize}`;\n"
"        case MemberType.Void:\n"
"          return 'void';\n"
"        case MemberType.Literal:\n"
"          return 'enum_literal';\n"
"        case MemberType.Null:\n"
"          return 'null';\n"
"        case MemberType.Undefined:\n"
"          return 'undefined';\n"
"        case MemberType.Type:\n"
"          return 'type';\n"
"        case MemberType.Object:\n"
"          return 'comptime';\n"
"        default:\n"
"          return 'unknown';\n"
"      }\n"
"    },\n"
"    getArrayName(s) {\n"
"      const { instance: { members: [ element ] }, length } = s;\n"
"      return `[${length}]${element.structure.name}`;\n"
"    },\n"
"    getStructName(s) {\n"
"      return `S${this.structureCounters.struct++}`;\n"
"    },\n"
"    getUnionName(s) {\n"
"      return `U${this.structureCounters.union++}`;\n"
"    },\n"
"    getErrorUnionName(s) {\n"
"      const { instance: { members: [ payload, errorSet ] } } = s;\n"
"      return `${errorSet.structure.name}!${payload.structure.name}`;\n"
"    },\n"
"    getErrorSetName(s) {\n"
"      return (s.flags & ErrorSetFlag.IsGlobal) ? 'anyerror' : `ES${this.structureCounters.errorSet++}`;\n"
"    },\n"
"    getEnumName(s) {\n"
"      return `E${this.structureCounters.enum++}`;\n"
"    },\n"
"    getOptionalName(s) {\n"
"      const { instance: { members: [ payload ] } } = s;\n"
"      return `?${payload.structure.name}`;\n"
"    },\n"
"    getPointerName(s) {\n"
"      const { instance: { members: [ target ] }, flags } = s;\n"
"      let prefix = '*';\n"
"      let targetName = target.structure.name;\n"
"      if (target.structure.type === StructureType.Slice) {\n"
"        targetName = targetName.slice(3);\n"
"      }\n"
"      if (flags & PointerFlag.IsMultiple) {\n"
"        if (flags & PointerFlag.HasLength) {\n"
"          prefix = '[]';\n"
"        } else if (flags & PointerFlag.IsSingle) {\n"
"          prefix = '[*c]';\n"
"        } else {\n"
"          prefix = '[*]';\n"
"        }\n"
"      }\n"
"      const sentinel = target.constructor[SENTINEL];\n"
"      if (sentinel) {\n"
"        prefix = prefix.slice(0, -1) + `:${sentinel.value}` + prefix.slice(-1);\n"
"      }\n"
"      if (flags & PointerFlag.IsConst) {\n"
"        prefix = `${prefix}const `;\n"
"      }\n"
"      return prefix + targetName;\n"
"    },\n"
"    getSliceName(s) {\n"
"      const { instance: { members: [ element ] }, flags } = s;\n"
"      return (flags & SliceFlag.IsOpaque) ? 'anyopaque' : `[_]${element.structure.name}`;\n"
"    },\n"
"    getVectorName(s) {\n"
"      const { instance: { members: [ element ] }, length } = s;\n"
"      return `@Vector(${length}, ${element.structure.name})`;\n"
"    },\n"
"    getOpaqueName(s) {\n"
"      return `O${this.structureCounters.opaque++}`;\n"
"    },\n"
"    getArgStructName(s) {\n"
"      const { instance: { members } } = s;\n"
"      const retval = members[0];\n"
"      const args = members.slice(1);\n"
"      const rvName = retval.structure.name;\n"
"      const argNames = args.map(a => a.structure.name);\n"
"      return `Arg(fn (${argNames.join(' ,')}) ${rvName})`;\n"
"    },\n"
"    getVariadicStructName(s) {\n"
"      const { instance: { members } } = s;\n"
"      const retval = members[0];\n"
"      const args = members.slice(1);\n"
"      const rvName = retval.structure.name;\n"
"      const argNames = args.map(a => a.structure.name);\n"
"      return `Arg(fn (${argNames.join(' ,')}, ...) ${rvName})`;\n"
"    },\n"
"    getFunctionName(s) {\n"
"      const { instance: { members: [ args ] } } = s;\n"
"      const argName = args.structure.name;\n"
"      return argName.slice(4, -1);\n"
"    },\n"
"    ...({\n"
"      exports: {\n"
"        captureView: null,\n"
"        castView: null,\n"
"        readSlot: null,\n"
"        writeSlot: null,\n"
"        beginStructure: null,\n"
"        attachMember: null,\n"
"        createTemplate: null,\n"
"        attachTemplate: null,\n"
"        defineStructure: null,\n"
"        endStructure: null,\n"
"      },\n"
"      imports: {\n"
"        getFactoryThunk: null,\n"
"        getModuleAttributes: null,\n"
"        getMemoryOffset: null,\n"
"      },\n"
"    /* c8 ignore next */\n"
"    } ),\n"
"  });\n"
"\n"
"  mixin({\n"
"    ...(undefined),\n"
"  });\n"
"\n"
"  mixin({\n"
"    viewMap: new Map(),\n"
"\n"
"    extractView(structure, arg, onError = throwError) {\n"
"      const { type, byteSize, constructor } = structure;\n"
"      let dv;\n"
"      // not using instanceof just in case we're getting objects created in other contexts\n"
"      const tag = arg?.[Symbol.toStringTag];\n"
"      if (tag) {\n"
"        if (tag === 'DataView') {\n"
"          // capture relationship between the view and its buffer\n"
"          dv = this.registerView(arg);\n"
"        } else if (tag === 'ArrayBuffer') {\n"
"          dv = this.obtainView(arg, 0, arg.byteLength);\n"
"        } else if ((tag && tag === constructor[TYPED_ARRAY]?.name) || (tag === 'Uint8ClampedArray' && constructor[TYPED_ARRAY] === Uint8Array)) {\n"
"          dv = this.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);\n"
"        } else if (tag === 'Uint8Array' && arg instanceof Buffer) {\n"
"          dv = this.obtainView(arg.buffer, arg.byteOffset, arg.byteLength);\n"
"        }\n"
"      }\n"
"      if (!dv) {\n"
"        const memory = arg?.[MEMORY];\n"
"        if (memory) {\n"
"          // arg a Zig data object\n"
"          const { constructor, instance: { members: [ member ] } } = structure;\n"
"          if (arg instanceof constructor) {\n"
"            // same type, no problem\n"
"            return memory;\n"
"          } else {\n"
"            if (isArrayLike(type)) {\n"
"              // make sure the arg has the same type of elements\n"
"              const { byteSize: elementSize, structure: { constructor: Child } } = member;\n"
"              const number = findElements(arg, Child);\n"
"              if (number !== undefined) {\n"
"                if (type === StructureType.Slice || number * elementSize === byteSize) {\n"
"                  return memory;\n"
"                } else {\n"
"                  throw new ArrayLengthMismatch(structure, null, arg);\n"
"                }\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"      }\n"
"      if (dv) {\n"
"        if (byteSize !== undefined) {\n"
"          checkDataViewSize(dv, structure);\n"
"        }\n"
"      } else {\n"
"        onError?.(structure, arg);\n"
"      }\n"
"      return dv;\n"
"    },\n"
"    assignView(target, dv, structure, copy, allocator) {\n"
"      const { byteSize, type } = structure;\n"
"      const elementSize = byteSize ?? 1;\n"
"      if (!target[MEMORY]) {\n"
"        if (byteSize !== undefined) {\n"
"          checkDataViewSize(dv, structure);\n"
"        }\n"
"        const len = dv.byteLength / elementSize;\n"
"        const source = { [MEMORY]: dv };\n"
"        target.constructor[SENTINEL]?.validateData?.(source, len);\n"
"        if (allocator) {\n"
"          // need to copy when target object is in Zig memory\n"
"          copy = true;\n"
"        }\n"
"        target[SHAPE](copy ? null : dv, len, allocator);\n"
"        if (copy) {\n"
"          target[COPY](source);\n"
"        }\n"
"      } else {\n"
"        const byteLength = (type === StructureType.Slice) ? elementSize * target.length : elementSize;\n"
"        if (dv.byteLength !== byteLength) {\n"
"          throw new BufferSizeMismatch(structure, dv, target);\n"
"        }\n"
"        const source = { [MEMORY]: dv };\n"
"        target.constructor[SENTINEL]?.validateData?.(source, target.length);\n"
"        target[COPY](source);\n"
"      }\n"
"    },\n"
"    findViewAt(buffer, offset, len) {\n"
"      let entry = this.viewMap.get(buffer);\n"
"      let existing;\n"
"      if (entry) {\n"
"        if (entry instanceof DataView) {\n"
"          // only one view created thus far--see if that's the matching one\n"
"          if (entry.byteOffset === offset && entry.byteLength === len) {\n"
"            existing = entry;\n"
"          } else {\n"
"            // no, need to replace the entry with a hash keyed by `offset:len`\n"
"            const prev = entry;\n"
"            const prevKey = `${prev.byteOffset}:${prev.byteLength}`;\n"
"            entry = new Map([ [ prevKey, prev ] ]);\n"
"            this.viewMap.set(buffer, entry);\n"
"          }\n"
"        } else {\n"
"          existing = entry.get(`${offset}:${len}`);\n"
"        }\n"
"      }\n"
"      return { existing, entry };\n"
"    },\n"
"    obtainView(buffer, offset, len) {\n"
"      const { existing, entry } = this.findViewAt(buffer, offset, len);\n"
"      let dv;\n"
"      if (existing) {\n"
"        return existing;\n"
"      } else if (entry) {\n"
"        dv = new DataView(buffer, offset, len);\n"
"        entry.set(`${offset}:${len}`, dv);\n"
"      } else {\n"
"        // just one view of this buffer for now\n"
"        this.viewMap.set(buffer, dv = new DataView(buffer, offset, len));\n"
"      }\n"
"      {\n"
"        const zig = buffer[ZIG];\n"
"        if (zig) {\n"
"          // attach address to view of zig buffer\n"
"          dv[ZIG] = { address: adjustAddress(zig.address, offset), len };\n"
"        }\n"
"      }\n"
"      return dv;\n"
"    },\n"
"    registerView(dv) {\n"
"      if (!dv[ZIG]) {\n"
"        const { buffer, byteOffset, byteLength } = dv;\n"
"        const { existing, entry } = this.findViewAt(buffer, byteOffset, byteLength);\n"
"        if (existing) {\n"
"          // return existing view instead of this one\n"
"          return existing;\n"
"        } else if (entry) {\n"
"          entry.set(`${byteOffset}:${byteLength}`, dv);\n"
"        } else {\n"
"          this.viewMap.set(buffer, dv);\n"
"        }\n"
"      }\n"
"      return dv;\n"
"    },\n"
"    allocateMemory(len, align = 0, allocator = null) {\n"
"      return allocator?.alloc?.(len, align) ?? this.allocateJSMemory(len, align);\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        requireBufferFallback: null,\n"
"        syncExternalBuffer: null,\n"
"      },\n"
"      needFallback: undefined,\n"
"\n"
"      usingBufferFallback() {\n"
"        if (this.needFallback === undefined) {\n"
"          this.needFallback = this.requireBufferFallback?.();\n"
"        }\n"
"        return this.needFallback;\n"
"      },\n"
"      allocateJSMemory(len, align) {\n"
"        // allocate extra memory for alignment purpose when align is larger than the default\n"
"        const extra = (align > defaultAlign && this.getBufferAddress) ? align : 0;\n"
"        const buffer = new ArrayBuffer(len + extra);\n"
"        let offset = 0;\n"
"        if (extra) {\n"
"          const address = this.getBufferAddress(buffer);\n"
"          const aligned = alignForward(address, align);\n"
"          offset = aligned - address;\n"
"        }\n"
"        return this.obtainView(buffer, Number(offset), len);\n"
"      },\n"
"      /* c8 ignore next */\n"
"    } ),\n"
"  });\n"
"\n"
"  function checkDataViewSize(dv, structure) {\n"
"    const { byteSize, type } = structure;\n"
"    const isSizeMatching = type === StructureType.Slice\n"
"    ? dv.byteLength % byteSize === 0\n"
"    : dv.byteLength === byteSize;\n"
"    if (!isSizeMatching) {\n"
"      throw new BufferSizeMismatch(structure, dv);\n"
"    }\n"
"  }\n"
"\n"
"  function isArrayLike(type) {\n"
"    return type === StructureType.Array || type === StructureType.Vector || type === StructureType.Slice;\n"
"  }\n"
"\n"
"  function throwError(structure) {\n"
"    throw new BufferExpected(structure);\n"
"  }\n"
"\n"
"  const defaultAlign = [ 'arm64', 'ppc64', 'x64', 's390x' ].includes(process.arch) ? 16 : /* c8 ignore next */ 8\n"
"  ;\n"
"\n"
"  mixin({\n"
"    ...(undefined),\n"
"  });\n"
"\n"
"  mixin({\n"
"    makeReadOnly(object) {\n"
"      protect(object);\n"
"    }\n"
"  });\n"
"\n"
"  const gp = Object.getOwnPropertyDescriptors;\n"
"  const df = Object.defineProperty;\n"
"\n"
"  function protect(object) {\n"
"    const pointer = object[POINTER];\n"
"    if (pointer) {\n"
"      protectProperties(pointer, [ 'length' ]);\n"
"    } else {\n"
"      const array = object[ARRAY];\n"
"      if (array) {\n"
"        protectProperties(array);\n"
"        protectElements(array);\n"
"      } else {\n"
"        protectProperties(object);\n"
"      }\n"
"    }\n"
"  }\n"
"\n"
"  function protectProperties(object, exclude = []) {\n"
"    const descriptors = gp(object.constructor.prototype);\n"
"    for (const [ name, descriptor ] of Object.entries(descriptors)) {\n"
"      if (descriptor.set && !exclude.includes(name)) {\n"
"        descriptor.set = throwReadOnly;\n"
"        df(object, name, descriptor);\n"
"      }\n"
"    }\n"
"    df(object, CONST_TARGET, { value: object });\n"
"  }\n"
"\n"
"  function protectElements(array) {\n"
"    df(array, 'set', { value: throwReadOnly });\n"
"    const get = array.get;\n"
"    const getReadOnly = function(index) {\n"
"      const element = get.call(this, index);\n"
"      if (element?.[CONST_TARGET] === null) {\n"
"        protect(element);\n"
"      }\n"
"      return element;\n"
"    };\n"
"    df(array, 'get', { value: getReadOnly });\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineMember(member, applyTransform = true) {\n"
"      if (!member) {\n"
"        return {};\n"
"      }\n"
"      const { type, structure } = member;\n"
"      const handleName = `defineMember${memberNames[type]}`;\n"
"      const f = this[handleName];\n"
"      /* c8 ignore end */\n"
"      const descriptor = f.call(this, member);\n"
"      if (applyTransform) {\n"
"        if (structure) {\n"
"          // we use int/uint getters to access underlying values of enums and error sets;\n"
"          // the transform functions put wrapper functions around the accessors that\n"
"          // perform item lookup\n"
"          const { type } = structure;\n"
"          const handleName = `transformDescriptor${structureNames[type]}`;\n"
"          const f = this[handleName];\n"
"          if (f) {\n"
"            return f.call(this, descriptor, member);\n"
"          }\n"
"        }\n"
"      }\n"
"      return descriptor;\n"
"    },\n"
"  });\n"
"\n"
"  function bindSlot(slot, { get, set }) {\n"
"    if (slot !== undefined) {\n"
"      return {\n"
"        get: function() {\n"
"          return get.call(this, slot);\n"
"        },\n"
"        set: (set)\n"
"        ? function(arg) {\n"
"            return set.call(this, slot, arg);\n"
"          }\n"
"        : undefined,\n"
"      };\n"
"    } else {\n"
"      // array accessors\n"
"      return { get, set };\n"
"    }\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineBase64(structure) {\n"
"      const thisEnv = this;\n"
"      return markAsSpecial({\n"
"        get() {\n"
"          return encodeBase64(this.dataView);\n"
"        },\n"
"        set(str, allocator) {\n"
"          if (typeof(str) !== 'string') {\n"
"            throw new TypeMismatch('string', str);\n"
"          }\n"
"          const dv = decodeBase64(str);\n"
"          thisEnv.assignView(this, dv, structure, false, allocator);\n"
"        }\n"
"      });\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberBool(member) {\n"
"      return this.defineMemberUsing(member, this.getAccessor);\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineClampedArray(structure) {\n"
"      const thisEnv = this;\n"
"      const ClampedArray = Uint8ClampedArray;\n"
"      return markAsSpecial({\n"
"        get() {\n"
"          const ta = this.typedArray;\n"
"          return new ClampedArray(ta.buffer, ta.byteOffset, ta.length);\n"
"        },\n"
"        set(ta, allocator) {\n"
"          if (ta?.[Symbol.toStringTag] !== ClampedArray.name) {\n"
"            throw new TypeMismatch(ClampedArray.name, ta);\n"
"          }\n"
"          const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);\n"
"          thisEnv.assignView(this, dv, structure, true, allocator);\n"
"        },\n"
"      });\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineDataView(structure) {\n"
"      const thisEnv = this;\n"
"      return markAsSpecial({\n"
"        get() {\n"
"          const dv = this[MEMORY];\n"
"          if (thisEnv.usingBufferFallback()) {\n"
"            const address = dv.buffer[FALLBACK];\n"
"            if (address !== undefined) {\n"
"              thisEnv.syncExternalBuffer(dv.buffer, address);\n"
"            }\n"
"          }\n"
"          return dv;\n"
"        },\n"
"        set(dv, allocator) {\n"
"          if (dv?.[Symbol.toStringTag] !== 'DataView') {\n"
"            throw new TypeMismatch('DataView', dv);\n"
"          }\n"
"          thisEnv.assignView(this, dv, structure, true, allocator);\n"
"        },\n"
"      });\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        syncExternalBuffer: null,\n"
"      },\n"
"    } )\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberFloat(member) {\n"
"      return this.defineMemberUsing(member, this.getAccessor);\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberInt(member) {\n"
"      let getAccessor = this.getAccessor;\n"
"      if (this.runtimeSafety) {\n"
"        getAccessor = this.addRuntimeCheck(getAccessor);\n"
"      }\n"
"      getAccessor = this.addIntConversion(getAccessor);\n"
"      return this.defineMemberUsing(member, getAccessor);\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberLiteral(member) {\n"
"      const { slot } = member;\n"
"      return bindSlot(slot, {\n"
"        get(slot) {\n"
"          const object = this[SLOTS][slot];\n"
"          return object.string;\n"
"        },\n"
"        set: throwReadOnly,\n"
"      });\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberNull(member) {\n"
"      return {\n"
"        get: function() {\n"
"          return null;\n"
"        },\n"
"        set: throwReadOnly,\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberObject(member) {\n"
"      return bindSlot(member.slot, {\n"
"        get: (member.structure.flags & StructureFlag.HasValue) ? getValue : getObject,\n"
"        set: (member.flags & MemberFlag.IsReadOnly) ? throwReadOnly : setValue,\n"
"      });\n"
"    }\n"
"  });\n"
"\n"
"  function getValue(slot) {\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATE](slot);\n"
"    return object.$;\n"
"  }\n"
"\n"
"  function getObject(slot) {\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATE](slot);\n"
"    return object;\n"
"  }\n"
"\n"
"  function setValue(slot, value) {\n"
"    const object = this[SLOTS][slot] ?? this[VIVIFICATE](slot);\n"
"    object.$ = value;\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineVisitorArray(structure) {\n"
"      const value = function visitPointers(cb, options = {}) {\n"
"        const {\n"
"          source,\n"
"          vivificate = false,\n"
"          isActive = always,\n"
"          isMutable = always,\n"
"        } = options;\n"
"        const childOptions = {\n"
"          ...options,\n"
"          isActive: () => isActive(this),\n"
"          isMutable: () => isMutable(this),\n"
"        };\n"
"        for (let i = 0, len = this.length; i < len; i++) {\n"
"          // no need to check for empty slots, since that isn't possible\n"
"          if (source) {\n"
"            childOptions.source = source?.[SLOTS][i];\n"
"          }\n"
"          const child = this[SLOTS][i] ?? (vivificate ? this[VIVIFICATE](i) : null);\n"
"          if (child) {\n"
"            child[VISIT](cb, childOptions);\n"
"          }\n"
"        }\n"
"      };\n"
"      return { value };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineVisitorStruct(structure, visitorOptions = {}) {\n"
"      const {\n"
"        isChildActive = always,\n"
"        isChildMutable = always,\n"
"      } = visitorOptions;\n"
"      const { instance: { members } } = structure;\n"
"      const pointerMembers = members.filter(m => m.structure?.flags & StructureFlag.HasPointer);\n"
"      const value = function visitPointers(cb, options = {}) {\n"
"        const {\n"
"          source,\n"
"          vivificate = false,\n"
"          isActive = always,\n"
"          isMutable = always,\n"
"        } = options;\n"
"        const childOptions = {\n"
"          ...options,\n"
"          isActive: (object) => {\n"
"            // make sure parent object is active, then check whether the child is active\n"
"            return isActive(this) && isChildActive.call(this, object);\n"
"          },\n"
"          isMutable: (object) => {\n"
"            return isMutable(this) && isChildMutable.call(this, object);\n"
"          },\n"
"        };\n"
"        for (const { slot } of pointerMembers) {\n"
"          if (source) {\n"
"            // when src is a the struct's template, most slots will likely be empty,\n"
"            // since pointer fields aren't likely to have default values\n"
"            const srcChild = source[SLOTS]?.[slot];\n"
"            if (!srcChild) {\n"
"              continue;\n"
"            }\n"
"            childOptions.source = srcChild;\n"
"          }\n"
"          const child = this[SLOTS][slot] ?? (vivificate ? this[VIVIFICATE](slot) : null);\n"
"          if (child) {\n"
"            child[VISIT](cb, childOptions);\n"
"          }\n"
"        }\n"
"      };\n"
"      return { value };\n"
"    }\n"
"  });\n"
"\n"
"  mixin({\n"
"    ...({\n"
"      defineMemberUsing(member, getAccessor) {\n"
"        const { littleEndian } = this;\n"
"        const { bitOffset, byteSize } = member;\n"
"        const getter = getAccessor.call(this, 'get', member);\n"
"        const setter = getAccessor.call(this, 'set', member);\n"
"        /* c8 ignore end */\n"
"        if (bitOffset !== undefined) {\n"
"          const offset = bitOffset >> 3;\n"
"          return {\n"
"            get: function getValue() {\n"
"              return getter.call(this[MEMORY], offset, littleEndian);\n"
"            },\n"
"            set: function setValue(value) {\n"
"              return setter.call(this[MEMORY], offset, value, littleEndian);\n"
"            }\n"
"          }\n"
"        } else {\n"
"          return {\n"
"            get: function getElement(index) {\n"
"              try {\n"
"                return getter.call(this[MEMORY], index * byteSize, littleEndian);\n"
"              } catch (err) {\n"
"                throw replaceRangeError(member, index, err);\n"
"              }\n"
"            },\n"
"            set: function setElement(index, value) {\n"
"              return setter.call(this[MEMORY], index * byteSize, value, littleEndian);\n"
"            },\n"
"          }\n"
"        }\n"
"      },\n"
"    }),\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineSentinel(structure) {\n"
"      const {\n"
"        byteSize,\n"
"        instance: { members: [ member, sentinel ], template },\n"
"      } = structure;\n"
"      /* c8 ignore end */\n"
"      const { get: getSentinelValue } = this.defineMember(sentinel);\n"
"      const { get } = this.defineMember(member);\n"
"      const value = getSentinelValue.call(template, 0);\n"
"      const isRequired = !!(sentinel.flags & MemberFlag.IsRequired);\n"
"      const { runtimeSafety } = this;\n"
"      return defineValue({\n"
"        value,\n"
"        bytes: template[MEMORY],\n"
"        validateValue(v, i, l) {\n"
"          if (isRequired) {\n"
"            if (runtimeSafety && v === value && i !== l - 1) {\n"
"              throw new MisplacedSentinel(structure, v, i, l);\n"
"            }\n"
"            if (v !== value && i === l - 1) {\n"
"              throw new MissingSentinel(structure, value, l);\n"
"            }\n"
"          }\n"
"        },\n"
"        validateData(source, len) {\n"
"          if (isRequired) {\n"
"            if (runtimeSafety) {\n"
"              for (let i = 0; i < len; i++) {\n"
"                const v = get.call(source, i);\n"
"                if (v === value && i !== len - 1) {\n"
"                  throw new MisplacedSentinel(structure, value, i, len);\n"
"                } else if (v !== value && i === len - 1) {\n"
"                  throw new MissingSentinel(structure, value, len);\n"
"                }\n"
"              }\n"
"            } else {\n"
"              // if the length doesn't match, let the operation fail elsewhere\n"
"              if (len > 0 && len * byteSize === source[MEMORY].byteLength) {\n"
"                const v = get.call(source, len - 1);\n"
"                if (v !== value) {\n"
"                  throw new MissingSentinel(structure, value, len);\n"
"                }\n"
"              }\n"
"            }\n"
"          }\n"
"        },\n"
"        isRequired,\n"
"      });\n"
"    },\n"
"    ...({\n"
"      imports: {\n"
"        findSentinel: null,\n"
"      },\n"
"    } ),\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineString(structure) {\n"
"      const thisEnv = this;\n"
"      const { byteSize } = structure.instance.members[0];\n"
"      const encoding = `utf-${byteSize * 8}`;\n"
"      return markAsSpecial({\n"
"        get() {\n"
"          let str = decodeText(this.typedArray, encoding);\n"
"          const sentinelValue = this.constructor[SENTINEL]?.value;\n"
"          if (sentinelValue !== undefined && str.charCodeAt(str.length - 1) === sentinelValue) {\n"
"            str = str.slice(0, -1);\n"
"          }\n"
"          return str;\n"
"        },\n"
"        set(str, allocator) {\n"
"          if (typeof(str) !== 'string') {\n"
"            throw new TypeMismatch('string', str);\n"
"          }\n"
"          const sentinelValue = this.constructor[SENTINEL]?.value;\n"
"          if (sentinelValue !== undefined && str.charCodeAt(str.length - 1) !== sentinelValue) {\n"
"            str += String.fromCharCode(sentinelValue);\n"
"          }\n"
"          const ta = encodeText(str, encoding);\n"
"          const dv = new DataView(ta.buffer);\n"
"          thisEnv.assignView(this, dv, structure, false, allocator);\n"
"        },\n"
"      });\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineValueOf() {\n"
"      return {\n"
"        value() {\n"
"          return normalizeObject(this, false);\n"
"        },\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  const INT_MAX = BigInt(Number.MAX_SAFE_INTEGER);\n"
"  const INT_MIN = BigInt(Number.MIN_SAFE_INTEGER);\n"
"\n"
"  function normalizeObject(object, forJSON) {\n"
"    const handleError = (forJSON)\n"
"    ? (cb) => {\n"
"        try {\n"
"          return cb();\n"
"        } catch (err) {\n"
"          return err;\n"
"        }\n"
"      }\n"
"    : (cb) => cb();\n"
"    const resultMap = new Map();\n"
"    const process = function(value) {\n"
"      // handle type (i.e. constructor) like a struct\n"
"      const type = (typeof(value) === 'function') ? StructureType.Struct : value?.constructor?.[TYPE];\n"
"      if (type === undefined) {\n"
"        if (forJSON) {\n"
"          if (typeof(value) === 'bigint' && INT_MIN <= value && value <= INT_MAX) {\n"
"            return Number(value);\n"
"          } else if (value instanceof Error) {\n"
"            return { error: value.message };\n"
"          }\n"
"        }\n"
"        return value;\n"
"      }\n"
"      let result = resultMap.get(value);\n"
"      if (result === undefined) {\n"
"        let entries;\n"
"        switch (type) {\n"
"          case StructureType.Struct:\n"
"            entries = value[ENTRIES];\n"
"            result = (value.constructor[FLAGS] & StructFlag.IsTuple) ? [] : {};\n"
"            break;\n"
"          case StructureType.Union:\n"
"            entries = value[ENTRIES];\n"
"            result = {};\n"
"            break;\n"
"          case StructureType.Array:\n"
"          case StructureType.Vector:\n"
"          case StructureType.Slice:\n"
"            entries = value[ENTRIES];\n"
"            result = [];\n"
"            break;\n"
"          case StructureType.Pointer:\n"
"            try {\n"
"              result = value['*'];\n"
"            } catch (err) {\n"
"              result = Symbol.for('inaccessible');\n"
"            }\n"
"            break;\n"
"          case StructureType.Enum:\n"
"            result = handleError(() => String(value));\n"
"            break;\n"
"          case StructureType.Opaque:\n"
"            result = {};\n"
"            break;\n"
"          default:\n"
"            result = handleError(() => value.$);\n"
"        }\n"
"        result = process(result);\n"
"        resultMap.set(value, result);\n"
"        if (entries) {\n"
"          for (const [ key, child ] of entries) {\n"
"            result[key] = process(child);\n"
"          }\n"
"        }\n"
"      }\n"
"      return result;\n"
"    };\n"
"    return process(object);\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineToJSON() {\n"
"      return {\n"
"        value() {\n"
"          return normalizeObject(this, true);\n"
"        },\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberType(member, env) {\n"
"      const { slot } = member;\n"
"      return bindSlot(slot, {\n"
"        get(slot) {\n"
"          // unsupported types will have undefined structure\n"
"          const structure = this[SLOTS][slot];\n"
"          return structure?.constructor;\n"
"        },\n"
"        set: throwReadOnly,\n"
"      });\n"
"    }\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineTypedArray(structure) {\n"
"      const thisEnv = this;\n"
"      const TypedArray = this.getTypedArray(structure); // (from mixin \"structures/all\")\n"
"      return markAsSpecial({\n"
"        get() {\n"
"          const dv = this.dataView;\n"
"          const length = dv.byteLength / TypedArray.BYTES_PER_ELEMENT;\n"
"          return new TypedArray(dv.buffer, dv.byteOffset, length);\n"
"        },\n"
"        set(ta, allocator) {\n"
"          if (ta?.[Symbol.toStringTag] !== TypedArray.name) {\n"
"            throw new TypeMismatch(TypedArray.name, ta);\n"
"          }\n"
"          const dv = new DataView(ta.buffer, ta.byteOffset, ta.byteLength);\n"
"          thisEnv.assignView(this, dv, structure, true, allocator);\n"
"        },\n"
"      });\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberUint(member) {\n"
"      let getAccessor = this.getAccessor;\n"
"      if (this.runtimeSafety) {\n"
"        getAccessor = this.addRuntimeCheck(getAccessor);\n"
"      }\n"
"      getAccessor = this.addIntConversion(getAccessor);\n"
"      return this.defineMemberUsing(member, getAccessor);\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberUndefined(member) {\n"
"      return {\n"
"        get: function() {\n"
"          return undefined;\n"
"        },\n"
"        set: throwReadOnly,\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberUnsupported(member) {\n"
"      const throwUnsupported = function() {\n"
"        throw new Unsupported();\n"
"      };\n"
"      return { get: throwUnsupported, set: throwUnsupported };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineMemberVoid(member, env) {\n"
"      const { bitOffset } = member;\n"
"      return {\n"
"        get() {\n"
"          return undefined;\n"
"        },\n"
"        set: (bitOffset !== undefined)\n"
"        ? function(value) {\n"
"          if (value !== undefined) {\n"
"            throw new NotUndefined(member);\n"
"          }\n"
"        }\n"
"        : function(index, value) {\n"
"          if (value !== undefined) {\n"
"            throw new NotUndefined(member);\n"
"          }\n"
"          if (index < 0 || index >= this.length) {\n"
"            throw new OutOfBound(member, index);\n"
"          }\n"
"        },\n"
"      };\n"
"    }\n"
"  });\n"
"\n"
"  function getZigIterator() {\n"
"    const self = this;\n"
"    return {\n"
"      next() {\n"
"        const value = self.next();\n"
"        const done = value === null;\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getStructEntries(options) {\n"
"    return {\n"
"      [Symbol.iterator]: getStructEntriesIterator.bind(this, options),\n"
"      length: this[PROPS].length,\n"
"    };\n"
"  }\n"
"\n"
"  function getStructIterator(options) {\n"
"    const entries = getStructEntries.call(this, options);\n"
"    return entries[Symbol.iterator]();\n"
"  }\n"
"\n"
"  function getStructEntriesIterator(options) {\n"
"    const handleError = getErrorHandler(options);\n"
"    const self = this;\n"
"    const props = this[PROPS];\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < props.length) {\n"
"          const current = props[index++];\n"
"          value = [ current, handleError(() => self[current]) ];\n"
"          done = false;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getArrayIterator() {\n"
"    const self = this[ARRAY] ?? this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          const current = index++;\n"
"          value = self.get(current);\n"
"          done = false;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getArrayEntriesIterator(options) {\n"
"    const handleError = getErrorHandler(options);\n"
"    const self = this[ARRAY] ?? this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          const current = index++;\n"
"          value = [ current, handleError(() => self.get(current)) ];\n"
"          done = false;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getArrayEntries(options) {\n"
"    return {\n"
"      [Symbol.iterator]: getArrayEntriesIterator.bind(this, options),\n"
"      length: this.length,\n"
"    };\n"
"  }\n"
"\n"
"  function getVectorIterator() {\n"
"    const self = this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          const current = index++;\n"
"          value = self[current];\n"
"          done = false;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getVectorEntriesIterator() {\n"
"    const self = this;\n"
"    const length = this.length;\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < length) {\n"
"          const current = index++;\n"
"          value = [ current, self[current] ];\n"
"          done = false;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getVectorEntries() {\n"
"    return {\n"
"      [Symbol.iterator]: getVectorEntriesIterator.bind(this),\n"
"      length: this.length,\n"
"    };\n"
"  }\n"
"\n"
"  function getUnionEntries(options) {\n"
"    return {\n"
"      [Symbol.iterator]: getUnionEntriesIterator.bind(this, options),\n"
"      length: this[PROPS].length,\n"
"    };\n"
"  }\n"
"\n"
"  function getUnionIterator(options) {\n"
"    const entries = getUnionEntries.call(this, options);\n"
"    return entries[Symbol.iterator]();\n"
"  }\n"
"\n"
"  function getUnionEntriesIterator(options) {\n"
"    const handleError = getErrorHandler(options);\n"
"    const self = this;\n"
"    const props = this[PROPS];\n"
"    const getters = this[GETTERS];\n"
"    let index = 0;\n"
"    return {\n"
"      next() {\n"
"        let value, done;\n"
"        if (index < props.length) {\n"
"          const current = props[index++];\n"
"          // get value of prop with no check\n"
"          value = [ current, handleError(() => getters[current].call(self)) ];\n"
"          done = false;\n"
"        } else {\n"
"          done = true;\n"
"        }\n"
"        return { value, done };\n"
"      },\n"
"    };\n"
"  }\n"
"\n"
"  function getErrorHandler(options) {\n"
"    return (options?.error === 'return')\n"
"    ? (cb) => {\n"
"        try {\n"
"          return cb();\n"
"        } catch (err) {\n"
"          return err;\n"
"        }\n"
"      }\n"
"    : (cb) => cb();\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineStructure(structure) {\n"
"      const {\n"
"        type,\n"
"        name,\n"
"        byteSize,\n"
"      } = structure;\n"
"      const handlerName = `define${structureNames[type]}`;\n"
"      const f = this[handlerName];\n"
"      // default discriptors\n"
"      const keys = [];\n"
"      const setters = {};\n"
"      const descriptors = {\n"
"        dataView: this.defineDataView(structure),\n"
"        base64: this.defineBase64(structure),\n"
"        toJSON: this.defineToJSON(),\n"
"        valueOf: this.defineValueOf(),\n"
"        [Symbol.toStringTag]: defineValue(name),\n"
"        [CONST_TARGET]: { value: null },\n"
"        [SETTERS]: defineValue(setters),\n"
"        [KEYS]: defineValue(keys),\n"
"        // add memory copier (from mixin \"memory/copying\")\n"
"        [COPY]: this.defineCopier(byteSize),\n"
"        ...(undefined),\n"
"      };\n"
"      const constructor = structure.constructor = f.call(this, structure, descriptors);\n"
"      for (const [ name, descriptor ] of Object.entries(descriptors)) {\n"
"        const s = descriptor?.set;\n"
"        if (s && !setters[name]) {\n"
"          setters[name] = s;\n"
"          keys.push(name);\n"
"        }\n"
"      }\n"
"      defineProperties(constructor.prototype, descriptors);\n"
"      return constructor;\n"
"    },\n"
"    finalizeStructure(structure) {\n"
"      const {\n"
"        name,\n"
"        type,\n"
"        constructor,\n"
"        align,\n"
"        byteSize,\n"
"        flags,\n"
"        static: { members, template },\n"
"      } = structure;\n"
"      const props = [];\n"
"      const staticDescriptors = {\n"
"        name: defineValue(name),\n"
"        toJSON: this.defineToJSON(),\n"
"        valueOf: this.defineValueOf(),\n"
"        [ALIGN]: defineValue(align),\n"
"        [SIZE]: defineValue(byteSize),\n"
"        [TYPE]: defineValue(type),\n"
"        [FLAGS]: defineValue(flags),\n"
"        [PROPS]: defineValue(props),\n"
"        [TYPED_ARRAY]: defineValue(this.getTypedArray(structure)),\n"
"        [Symbol.iterator]: defineValue(getStructIterator),\n"
"        [ENTRIES]: { get: getStructEntries },\n"
"        [PROPS]: defineValue(props),\n"
"      };\n"
"      const descriptors = {};\n"
"      for (const member of members) {\n"
"        const { name, slot } = member;\n"
"        if (member.structure.type === StructureType.Function) {\n"
"          const fn = template[SLOTS][slot];\n"
"          staticDescriptors[name] = defineValue(fn);\n"
"          // provide a name if one isn't assigned yet\n"
"          if (!fn.name) {\n"
"            defineProperty(fn, 'name', defineValue(name));\n"
"          }\n"
"          // see if it's a getter or setter\n"
"          const [ accessorType, propName ] = /^(get|set)\\s+([\\s\\S]+)/.exec(name)?.slice(1) ?? [];\n"
"          const argRequired = (accessorType === 'get') ? 0 : 1;\n"
"          if (accessorType && fn.length  === argRequired) {\n"
"            const descriptor = staticDescriptors[propName] ??= {};\n"
"            descriptor[accessorType] = fn;\n"
"          }\n"
"          // see if it's a method\n"
"          if (member.flags & MemberFlag.IsMethod) {\n"
"            const method = function(...args) {\n"
"              try {\n"
"                return fn(this, ...args);\n"
"              } catch (err) {\n"
"                if ('argCount' in err) {\n"
"                  err.argIndex--;\n"
"                  err.argCount--;\n"
"                }\n"
"                throw err;\n"
"              }\n"
"            };\n"
"            defineProperties(method, {\n"
"              name: defineValue(name),\n"
"              length: defineValue(fn.length - 1),\n"
"            });\n"
"            descriptors[name] = defineValue(method);\n"
"            if (accessorType && method.length === argRequired) {\n"
"              const descriptor = descriptors[propName] ??= {};\n"
"              descriptor[accessorType] = method;\n"
"            }\n"
"          }\n"
"        } else {\n"
"          staticDescriptors[name] = this.defineMember(member);\n"
"          props.push(name);\n"
"        }\n"
"      }\n"
"      // static variable/constants are stored in slots\n"
"      staticDescriptors[SLOTS] = (props.length > 0) && defineValue(template[SLOTS]);\n"
"      const handlerName = `finalize${structureNames[type]}`;\n"
"      const f = this[handlerName];\n"
"      if (f?.call(this, structure, staticDescriptors) !== false) {\n"
"        defineProperties(constructor.prototype, descriptors);\n"
"        defineProperties(constructor, staticDescriptors);\n"
"      }\n"
"    },\n"
"    createConstructor(structure, handlers = {}) {\n"
"      const {\n"
"        type,\n"
"        byteSize,\n"
"        align,\n"
"        flags,\n"
"        instance: { members, template },\n"
"      } = structure;\n"
"      const { onCastError } = handlers;\n"
"      // comptime fields are stored in the instance template's slots\n"
"      let comptimeFieldSlots;\n"
"      if (template?.[SLOTS]) {\n"
"        const comptimeMembers = members.filter(m => m.flags & MemberFlag.IsReadOnly);\n"
"        if (comptimeMembers.length > 0) {\n"
"          comptimeFieldSlots = comptimeMembers.map(m => m.slot);\n"
"        }\n"
"      }\n"
"      const cache = new ObjectCache();\n"
"      const thisEnv = this;\n"
"      const constructor = function(arg, options = {}) {\n"
"        const {\n"
"          allocator,\n"
"        } = options;\n"
"        const creating = this instanceof constructor;\n"
"        let self, dv;\n"
"        if (creating) {\n"
"          if (arguments.length === 0) {\n"
"            throw new NoInitializer(structure);\n"
"          }\n"
"          self = this;\n"
"          if (flags & StructureFlag.HasSlot) {\n"
"            self[SLOTS] = {};\n"
"          }\n"
"          if (SHAPE in self) {\n"
"            // provided by defineStructureSlice(); the slice is different from other structures\n"
"            // as it does not have a zig size; memory is allocated by the slice initializer\n"
"            // based on the argument given\n"
"            self[INITIALIZE](arg, allocator);\n"
"            dv = self[MEMORY];\n"
"          } else {\n"
"            // don't use allocator to create storage for pointer\n"
"            const a = (type !== StructureType.Pointer) ? allocator : null;\n"
"            self[MEMORY] = dv = thisEnv.allocateMemory(byteSize, align, a);\n"
"          }\n"
"        } else {\n"
"          if (CAST in constructor) {\n"
"            // casting from number, string, etc.\n"
"            self = constructor[CAST].call(this, arg, options);\n"
"            if (self !== false) {\n"
"              return self;\n"
"            }\n"
"          }\n"
"          // look for buffer\n"
"          dv = thisEnv.extractView(structure, arg, onCastError);\n"
"          if (self = cache.find(dv)) {\n"
"            return self;\n"
"          }\n"
"          self = Object.create(constructor.prototype);\n"
"          if (SHAPE in self) {\n"
"            thisEnv.assignView(self, dv, structure, false, false);\n"
"          } else {\n"
"            self[MEMORY] = dv;\n"
"          }\n"
"          if (flags & StructureFlag.HasSlot) {\n"
"            self[SLOTS] = {};\n"
"          }\n"
"        }\n"
"        if (comptimeFieldSlots) {\n"
"          for (const slot of comptimeFieldSlots) {\n"
"            self[SLOTS][slot] = template[SLOTS][slot];\n"
"          }\n"
"        }\n"
"        if (MODIFY in self) {\n"
"          self[MODIFY]();\n"
"        }\n"
"        if (creating) {\n"
"          // initialize object unless that's done already\n"
"          if (!(SHAPE in self)) {\n"
"            self[INITIALIZE](arg, allocator);\n"
"          }\n"
"        }\n"
"        if (FINALIZE in self) {\n"
"          self = self[FINALIZE]();\n"
"        }\n"
"        return cache.save(dv, self);\n"
"      };\n"
"      defineProperty(constructor, CACHE, defineValue(cache));\n"
"      return constructor;\n"
"    },\n"
"    createApplier(structure) {\n"
"      const { instance: { template } } = structure;\n"
"      return function(arg, allocator) {\n"
"        const argKeys = Object.keys(arg);\n"
"        const keys = this[KEYS];\n"
"        const setters = this[SETTERS];\n"
"        // don't accept unknown props\n"
"        for (const key of argKeys) {\n"
"          if (!(key in setters)) {\n"
"            throw new NoProperty(structure, key);\n"
"          }\n"
"        }\n"
"        // checking each name so that we would see inenumerable initializers as well\n"
"        let normalCount = 0;\n"
"        let normalFound = 0;\n"
"        let normalMissing = 0;\n"
"        let specialFound = 0;\n"
"        for (const key of keys) {\n"
"          const set = setters[key];\n"
"          if (set.special) {\n"
"            if (key in arg) {\n"
"              specialFound++;\n"
"            }\n"
"          } else {\n"
"            normalCount++;\n"
"            if (key in arg) {\n"
"              normalFound++;\n"
"            } else if (set.required) {\n"
"              normalMissing++;\n"
"            }\n"
"          }\n"
"        }\n"
"        if (normalMissing !== 0 && specialFound === 0) {\n"
"          const missing = keys.filter(k => setters[k].required && !(k in arg));\n"
"          throw new MissingInitializers(structure, missing);\n"
"        }\n"
"        if (specialFound + normalFound > argKeys.length) {\n"
"          // some props aren't enumerable\n"
"          for (const key of keys) {\n"
"            if (key in arg) {\n"
"              if (!argKeys.includes(key)) {\n"
"                argKeys.push(key);\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"        // apply default values unless all properties are initialized\n"
"        if (normalFound < normalCount && specialFound === 0) {\n"
"          if (template) {\n"
"            if (template[MEMORY]) {\n"
"              this[COPY](template);\n"
"            }\n"
"            this[VISIT]?.('copy', { vivificate: true, source: template });\n"
"          }\n"
"        }\n"
"        for (const key of argKeys) {\n"
"          const set = setters[key];\n"
"          set.call(this, arg[key], allocator);\n"
"        }\n"
"        return argKeys.length;\n"
"      };\n"
"    },\n"
"    getTypedArray(structure) {\n"
"      const { type, instance } = structure;\n"
"      if (type !== undefined && instance) {\n"
"        const [ member ] = instance.members;\n"
"        switch (type) {\n"
"          case StructureType.Enum:\n"
"          case StructureType.ErrorSet:\n"
"          case StructureType.Primitive: {\n"
"            const { byteSize, type } = member;\n"
"            const intType = (type === MemberType.Float)\n"
"                          ? 'Float'\n"
"                          : (type === MemberType.Int) ? 'Int' : 'Uint';\n"
"            const prefix = (byteSize > 4 && type !== MemberType.Float) ? 'Big' : '';\n"
"            const arrayName = prefix + intType + (byteSize * 8) + 'Array';\n"
"            return globalThis[arrayName];\n"
"          }        case StructureType.Array:\n"
"          case StructureType.Slice:\n"
"          case StructureType.Vector:\n"
"            return this.getTypedArray(member.structure);\n"
"        }\n"
"      }\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineArgStruct(structure, descriptors) {\n"
"      const {\n"
"        flags,\n"
"        byteSize,\n"
"        align,\n"
"        length,\n"
"        instance: { members },\n"
"      } = structure;\n"
"      const thisEnv = this;\n"
"      const argMembers = members.slice(1);\n"
"      const constructor = function(args) {\n"
"        const creating = this instanceof constructor;\n"
"        let self, dv;\n"
"        if (creating) {\n"
"          self = this;\n"
"          dv = thisEnv.allocateMemory(byteSize, align);\n"
"        } else {\n"
"          self = Object.create(constructor.prototype);\n"
"          dv = args;\n"
"        }\n"
"        self[MEMORY] = dv;\n"
"        if (flags & StructureFlag.HasSlot) {\n"
"          self[SLOTS] = {};\n"
"        }\n"
"        if (creating) {\n"
"          let options;\n"
"          if (flags & ArgStructFlag.HasOptions) {\n"
"            if (args.length === length + 1) {\n"
"              options = args.pop();\n"
"            }\n"
"          }\n"
"          // length holds the minimum number of arguments\n"
"          if (args.length !== length) {\n"
"            throw new ArgumentCountMismatch(length, args.length);\n"
"          }\n"
"          this[CONTEXT] = new CallContext();\n"
"          if (flags & ArgStructFlag.IsAsync) {\n"
"            self[FINALIZE] = null;\n"
"          }\n"
"          thisEnv.copyArguments(self, args, argMembers, options);\n"
"        } else {\n"
"          return self;\n"
"        }\n"
"      };\n"
"      for (const member of members) {\n"
"        descriptors[member.name] = this.defineMember(member);\n"
"      }\n"
"      const { slot: rvSlot, type: rvType } = members[0];\n"
"      const isChildMutable = (rvType === MemberType.Object)\n"
"      ? function(object) {\n"
"          const child = this[VIVIFICATE](rvSlot);\n"
"          return object === child;\n"
"        }\n"
"      : never;\n"
"      descriptors.length = defineValue(argMembers.length);\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);\n"
"      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, { isChildMutable });\n"
"      descriptors[Symbol.iterator] = this.defineArgIterator?.(argMembers);\n"
"      if (process.env.MIXIN === 'track') {\n"
"        this.detectArgumentFeatures(argMembers);\n"
"      }\n"
"      return constructor;\n"
"    },\n"
"    finalizeArgStruct(structure, staticDescriptors) {\n"
"      const { flags } = structure;\n"
"      staticDescriptors[THROWING] = defineValue(!!(flags & ArgStructFlag.IsThrowing));\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineFinalizerArray({ get, set }) {\n"
"      return {\n"
"        value() {\n"
"          const value = new Proxy(this, proxyHandlers$1);\n"
"          defineProperties(this, {\n"
"            [PROXY]: { value },\n"
"            get: { value: get.bind(this) },\n"
"            set: set && { value: set.bind(this) },\n"
"          });\n"
"          return value;\n"
"        },\n"
"      };\n"
"    },\n"
"    defineVivificatorArray(structure) {\n"
"      const { instance: { members: [ member ]} } = structure;\n"
"      const { byteSize, structure: elementStructure } = member;\n"
"      const thisEnv = this;\n"
"      const value = function getChild(index) {\n"
"        const { constructor } = elementStructure;\n"
"        const dv = this[MEMORY];\n"
"        const parentOffset = dv.byteOffset;\n"
"        const offset = parentOffset + byteSize * index;\n"
"        const childDV = thisEnv.obtainView(dv.buffer, offset, byteSize);\n"
"        const object = this[SLOTS][index] = constructor.call(PARENT, childDV);\n"
"        return object;\n"
"      };\n"
"      return { value };\n"
"    },\n"
"  });\n"
"\n"
"  const proxyHandlers$1 = {\n"
"    get(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return array.get(index);\n"
"      } else if (name === ARRAY) {\n"
"        return array;\n"
"      } else {\n"
"        return array[name];\n"
"      }\n"
"    },\n"
"    set(array, name, value) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        array.set(index, value);\n"
"      } else {\n"
"        array[name] = value;\n"
"      }\n"
"      return true;\n"
"    },\n"
"    deleteProperty(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return false;\n"
"      } else {\n"
"        delete array[name];\n"
"        return true;\n"
"      }\n"
"    },\n"
"    has(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        return (index >= 0 && index < array.length);\n"
"      } else {\n"
"        return array[name];\n"
"      }\n"
"    },\n"
"    ownKeys(array) {\n"
"      const keys = [];\n"
"      for (let i = 0, len = array.length; i < len; i++) {\n"
"        keys.push(`${i}`);\n"
"      }\n"
"      keys.push('length', PROXY);\n"
"      return keys;\n"
"    },\n"
"    getOwnPropertyDescriptor(array, name) {\n"
"      const index = (typeof(name) === 'symbol') ? 0 : name|0;\n"
"      if (index !== 0 || index == name) {\n"
"        if (index >= 0 && index < array.length) {\n"
"          return { value: array.get(index), enumerable: true, writable: true, configurable: true };\n"
"        }\n"
"      } else {\n"
"        return Object.getOwnPropertyDescriptor(array, name);\n"
"      }\n"
"    },\n"
"  };\n"
"\n"
"  mixin({\n"
"    defineArray(structure, descriptors) {\n"
"      const {\n"
"        length,\n"
"        instance: { members: [ member ] },\n"
"        flags,\n"
"      } = structure;\n"
"      const propApplier = this.createApplier(structure);\n"
"      const descriptor = this.defineMember(member);\n"
"      const { set } = descriptor;\n"
"      const constructor = this.createConstructor(structure);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"          if (flags & StructureFlag.HasPointer) {\n"
"            this[VISIT]('copy', { vivificate: true, source: arg });\n"
"          }\n"
"        } else {\n"
"          if (typeof(arg) === 'string' && flags & ArrayFlag.IsString) {\n"
"            arg = { string: arg };\n"
"          }\n"
"          if (arg?.[Symbol.iterator]) {\n"
"            arg = transformIterable(arg);\n"
"            if (arg.length !== length) {\n"
"              throw new ArrayLengthMismatch(structure, this, arg);\n"
"            }\n"
"            let i = 0;\n"
"            for (const value of arg) {\n"
"              set.call(this, i++, value);\n"
"            }\n"
"          } else if (arg && typeof(arg) === 'object') {\n"
"            if (propApplier.call(this, arg) === 0) {\n"
"              throw new InvalidArrayInitializer(structure, arg);\n"
"            }\n"
"          } else if (arg !== undefined) {\n"
"            throw new InvalidArrayInitializer(structure, arg);\n"
"          }\n"
"        }\n"
"      };\n"
"      descriptors.$ = { get: getProxy, set: initializer };\n"
"      descriptors.length = defineValue(length);\n"
"      descriptors.entries = defineValue(getArrayEntries);\n"
"      if (flags & ArrayFlag.IsTypedArray) {\n"
"        descriptors.typedArray = this.defineTypedArray(structure);\n"
"        if (flags & ArrayFlag.IsString) {\n"
"          descriptors.string = this.defineString(structure);\n"
"        }\n"
"        if (flags & ArrayFlag.IsClampedArray) {\n"
"          descriptors.clampedArray = this.defineClampedArray(structure);\n"
"        }\n"
"      }\n"
"      descriptors[Symbol.iterator] = defineValue(getArrayIterator);\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[FINALIZE] = this.defineFinalizerArray(descriptor);\n"
"      descriptors[ENTRIES] = { get: getArrayEntries };\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorArray(structure);\n"
"      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorArray(structure);\n"
"      return constructor;\n"
"    },\n"
"    finalizeArray(structure, staticDescriptors) {\n"
"      const {\n"
"        flags,\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      staticDescriptors.child = defineValue(member.structure.constructor);\n"
"      staticDescriptors[SENTINEL] = (flags & ArrayFlag.HasSentinel) && this.defineSentinel(structure);\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineEnum(structure, descriptors) {\n"
"      const {\n"
"        instance: {\n"
"          members: [ member ],\n"
"        },\n"
"      } = structure;\n"
"      const descriptor = this.defineMember(member);\n"
"      const { get, set } = descriptor;\n"
"      const { get: getNumber } = this.defineMember(member, false);\n"
"      const propApplier = this.createApplier(structure);\n"
"      const expected = [ 'string', 'number', 'tagged union' ];\n"
"      const initializer = function(arg) {\n"
"        if (arg && typeof(arg) === 'object') {\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            throw new InvalidInitializer(structure, expected, arg);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          set.call(this, arg);\n"
"        }\n"
"      };\n"
"      const constructor = this.createConstructor(structure, {\n"
"        onCastError(structure, arg) {\n"
"          throw new InvalidInitializer(structure, expected, arg);\n"
"        }\n"
"      });\n"
"      descriptors.$ = descriptor;\n"
"      descriptors.toString = defineValue(toString);\n"
"      descriptors[Symbol.toPrimitive] = {\n"
"        value(hint)  {\n"
"          switch (hint) {\n"
"            case 'string':\n"
"            case 'default':\n"
"              return this.$[NAME];\n"
"            default:\n"
"              return getNumber.call(this);\n"
"          }\n"
"        },\n"
"      };\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      return constructor;\n"
"    },\n"
"    finalizeEnum(structure, staticDescriptors) {\n"
"      const {\n"
"        flags,\n"
"        constructor,\n"
"        instance: { members: [ member ] },\n"
"        static: { members, template },\n"
"      } = structure;\n"
"      const items = template[SLOTS];\n"
"      // obtain getter/setter for accessing int values directly\n"
"      const { get, set } = this.defineMember(member, false);\n"
"      for (const { name, flags, slot } of members) {\n"
"        if (flags & MemberFlag.IsPartOfSet) {\n"
"          const item = items[slot];\n"
"          // attach name to item so tagged union code can quickly find it\n"
"          defineProperty(item, NAME, defineValue(name));\n"
"          const index = get.call(item);\n"
"          // make item available by name and by index\n"
"          staticDescriptors[name] = staticDescriptors[index] = { value: item, writable: false };\n"
"        }\n"
"      }\n"
"      // add cast handler allowing strings, numbers, and tagged union to be casted into enums\n"
"      staticDescriptors[CAST] = {\n"
"        value(arg) {\n"
"          if (typeof(arg)  === 'string' || typeof(arg) === 'number' || typeof(arg) === 'bigint') {\n"
"            let item = constructor[arg];\n"
"            if (!item) {\n"
"              if (flags & EnumFlag.IsOpenEnded && typeof(arg) !== 'string') {\n"
"                // create the item on-the-fly when enum is non-exhaustive\n"
"                item = new constructor(undefined);\n"
"                // write the value into memory\n"
"                set.call(item, arg);\n"
"                // attach the new item to the enum set\n"
"                defineProperty(item, NAME, defineValue(arg));\n"
"                defineProperty(constructor, arg, defineValue(item));\n"
"              }\n"
"            }\n"
"            return item;\n"
"          } else if (arg instanceof constructor) {\n"
"            return arg;\n"
"          } else if (arg?.[TAG] instanceof constructor) {\n"
"            // a tagged union, return the active tag\n"
"            return arg[TAG];\n"
"          } else {\n"
"            return false;\n"
"          }\n"
"        }\n"
"      };\n"
"      staticDescriptors[TYPED_ARRAY] = defineValue(this.getTypedArray(structure));\n"
"    },\n"
"    transformDescriptorEnum(descriptor, member) {\n"
"      const { type, structure } = member;\n"
"      if (type === MemberType.Object) {\n"
"        return descriptor;\n"
"      }\n"
"      const findEnum = function(value) {\n"
"        const { constructor } = structure;\n"
"        // the enumeration constructor returns the object for the int value\n"
"        const item = constructor(value);\n"
"        if (!item) {\n"
"          throw new EnumExpected(structure, value);\n"
"        }\n"
"        return item\n"
"      };\n"
"      const { get, set } = descriptor;\n"
"      return {\n"
"        get: (get.length === 0)\n"
"        ? function getEnum() {\n"
"            const value = get.call(this);\n"
"            return findEnum(value);\n"
"          }\n"
"        : function getEnumElement(index) {\n"
"            const value = get.call(this, index);\n"
"            return findEnum(value);\n"
"          },\n"
"        set: (set.length === 1)\n"
"        ? function setEnum(value) {\n"
"            const item = findEnum(value);\n"
"            // call Symbol.toPrimitive directly as enum can be bigint or number\n"
"            value = item[Symbol.toPrimitive]();\n"
"            set.call(this, value);\n"
"          }\n"
"        : function setEnumElement(index, value) {\n"
"            const item = findEnum(value);\n"
"            set.call(this, index, item[Symbol.toPrimitive]());\n"
"          },\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    currentGlobalSet: undefined,\n"
"    currentErrorClass: undefined,\n"
"\n"
"    defineErrorSet(structure, descriptors) {\n"
"      const {\n"
"        instance: { members: [ member ] },\n"
"        flags,\n"
"      } = structure;\n"
"      if (!this.currentErrorClass) {\n"
"        // create anyerror set\n"
"        this.currentErrorClass = class Error extends ZigErrorBase {};\n"
"        const ae = {\n"
"          type: StructureType.ErrorSet,\n"
"          name: 'anyerror',\n"
"          instance: { members: [ member ] },\n"
"          static: { members: [], template: { SLOTS: {} } },\n"
"        };\n"
"        this.currentGlobalSet = this.defineStructure(ae);\n"
"        this.finalizeStructure(ae);\n"
"      }\n"
"      if (this.currentGlobalSet && (flags & ErrorSetFlag.IsGlobal)) {\n"
"        return this.currentGlobalSet;\n"
"      }\n"
"      const descriptor = this.defineMember(member);\n"
"      const { set } = descriptor;\n"
"      const expected = [ 'string', 'number' ];\n"
"      const propApplier = this.createApplier(structure);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor[CLASS]) {\n"
"          set.call(this, arg);\n"
"        } else if (arg && typeof(arg) === 'object' && !isErrorJSON(arg)) {\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            throw new InvalidInitializer(structure, expected, arg);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          set.call(this, arg);\n"
"        }\n"
"      };\n"
"      const constructor = this.createConstructor(structure, {\n"
"        onCastError(structure, arg) {\n"
"          throw new InvalidInitializer(structure, expected, arg);\n"
"        }\n"
"      });\n"
"      descriptors.$ = descriptor;\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      return constructor;\n"
"    },\n"
"    finalizeErrorSet(structure, staticDescriptors) {\n"
"      const {\n"
"        constructor,\n"
"        flags,\n"
"        instance: { members: [ member ] },\n"
"        static: { members, template },\n"
"      } = structure;\n"
"      if (this.currentGlobalSet && (flags & ErrorSetFlag.IsGlobal)) {\n"
"        // already finalized\n"
"        return false;\n"
"      }\n"
"      const items = template?.[SLOTS] ?? {};\n"
"      // obtain getter/setter for accessing int values directly\n"
"      const { get } = this.defineMember(member, false);\n"
"      for (const { name, slot } of members) {\n"
"        const item = items[slot];\n"
"        // unlike enums, error objects in an error-set aren't instances of the error-set class\n"
"        // they're instance of a superclass of JavaScript's Error; here we need to extract the\n"
"        // error number from the error-set instance and create the error object, if hasn't been\n"
"        // created already for an earlier set\n"
"        const number = get.call(item);\n"
"        let error = this.currentGlobalSet[number], inGlobalSet = true;\n"
"        if (!error) {\n"
"          error = new this.currentErrorClass(name, number);\n"
"          inGlobalSet = false;\n"
"        }\n"
"        // make the error object available by errno, by name, and by error message\n"
"        const descriptor = defineValue(error);\n"
"        const string = String(error);\n"
"        staticDescriptors[name] =\n"
"        staticDescriptors[string] =\n"
"        staticDescriptors[number] = descriptor;\n"
"        if (!inGlobalSet) {\n"
"          // add to global error set as well\n"
"          defineProperties(this.currentGlobalSet, {\n"
"            [number]: descriptor,\n"
"            [string]: descriptor,\n"
"            [name]: descriptor,\n"
"          });\n"
"          this.currentGlobalSet[PROPS].push(name);\n"
"        }\n"
"      }\n"
"      // add cast handler allowing strings, numbers, and JSON object to be casted into error set\n"
"      staticDescriptors[CAST] = {\n"
"        value(arg) {\n"
"          if (typeof(arg) === 'number' || typeof(arg) === 'string') {\n"
"            return constructor[arg];\n"
"          } else if (arg instanceof constructor[CLASS]) {\n"
"            return constructor[Number(arg)];\n"
"          } else if (isErrorJSON(arg)) {\n"
"            return constructor[`Error: ${arg.error}`];\n"
"          } else if (arg instanceof Error) {\n"
"            return undefined;\n"
"          } else {\n"
"            return false;\n"
"          }\n"
"        }\n"
"      };\n"
"      staticDescriptors[CLASS] = defineValue(this.currentErrorClass);\n"
"    },\n"
"    transformDescriptorErrorSet(descriptor, member) {\n"
"      const { type, structure } = member;\n"
"      if (type === MemberType.Object) {\n"
"        return descriptor;\n"
"      }\n"
"      const findError = function(value) {\n"
"        const { constructor } = structure;\n"
"        const item = constructor(value);\n"
"        if (!item) {\n"
"          if (value instanceof Error) {\n"
"            throw new NotInErrorSet(structure);\n"
"          } else {\n"
"            throw new ErrorExpected(structure, value);\n"
"          }\n"
"        }\n"
"        return item\n"
"      };\n"
"      const { get, set } = descriptor;\n"
"      return {\n"
"        get: (get.length === 0)\n"
"        ? function getError() {\n"
"            const value = get.call(this);\n"
"            return findError(value);\n"
"          }\n"
"        : function getErrorElement(index) {\n"
"            const value = get.call(this, index);\n"
"            return findError(value);\n"
"          },\n"
"        set: (set.length === 1)\n"
"        ? function setError(value) {\n"
"          const item = findError(value);\n"
"            value = Number(item);\n"
"            set.call(this, value);\n"
"          }\n"
"        : function setError(index, value) {\n"
"            const item = findError(value);\n"
"            value = Number(item);\n"
"            set.call(this, index, value);\n"
"          },\n"
"      };\n"
"    },\n"
"    resetGlobalErrorSet() {\n"
"      this.currentErrorClass = this.currentGlobalSet = undefined;\n"
"    },\n"
"  });\n"
"\n"
"  class ZigErrorBase extends Error {\n"
"    constructor(name, number) {\n"
"      super(deanimalizeErrorName(name));\n"
"      this.number = number;\n"
"      this.stack = undefined;\n"
"    }\n"
"\n"
"    [Symbol.toPrimitive](hint) {\n"
"      switch (hint) {\n"
"        case 'string':\n"
"        case 'default':\n"
"          return Error.prototype.toString.call(this, hint);\n"
"        default:\n"
"          return this.number;\n"
"      }\n"
"    }\n"
"\n"
"    toJSON() {\n"
"      return { error: this.message };\n"
"    }\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineErrorUnion(structure, descriptors) {\n"
"      const {\n"
"        instance: { members },\n"
"        flags,\n"
"      } = structure;\n"
"      const { get: getValue, set: setValue } = this.defineMember(members[0]);\n"
"      const { get: getError, set: setError } = this.defineMember(members[1]);\n"
"      const { get: getErrorNumber, set: setErrorNumber } = this.defineMember(members[1], false);\n"
"      const get = function() {\n"
"        const errNum = getErrorNumber.call(this);\n"
"        if (errNum) {\n"
"          throw getError.call(this);\n"
"        } else {\n"
"          return getValue.call(this);\n"
"        }\n"
"      };\n"
"      const isValueVoid = members[0].type === MemberType.Void;\n"
"      const errorSet = members[1].structure.constructor;\n"
"      const isChildActive = function() {\n"
"        return !getErrorNumber.call(this);\n"
"      };\n"
"      const clearValue = function() {\n"
"        this[RESET]();\n"
"        this[VISIT]?.('reset');\n"
"      };\n"
"      const propApplier = this.createApplier(structure);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"          if (flags & StructureFlag.HasPointer) {\n"
"            if (isChildActive.call(this)) {\n"
"              this[VISIT]('copy', { vivificate: true, source: arg });\n"
"            }\n"
"          }\n"
"        } else if (arg instanceof errorSet[CLASS] && errorSet(arg)) {\n"
"          setError.call(this, arg);\n"
"          clearValue.call(this);\n"
"        } else if (arg !== undefined || isValueVoid) {\n"
"          try {\n"
"            // call setValue() first, in case it throws\n"
"            setValue.call(this, arg);\n"
"            setErrorNumber.call(this, 0);\n"
"          } catch (err) {\n"
"            if (arg instanceof Error) {\n"
"              // we gave setValue a chance to see if the error is actually an acceptable value\n"
"              // now is time to throw an error\n"
"              throw new NotInErrorSet(structure);\n"
"            } else if (isErrorJSON(arg)) {\n"
"              // setValue() failed because the argument actually is an error as JSON\n"
"              setError.call(this, arg);\n"
"              clearValue.call(this);\n"
"            } else if (arg && typeof(arg) === 'object') {\n"
"              // maybe the argument contains a special property like `dataView` or `base64`\n"
"              if (propApplier.call(this, arg) === 0) {\n"
"                // propApplier() found zero prop, so it's time to throw\n"
"                throw err;\n"
"              }\n"
"            } else {\n"
"              throw err;\n"
"            }\n"
"          }\n"
"        }\n"
"      };\n"
"      const { bitOffset, byteSize } = members[0];\n"
"      const constructor = this.createConstructor(structure);\n"
"      descriptors.$ = { get, set: initializer };\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);\n"
"      // for clear value after error union is set to an an error (from mixin \"features/data-copying\")\n"
"      descriptors[RESET] = this.defineResetter(bitOffset / 8, byteSize);\n"
"      // for operating on pointers contained in the error union\n"
"      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, { isChildActive });\n"
"      return constructor;\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineFunction(structure, descriptors) {\n"
"      const {\n"
"        instance: { members: [ member ], template: thunk },\n"
"        static: { template: jsThunkController },\n"
"      } = structure;\n"
"      const cache = new ObjectCache();\n"
"      const { structure: { constructor: ArgStruct } } = member;\n"
"      const thisEnv = this;\n"
"      const constructor = function(arg) {\n"
"        const creating = this instanceof constructor;\n"
"        let dv;\n"
"        if (creating) {\n"
"          // creating a Zig function object from a JavaScript function\n"
"          if (arguments.length === 0) {\n"
"            throw new NoInitializer(structure);\n"
"          }\n"
"          if (typeof(arg) !== 'function') {\n"
"            throw new TypeMismatch('function', arg);\n"
"          }\n"
"          // create an inbound thunk for function (from mixin \"features/call-marshaling-inbound\")\n"
"          dv = thisEnv.getFunctionThunk(arg, jsThunkController);\n"
"        } else {\n"
"          if (this !== ENVIRONMENT) {\n"
"            // casting from buffer to function is allowed only if request comes from the runtime\n"
"            throw new NoCastingToFunction();\n"
"          }\n"
"          // casting a memory pointing to Zig binary\n"
"          dv = arg;\n"
"        }\n"
"        let existing;\n"
"        if (existing = cache.find(dv)) {\n"
"          return existing;\n"
"        }\n"
"        const argCount = ArgStruct.prototype.length;\n"
"        const self = (creating)\n"
"        ? thisEnv.createInboundCaller(arg, ArgStruct)\n"
"        : thisEnv.createOutboundCaller(thunk, ArgStruct);\n"
"        defineProperties(self, {\n"
"          length: defineValue(argCount),\n"
"          name: defineValue(''),\n"
"        });\n"
"        // make self an instance of this function type\n"
"        Object.setPrototypeOf(self, constructor.prototype);\n"
"        self[MEMORY] = dv;\n"
"        cache.save(dv, self);\n"
"        if (process.env.MIXIN === 'track') {\n"
"          if (!creating) {\n"
"            thisEnv.usingFunction = true;\n"
"          }\n"
"        }\n"
"        return self;\n"
"      };\n"
"      // make function type a superclass of Function\n"
"      Object.setPrototypeOf(constructor.prototype, Function.prototype);\n"
"      // don't change the tag of functions\n"
"      descriptors[Symbol.toStringTag] = undefined;\n"
"      descriptors.valueOf = descriptors.toJSON = defineValue(getSelf);\n"
"      if (process.env.MIXIN === 'track') {\n"
"        if (jsThunkController) {\n"
"          this.usingFunctionPointer = true;\n"
"        }\n"
"      }\n"
"      return constructor;\n"
"    },\n"
"    /* c8 ignore start */\n"
"    ...(process.env.MIXIN === 'track' ? {\n"
"      usingFunction: false,\n"
"      usingFunctionPointer: false,\n"
"    } : undefined),\n"
"    /* c8 ignore end */\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineOpaque(structure, descriptors) {\n"
"      const {\n"
"        flags,\n"
"      } = structure;\n"
"      const initializer = () => { throw new CreatingOpaque(structure) };\n"
"      const valueAccessor = () => { throw new AccessingOpaque(structure) };\n"
"      const constructor = this.createConstructor(structure);\n"
"      descriptors.$ = { get: valueAccessor, set: valueAccessor };\n"
"      descriptors[Symbol.iterator] = (flags & OpaqueFlag.IsIterator) && {\n"
"        value: getZigIterator\n"
"      };\n"
"      descriptors[Symbol.toPrimitive] = {\n"
"        value(hint) {\n"
"          const { name } = structure;\n"
"          return `[opaque ${name}]`;\n"
"        },\n"
"      };\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      return constructor;\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineOptional(structure, descriptors) {\n"
"      const {\n"
"        instance: { members },\n"
"        flags,\n"
"      } = structure;\n"
"      const { get: getValue, set: setValue } = this.defineMember(members[0]);\n"
"      const { get: getPresent, set: setPresent } = this.defineMember(members[1]);\n"
"      const get = function() {\n"
"        const present = getPresent.call(this);\n"
"        if (present) {\n"
"          return getValue.call(this);\n"
"        } else {\n"
"          this[VISIT]?.('reset');\n"
"          return null;\n"
"        }\n"
"      };\n"
"      const isValueVoid = members[0].type === MemberType.Void;\n"
"      const isChildPointer = members[0].structure.type === StructureType.Pointer;\n"
"      const isChildActive = function () {\n"
"        return !!getPresent.call(this);\n"
"      };\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"          if (flags & StructureFlag.HasPointer) {\n"
"            // don't bother copying pointers when it's empty\n"
"            if (isChildActive.call(arg)) {\n"
"              this[VISIT]('copy', { vivificate: true, source: arg });\n"
"            }\n"
"          }\n"
"        } else if (arg === null) {\n"
"          setPresent.call(this, 0);\n"
"          this[RESET]?.();\n"
"          // clear references so objects can be garbage-collected\n"
"          this[VISIT]?.('reset');\n"
"        } else if (arg !== undefined || isValueVoid) {\n"
"          // call setValue() first, in case it throws\n"
"          setValue.call(this, arg);\n"
"          if (flags & OptionalFlag.HasSelector || (isChildPointer && !this[MEMORY][ZIG])) {\n"
"            // since setValue() wouldn't write address into memory when the pointer is in\n"
"            // relocatable memory, we need to use setPresent() in order to write something\n"
"            // non-zero there so that we know the field is populated\n"
"            setPresent.call(this, 1);\n"
"          }\n"
"        }\n"
"      };\n"
"      const constructor = structure.constructor = this.createConstructor(structure);\n"
"      const { bitOffset, byteSize } = members[0];\n"
"      descriptors.$ = { get, set: initializer };\n"
"      // we need to clear the value portion when there's a separate bool indicating whether a value\n"
"      // is present; for optional pointers, the bool overlaps the usize holding the address; setting\n"
"      // it to false automatically clears the address\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[RESET] = (flags & OptionalFlag.HasSelector) && this.defineResetter(bitOffset / 8, byteSize);\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);\n"
"      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, { isChildActive });\n"
"      return constructor;\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    definePointer(structure, descriptors) {\n"
"      const {\n"
"        name,\n"
"        flags,\n"
"        byteSize,\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      const { structure: targetStructure } = member;\n"
"      const {\n"
"        type: targetType,\n"
"        flags: targetFlags,\n"
"        byteSize: targetSize = 1\n"
"      } = targetStructure;\n"
"      // length for slice can be zero or undefined\n"
"      const addressSize = (flags & PointerFlag.HasLength) ? byteSize / 2 : byteSize;\n"
"      const { get: readAddress, set: writeAddress } = this.defineMember({\n"
"        type: MemberType.Uint,\n"
"        bitOffset: 0,\n"
"        bitSize: addressSize * 8,\n"
"        byteSize: addressSize,\n"
"        structure: { byteSize: addressSize },\n"
"      });\n"
"      const { get: readLength, set: writeLength } = (flags & PointerFlag.HasLength) ? this.defineMember({\n"
"        type: MemberType.Uint,\n"
"        bitOffset: addressSize * 8,\n"
"        bitSize: addressSize * 8,\n"
"        byteSize: addressSize,\n"
"        structure: {\n"
"          flags: PrimitiveFlag.IsSize,\n"
"          byteSize: addressSize\n"
"        },\n"
"      }) : {};\n"
"      const updateTarget = function(context, all = true, active = true) {\n"
"        if (all || this[MEMORY][ZIG]) {\n"
"          if (active) {\n"
"            const Target = constructor.child;\n"
"            const address = readAddress.call(this);\n"
"            const length = (flags & PointerFlag.HasLength)\n"
"            ? readLength.call(this)\n"
"            : (targetType === StructureType.Slice && targetFlags & SliceFlag.HasSentinel)\n"
"              ? thisEnv.findSentinel(address, Target[SENTINEL].bytes) + 1\n"
"              : 1;\n"
"            if (address !== this[LAST_ADDRESS] || length !== this[LAST_LENGTH]) {\n"
"              const dv = thisEnv.findMemory(context, address, length, Target[SIZE]);\n"
"              const newTarget = (dv) ? Target.call(ENVIRONMENT, dv) : null;\n"
"              this[SLOTS][0] = newTarget;\n"
"              this[LAST_ADDRESS] = address;\n"
"              this[LAST_LENGTH] = length;\n"
"              if (flags & PointerFlag.HasLength) {\n"
"                this[MAX_LENGTH] = undefined;\n"
"              }\n"
"              return newTarget;\n"
"            }\n"
"          } else {\n"
"            return this[SLOTS][0] = undefined;\n"
"          }\n"
"        }\n"
"        return this[SLOTS][0];\n"
"      };\n"
"      const setAddress = function(address) {\n"
"        writeAddress.call(this, address);\n"
"        this[LAST_ADDRESS] = address;\n"
"      };\n"
"      const setLength = (flags & PointerFlag.HasLength || targetFlags & SliceFlag.HasSentinel)\n"
"      ? function(length) {\n"
"          writeLength?.call?.(this, length);\n"
"          this[LAST_LENGTH] = length;\n"
"        }\n"
"      : null;\n"
"      const getTargetObject = function() {\n"
"        const pointer = this[POINTER] ?? this;\n"
"        const target = updateTarget.call(pointer, null, false);\n"
"        if (!target) {\n"
"          if (flags & PointerFlag.IsNullable) {\n"
"            return null;\n"
"          }\n"
"          throw new NullPointer();\n"
"        }\n"
"        return (flags & PointerFlag.IsConst) ? getConstProxy(target) : target;\n"
"      };\n"
"      const setTargetObject = function(arg) {\n"
"        if (arg === undefined) {\n"
"          return;\n"
"        }\n"
"        const pointer = this[POINTER] ?? this;\n"
"        // the target sits in Zig memory--apply the change immediately\n"
"        if (arg) {\n"
"          if (arg[MEMORY][ZIG]) {\n"
"            const address = thisEnv.getViewAddress(arg[MEMORY]);\n"
"            setAddress.call(this, address);\n"
"            setLength?.call?.(this, arg.length);\n"
"          } else {\n"
"            if (pointer[MEMORY][ZIG]) {\n"
"              throw new ZigMemoryTargetRequired(structure, arg);\n"
"            }\n"
"          }\n"
"        } else if (pointer[MEMORY][ZIG]) {\n"
"          setAddress.call(this, 0);\n"
"          setLength?.call?.(this, 0);\n"
"        }\n"
"        pointer[SLOTS][0] = arg ?? null;\n"
"        if (flags & PointerFlag.HasLength) {\n"
"          pointer[MAX_LENGTH] = undefined;\n"
"        }\n"
"      };\n"
"      const getTarget = (targetFlags & StructureFlag.HasValue)\n"
"      ? function() {\n"
"          const target = getTargetObject.call(this);\n"
"          return target.$;\n"
"        }\n"
"      : getTargetObject;\n"
"      const setTarget = (flags & PointerFlag.IsConst)\n"
"      ? throwReadOnly\n"
"      : function(value) {\n"
"          const target = getTargetObject.call(this);\n"
"          return target.$ = value;\n"
"        };\n"
"      const getTargetLength = function() {\n"
"        const target = getTargetObject.call(this);\n"
"        return (target) ? target.length : 0;\n"
"      };\n"
"      const setTargetLength = function(len) {\n"
"        len = len | 0;\n"
"        const target = getTargetObject.call(this);\n"
"        if (target) {\n"
"          if (target.length === len) {\n"
"            return;\n"
"          }\n"
"        } else {\n"
"          if (len !== 0) {\n"
"            throw new InvalidSliceLength(len, 0);\n"
"          }\n"
"          return;\n"
"        }\n"
"        const dv = target[MEMORY];\n"
"        const zig = dv[ZIG];\n"
"        const bytesAvailable = dv.buffer.byteLength - dv.byteOffset;\n"
"        // determine the maximum length\n"
"        let max;\n"
"        if (!zig) {\n"
"          if (flags & PointerFlag.HasLength) {\n"
"            max = this[MAX_LENGTH] ??= target.length;\n"
"          } else {\n"
"            max = (bytesAvailable / targetSize) | 0;\n"
"          }\n"
"        }\n"
"        if (len < 0 || len > max) {\n"
"          throw new InvalidSliceLength(len, max);\n"
"        }\n"
"        const byteLength = len * targetSize;\n"
"        const newDV = (byteLength <= bytesAvailable)\n"
"        // can use the same buffer\n"
"        ? thisEnv.obtainView(dv.buffer, dv.byteOffset, byteLength)\n"
"        // need to ask V8 for a larger external buffer\n"
"        : thisEnv.obtainZigView(zig.address, byteLength);\n"
"        const free = zig?.free;\n"
"        if (free) {\n"
"          // transfer free function to new view\n"
"          newDV[ZIG].free = free;\n"
"          zig.free = null;\n"
"        }\n"
"        const Target = targetStructure.constructor;\n"
"        this[SLOTS][0] = Target.call(ENVIRONMENT, newDV);\n"
"        setLength?.call?.(this, len);\n"
"      };\n"
"      const thisEnv = this;\n"
"      const initializer = function(arg, allocator) {\n"
"        const Target = targetStructure.constructor;\n"
"        if (isPointerOf(arg, Target)) {\n"
"          // initialize with the other pointer'structure target\n"
"          if (!(flags & PointerFlag.IsConst) && arg.constructor.const) {\n"
"            throw new ConstantConstraint(structure, arg);\n"
"          }\n"
"          arg = arg[SLOTS][0];\n"
"        } else if (flags & PointerFlag.IsMultiple) {\n"
"          if (isCompatiblePointer(arg, Target, flags)) {\n"
"            arg = Target(arg[SLOTS][0][MEMORY]);\n"
"          }\n"
"        } else if (targetType === StructureType.Slice && (targetFlags & SliceFlag.IsOpaque) && arg) {\n"
"          if (arg.constructor[TYPE] === StructureType.Pointer) {\n"
"            arg = arg['*']?.[MEMORY];\n"
"          } else if (arg[MEMORY]) {\n"
"            arg = arg[MEMORY];\n"
"          } else if (arg?.buffer instanceof ArrayBuffer) {\n"
"            if (!(arg instanceof Uint8Array || arg instanceof DataView)) {\n"
"              const { byteOffset, byteLength } = arg;\n"
"              if (byteOffset !== undefined && byteLength !== undefined) {\n"
"                arg = new DataView(arg.buffer, byteOffset, byteLength);\n"
"              }\n"
"            }\n"
"          }\n"
"        }\n"
"        if (arg instanceof Target) {\n"
"          const constTarget = arg[CONST_TARGET];\n"
"          if (constTarget) {\n"
"            if (flags & PointerFlag.IsConst) {\n"
"              arg = constTarget;\n"
"            } else {\n"
"              throw new ReadOnlyTarget(structure);\n"
"            }\n"
"          }\n"
"        } else if (flags & PointerFlag.IsSingle && flags & PointerFlag.IsMultiple && arg instanceof Target.child) {\n"
"          // C pointer\n"
"          arg = Target(arg[MEMORY]);\n"
"        } else if (isCompatibleBuffer(arg, Target)) {\n"
"          // autocast to target type\n"
"          const dv = thisEnv.extractView(targetStructure, arg);\n"
"          arg = Target(dv);\n"
"        } else if (arg != undefined && !arg[MEMORY]) {\n"
"          if (flags & PointerFlag.IsSingle && flags & PointerFlag.IsMultiple) {\n"
"            // C pointer\n"
"            if (typeof(arg) === 'object' && !arg[Symbol.iterator]) {\n"
"              let single = true;\n"
"              // make sure the object doesn't contain special props for the slice\n"
"              const propSetters = Target.prototype[SETTERS];\n"
"              for (const key of Object.keys(arg)) {\n"
"                const set = propSetters[key];\n"
"                if (set?.special) {\n"
"                  single = false;\n"
"                  break;\n"
"                }\n"
"              }\n"
"              if (single) {\n"
"                arg = [ arg ];\n"
"              }\n"
"            }\n"
"          }\n"
"          // autovivificate target object\n"
"          const autoObj = new Target(arg, { allocator });\n"
"          if (thisEnv.runtimeSafety) {\n"
"            // creation of a new slice using a typed array is probably\n"
"            // not what the user wants; it's more likely that the intention\n"
"            // is to point to the typed array but there's a mismatch (e.g. u32 vs i32)\n"
"            if (TYPED_ARRAY in Target) {\n"
"              const tag = arg?.buffer?.[Symbol.toStringTag];\n"
"              if (tag === 'ArrayBuffer') {\n"
"                warnImplicitArrayCreation(targetStructure, arg);\n"
"              }\n"
"            }\n"
"          }\n"
"          arg = autoObj;\n"
"        } else if (arg !== undefined) {\n"
"          if (!(flags & PointerFlag.IsNullable) || arg !== null) {\n"
"            throw new InvalidPointerTarget(structure, arg);\n"
"          }\n"
"        }\n"
"        const zig = arg?.[MEMORY]?.[ZIG];\n"
"        if (zig?.address === usizeInvalid) {\n"
"          throw new PreviouslyFreed(arg);\n"
"        }\n"
"        this[TARGET] = arg;\n"
"      };\n"
"      const constructor = this.createConstructor(structure);\n"
"      descriptors['*'] = { get: getTarget, set: setTarget };\n"
"      descriptors.$ = { get: getProxy, set: initializer };\n"
"      descriptors.length = { get: getTargetLength, set: setTargetLength };\n"
"      descriptors.slice = (targetType === StructureType.Slice) && {\n"
"        value(begin, end) {\n"
"          const newTarget = this[TARGET].slice(begin, end);\n"
"          return new constructor(newTarget);\n"
"        }\n"
"      };\n"
"      descriptors.subarray = (targetType === StructureType.Slice) && {\n"
"        value(begin, end, options) {\n"
"          const newTarget = this[TARGET].subarray(begin, end, options);\n"
"          return new constructor(newTarget);\n"
"        }\n"
"      };\n"
"      descriptors[Symbol.toPrimitive] = (targetType === StructureType.Primitive) && {\n"
"        value(hint) {\n"
"          return this[TARGET][Symbol.toPrimitive](hint);\n"
"        }\n"
"      };\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[FINALIZE] = {\n"
"        value() {\n"
"          const handlers = (targetType === StructureType.Pointer) ? {} : proxyHandlers;\n"
"          const proxy = new Proxy(this, handlers);\n"
"          // hide the proxy so console wouldn't display a recursive structure\n"
"          Object.defineProperty(this, PROXY, { value: proxy });\n"
"          return proxy;\n"
"        }\n"
"      };\n"
"      descriptors[TARGET] = { get: getTargetObject, set: setTargetObject };\n"
"      descriptors[UPDATE] = defineValue(updateTarget);\n"
"      descriptors[ADDRESS] = { set: setAddress };\n"
"      descriptors[LENGTH] = { set: setLength };\n"
"      descriptors[VISIT] = defineValue(visitPointer);\n"
"      descriptors[LAST_ADDRESS] = defineValue(0);\n"
"      descriptors[LAST_LENGTH] = defineValue(0);\n"
"      // disable these so the target's properties are returned instead through auto-dereferencing\n"
"      descriptors.dataView = descriptors.base64 = undefined;\n"
"      return constructor;\n"
"    },\n"
"    finalizePointer(structure, staticDescriptors) {\n"
"      const {\n"
"        flags,\n"
"        constructor,\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      const { structure: targetStructure } = member;\n"
"      const { type: targetType, constructor: Target } = targetStructure;\n"
"      staticDescriptors.child = (Target) ? defineValue(Target) : {\n"
"        // deal with self-referencing pointer\n"
"        get() { return targetStructure.constructor }\n"
"      };\n"
"      staticDescriptors.const = defineValue(!!(flags & PointerFlag.IsConst));\n"
"      staticDescriptors[CAST] = {\n"
"        value(arg, options) {\n"
"          if (this === ENVIRONMENT || this === PARENT || arg instanceof constructor) {\n"
"            // casting from buffer to pointer is allowed only if request comes from the runtime\n"
"            // casting from writable to read-only is also allowed\n"
"            return false;\n"
"          } else if (isPointerOf(arg, Target)) {\n"
"            // const/non-const casting\n"
"            return new constructor(Target(arg['*']), options);\n"
"          } else if (isCompatiblePointer(arg, Target, flags)) {\n"
"            // casting between C/multi/slice pointers\n"
"            return new constructor(arg);\n"
"          } else if (targetType === StructureType.Slice) {\n"
"            // allow casting to slice through constructor of its pointer\n"
"            return new constructor(Target(arg), options);\n"
"          } else {\n"
"            throw new NoCastingToPointer(structure);\n"
"          }\n"
"        }\n"
"      };\n"
"    }\n"
"  });\n"
"\n"
"  function throwInaccessible() {\n"
"    throw new InaccessiblePointer();\n"
"  }\n"
"  const builtinVisitors = {\n"
"    copy({ source }) {\n"
"      const target = source[SLOTS][0];\n"
"      if (target) {\n"
"        this[TARGET] = target;\n"
"      }\n"
"    },\n"
"    reset({ isActive }) {\n"
"      if (this[SLOTS][0] && !isActive(this)) {\n"
"        this[SLOTS][0] = undefined;\n"
"      }\n"
"    },\n"
"    disable() {\n"
"      const disabledProp = { get: throwInaccessible, set: throwInaccessible };\n"
"      defineProperties(this[POINTER], {\n"
"        '*': disabledProp,\n"
"        '$': disabledProp,\n"
"        [POINTER]: disabledProp,\n"
"        [TARGET]: disabledProp,\n"
"      });\n"
"    },\n"
"  };\n"
"\n"
"  function visitPointer(visitor, options = {}) {\n"
"    const {\n"
"      source,\n"
"      isActive = always,\n"
"      isMutable = always,\n"
"    } = options;\n"
"    let fn;\n"
"    if (typeof(visitor) === 'string') {\n"
"      fn = builtinVisitors[visitor];\n"
"    } else {\n"
"      fn = visitor;\n"
"    }\n"
"    fn.call(this, { source, isActive, isMutable });\n"
"  }\n"
"\n"
"  function isPointerOf(arg, Target) {\n"
"    return (arg?.constructor?.child === Target && arg['*']);\n"
"  }\n"
"\n"
"  function isCompatiblePointer(arg, Target, flags) {\n"
"    if (flags & PointerFlag.IsMultiple) {\n"
"      if (arg?.constructor?.child?.child === Target.child && arg['*']) {\n"
"        return true;\n"
"      } else if (flags & PointerFlag.IsSingle && isPointerOf(arg, Target.child)) {\n"
"        // C pointer\n"
"        return true;\n"
"      }\n"
"    }\n"
"    return false;\n"
"  }\n"
"\n"
"  function getConstProxy(target) {\n"
"    let proxy = target[CONST_PROXY];\n"
"    if (!proxy) {\n"
"      Object.defineProperty(target, CONST_PROXY, { value: undefined, configurable: true });\n"
"      proxy = new Proxy(target, constTargetHandlers);\n"
"      Object.defineProperty(target, CONST_PROXY, { value: proxy });\n"
"    }\n"
"    return proxy;\n"
"  }\n"
"\n"
"  const proxyHandlers = {\n"
"    get(pointer, name) {\n"
"      if (name === POINTER) {\n"
"        return pointer;\n"
"      } else if (name in pointer) {\n"
"        return pointer[name];\n"
"      } else {\n"
"        const target = pointer[TARGET];\n"
"        return target[name];\n"
"      }\n"
"    },\n"
"    set(pointer, name, value) {\n"
"      if (name in pointer) {\n"
"        pointer[name] = value;\n"
"      } else {\n"
"        const target = pointer[TARGET];\n"
"        target[name] = value;\n"
"      }\n"
"      return true;\n"
"    },\n"
"    deleteProperty(pointer, name) {\n"
"      if (name in pointer) {\n"
"        delete pointer[name];\n"
"      } else {\n"
"        const target = pointer[TARGET];\n"
"        delete target[name];\n"
"      }\n"
"      return true;\n"
"    },\n"
"    has(pointer, name) {\n"
"      if (name in pointer) {\n"
"        return true;\n"
"      } else {\n"
"        const target = pointer[TARGET];\n"
"        return name in target;\n"
"      }\n"
"    },\n"
"  };\n"
"\n"
"  const constTargetHandlers = {\n"
"    get(target, name) {\n"
"      if (name === CONST_TARGET) {\n"
"        return target;\n"
"      } else {\n"
"        const value = target[name];\n"
"        if (value?.[CONST_TARGET] === null) {\n"
"          return getConstProxy(value);\n"
"        }\n"
"        return value;\n"
"      }\n"
"    },\n"
"    set(target, name, value) {\n"
"      const ptr = target[POINTER];\n"
"      if (ptr && !(name in ptr)) {\n"
"        target[name] = value;\n"
"      } else {\n"
"        throwReadOnly();\n"
"      }\n"
"      return true;\n"
"    }\n"
"  };\n"
"\n"
"  function isCompatibleBuffer(arg, constructor) {\n"
"    // TODO: merge this with extractView in mixin \"view-management\"\n"
"    const tag = arg?.[Symbol.toStringTag];\n"
"    if (tag) {\n"
"      const typedArray = constructor[TYPED_ARRAY];\n"
"      if (typedArray) {\n"
"        switch (tag) {\n"
"          case typedArray.name:\n"
"          case 'DataView':\n"
"            return true;\n"
"          case 'ArrayBuffer':\n"
"            return typedArray === Uint8Array || typedArray === Int8Array;\n"
"          case 'Uint8ClampedArray':\n"
"            return typedArray === Uint8Array;\n"
"        }\n"
"      }\n"
"      if (constructor.child) {\n"
"        if (findElements(arg, constructor.child) !== undefined) {\n"
"          return true;\n"
"        }\n"
"      }\n"
"    }\n"
"    return false;\n"
"  }\n"
"\n"
"  mixin({\n"
"    definePrimitive(structure, descriptors) {\n"
"      const {\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      const propApplier = this.createApplier(structure);\n"
"      const { get, set } = this.defineMember(member);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"        } else {\n"
"          if (arg && typeof(arg) === 'object') {\n"
"            if (propApplier.call(this, arg) === 0) {\n"
"              const type = getPrimitiveName(member);\n"
"              throw new InvalidInitializer(structure, type, arg);\n"
"            }\n"
"          } else if (arg !== undefined) {\n"
"            set.call(this, arg);\n"
"          }\n"
"        }\n"
"      };\n"
"      const constructor = this.createConstructor(structure);\n"
"      descriptors.$ = { get, set: initializer };\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[Symbol.toPrimitive] = defineValue(get);\n"
"      return constructor;\n"
"    },\n"
"    finalizePrimitive(structure, staticDescriptors) {\n"
"      const {\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      staticDescriptors[BIT_SIZE] = defineValue(member.bitSize);\n"
"      staticDescriptors[PRIMITIVE] = defineValue(member.type);\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineSlice(structure, descriptors) {\n"
"      const {\n"
"        align,\n"
"        flags,\n"
"        byteSize,\n"
"        instance: {\n"
"          members: [ member ],\n"
"        },\n"
"      } = structure;\n"
"      /* c8 ignore end */\n"
"      const { byteSize: elementSize, structure: elementStructure } = member;\n"
"      const thisEnv = this;\n"
"      const shapeDefiner = function(dv, length, allocator) {\n"
"        if (!dv) {\n"
"          dv = thisEnv.allocateMemory(length * elementSize, align, allocator);\n"
"        }\n"
"        this[MEMORY] = dv;\n"
"        this[LENGTH] = length;\n"
"      };\n"
"      const shapeChecker = function(arg, length) {\n"
"        if (length !== this[LENGTH]) {\n"
"          throw new ArrayLengthMismatch(structure, this, arg);\n"
"        }\n"
"      };\n"
"      const descriptor = this.defineMember(member);\n"
"      const { set } = descriptor;\n"
"      // the initializer behave differently depending on whether it's called by the\n"
"      // constructor or by a member setter (i.e. after object's shape has been established)\n"
"      const propApplier = this.createApplier(structure);\n"
"      const initializer = function(arg, allocator) {\n"
"        if (arg instanceof constructor) {\n"
"          if (!this[MEMORY]) {\n"
"            shapeDefiner.call(this, null, arg.length, allocator);\n"
"          } else {\n"
"            shapeChecker.call(this, arg, arg.length);\n"
"          }\n"
"          this[COPY](arg);\n"
"          if (flags & StructureFlag.HasPointer) {\n"
"            this[VISIT]('copy', { vivificate: true, source: arg });\n"
"          }\n"
"        } else if (typeof(arg) === 'string' && flags & SliceFlag.IsString) {\n"
"          initializer.call(this, { string: arg }, allocator);\n"
"        } else if (arg?.[Symbol.iterator]) {\n"
"          arg = transformIterable(arg);\n"
"          if (!this[MEMORY]) {\n"
"            shapeDefiner.call(this, null, arg.length, allocator);\n"
"          } else {\n"
"            shapeChecker.call(this, arg, arg.length);\n"
"          }\n"
"          let i = 0;\n"
"          for (const value of arg) {\n"
"            constructor[SENTINEL]?.validateValue(value, i, arg.length);\n"
"            set.call(this, i++, value);\n"
"          }\n"
"        } else if (typeof(arg) === 'number') {\n"
"          if (!this[MEMORY] && arg >= 0 && isFinite(arg)) {\n"
"            shapeDefiner.call(this, null, arg, allocator);\n"
"          } else {\n"
"            throw new InvalidArrayInitializer(structure, arg, !this[MEMORY]);\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          if (propApplier.call(this, arg, allocator) === 0) {\n"
"            throw new InvalidArrayInitializer(structure, arg);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throw new InvalidArrayInitializer(structure, arg);\n"
"        }\n"
"      };\n"
"      const getSubArrayView = function(begin, end) {\n"
"        const length = this[LENGTH];\n"
"        const dv = this[MEMORY];\n"
"        begin = (begin === undefined) ? 0 : adjustIndex(begin, length);\n"
"        end = (end === undefined) ? length : adjustIndex(end, length);\n"
"        const offset = begin * elementSize;\n"
"        const len = (end * elementSize) - offset;\n"
"        return thisEnv.obtainView(dv.buffer, dv.byteOffset + offset, len);\n"
"      };\n"
"      const constructor = this.createConstructor(structure);\n"
"      descriptors.$ = { get: getProxy, set: initializer };\n"
"      descriptors.length = { get: getLength };\n"
"      if (flags & SliceFlag.IsTypedArray) {\n"
"        descriptors.typedArray = this.defineTypedArray(structure);\n"
"        if (flags & SliceFlag.IsString) {\n"
"          descriptors.string = this.defineString(structure);\n"
"        }\n"
"        if (flags & SliceFlag.IsClampedArray) {\n"
"          descriptors.clampedArray = this.defineClampedArray(structure);\n"
"        }\n"
"      }\n"
"      descriptors.entries = defineValue(getArrayEntries);\n"
"      descriptors.subarray = {\n"
"        value(begin, end) {\n"
"          const dv = getSubArrayView.call(this, begin, end);\n"
"          return constructor(dv);\n"
"        },\n"
"      };\n"
"      descriptors.slice = {\n"
"        value(begin, end, options = {}) {\n"
"          const {\n"
"            zig = false\n"
"          } = options;\n"
"          const dv1 = getSubArrayView.call(this, begin, end);\n"
"          const dv2 = thisEnv.allocateMemory(dv1.byteLength, align, zig);\n"
"          const slice = constructor(dv2);\n"
"          slice[COPY]({ [MEMORY]: dv1 });\n"
"          return slice;\n"
"        },\n"
"      };\n"
"      descriptors[Symbol.iterator] = defineValue(getArrayIterator);\n"
"      descriptors[SHAPE] = defineValue(shapeDefiner);\n"
"      descriptors[COPY] = this.defineCopier(byteSize, true);\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[FINALIZE] = this.defineFinalizerArray(descriptor);\n"
"      descriptors[ENTRIES] = { get: getArrayEntries };\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorArray(structure);\n"
"      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorArray(structure);\n"
"      return constructor;\n"
"    },\n"
"    finalizeSlice(structure, staticDescriptors) {\n"
"      const {\n"
"        flags,\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      staticDescriptors.child = defineValue(member.structure.constructor);\n"
"      staticDescriptors[SENTINEL] = (flags & SliceFlag.HasSentinel) && this.defineSentinel(structure);\n"
"    },\n"
"  });\n"
"\n"
"  function getLength() {\n"
"    return this[LENGTH];\n"
"  }\n"
"\n"
"  function adjustIndex(index, len) {\n"
"    index = index | 0;\n"
"    if (index < 0) {\n"
"      index = len + index;\n"
"      if (index < 0) {\n"
"        index = 0;\n"
"      }\n"
"    } else {\n"
"      if (index > len) {\n"
"        index = len;\n"
"      }\n"
"    }\n"
"    return index;\n"
"  }\n"
"\n"
"  mixin({\n"
"    defineVivificatorStruct(structure) {\n"
"      const { instance: { members } } = structure;\n"
"      const objectMembers = {};\n"
"      for (const member of members.filter(m => m.type === MemberType.Object)) {\n"
"        objectMembers[member.slot] = member;\n"
"      }\n"
"      const thisEnv = this;\n"
"      return {\n"
"        value(slot) {\n"
"          const member = objectMembers[slot];\n"
"          const { bitOffset, byteSize, structure: { constructor } } = member;\n"
"          const dv = this[MEMORY];\n"
"          const parentOffset = dv.byteOffset;\n"
"          const offset = parentOffset + (bitOffset >> 3);\n"
"          let len = byteSize;\n"
"          if (len === undefined) {\n"
"            if (bitOffset & 7) {\n"
"              throw new NotOnByteBoundary(member);\n"
"            }\n"
"            len = member.bitSize >> 3;\n"
"          }\n"
"          const childDV = thisEnv.obtainView(dv.buffer, offset, len);\n"
"          const object = this[SLOTS][slot] = constructor.call(PARENT, childDV);\n"
"          return object;\n"
"        }\n"
"      };\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineStruct(structure, descriptors) {\n"
"      const {\n"
"        flags,\n"
"        length,\n"
"        instance: { members },\n"
"      } = structure;\n"
"      const backingIntMember = members.find(m => m.flags & MemberFlag.IsBackingInt);\n"
"      const backingInt = backingIntMember && this.defineMember(backingIntMember);\n"
"      const propApplier = this.createApplier(structure);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"          if (flags & StructureFlag.HasPointer) {\n"
"            this[VISIT]('copy', { vivificate: true, source: arg });\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          propApplier.call(this, arg);\n"
"        } else if ((typeof(arg) === 'number' || typeof(arg) === 'bigint') && backingInt) {\n"
"          backingInt.set.call(this, arg);\n"
"        } else if (arg !== undefined) {\n"
"          throw new InvalidInitializer(structure, 'object', arg);\n"
"        }\n"
"      };\n"
"      const constructor = this.createConstructor(structure);\n"
"      // add descriptors of struct field\n"
"      const setters = descriptors[SETTERS].value;\n"
"      const keys = descriptors[KEYS].value;\n"
"      const props = [];\n"
"      for (const member of members.filter(m => !!m.name)) {\n"
"        const { name, flags } = member;\n"
"        const { set } = descriptors[name] = this.defineMember(member);\n"
"        if (set) {\n"
"          if (flags & MemberFlag.IsRequired) {\n"
"            set.required = true;\n"
"          }\n"
"          setters[name] = set;\n"
"          keys.push(name);\n"
"        }\n"
"        props.push(name);\n"
"      }\n"
"      descriptors.$ = { get: getSelf, set: initializer };\n"
"      // add length and entries if struct is a tuple\n"
"      descriptors.length = defineValue(length);\n"
"      descriptors.entries = (flags & StructFlag.IsTuple) && {\n"
"        value: getVectorEntries,\n"
"      };\n"
"      // allow conversion of packed struct to number when there's a backing int\n"
"      descriptors[Symbol.toPrimitive] = backingInt && {\n"
"        value(hint) {\n"
"          return (hint === 'string')\n"
"            ? Object.prototype.toString.call(this)\n"
"            : backingInt.get.call(this);\n"
"        }\n"
"      };\n"
"      // add iterator\n"
"      descriptors[Symbol.iterator] = defineValue(\n"
"        (flags & StructFlag.IsIterator)\n"
"        ? getZigIterator\n"
"        : (flags & StructFlag.IsTuple)\n"
"          ? getVectorIterator\n"
"          : getStructIterator\n"
"      );\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      // for creating complex fields on access\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);\n"
"      // for operating on pointers contained in the struct\n"
"      descriptors[VISIT] = (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure);\n"
"      descriptors[ENTRIES] = { get: (flags & StructFlag.IsTuple) ? getVectorEntries : getStructEntries };\n"
"      descriptors[PROPS] = defineValue(props);\n"
"      if (flags & StructFlag.IsAllocator) {\n"
"        descriptors.alloc = this.defineAlloc();\n"
"        descriptors.free = this.defineFree();\n"
"        descriptors.dupe = this.defineDupe();\n"
"      }\n"
"      return constructor;\n"
"    }\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineUnion(structure, descriptors) {\n"
"      const {\n"
"        flags,\n"
"        instance: { members },\n"
"      } = structure;\n"
"      const exclusion = !!(flags & UnionFlag.HasSelector);\n"
"      const valueMembers = (exclusion) ? members.slice(0, -1) : members;\n"
"      const selectorMember = (exclusion) ? members[members.length - 1] : null;\n"
"      const { get: getSelector, set: setSelector } = this.defineMember(selectorMember);\n"
"      const { get: getSelectorNumber } = this.defineMember(selectorMember, false);\n"
"      const getActiveField = (flags & UnionFlag.HasTag)\n"
"      ? function() {\n"
"          const item = getSelector.call(this);\n"
"          return item[NAME];\n"
"        }\n"
"      : function() {\n"
"          const index = getSelector.call(this);\n"
"          return valueMembers[index].name;\n"
"        };\n"
"      const setActiveField = (flags & UnionFlag.HasTag)\n"
"      ? function(name) {\n"
"          const { constructor } = selectorMember.structure;\n"
"          setSelector.call(this, constructor[name]);\n"
"        }\n"
"      : function(name) {\n"
"          const index = valueMembers.findIndex(m => m.name === name);\n"
"          setSelector.call(this, index);\n"
"        };\n"
"      const propApplier = this.createApplier(structure);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"          if (flags & StructureFlag.HasPointer) {\n"
"            this[VISIT]('copy', { vivificate: true, source: arg });\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          let found = 0;\n"
"          for (const key of props) {\n"
"            if (key in arg) {\n"
"              found++;\n"
"            }\n"
"          }\n"
"          if (found > 1) {\n"
"            throw new MultipleUnionInitializers(structure);\n"
"          }\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            throw new MissingUnionInitializer(structure, arg, exclusion);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throw new InvalidInitializer(structure, 'object with a single property', arg);\n"
"        }\n"
"      };\n"
"      const constructor = this.createConstructor(structure);\n"
"      const getters = {};\n"
"      const setters = descriptors[SETTERS].value;\n"
"      const keys = descriptors[KEYS].value;\n"
"      const props = [];\n"
"      for (const member of valueMembers) {\n"
"        const { name } = member;\n"
"        const { get: getValue, set: setValue } = this.defineMember(member);\n"
"        const get = (exclusion)\n"
"        ? function() {\n"
"            const currentName = getActiveField.call(this);\n"
"            if (name !== currentName) {\n"
"              if (flags & UnionFlag.HasTag) {\n"
"                // tagged union allows inactive member to be queried\n"
"                return null;\n"
"              } else {\n"
"                // whereas bare union does not, since the condition is not detectable\n"
"                // when runtime safety is off\n"
"                throw new InactiveUnionProperty(structure, name, currentName);\n"
"              }\n"
"            }\n"
"            this[VISIT]?.('reset');\n"
"            return getValue.call(this);\n"
"          }\n"
"        : getValue;\n"
"        const set = (exclusion && setValue)\n"
"        ? function(value) {\n"
"            const currentName = getActiveField.call(this);\n"
"            if (name !== currentName) {\n"
"              throw new InactiveUnionProperty(structure, name, currentName);\n"
"            }\n"
"            setValue.call(this, value);\n"
"          }\n"
"        : setValue;\n"
"        const init = (exclusion && setValue)\n"
"        ? function(value) {\n"
"            setActiveField.call(this, name);\n"
"            setValue.call(this, value);\n"
"            this[VISIT]?.('reset');\n"
"          }\n"
"        : setValue;\n"
"        descriptors[name] = { get, set };\n"
"        setters[name] = init;\n"
"        getters[name] = getValue;\n"
"        keys.push(name);\n"
"        props.push(name);\n"
"      }\n"
"      descriptors.$ = { get: function() { return this }, set: initializer };\n"
"      descriptors[Symbol.iterator] = {\n"
"        value: (flags & UnionFlag.IsIterator) ? getZigIterator : getUnionIterator,\n"
"      };\n"
"      descriptors[Symbol.toPrimitive] = (flags & UnionFlag.HasTag) && {\n"
"        value(hint) {\n"
"          switch (hint) {\n"
"            case 'string':\n"
"            case 'default':\n"
"              return getActiveField.call(this);\n"
"            default:\n"
"              return getSelectorNumber.call(this);\n"
"          }\n"
"        }\n"
"      };\n"
"      descriptors[MODIFY] = (flags & UnionFlag.HasInaccessible && !this.comptime) && {\n"
"        value() {\n"
"          // pointers in non-tagged union are not accessible--we need to disable them\n"
"          this[VISIT]('disable', { vivificate: true });\n"
"        }\n"
"      };\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[TAG] = (flags & UnionFlag.HasTag) && { get: getSelector, set : setSelector };\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);\n"
"      descriptors[VISIT] =  (flags & StructureFlag.HasPointer) && this.defineVisitorStruct(structure, {\n"
"        isChildActive: (flags & UnionFlag.HasTag)\n"
"        ? function(child) {\n"
"            const name = getActiveField.call(this);\n"
"            const active = getters[name].call(this);\n"
"            return child === active;\n"
"          }\n"
"        : () => false,\n"
"      });\n"
"      descriptors[ENTRIES] = { get: getUnionEntries };\n"
"      descriptors[PROPS] = (flags & UnionFlag.HasTag) ? {\n"
"        get() {\n"
"          return [ getActiveField.call(this) ];\n"
"        }\n"
"      } : defineValue(props);\n"
"      descriptors[GETTERS] = defineValue(getters);\n"
"      return constructor;\n"
"    },\n"
"    finalizeUnion(structure, staticDescriptors) {\n"
"      const {\n"
"        flags,\n"
"        instance: { members },\n"
"      } = structure;\n"
"      if (flags & UnionFlag.HasTag) {\n"
"        staticDescriptors.tag = defineValue(members[members.length - 1].structure.constructor);\n"
"      }\n"
"    }\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineVariadicStruct(structure, descriptors) {\n"
"      const {\n"
"        byteSize,\n"
"        align,\n"
"        flags,\n"
"        length,\n"
"        instance: { members },\n"
"      } = structure;\n"
"      const argMembers = members.slice(1);\n"
"      const maxSlot = members.map(m => m.slot).sort().pop();\n"
"      const thisEnv = this;\n"
"      const constructor = function(args) {\n"
"        if (args.length < length) {\n"
"          throw new ArgumentCountMismatch(length, args.length, true);\n"
"        }\n"
"        // calculate the actual size of the struct based on arguments given\n"
"        let totalByteSize = byteSize;\n"
"        let maxAlign = align;\n"
"        const varArgs = args.slice(length);\n"
"        const offsets = {};\n"
"        for (const [ index, arg ] of varArgs.entries()) {\n"
"          const dv = arg?.[MEMORY];\n"
"          let argAlign = arg?.constructor?.[ALIGN];\n"
"          if (!dv || !argAlign) {\n"
"            const err = new InvalidVariadicArgument();\n"
"            throw adjustArgumentError.call(err, length + index, args.length);\n"
"          }\n"
"          if (argAlign > maxAlign) {\n"
"            maxAlign = argAlign;\n"
"          }\n"
"          // can't use alignForward() here, since that uses bigint when platform is 64-bit\n"
"          const byteOffset = offsets[index] = (totalByteSize + (argAlign - 1)) & ~(argAlign - 1);\n"
"          totalByteSize = byteOffset + dv.byteLength;\n"
"        }\n"
"        const attrs = new ArgAttributes(args.length);\n"
"        const dv = thisEnv.allocateMemory(totalByteSize, maxAlign);\n"
"        // attach the alignment so we can correctly shadow the struct\n"
"        dv[ALIGN] = maxAlign;\n"
"        this[MEMORY] = dv;\n"
"        this[SLOTS] = {};\n"
"        // copy fixed args\n"
"        thisEnv.copyArguments(this, args, argMembers);\n"
"        // set their attributes\n"
"        for (const [ index, { bitOffset, bitSize, type, structure: { align } } ] of argMembers.entries()) {\n"
"          attrs.set(index, bitOffset / 8, bitSize, align, type);\n"
"        }\n"
"        // create additional child objects and copy arguments into them\n"
"        for (const [ index, arg ] of varArgs.entries()) {\n"
"          const slot = maxSlot + index + 1;\n"
"          const { byteLength } = arg[MEMORY];\n"
"          const offset = offsets[index];\n"
"          const childDV = thisEnv.obtainView(dv.buffer, offset, byteLength);\n"
"          const child = this[SLOTS][slot] = arg.constructor.call(PARENT, childDV);\n"
"          const bitSize = arg.constructor[BIT_SIZE] ?? byteLength * 8;\n"
"          const align = arg.constructor[ALIGN];\n"
"          const type = arg.constructor[PRIMITIVE];\n"
"          child.$ = arg;\n"
"          // set attributes\n"
"          attrs.set(length + index, offset, bitSize, align, type);\n"
"        }\n"
"        this[ATTRIBUTES] = attrs;\n"
"        this[CONTEXT] = new CallContext();\n"
"      };\n"
"      for (const member of members) {\n"
"        descriptors[member.name] = this.defineMember(member);\n"
"      }\n"
"      const { slot: retvalSlot, type: retvalType } = members[0];\n"
"      const isChildMutable = (retvalType === MemberType.Object)\n"
"      ? function(object) {\n"
"          const child = this[VIVIFICATE](retvalSlot);\n"
"          return object === child;\n"
"        }\n"
"      : function() { return false };\n"
"      const ArgAttributes = function(length) {\n"
"        this[MEMORY] = thisEnv.allocateMemory(length * 8, 4);\n"
"        this.length = length;\n"
"        this.littleEndian = thisEnv.littleEndian;\n"
"      };\n"
"      const setAttributes = function(index, offset, bitSize, align, type) {\n"
"        const dv = this[MEMORY];\n"
"        const le = thisEnv.littleEndian;\n"
"        dv.setUint16(index * 8, offset, le);\n"
"        dv.setUint16(index * 8 + 2, bitSize, le);\n"
"        dv.setUint16(index * 8 + 4, align, le);\n"
"        dv.setUint8(index * 8 + 6, type == MemberType.Float);\n"
"        dv.setUint8(index * 8 + 7, type == MemberType.Int || type == MemberType.Float);\n"
"      };\n"
"      defineProperties(ArgAttributes, {\n"
"        [ALIGN]: { value: 4 },\n"
"      });\n"
"      defineProperties(ArgAttributes.prototype, {\n"
"        set: defineValue(setAttributes),\n"
"        [COPY]: this.defineCopier(4, true),\n"
"        ...(undefined),\n"
"      });\n"
"      descriptors[COPY] = this.defineCopier(undefined, true);\n"
"      descriptors[VIVIFICATE] = (flags & StructureFlag.HasObject) && this.defineVivificatorStruct(structure);\n"
"      descriptors[VISIT] = {\n"
"        value(cb, options = {}) {\n"
"          const {\n"
"            vivificate = false,\n"
"            isActive = always,\n"
"            isMutable = always,\n"
"          } = options;\n"
"          const childOptions = {\n"
"            ...options,\n"
"            isActive,\n"
"            isMutable: (object) => isMutable(this) && isChildMutable.call(this, object),\n"
"          };\n"
"          if (vivificate && retvalType === MemberType.Object) {\n"
"            this[VIVIFICATE](retvalSlot);\n"
"          }\n"
"          for (const child of Object.values(this[SLOTS])) {\n"
"            child?.[VISIT]?.(cb, childOptions);\n"
"          }\n"
"        },\n"
"      };\n"
"      return constructor;\n"
"    },\n"
"    finalizeVariadicStruct(structure, staticDescriptors) {\n"
"      const { flags } = structure;\n"
"      staticDescriptors[THROWING] = defineValue(!!(flags & ArgStructFlag.IsThrowing));\n"
"    },\n"
"  });\n"
"\n"
"  mixin({\n"
"    defineVector(structure, descriptors) {\n"
"      const {\n"
"        flags,\n"
"        length,\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      const propApplier = this.createApplier(structure);\n"
"      const initializer = function(arg) {\n"
"        if (arg instanceof constructor) {\n"
"          this[COPY](arg);\n"
"        } else if (arg?.[Symbol.iterator]) {\n"
"          let argLen = arg.length;\n"
"          if (typeof(argLen) !== 'number') {\n"
"            arg = [ ...arg ];\n"
"            argLen = arg.length;\n"
"          }\n"
"          if (argLen !== length) {\n"
"            throw new ArrayLengthMismatch(structure, this, arg);\n"
"          }\n"
"          let i = 0;\n"
"          for (const value of arg) {\n"
"            this[i++] = value;\n"
"          }\n"
"        } else if (arg && typeof(arg) === 'object') {\n"
"          if (propApplier.call(this, arg) === 0) {\n"
"            throw new InvalidArrayInitializer(structure, arg);\n"
"          }\n"
"        } else if (arg !== undefined) {\n"
"          throw new InvalidArrayInitializer(structure, arg);\n"
"        }\n"
"      };\n"
"      const constructor = this.createConstructor(structure, { initializer });\n"
"      const { bitSize: elementBitSize } = member;\n"
"      for (let i = 0, bitOffset = 0; i < length; i++, bitOffset += elementBitSize) {\n"
"        descriptors[i] = this.defineMember({ ...member, bitOffset });\n"
"      }\n"
"      descriptors.$ = { get: getSelf, set: initializer };\n"
"      descriptors.length = defineValue(length);\n"
"      if (flags & VectorFlag.IsTypedArray) {\n"
"        descriptors.typedArray = this.defineTypedArray(structure);\n"
"        if (flags & VectorFlag.IsClampedArray) {\n"
"          descriptors.clampedArray = this.defineClampedArray(structure);\n"
"        }\n"
"      }\n"
"      descriptors.entries = defineValue(getVectorEntries);\n"
"      descriptors[Symbol.iterator] = defineValue(getVectorIterator);\n"
"      descriptors[INITIALIZE] = defineValue(initializer);\n"
"      descriptors[ENTRIES] = { get: getVectorEntries };\n"
"      return constructor;\n"
"    },\n"
"    finalizeVector(structure, staticDescriptors) {\n"
"      const {\n"
"        instance: { members: [ member ] },\n"
"      } = structure;\n"
"      staticDescriptors.child = defineValue(member.structure.constructor);\n"
"    },\n"
"  });\n"
"\n"
"  function createEnvironment() {\n"
"    // define Environment class, incorporating methods and properties in all mixins\n"
"    const Env = defineEnvironment();\n"
"    return new Env();\n"
"  }\n"
"\n"
"  exports.createEnvironment = createEnvironment;\n"
"\n"
"  return exports;\n"
"\n"
"})({}))"
